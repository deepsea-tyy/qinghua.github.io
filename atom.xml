<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>懒程序员改变世界</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://qinghua.github.io/"/>
  <updated>2017-07-05T01:01:24.000Z</updated>
  <id>http://qinghua.github.io/</id>
  
  <author>
    <name>Qinghua Gao</name>
    <email>ggggqh666@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《智能时代》读后感</title>
    <link href="http://qinghua.github.io/intelligence-age-book-review/"/>
    <id>http://qinghua.github.io/intelligence-age-book-review/</id>
    <published>2017-07-02T08:51:23.000Z</published>
    <updated>2017-07-05T01:01:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>上个月刚刚读完吴军的<a href="https://book.douban.com/subject/26838557/" target="_blank" rel="external">《智能时代》</a>，本文总结并记录一些笔记及感想。<br><a id="more"></a></p>
<h2 id="数据、信息、知识和智能"><a href="#数据、信息、知识和智能" class="headerlink" title="数据、信息、知识和智能"></a>数据、信息、知识和智能</h2><p>在谈论数据时，人们经常将其与信息相混淆。其实信息来源于数据，但是并非所有的数据都承载着有用的信息。例如，对于<code>dd if=/dev/zero of=ggg.txt bs=1k count=10000</code>这样的一个10M文件来说，里面的每一个bit都为0，所以并不能提供什么有意义的信息。而且，无意义和伪造的数据都会干扰和影响我们。通过对信息的处理，可以获取知识，以推动人类文明的发展。例如：通过测量星球的位置和对应的时间，我们可以得到数据；通过处理这些数据得到星球运动的轨迹，就是信息；通过信息总结出开普勒三定律，则是知识。而人类的智能往往体现在：获取数据→分析数据→建立模型→预测未知上。</p>
<p>现在我们所说的人工智能有两个定义：狭义的人工智能指的是20世纪五六十年代的研究机器智能的特定方法，即传统人工智能方法，专注于让机器像人一样地去思考；广义的人工智能指的是任何可以让计算机通过图灵测试的方法，即让一台机器和一个人在幕后，一位裁判同时与他们交流，看看裁判是否能够分辨出自己交流的对象是机器还是人。以翻译为例：传统的方法就是针对某两种语言编写大量的规则，以反映人类的思考方式；而现代的方法则是通过数据驱动，用机器学习的方式训练出翻译模型的各种参数。在互联网出现以前，很难获取到大量的有效数据，因而实用性不高。但是在如今的大数据时代，获取大量数据已经成为了可能。越来越多的信息可以使模型越来越准确，进而使翻译的效果越来越好。这里有个大数据预测美国大选的例子：2012年有人把互联网上公开的新闻、Facebook、Twitter等选战数据按照州来整理，竟然成功地预测了全部50+1个州的选举结果。</p>
<p>数据的作用过去常常被人们所忽视。首先是由于过去的数据量不足（少了大数据的大，Vast）；其次是数据缺乏相关性（少了多维度，即多样性Variety）。而现在的数据量由于计算机本身的数据、传感器的数据以及旧信息的数字化，比过去增加了许多，使量变足以成为了质变。数据驱动方法过去的死穴在于，使用基于概率统计的模型会有很多小概率事件覆盖不到。只有提高数据的完备性才行。这在以前是很难做到的，比如搜集全国所有人的面孔。但是如今这样的事情也并非遥不可及。所以我们也许需要重新认识穷举法，在大数据时代它并不像想象中的那样笨。数据的相关性也非常重要。我上班的时候会经过一家广东肠粉的小吃店，招牌上“广”字的一点已经脱落，成了“厂东肠粉”。我们的智能当然能够判断出来这是广东而不是厂东，但是大数据呢？首先它并不能找到什么有意义的“厂东”，但是能找到广东，并且“厂”和“广”字形非常接近。但是这样也无法否定是不是有个小地方叫“厂东”，或是老板的名字叫“厂东”。所以需要交叉验证。接下来发现“广东”和“肠粉”两字经常出现，有相关性。这样数据的相关性便大大提升了可信度。要是有图片，还能根据“厂”的字形比另外三个字稍扁来做进一步的交叉验证，准确性就能够更上一层楼。实际上如果在baidu搜索“厂东肠粉”的时候，它已经会问你“您要找的是不是: 广东肠粉”。Google虽然并不提示你，但显示的搜索结果也都是广东肠粉。当大家都意识到数据的重要性后，市场上的竞争就从技术的竞争转变成了数据的竞争，智能问题已经演变成了数据问题。</p>
<h2 id="智能革命"><a href="#智能革命" class="headerlink" title="智能革命"></a>智能革命</h2><p>我们现在说起机械思维，总觉得它是个贬义词。但其实它正是以前推动工业革命的要素。机械思维认为世界变化的规律是确定的，因此规律可以被认识，并且可以用公式或语言描述清楚，放之四海而皆准。但成也萧何败萧何，它的局限性正是否认了不确定性和不可知性。世界的不确定性首先来自影响世界的变量实在太多，以至于无法套用公式算出结果。其次世界本身也是不确定的，人类对于世界的观察将会改变世界本身，如量子力学的不确定性原理。但是不确定并不意味着没有规律可循。香农在概率论的基础上，用信息论将世界的不确定性与信息联系了起来，给了人们一种看待世界和处理问题的全新思路。</p>
<p>新思路为我们带来了大数据思维。它的核心是：数据中所包含的信息可以帮助我们消除不确定性，而数据之间的相关性在某种程度上可以取代原来的因果关系，帮助我们得到想知道的答案。例如，根据大数据的统计结果，可以发现在视频网站上投放零食的广告效果很好，我们可以据此猜出人们在看视频时喜欢吃零食。所以这种新的思维方法允许我们在不知道原因的情况下直接从大量数据中寻找答案，即无监督学习。虽然机器推算出来相关的事情只有一定的概率，但是世界本身就充满了不确定性，100%的准确率固然是好，但是90%的结果也是非常有价值的。这就是思维的革命。</p>
<p>还有产业的革命。套用一个公式：<strong>现有产业 + 新技术 = 新产业</strong>。例如：</p>
<ul>
<li>第一次工业革命：现有产业 + 蒸汽机 = 新产业</li>
<li>第二次工业革命：现有产业 + 电 = 新产业</li>
<li>现今的信息革命：现有产业 + 摩尔定律 = 新产业</li>
<li>由大数据引发的智能革命：<ul>
<li>现有产业 + 大数据 = 新产业</li>
<li>现有产业 + 机器智能 = 新产业</li>
</ul>
</li>
</ul>
<p>在瓦特改良万能蒸汽机之后，很多上千年历史的古老行业都通过使用蒸汽机而变为新产业，如纺织业冲击了几千年来的家庭纺织业，而瓷器则由白色黄金变成了日用品等。并不需要每一个工厂都去制造蒸汽机，而大多数工厂都会受益于蒸汽机。到了19世纪末，电力的应用也催生了各种新产业，如建筑业通过使用电梯使人们可以把楼盖高，交通运输业通过电车、地铁等公共交通促进了城市的发展，形成了大都市。但是也不需要太多的供电公司，对于美国而言就是通用电气和西屋电气，而大多数公司都会受益于电。“二战”之后，许多产业在使用计算机之后产生了质的变化，如金融业、通信业等。计算机处理器是信息革命的代表产品，但是同样并不需要有很多生产它的公司，今天大部分的处理器都是来自Intel或AMD以及ARM公司所设计的产品，而大部分电脑和智能设备都离不开它们。正在到来的智能革命，也将催生和改造出许多的新产业，但同样，并不是所有公司都会掌握大数据或是培养出机器智能，而大多数公司都将受益于大数据和机器智能。</p>
<h2 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h2><p>新革命的到来当然不会是一帆风顺的，首先要解决的是技术上的挑战。大量的数据必然需要大量的存储，并使查找和使用数据的时间剧增。早期存储数据的磁带和软盘根本不可能承担起存储如此海量数据的任务。硬盘虽然容量上去了，但是其存取速度仍然受限于机械运动。直到SSD的崛起和平价化，才使得在存储技术上适应了大数据。数据的传输也是一个挑战，直到移动互联网和WIFI技术的兴起，才使得大量数据的传输成为可能。而对数据的处理，则受益于摩尔定律，处理器速度增加并越来越便宜，从而导致并行处理技术如Map Reduce等的发展。也有目前还没完全解决的问题，如数据的标准化等。Google设计了一种称为<a href="https://github.com/google/protobuf" target="_blank" rel="external">Protocal Buffer</a>的数据格式，并已开源供大家使用。</p>
<p>技术问题解决后，就是商业问题了。如何获得一个全集的大数据呢？例如，为了了解电视的收视率，显然不能再一个个地去发传单、打电话了。最好的方法是通过机顶盒记录用户的收视情况。但是掌握这些数据的生产厂商和有线电视运营商当然不会轻易地把这些数据分享出来。所以Google推出了自己的电视机顶盒Google TV，为获取数据进入电视广告市场做准备，但是销售结果很糟糕，据说后来每个季度退回来的机顶盒比卖出去的还多。以至于Google在2014年斥巨资收购了还在亏损状态的nest公司，以获取nest公司的产品（恒温器）在每一个家庭的数据。一些公司已经敏锐地发现了数据的价值，而另一些公司却捧着金饭碗要饭。</p>
<p>还有数据的安全。首先由于数据量大，数据一旦丢失或被盗，损失将是巨大的。一种行之有效的方式就是利用大数据本身的特点来保护大数据的信息安全。如果外来的入侵者侵入了计算机系统，由于对业务的不熟悉，他的操作很可能与众不同，因此可以通过与大数据的对比而被发现，从而被制止。还有就是对于隐私的保护。如果导航系统能够帮人们导航并避开拥堵路段，那也说明它知道每个人的行踪。一旦这些信息暴露出来，这是非常危险的。再比如说<a href="http://www.sohu.com/a/117859356_469880" target="_blank" rel="external">《大数据高手塔吉特：我知道你怀孕了！》</a>。现在的很多公司都或多或少具备了这样的能力，只是大家不知道或者不注意而已。甚至连淘宝的商家都有可能收集到你的信息，从而决定给你寄真货还是寄假货。</p>
<p>最后，随着生产力的进一步发展，机器将会抢掉许多人的饭碗：工人、医生、律师、翻译、编辑、中间商等等。特斯拉的汽车装配厂都是由机器人操作，很少雇佣汽车行业的人员，而所雇的都是IT人员。机器将会从大数据中学习到各种专家的知识，甚至表现得更好。那未来如此多失业的人将会怎么办？目前人类还没有很好的办法，只能靠“拖”字决。一两代之后，无法掌握新技能的人也已经到了退休年龄了。AI会有更好的办法么？也许AI会发现只需要让大家陷入深深的睡眠就可以了。《黑客帝国》又向现实迈进了一步。但是AI毕竟来自于大数据，而不是全数据。有朝一日醒来的人类，也许能够通过制造不常见的场景，引发AI的bug，就像李世石曾经战胜AlphaGo的那一盘围棋一样。而埃隆·马斯克用“<a href="https://www.huxiu.com/article/201384.html" target="_blank" rel="external">脑机接口</a>”的宏伟蓝图来应对AI。既然人类可能最终会被AI消灭，那不如就让人类与AI成为一体。</p>
<p>“2%的人将控制未来，成为他们或被淘汰”。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上个月刚刚读完吴军的&lt;a href=&quot;https://book.douban.com/subject/26838557/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《智能时代》&lt;/a&gt;，本文总结并记录一些笔记及感想。&lt;br&gt;
    
    </summary>
    
      <category term="AI" scheme="http://qinghua.github.io/categories/AI/"/>
    
    
      <category term="AI" scheme="http://qinghua.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin的语法糖们</title>
    <link href="http://qinghua.github.io/kotlin-syntax-suger/"/>
    <id>http://qinghua.github.io/kotlin-syntax-suger/</id>
    <published>2017-06-24T01:01:21.000Z</published>
    <updated>2017-06-24T02:10:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>当今的<a href="https://kotlinlang.org/" target="_blank" rel="external">Kotlin</a>真是炙手可热啊。自2011年JetBrains为了提高IDEA的销量而推出这个项目至今，它一直低调而稳定地发展着。到了上个月即2017年5月，<a href="https://blog.jetbrains.com/kotlin/2017/05/kotlin-on-android-now-official/" target="_blank" rel="external">Google宣布将Kotlin语言作为Android开发的一级编程语言</a>，算是到达了语言生的第一个巅峰。<a href="https://kotlinlang.org/docs/reference/faq.html#is-kotlin-hard" target="_blank" rel="external">Kotlin自身受到Java、C#、JavaScript、Scala、Groovy等语言的影响</a>，本文总结了它提供的部分常见语法糖并与其它语言进行比较。<br><a id="more"></a></p>
<h2 id="字符串模板（string-template）"><a href="#字符串模板（string-template）" class="headerlink" title="字符串模板（string template）"></a>字符串模板（<a href="https://kotlinlang.org/docs/reference/basic-types.html#string-templates" target="_blank" rel="external">string template</a>）</h2><p>Kotlin可以直接通过<code>println(&quot;Hello, {name}&quot;)</code>或<code>println(&quot;Hello, $name&quot;)</code>来使用字符串模板，而Java则需要先借助<code>String.format</code>来生成字符串。而kotlin还支持表达式，如<code>${person.name}</code>和<code>${2 * 3}</code>。这块古老的糖从shell开始就有了：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo "Hello, $&#123;name&#125;"</div></pre></td></tr></table></figure></p>
<p>如果你疑惑为什么无须导入包即可直接使用<code>println</code>，那是因为这个方法所在的<code>kotlin.io</code>包是默认导入（Default Imports）的，正如Java会默认导入<code>java.lang.*</code>一样。Kotlin的默认导入请参考<a href="https://kotlinlang.org/docs/reference/packages.html#default-imports" target="_blank" rel="external">这里</a>。</p>
<h2 id="分号推断（semicolon-inference）"><a href="#分号推断（semicolon-inference）" class="headerlink" title="分号推断（semicolon inference）"></a>分号推断（<a href="https://kotlinlang.org/docs/reference/grammar.html#semicolons" target="_blank" rel="external">semicolon inference</a>）</h2><p>我们知道Java中的每一条语句结束后，需要加上分号。Kotlin中的分号是可选的。这应该是来自JavaScript吧。不过写JavaScript还是推荐把分号都加上，否则可能<a href="http://cjihrig.com/blog/the-dangers-of-javascripts-automatic-semicolon-insertion/" target="_blank" rel="external">有危险</a>。Groovy、Scala也有同样的能力。</p>
<h2 id="定义函数（define-function）"><a href="#定义函数（define-function）" class="headerlink" title="定义函数（define function）"></a>定义函数（<a href="https://kotlinlang.org/docs/reference/functions.html" target="_blank" rel="external">define function</a>）</h2><p>JavaScript中，<code>function</code>；Go语言，<code>func</code>；Kotlin，<code>fun</code>。怎么看都像是SIM卡变成了micro-SIM，然后又变成了nano-SIM卡。Kotlin可以在类之外定义全局函数，也可以在函数中定义局部函数。这一点类似于JavaScript。</p>
<h2 id="var／val（local-variable）"><a href="#var／val（local-variable）" class="headerlink" title="var／val（local variable）"></a>var／val（<a href="https://kotlinlang.org/docs/reference/basic-syntax.html#defining-local-variables" target="_blank" rel="external">local variable</a>）</h2><p>变量是<code>var</code>，表示variable；常量是<code>val</code>，表示fixed value。这个很明显来自Scala。在Java中就只能用<code>final</code>关键字了。</p>
<h2 id="可空值（nullable-value）"><a href="#可空值（nullable-value）" class="headerlink" title="可空值（nullable value）"></a>可空值（<a href="https://kotlinlang.org/docs/reference/null-safety.html" target="_blank" rel="external">nullable value</a>）</h2><p>在变量类型后面加上一个问号，表明这个变量可以为null，否则默认不能为null。例如：<br>这一句编译错误：<code>var a: Int = null</code><br>这样才能成功：<code>var a: Int? = null</code><br>这块糖显然来自于C#，但是更加严格了。它是为了避免Java中的null所造成的<a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare" target="_blank" rel="external">十亿美元的错误</a>。</p>
<h2 id="集合字面量（collection-literals）"><a href="#集合字面量（collection-literals）" class="headerlink" title="集合字面量（collection literals）"></a>集合字面量（<a href="https://kotlinlang.org/docs/reference/collections.html#collections" target="_blank" rel="external">collection literals</a>）</h2><p>Java从来就不愿意用糖吸引小朋友……所以一般快速创建集合是这么写的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; colors = Arrays.asList(<span class="string">"red"</span>, <span class="string">"blue"</span>);</div></pre></td></tr></table></figure></p>
<p>有好事者（Guava）提供了这样的类库：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; colors = ImmutableList.of(<span class="string">"red"</span>, <span class="string">"blue"</span>);</div></pre></td></tr></table></figure></p>
<p>其实Java 8提供的Stream也许已经能够满足你的需求：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Stream&lt;String&gt; colors = Stream.of(<span class="string">"red"</span>, <span class="string">"blue"</span>);</div></pre></td></tr></table></figure></p>
<p>Java 9很可能会<a href="http://openjdk.java.net/jeps/269" target="_blank" rel="external">引入集合字面量</a>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; colors = List.of(<span class="string">"red"</span>, <span class="string">"blue"</span>);</div></pre></td></tr></table></figure></p>
<p>Kotlin出手了：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> colors = listOf(<span class="string">"red"</span>, <span class="string">"blue"</span>)</div></pre></td></tr></table></figure></p>
<p>不过实际上并非是语法层面的糖，<code>listOf</code>只是一个方法而已。我相信是从Scala中偷师的：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> colors = <span class="type">List</span>(<span class="string">"red"</span>, <span class="string">"blue"</span>)</div></pre></td></tr></table></figure></p>
<p>当然Scala还有自己的经典方式：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> colors = <span class="string">"red"</span> :: <span class="string">"blue"</span> :: <span class="type">Nil</span></div></pre></td></tr></table></figure></p>
<p>C#可以这样来初始化集合：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> ArrayList&#123;<span class="string">"red"</span>, <span class="string">"blue"</span>&#125;;</div></pre></td></tr></table></figure></p>
<p>JavaScript、Ruby、Go等直接扩展了数组，所以就更省心了。</p>
<h2 id="when表达式（when-expression）"><a href="#when表达式（when-expression）" class="headerlink" title="when表达式（when expression）"></a>when表达式（<a href="https://kotlinlang.org/docs/reference/control-flow.html#when-expression" target="_blank" rel="external">when expression</a>）</h2><p><code>when</code>表达式有点像是不需要<code>break</code>的<code>switch…case</code>：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">when</span> (x) &#123;</div><div class="line">    <span class="number">1</span> -&gt; print(<span class="string">"x == 1"</span>)</div><div class="line">    <span class="number">2</span> -&gt; print(<span class="string">"x == 2"</span>)</div><div class="line">    <span class="keyword">else</span> -&gt; &#123; <span class="comment">// 这里可以写多行哦</span></div><div class="line">        print(<span class="string">"x is neither 1 nor 2"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但它还可以做得更多：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">when</span> &#123;</div><div class="line">    <span class="string">"orange"</span> <span class="keyword">in</span> items -&gt; println(<span class="string">"juicy"</span>)</div><div class="line">    <span class="string">"apple"</span> <span class="keyword">in</span> items -&gt; println(<span class="string">"apple is fine too"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以把它作为扩展版<code>if…else</code>来用。它有点类似Groovy的<code>switch</code>。</p>
<h2 id="is运算符（is-operator）"><a href="#is运算符（is-operator）" class="headerlink" title="is运算符（is operator）"></a>is运算符（<a href="https://kotlinlang.org/docs/reference/basic-syntax.html#using-type-checks-and-automatic-casts" target="_blank" rel="external">is operator</a>）</h2><p>先看代码：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getStringLength</span><span class="params">(obj: <span class="type">Any</span>)</span></span>: <span class="built_in">Int</span>? &#123;</div><div class="line">    <span class="keyword">if</span> (obj <span class="keyword">is</span> String &amp;&amp; obj.length &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> obj.length</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">null</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里，<code>obj is String</code>之后就可以将其作为<code>String</code>来使用了，调用<code>String</code>的<code>length</code>属性。<code>is</code>不仅比<code>instanceof</code>更加短小精悍，而且还会自动将变量转换为<code>is</code>后面的类型。应该是出于C#而胜于C#。C#提供了<code>is</code>和<code>as</code>，但是<code>as</code>在Kotlin中显然就毫无用武之地了。</p>
<h2 id="范围运算符（range）"><a href="#范围运算符（range）" class="headerlink" title="范围运算符（range）"></a>范围运算符（<a href="https://kotlinlang.org/docs/reference/ranges.html" target="_blank" rel="external">range</a>）</h2><p>Java如果要循环打印1至9，一般就是这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Java 8以前</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</div><div class="line">    System.out.println(i);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Java 8 lambda</span></div><div class="line">IntStream.range(<span class="number">1</span>, <span class="number">9</span>).forEach(System.out::println);</div></pre></td></tr></table></figure></p>
<p>如果需要步长（step），lambda方案就需要引入filter、map或iterate。Kotlin自带接口<code>ClosedRange</code>，用了点糖：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.9</span>) print(i)</div><div class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.9</span> step <span class="number">2</span>) print(i)</div><div class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">9</span> downTo <span class="number">1</span>) print(i)</div></pre></td></tr></table></figure></p>
<p>bash早就支持大括号配合<code>..</code>（<a href="http://www.gnu.org/software/bash/manual/html_node/Brace-Expansion.html" target="_blank" rel="external">brace expansion</a>）的这种方式了：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">for i in &#123;1..9&#125;; do echo $i; done</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> bash 4支持步长</span></div><div class="line">for i in &#123;1..9..2&#125;; do echo $i; done</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> 否则用seq</span></div><div class="line">for i in `seq 1 2 9`; do echo $i; done</div></pre></td></tr></table></figure></p>
<p>不过我更喜欢ruby，支持lambda的写法更加优雅：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="number">1</span>..<span class="number">9</span>).each &#123;<span class="params">|x|</span> puts x&#125;</div><div class="line">(<span class="number">1</span>..<span class="number">9</span>).step(<span class="number">2</span>) &#123;<span class="params">|x|</span> puts x&#125;</div></pre></td></tr></table></figure></p>
<h2 id="运算符重载（operator-overloading）"><a href="#运算符重载（operator-overloading）" class="headerlink" title="运算符重载（operator overloading）"></a>运算符重载（<a href="https://kotlinlang.org/docs/reference/operator-overloading.html" target="_blank" rel="external">operator overloading</a>）</h2><p>这个是C#和Scala的把戏：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>, <span class="keyword">val</span> y: <span class="built_in">Int</span>)</div><div class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Point.<span class="title">plus</span><span class="params">(<span class="keyword">val</span> point: <span class="type">Point</span>)</span></span> = Point(x + point.x, y + point.y)</div><div class="line"></div><div class="line">Point(<span class="number">1</span>, <span class="number">2</span>) + Point(<span class="number">3</span>, <span class="number">4</span>) <span class="comment">// Point(x=4, y=6)</span></div></pre></td></tr></table></figure></p>
<p>怎么知道<code>+</code>号上映射的是<code>plus</code>方法呢？还是得参考<a href="https://kotlinlang.org/docs/reference/operator-overloading.html" target="_blank" rel="external">官方文档</a>。</p>
<h2 id="包别名（package-alias）"><a href="#包别名（package-alias）" class="headerlink" title="包别名（package alias）"></a>包别名（<a href="https://kotlinlang.org/docs/reference/packages.html#imports" target="_blank" rel="external">package alias</a>）</h2><p>Kotlin支持为包指定别名，对代码洁癖患者可能会起到一定的疗效：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.math.BigDecimal <span class="keyword">as</span> bd</div></pre></td></tr></table></figure></p>
<p>Python、Groovy也都是这样：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.List <span class="keyword">as</span> UtilList</div><div class="line"><span class="keyword">import</span> java.awt.List <span class="keyword">as</span> AwtList</div></pre></td></tr></table></figure></p>
<h2 id="类型别名（type-alias）"><a href="#类型别名（type-alias）" class="headerlink" title="类型别名（type alias）"></a>类型别名（<a href="https://kotlinlang.org/docs/reference/type-aliases.html" target="_blank" rel="external">type alias</a>）</h2><p>Kotlin还支持为类型指定别名：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typealias Row = List&lt;<span class="built_in">Int</span>&gt;</div></pre></td></tr></table></figure></p>
<p>这应该是来自Scala的Type：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">type</span> <span class="title">Row</span> </span>= <span class="type">List</span>[<span class="type">Int</span>]</div></pre></td></tr></table></figure></p>
<h2 id="扩展函数（extension-function）"><a href="#扩展函数（extension-function）" class="headerlink" title="扩展函数（extension function）"></a>扩展函数（<a href="https://kotlinlang.org/docs/reference/extensions.html" target="_blank" rel="external">extension function</a>）</h2><p>扩展函数允许为一个类增加公有静态方法，调用时就好像这个方法是原生的一样。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">greetingsWith</span><span class="params">(greeting: <span class="type">String</span>)</span></span> &#123;</div><div class="line">    println(<span class="string">"<span class="variable">$greeting</span>, <span class="variable">$this</span>"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="string">"ggg"</span>.greetingsWith(<span class="string">"Hello"</span>)</div></pre></td></tr></table></figure></p>
<p>虽然JavaScript也能轻易做到，但我还是强烈地认为它来自于C#，毕竟都是一脉相承。kotlin更近一步支持扩展属性：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> String.halfLength: <span class="built_in">Int</span></div><div class="line">    <span class="keyword">get</span>() = length / <span class="number">2</span></div><div class="line"></div><div class="line"><span class="string">"ggg"</span>.halfLength <span class="comment">// 1</span></div></pre></td></tr></table></figure></p>
<h2 id="函数扩展（function-expansion）"><a href="#函数扩展（function-expansion）" class="headerlink" title="函数扩展（function expansion）"></a>函数扩展（<a href="https://kotlinlang.org/docs/reference/lambdas.html#higher-order-functions" target="_blank" rel="external">function expansion</a>）</h2><p>如果函数的最后一个参数类型是个函数，可以通过大括号来传值：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">calculate</span><span class="params">(a: <span class="type">Int</span>, cal: (<span class="type">Int</span>)</span></span> -&gt; <span class="built_in">Int</span>): <span class="built_in">Int</span> &#123;</div><div class="line">    <span class="keyword">return</span> cal(a)</div><div class="line">&#125;</div><div class="line"></div><div class="line">calculate(<span class="number">3</span>) &#123; x -&gt; x * x &#125; <span class="comment">// 9</span></div></pre></td></tr></table></figure></p>
<p>这应该是来自ruby的block：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate</span><span class="params">(a, &amp;cal)</span></span></div><div class="line">    cal.call a</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">calculate(<span class="number">3</span>) &#123; <span class="params">|x|</span> x * x &#125; <span class="comment"># 9</span></div></pre></td></tr></table></figure></p>
<h2 id="默认参数（default-arguments）"><a href="#默认参数（default-arguments）" class="headerlink" title="默认参数（default arguments）"></a>默认参数（<a href="https://kotlinlang.org/docs/reference/functions.html#default-arguments" target="_blank" rel="external">default arguments</a>）</h2><p>Kotlin支持为参数指定一个默认值：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  show()</div><div class="line">  show(<span class="string">"Good morning"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">show</span> <span class="params">(msg: <span class="type">String</span> = <span class="string">"Hello World"</span>)</span></span> &#123;</div><div class="line">    println(<span class="string">"<span class="variable">$msg</span>"</span>) </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Java一般是靠重载来实现默认参数。许多其它的语言都支持默认参数。例如，JavaScript在ES6上也支持默认参数了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">a, b = <span class="number">1</span></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> a * b;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="单例对象（singleton）"><a href="#单例对象（singleton）" class="headerlink" title="单例对象（singleton）"></a>单例对象（<a href="https://kotlinlang.org/docs/reference/object-declarations.html#object-declarations" target="_blank" rel="external">singleton</a>）</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">object</span> Document &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这应该是来自于Scala，连关键字都一模一样。</p>
<h2 id="伴生对象（companion-object）"><a href="#伴生对象（companion-object）" class="headerlink" title="伴生对象（companion object）"></a>伴生对象（<a href="https://kotlinlang.org/docs/reference/object-declarations.html#companion-objects" target="_blank" rel="external">companion object</a>）</h2><p>伴生对象经常用于Factory。这一点相信也是来自于Scala。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</div><div class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> Factory &#123; <span class="comment">// Factory可省略，省略后可用Companion引用</span></div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">()</span></span>: MyClass = MyClass()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="getter和setter（getter-and-setter）"><a href="#getter和setter（getter-and-setter）" class="headerlink" title="getter和setter（getter and setter）"></a>getter和setter（<a href="https://kotlinlang.org/docs/reference/properties.html#getters-and-setters" target="_blank" rel="external">getter and setter</a>）</h2><p>Kotlin像C#一样支持属性（property）。我们来看两个例子：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> isEmpty: <span class="built_in">Boolean</span></div><div class="line">    <span class="keyword">get</span>() = <span class="keyword">this</span>.size == <span class="number">0</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> counter = <span class="number">0</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">set</span>(value) &#123;</div><div class="line">        <span class="keyword">if</span> (value &gt;= <span class="number">0</span>) field = value</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h2 id="数据类（data-class）"><a href="#数据类（data-class）" class="headerlink" title="数据类（data class）"></a>数据类（<a href="https://kotlinlang.org/docs/reference/data-classes.html" target="_blank" rel="external">data class</a>）</h2><p>告别繁琐的Java数据类的时代到来了：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</div></pre></td></tr></table></figure></p>
<p>看到最前面的<code>data</code>，我突然觉得这是源于<a href="/lombok">lombok</a>…</p>
<h2 id="没有原始类型（no-raw-types）"><a href="#没有原始类型（no-raw-types）" class="headerlink" title="没有原始类型（no raw types）"></a>没有原始类型（<a href="https://kotlinlang.org/docs/reference/java-interop.html#mapped-types" target="_blank" rel="external">no raw types</a>）</h2><p>Kotlin没有原始类型，一切皆对象：<code>1.inc()</code>。这一点与Ruby、Scala相同。</p>
<h2 id="没有受检查异常（no-checked-exception）"><a href="#没有受检查异常（no-checked-exception）" class="headerlink" title="没有受检查异常（no checked exception）"></a>没有受检查异常（<a href="https://kotlinlang.org/docs/reference/exceptions.html#checked-exceptions" target="_blank" rel="external">no checked exception</a>）</h2><p>Kotlin并没有受检查异常。因为在大型的项目中，它对代码质量的提升极其有限，但是却大大降低了效率。C#十多年前就是这样了，有兴趣的读者可以参考<a href="https://blogs.msdn.microsoft.com/csharpfaq/2004/03/12/why-doesnt-c-have-checked-exceptions/" target="_blank" rel="external">这篇文章</a>。</p>
<h2 id="没有static（no-static-member）"><a href="#没有static（no-static-member）" class="headerlink" title="没有static（no static member）"></a>没有static（<a href="https://kotlinlang.org/docs/reference/classes.html#companion-objects" target="_blank" rel="external">no static member</a>）</h2><p>Kotlin也没有static的成员。这一点与Scala相同。在Kotiln中可以使用包级别的函数，或者是伴生对象来实现static的效果。</p>
<h2 id="多返回值（multiple-return-values）"><a href="#多返回值（multiple-return-values）" class="headerlink" title="多返回值（multiple return values）"></a>多返回值（<a href="https://kotlinlang.org/docs/reference/multi-declarations.html" target="_blank" rel="external">multiple return values</a>）</h2><p>可以从<a href="https://kotlinlang.org/docs/reference/multi-declarations.html#example-returning-two-values-from-a-function" target="_blank" rel="external">这一个例子</a>中看到Kotlin是如何实现函数的多返回值的。我猜应该是受到了Go语言的启发。</p>
<h2 id="嵌套块注释（nested-block-comment）"><a href="#嵌套块注释（nested-block-comment）" class="headerlink" title="嵌套块注释（nested block comment）"></a>嵌套块注释（<a href="https://kotlinlang.org/docs/reference/basic-syntax.html#comments" target="_blank" rel="external">nested block comment</a>）</h2><p>Kotlin支持块注释<code>/* … */</code>的嵌套。这可能是来自Haskell或F#。</p>
<h2 id="在线版IDE"><a href="#在线版IDE" class="headerlink" title="在线版IDE"></a>在线版IDE</h2><p>如果不想安装那么多语言，可以试试这个<a href="https://codepad.remoteinterview.io" target="_blank" rel="external">在线版IDE</a>，它支持包括Kotlin在内的几十种语言。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当今的&lt;a href=&quot;https://kotlinlang.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Kotlin&lt;/a&gt;真是炙手可热啊。自2011年JetBrains为了提高IDEA的销量而推出这个项目至今，它一直低调而稳定地发展着。到了上个月即2017年5月，&lt;a href=&quot;https://blog.jetbrains.com/kotlin/2017/05/kotlin-on-android-now-official/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Google宣布将Kotlin语言作为Android开发的一级编程语言&lt;/a&gt;，算是到达了语言生的第一个巅峰。&lt;a href=&quot;https://kotlinlang.org/docs/reference/faq.html#is-kotlin-hard&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Kotlin自身受到Java、C#、JavaScript、Scala、Groovy等语言的影响&lt;/a&gt;，本文总结了它提供的部分常见语法糖并与其它语言进行比较。&lt;br&gt;
    
    </summary>
    
      <category term="development" scheme="http://qinghua.github.io/categories/development/"/>
    
    
      <category term="kotlin" scheme="http://qinghua.github.io/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>用Lombok优雅地写代码</title>
    <link href="http://qinghua.github.io/lombok/"/>
    <id>http://qinghua.github.io/lombok/</id>
    <published>2017-05-20T02:12:01.000Z</published>
    <updated>2017-05-20T07:56:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://projectlombok.org/index.html" target="_blank" rel="external">Lombok</a>是一个比较早、小众但是功能强大的Java库，源码在<a href="https://github.com/rzwitserloot/lombok" target="_blank" rel="external">github上</a>。如果你厌恶写Java代码时不得不手写或用IDE生成大量无趣的样板代码，如getter、setter等，那就准备好拥抱lombok吧。<br><a id="more"></a></p>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><h3 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h3><p>Lombok通过注解来减少样板代码的使用。对于数据类来说，自己看<a href="https://projectlombok.org/" target="_blank" rel="external">官网的视频</a>吧。三分钟太长不想看？那么也可以快速浏览一下<a href="https://projectlombok.org/features/Data.html" target="_blank" rel="external">这里的代码</a>。神奇的事情是怎么做到的呢？奥秘就是<a href="http://notatube.blogspot.com/2010/11/project-lombok-trick-explained.html" target="_blank" rel="external">在编译时插入代码</a>。你甚至还可以创建自己的注解！参考<a href="http://notatube.blogspot.com/2010/12/project-lombok-creating-custom.html" target="_blank" rel="external">这篇文章</a></p>
<h3 id="其它特性"><a href="#其它特性" class="headerlink" title="其它特性"></a>其它特性</h3><p>除了本职的数据类以外，lombok还提供了许多<a href="https://projectlombok.org/features/index.html" target="_blank" rel="external">其它的特性</a>，以帮助我们减少样板代码的使用。官网的说明非常详细，也都附带了代码，我就不做说明书的搬运工了。这里放一个例子：<a href="https://projectlombok.org/features/Synchronized.html" target="_blank" rel="external">@Synchronized</a>。</p>
<h2 id="与Intellij-IDEA集成"><a href="#与Intellij-IDEA集成" class="headerlink" title="与Intellij IDEA集成"></a>与Intellij IDEA集成</h2><p>动手时间。新建Maven工程，往pom.xml中增加dependency，最后的pom.xml看起来就像这样：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></div><div class="line">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.ggg.lombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>helloLombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>在src/main/java中新增一个Person类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Person类中右击，Go To，Test（或者Ctrl/Command+T）便可以在src/test/java中新增一个对应的测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.junit.Test;</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span> </span>&#123;</div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">should_get_name_from_person</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> Person(<span class="string">"ggg"</span>, <span class="number">18</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>出现了一条红线，编译失败。回到Person类中，在Person类的定义上面加上<code>@AllArgsConstructor</code>并<code>import lombok.AllArgsConstructor;</code>，还是编译不过。现在到了应该加载IDEA插件的时候了。参考<a href="https://github.com/mplushnikov/lombok-intellij-plugin" target="_blank" rel="external">这里</a>来安装lombok插件，别忘了重启Intellij IDEA。这回编译成功了。在测试的调用构造函数处Command/Ctrl+B便能跳转到Person类的<code>@AllArgsConstructor</code>上。接着写测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Person ggg = <span class="keyword">new</span> Person(<span class="string">"ggg"</span>, <span class="number">18</span>);</div><div class="line"></div><div class="line">assertEquals(<span class="string">"ggg"</span>, ggg.getName());</div></pre></td></tr></table></figure></p>
<p>getName又红了。切换回Person类，再加上<code>@Getter</code>，编译通过！运行测试，绿了！<br><img src="/img/lombok.jpg" alt=""></p>
<p>还可以通过Find Usages来找到字段的get方法在哪调用，可惜不能找到构造函数在哪调用。在享用便捷的同时，也需要付出些许的代价。有兴趣的看官可以自行尝试文档中的其它注解。例如<code>@ToString(of=&quot;name&quot;)</code>，<code>@Log</code>，<code>@Getter(lazy=true)</code>等等。值得一提的是，<a href="https://projectlombok.org/features/Cleanup.html" target="_blank" rel="external">@Cleanup</a>可以轻松地关闭流、连接等对象，Java 7也提供了<a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html" target="_blank" rel="external">try-with-resources</a>来做到这一点，只不过需要缩进罢了，但是可以很明显地看出作用域。还请自行选择喜欢的那个。当然，如果你的项目还在用老旧的Java 6，那确实也没有什么选择的余地。</p>
<h2 id="风险"><a href="#风险" class="headerlink" title="风险"></a>风险</h2><p>首先，Lombok扮演着一个注解处理器的角色，在编译时通过修改抽象语法树（Abstract Syntax Tree，AST）来修改代码。但是这是被注解处理器规范所明令禁止的，规范仅允许生成新文件或是新类。而聪明的lombok开发者通过javac未公开的API绕开了这个限制。所以有人视lombok为邪门歪道。不过嘛，不管黑猫白猫，能捉老鼠的就是好猫；不管黑糖白糖，能少写代码的就是好糖。先了解它，再决定要不要因为代价而放弃收益。如果未来的Java版本取消了后门，那么使用lombok的项目就存在升级JDK的风险。如果介意这一点，并且只有数据类的需求，可以去看看google的<a href="https://github.com/google/auto/blob/master/value/userguide/index.md" target="_blank" rel="external">AutoValue</a>。不过白魔法比黑魔法总是缺了点什么…</p>
<p>第二点是IDE的支持。虽然是支持，但是你也看到了并不能像原来虽然写了代码，但大都是自动生成的代码那样随心所欲地各种重构。另外IDE偶尔抽点风也可能会让你流半天汗。</p>
<p>最后一点是代码覆盖率的测试。如果贵公司对它有明确而严格的要求，那就需要好好研究lombok与所用的代码覆盖率工具的兼容程度了。目前看来lombok与<a href="http://cobertura.github.io/cobertura/" target="_blank" rel="external">Cobertura</a>的兼容性还是最好的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://projectlombok.org/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Lombok&lt;/a&gt;是一个比较早、小众但是功能强大的Java库，源码在&lt;a href=&quot;https://github.com/rzwitserloot/lombok&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github上&lt;/a&gt;。如果你厌恶写Java代码时不得不手写或用IDE生成大量无趣的样板代码，如getter、setter等，那就准备好拥抱lombok吧。&lt;br&gt;
    
    </summary>
    
      <category term="development" scheme="http://qinghua.github.io/categories/development/"/>
    
    
      <category term="lombok" scheme="http://qinghua.github.io/tags/lombok/"/>
    
  </entry>
  
  <entry>
    <title>区块链技术浅析</title>
    <link href="http://qinghua.github.io/blockchain/"/>
    <id>http://qinghua.github.io/blockchain/</id>
    <published>2017-04-03T05:33:33.000Z</published>
    <updated>2017-04-03T15:06:19.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zh.wikipedia.org/wiki/%E5%8C%BA%E5%9D%97%E9%93%BE" target="_blank" rel="external">区块链</a>是2016年起突然走红起来的一门技术，连国务院印发的<a href="http://news.sohu.com/20161227/n477114271.shtml" target="_blank" rel="external">《“十三五”国家信息化规划》</a>也将其纳入。上周公司举办黑客马拉松的活动，有幸浅尝了一下区块链的应用，本文旨在记录并分享区块链的一些心得。<br><a id="more"></a></p>
<h2 id="比特币（Bitcoin）"><a href="#比特币（Bitcoin）" class="headerlink" title="比特币（Bitcoin）"></a>比特币（Bitcoin）</h2><p>要说清楚区块链，首先需要了解<a href="https://zh.wikipedia.org/wiki/%E6%AF%94%E7%89%B9%E5%B8%81" target="_blank" rel="external">比特币</a>。2008年金融危机时，神秘的<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E6%9C%AC%E8%81%AA" target="_blank" rel="external">中本聪</a>发表了一篇论文，详细描述了比特币。一年之后，他将其实现。再一年之后，他便把比特币交予社区维护，自己不再露面了。比特币其实就是一个文件，里面记载了所有人的账户及交易信息。这个文件只能往里增加数据而不能修改数据。比特币网络中的每一个人都拥有这个文件的备份。</p>
<p>我也可以写一个文件来表示所有人的帐户信息，但是它一文不值。为什么比特币就有价值呢？它存在价值是因为人们相信它有价值，就像印出来的钞票一样。而人们自发的信任是需要时间的。最初比特币也没有什么价值。第一笔交易发生在2010年，一位程序员在佛罗里达花了一万个比特币购买了价值25美元的披萨。截止本文发布，一个比特币大约是7000元人民币左右，可以在<a href="https://www.okcoin.cn/market-btc.html" target="_blank" rel="external">OKCoin</a>上查看。随着比特币的流行，出现了不少类似的货币，如以太坊（Ethereum）、莱特币（Litecoin）等等。只要有人相信它，它就有价值。想当年刚听说比特币的时候，我心底还暗自嘲笑怎么会有人相信这种一点实体都没有的东西，事实证明我还是太naive了。</p>
<p>作为一种货币，需要能够向别人转账。假如邻居家老王要给你转10个比特币，他需要把这笔交易写入文件并告诉比特币网络的其他节点，让大家把交易添加进这个文件。所以每个人都能够得知这笔交易信息。现在问题来了，其它的节点怎么知道这笔转账是可信的，即老王提出的呢？要是每个人都发起从老王转账到自己的请求，那老王可就亏死了。其他人当然做不到。因为这笔交易需要用老王的私钥签名。公私钥的简介可以参考我写的<a href="http://qinghua.github.io/certificate/#u975E_u5BF9_u79F0_u52A0_u5BC6">《证书的那些事儿》的非对称加密一节</a>。其他人拿不到老王的私钥，当然就无从伪造请求了。在比特币中，公钥也用于表示对方的地址。消费时，你需要用数字签名证明你拥有对应的私钥。比特币没有中心节点，所以如果老王转错账了，抱歉，要不回来了。你只知道对方的公钥（或者说是比特币的帐号或地址），并不知道对方的身份。</p>
<p>为了安全，比特币上并不会记载每个账户的余额是多少。每当要转账时，它需要提供至少一笔未消费的历史交易信息作为input，转完账后，剩余的部分称为零钱，可以转入你自己的公钥，或是你小号的公钥。至此，未消费的交易就变成了已消费，不能被再次使用了。所以多次重复的请求只有第一笔才能成功。比特币的转账并非立即生效，只有在解开一道数学题之后才行。解题的过程就叫挖矿。题目的难度由程序控制，程序会根据历史记录把解题时间控制在大约十分钟左右。</p>
<p>还有一个问题，由于网络传输的不确定性，你并不能保证老王的转账被及时同步到了所有的节点上。所以如果在这笔交易完全传播出去之前，老王又在这笔交易之前将本来作为input的历史交易转帐给他的小号呢？其它的节点根本判断不了哪个在前，哪个在后。所以顺序在这里至关重要。比特币是这么解决这个问题的：把交易分配到区块里（多对一），然后将区块链接起来，称为区块链。每个区块都会引用上一个区块，这样便实现了有序。同一区块内的交易被认为是同时发生的。由于同一时间可能会产生多笔交易，所以可能会产生多个区块。那如何知道应该以哪一个区块为准呢？事实上，每一个区块都包含了一道特殊的数学题，只有解开这道题才能使之有效。当一个节点解开了这道题，它便会向比特币网络广播自己的结果，并把交易排在区块链的下一位。如果偶尔有多人同时解出了结果，那么区块链便会产生不同的分支。两个分支开始竞争，看谁能够更快生成下一个区块。哪个分支更长，哪个分支就有效。这样的话，由于多人同时算出答案的概率很低，所以分支会在一定时间之后消失。如果你的交易在一个消失的分支的区块里，便会重新放到未确认的交易区里，等待加入下一个区块。那如果有人能快速计算多个区块，岂不是可以随心所欲了？话虽如此，但是要以个人之力来对抗全网，实在是非常困难的事情。除非控制了整个比特币网络上50%以上的运算力，才开始有可能做到。这样的成本是非常高的，对于一般的交易来说，实在是有些不值得。你也无法提前运算，因为下一个区块需要引用当前的区块和随机数，只有在当前区块完成之后，才能开始计算。所以说参与的机器越多，比特币或者说区块链就越安全。还有一点值得注意的是，越前面的区块就越安全，因为攻击所需的资源会越大。小规模的转账，等一个区块便可以了；大规模的话，最好多等几个，以降低分支消失的概率。</p>
<p>有意思的是，由于比特币网络上的机器是那么的多，导致个人很难能够挖到矿。所以采矿池（mining pool）应运而生，集多人的算力，挖到矿后根据贡献来分配。但是采矿池太大了也会带来安全问题，因为有可能超过了50%的运算力。有一家BTC Guild曾经能够独立解出一个链中的6个区块，所以这个采矿组织主动限制了规模和会员的数量，以减少比特币网络成员的不安。</p>
<h2 id="区块链（blockchain）"><a href="#区块链（blockchain）" class="headerlink" title="区块链（blockchain）"></a>区块链（blockchain）</h2><p>上一节已经介绍了比特币的区块链了。其实区块链就是一个去中心化的存储。在这一点上，它与git是比较相似的。它们都是分布式、无中心的链式存储，但是在出现分支时的解决方式不一样。Git可以通过merge和rebase来解决冲突，而区块链则是通过链的长度来自动废弃分支，作废分支里的交易重新放到未确认的交易区里，以便下次再放入新区块里，这样的行为有些类似<code>git rebase</code>。</p>
<p>由于区块链不停地往里增加区块，势必导致文件越来越大。虽然可以控制区块的大小（最大1M）和增长速度（10分钟左右），但这么计算每年也有<code>365×24×6×1M=52G</code>左右的数据。长此以往，如何受得了？作为消费者来说，已经校验并消费过了的历史数据，可以仅保存其散列码，这样便能大大减少数据。比特币钱包用的是<a href="https://en.wikipedia.org/wiki/Merkle_tree" target="_blank" rel="external">Merkle Tree</a>来做验证。</p>
<p>区块链按照参与者的身份，可以分为公有链（Public blockchain）、联盟链（Consortium blockchain）和私有链（Private blockchain），公有链如比特币，是通过挖矿来达成共识（consensus），但是挖矿的计算需要消耗大量的电力资源。联盟链顾名思义，仅由联盟内部可写，外部经过授权可读。而私有链只有一个成员可写，类似传统的分布式数据库。联盟链和私有链由于成员并非匿名，可受部分信任，并且消耗运算力其实也是一种浪费，所以可以相对放松一些要求，不必非得挖矿，可以通过共识协议来达成共识。</p>
<p>使用区块链必须能够达成共识，否则就失去意义了。其实传统的分布式一致性算法也能解决达成共识的问题，只不过一般并不考虑恶意节点篡改数据的问题罢了，而且实际上使用的节点也不像区块链那么多。传统的常见算法有：ZooKeeper使用的Zab协议；etcd使用的Raft协议；当然还有大名鼎鼎的Paxos协议。限于篇幅，本文就不具体讨论它们的具体算法了。</p>
<p>区块链最主要的贡献，是解决了在不信任网络中的信任问题。与传统的解决方案相反，参与区块链的人越多则越安全。但是如果你的组织已经有足够的信誉，是否真的需要使用区块链来实现？当你想使用区块链技术来解决特定问题的时候，应该先问问自己，如果不用区块链，会有什么问题？如果回答不了这个问题，那可能你对区块链还不够了解，或者是区块链并不是你问题的最佳解决方案。相对于技术本身来说，更麻烦的问题是靠谱的想法和实施。别手里拿着个锤子看什么都是钉子哦。再考虑一下传统的方案吧。</p>
<p>除了金融领域以外，还有许多应用区块链的有趣想法：</p>
<ul>
<li><a href="http://business.sohu.com/20160414/n444147338.shtml" target="_blank" rel="external">当Airbnb遇到区块链：你弄碎房东花瓶的事全世界都会知道</a></li>
<li><a href="http://www.weiyangx.com/165124.html" target="_blank" rel="external">纳斯达克在爱沙尼亚推出区块链投票系统</a></li>
<li><a href="http://36kr.com/p/5068610.html" target="_blank" rel="external">沃尔玛推零售“黑科技”:区块链跟踪食品溯源</a></li>
<li><a href="http://news.163.com/16/0711/05/BRLVNTKN00014AED.html" target="_blank" rel="external">蚂蚁金服将使用区块链技术 追踪每一笔公益善款去向</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://v.youku.com/v_show/id_XNjQ0NzE0Mjky.html" target="_blank" rel="external">《详解比特币的原理和运行机制》</a><br><a href="http://blockchaindev.org/article/introduce_blockchain.html" target="_blank" rel="external">《区块链(Blockchain)深入介绍》</a><br><a href="http://blockchaindev.org/article/consensus_introduction.html" target="_blank" rel="external">《浅谈区块链共识机制与分布式一致性算法》</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%8C%BA%E5%9D%97%E9%93%BE&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;区块链&lt;/a&gt;是2016年起突然走红起来的一门技术，连国务院印发的&lt;a href=&quot;http://news.sohu.com/20161227/n477114271.shtml&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《“十三五”国家信息化规划》&lt;/a&gt;也将其纳入。上周公司举办黑客马拉松的活动，有幸浅尝了一下区块链的应用，本文旨在记录并分享区块链的一些心得。&lt;br&gt;
    
    </summary>
    
      <category term="architecture" scheme="http://qinghua.github.io/categories/architecture/"/>
    
    
      <category term="blockchain" scheme="http://qinghua.github.io/tags/blockchain/"/>
    
  </entry>
  
  <entry>
    <title>DevOpsDays北京站见闻</title>
    <link href="http://qinghua.github.io/devopsdays-beijing-2017/"/>
    <id>http://qinghua.github.io/devopsdays-beijing-2017/</id>
    <published>2017-03-19T12:00:00.000Z</published>
    <updated>2017-03-19T13:57:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>首度来到中国的DevOpsDays北京站昨天顺利举行了。有幸得到赠票，在大会上见到了DevOps之父Patrick Debois还有诸多业内专家。当天的盛况及ppt下载请移步<a href="http://mp.weixin.qq.com/s/A6QDB4Z-O5cm4KCnDOmKAw" target="_blank" rel="external">此处</a>。<br><a id="more"></a></p>
<p>传统的DevOps主要涵盖了CAMS（Culture文化、Automation自动化、Measure度量、Sharing分享）四大方面。而要落地DevOps，需要两条腿：一条是组织方面的转型，另一条是技术方面的自动化工具。组织转型是要涉及到利益的，不容易下手。所以大部分的分享还是以技术方面为主。只有Patrick的好基友<a href="http://www.krisbuytaert.be/blog/" target="_blank" rel="external">Kris Buytaert</a>的ppt讲的是reorg。乔梁讲的是他在百度和腾讯的经历，但可能是受时间所限并没有太多的实际内容。如果没有自上而下的变革，很难推动起组织转型。对于许多人来说，也许能够做到的，也就是自动化工具罢了。下午的Open Space深度交流专场里，不乏对组织转型方面的问题，但是嘉宾们其实也没有什么非常好的办法。有些技巧（比如说拿数据说话）可以让你把DevOps推销给老板，但终究一场战斗的胜利很难能够左右战略上的部署。没有自上而下的决心和后盾，在触及利益的时候肯定是各种痛啊。两条慢腿可能凑活着还能走走，一条腿快一条腿慢必然会驱使着变革的前进或倒退。DevOps讲究痛点驱动，相信以后的DevOpsDays会有更多组织转型方面的分享。</p>
<p>在技术上，专家们一直强调，没有DevOps团队，别叫他们DevOps工程师。DevOps需要融入到跨功能团队中的每一个人，不是某一类人，不是某一个团队。这里我感觉有一个词很重要：<strong>同理心</strong>。有了同理心，你会理解其它角色的痛点，反之亦然。由此，便可以催生出<strong>分享</strong>。有了分享，理解痛点，便能从“像部署一样痛苦的事要多做”出发，提取出最佳实践，催生<strong>自动化</strong>。要衡量效果如何？数据说话。于是催生<strong>度量</strong>。这几方面相辅相成，在整体的良性循环之下，团队<strong>文化</strong>的成型便是顺理成章。怎样让大家拥有同理心？除了依靠人的素质进步，百度的刘俊还提到了一个做法，据说甚是有效，那就是开发运维轮岗。想想也对，把你推到别人的位置上，自然就有同理心了。</p>
<p>我在《DevOps实践》的译者序上也说过，DevOps是要很高成本的。在应用它之前，先问自己这样的问题：为什么要上DevOps？它能解决我的什么问题？不要说我想提高工作效率，提高程序质量，要从更高层次的业务上说。换句话说，从战略层面上想清楚应用DevOps的目的，然后在战术层面上依照战略来有根据有优先级地安排资源打硬仗。跟性能调优一样，搞清楚哪里才是瓶颈，针对性地动手解决。而不是直接拍胸脯就上DevOps，把最宝贵的资源浪费在可能对这个组织最没用的地方上。</p>
<p>对于中小企业来说，不要开发自己的自动化工具，不要重复发明轮子，直接拿现成的开源工具来用吧。不是BAT这样的量级，玩不起自研版的工具，它们其实是很重量级的。针对开源工具有些功能不符合自己的需求这方面，ThoughtWorks的黄博文说道：可以从另一个角度来看待这个问题，为什么你要的功能没有？这是一个正常的功能吗？究竟是功能的缺失，还是说只是你走错了路？此言深得我心。据说业界运维做得最好的应该就是谷歌和Netfilx。它们都有不少开源的运维工具，值得业内人士仔细研究。</p>
<p>最后放一张乔梁对DevOps和持续交付的看法，四个角色分别是产品、开发、测试和运维。先剧透一下并不是所有人都同意这个观点，少年，你怎么看？<br><img src="/img/agile-devops-and-cicd.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首度来到中国的DevOpsDays北京站昨天顺利举行了。有幸得到赠票，在大会上见到了DevOps之父Patrick Debois还有诸多业内专家。当天的盛况及ppt下载请移步&lt;a href=&quot;http://mp.weixin.qq.com/s/A6QDB4Z-O5cm4KCnDOmKAw&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;此处&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="devops" scheme="http://qinghua.github.io/categories/devops/"/>
    
    
      <category term="activity" scheme="http://qinghua.github.io/tags/activity/"/>
    
  </entry>
  
  <entry>
    <title>如何测试随机数</title>
    <link href="http://qinghua.github.io/test-random/"/>
    <id>http://qinghua.github.io/test-random/</id>
    <published>2017-03-05T06:32:19.000Z</published>
    <updated>2017-03-05T07:18:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>怎样知道它是不是<a href="https://zh.wikipedia.org/wiki/%E9%9A%8F%E6%9C%BA%E6%95%B0" target="_blank" rel="external">随机数</a>？如何测试一个<a href="https://zh.wikipedia.org/wiki/%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8" target="_blank" rel="external">随机数生成器</a>？<br><a id="more"></a></p>
<p>有些程序很容易测试，但并非所有程序都是如此。自动化测试的目的是以现在的时间成本，来换取未来的时间成本。很多程序员们经常自己写一个小玩意，就不爱写测试了，这是因为他们觉得这个小玩意也就用那么几次，不值得为它单写一个测试。从这个角度上看，这是没错的。大型项目经常会有比较完备的测试，因为这个项目可能会交付很长时间，也可能会有很长的维护时间。这时候测试的成本就可以在未来得到回报。测试随机数生成器，首先要回答的问题是：值不值得做这个测试？如果说这个随机数生成器本来就是系统提供的接口，那是否我们有必要费精力去测试它呢？如果它是不可靠的，那可能暗示着你的技术选型出了问题。如果它可靠（<a href="https://zh.wikipedia.org/wiki/%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%80%A7" target="_blank" rel="external">伪随机数</a>也算是可靠），那是否可以使用系统的随机数生成器来生成你自己特定的随机数生成器呢？在这种情况下，自己写的随机数生成器还是可能需要测试的。那应该怎么测试它呢？</p>
<p>让我们来举个简单的例子。比如我们需要得到由两位数字组成的随机字符串（”00”~”99”），它要做的仅仅是调用系统接口生成0~99的数字并格式化为”00”~”99”的字符串。这时我们只需测试它调用系统接口的参数，以及格式化的逻辑即可。而它们都可以通过mock等技术手段很容易地测试。在系统提供的随机数生成器的支持下，应该是可以满足大部分的随机需求的。</p>
<p>如果你非要以打硬仗的方式来测试随机数的话，除去成本因素，要想从纯技术上回答这个问题，那就要先回答另一个问题：什么是随机数？这就回到了业务的本质：在不考虑测试时，在什么情况下你会认为它是一个随机数？简单起见，我们就以0~99的伪随机数为例。取决于业务，可能你的需求是：①连续两次执行结果基本不同（“基本”是由于真随机的不可预测性，它们是可能相同的），或者是②连续执行100遍每次数字都不同，或者是③计算一万遍，要求结果呈现怎样怎样的分布。对于①来说，两次计算结果相同的概率只有百分之一（1% <em> 1% </em> 100），三次结果相同的概率只有万分之一（1% <em> 1% </em> 1% * 100）。所以测试可以这样来设计：调用两次，如果结果相同，那就再调用一次，如果还相同，那就再调用，直至不同为止。最后看调用次数<code>count</code>：如果<code>count = 2</code>，很好。如果<code>count = 3</code>，那就说明现在正好是1%的那次。如果<code>count = 4</code>，说明是0.01%的那次。理想情况下，如果每天运行100次测试，可能会有1次<code>count = 3</code>，运行100天，有1次<code>count = 4</code>，运行10000天（大约27年），会有一次<code>count = 5</code>。根据业务的容忍程度判断<code>count</code>的大小，例如当它大于5就算测试失败。虽然偶尔也会出现<code>count = 6</code>的情况，但是非常罕有，平均2700年会有一次，而且就算测试失败，也很容易排查到这个问题。所以就可以认为是符合业务需求。对于②来说，那就执行100遍看结果好了，也是技术上可实现的。对于③来说，其实与①有相似之处，只要能够描述出来，就能够测试出来。只要自己控制好测试的阈值就可以了。</p>
<p>维基百科上提供了一些<a href="https://zh.wikipedia.org/wiki/%E9%9A%8F%E6%9C%BA%E6%80%A7#.E9.9A.8F.E6.9C.BA.E6.80.A7.E6.B5.8B.E8.AF.95.E6.96.B9.E6.B3.95" target="_blank" rel="external">随机性测试方法</a>。只要能描述，就可以测试。但是，值得吗？</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;怎样知道它是不是&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%9A%8F%E6%9C%BA%E6%95%B0&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;随机数&lt;/a&gt;？如何测试一个&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;随机数生成器&lt;/a&gt;？&lt;br&gt;
    
    </summary>
    
      <category term="development" scheme="http://qinghua.github.io/categories/development/"/>
    
    
      <category term="test" scheme="http://qinghua.github.io/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>如何尽量避免生产事故</title>
    <link href="http://qinghua.github.io/avoid-production-accident/"/>
    <id>http://qinghua.github.io/avoid-production-accident/</id>
    <published>2017-02-02T02:22:21.000Z</published>
    <updated>2017-02-05T13:43:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>运维不好当啊。上个月<a href="http://hs.blizzard.cn/articles/16/8565" target="_blank" rel="external">炉石传说数据库故障导致数据损坏</a>刚刚补偿完毕，这两天又出了个<a href="http://www.oschina.net/news/81473/gitlab-com-down" target="_blank" rel="external">GitLab误删生产数据库</a>。本文聊聊尽量避免生产事故的一些方法。<br><a id="more"></a></p>
<p>我看到<a href="http://mp.weixin.qq.com/s/kTA24o0opEk51Q-RNNWPKg" target="_blank" rel="external">圈内讨论</a>里有人说，重要系统维护的时候必须两个人一起干活，一个做另外一个在旁边看。这有点儿像是结对编程的思路。我觉得两个人一起固然会好一点，但从结对的实际经验来看，一来可能导致效率更低，二来两个人一起也不能保证不会出问题。大部分情况下这两个人的水平并不是一致的，水平高的人操作，容易导致另一个人只是干看着；而水平低的人操作，反而增加了误操作的几率，需要水平高的人紧盯着。</p>
<p>还有人说，改造一下<code>rm -rf</code>，让它只能删空目录，我觉得这是一个不错的点子。由于人总是可能会出错，所以由一个机制来保证（法制而非人治），效果应该更加理想。不过这种办法也有几个问题存在。一是所有的机器都需要替换并保持<code>rm</code>命令，二是操作的时候还是不免会稍微降低效率，三是误操作一般是在低意识的时候发生，<code>rm</code>的报错，固然有可能会警醒操作者，但也有可能在惯性思维的引导下使操作者直接调用重命名后的老<code>rm</code>。还有其它的办法吗？</p>
<p>我也来抛砖引玉一个：如果从数据库同步上着手呢？只要是关于删除数据库、数据表（数据记录单谈，视需求而定）的操作，都创建新库来备份旧数据而非直接删除。缺点一是需要修改同步工具的代码，工作难度比较大；二是需要定期清理同步数据库。</p>
<p>至于各种灾难恢复演练，确实很有必要，可惜目前的现实是大家每天手上都是一堆活儿，加上IT人员流动性又高，可操作性就欠缺了一点。无论如何，从性价比上来说，一个定期的备份绝对是避免进一步损失的救命稻草。当然，还有不断地学习……</p>
<p><img src="/img/mysql-drop-and-run.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;运维不好当啊。上个月&lt;a href=&quot;http://hs.blizzard.cn/articles/16/8565&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;炉石传说数据库故障导致数据损坏&lt;/a&gt;刚刚补偿完毕，这两天又出了个&lt;a href=&quot;http://www.oschina.net/news/81473/gitlab-com-down&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitLab误删生产数据库&lt;/a&gt;。本文聊聊尽量避免生产事故的一些方法。&lt;br&gt;
    
    </summary>
    
      <category term="idea" scheme="http://qinghua.github.io/categories/idea/"/>
    
    
      <category term="soft skill" scheme="http://qinghua.github.io/tags/soft-skill/"/>
    
  </entry>
  
  <entry>
    <title>创业公司里就职的那些事儿</title>
    <link href="http://qinghua.github.io/work-in-start-up/"/>
    <id>http://qinghua.github.io/work-in-start-up/</id>
    <published>2017-01-10T01:46:50.000Z</published>
    <updated>2017-01-10T08:41:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>创业公司和一般公司很不一样。第一次加入的小伙伴们如果了解得不够清楚，可能会像我当初那样一脸懵逼。本文主要说的是加入创业公司的一些值得注意的地方。<br><a id="more"></a></p>
<p>创业公司的特点就是快。哪怕代码写的烂，不好维护，也要比竞品更快地推出新功能。当然，这样的程序质量太差，过了一段时间就很难维护或是扩展了。所以在中期拉到投资之后，重心就转移到重构代码使之更稳定上面。当然也有只要修修补补能撑到上市那天就行的战略。至于后期，像阿里腾讯这样的，持续地为社区贡献出开源代码，那就已经是质量非常好的程序了。所以一句话总结就是：前期快速从无到有，中期从有到好，后期从好到精。</p>
<p>在大公司里，业务和体系都已经比较成熟了，你的位置可能就是一颗螺丝钉，但是可以研究得很深。而在创业公司里，对个人来说，会接触到方方面面的知识，得到更全面的发展，可能研究得广而不深。大公司的机会比较少，创业公司的机会比较多，倒闭的风险也很大。</p>
<h2 id="融资"><a href="#融资" class="headerlink" title="融资"></a>融资</h2><p>面试的时候，hr总会介绍：我们公司现在已经是A/B/C轮融资了，估值多少多少万美元。可是在当时的我看来，只不过是一个字母和一个数字罢了，没有太深的感触。它究竟有什么意义呢？这要从创业公司的成长过程说起了。来自36氪的下图说得非常清楚：<br><img src="/img/idea-to-ipo.jpg" alt=""></p>
<ul>
<li>种子轮和天使轮还没有产品，变数太大，就不细说了。</li>
<li>A轮意味着已经有了一小部分的用户规模，产品得到初步验证，但是对收入没有什么要求。</li>
<li>B轮意味着更大规模的用户，也开始要求有初步的商业模式了，对于共享单车这样的领域，很明显用户要使用就必须付费，所以自带商业模式光环，只要市场占有率高就行。</li>
<li>C轮意味着需要开始变现、盈利，不断地用钱去砸市场。如果市场还没有抢下来，很可能还需要继续融资往里烧钱。</li>
<li>到了DEF轮，就没有什么本质上的区别了。</li>
</ul>
<p>创业公司在C轮之前挂掉很正常，例如找不到盈利模式，或是占不住市场。到了D轮，挂掉的风险就非常小了，公司一般都是奔着上市去了，再不行还可以被收购。</p>
<h2 id="期权"><a href="#期权" class="headerlink" title="期权"></a>期权</h2><p>期权（option）是员工持股计划（ESOP，Employee Stock Ownership Plans）的一种方式，用于激励员工。期权本身并不是股票，但是赋予了员工以较低价格购买公司普通股（ordinary shares）的权利。一开始100%的股池里，可能会抽出10%~20%作为员工的持股。不过随着每一轮的新投资进来，包括前期投资人在内的所有人的股份都会被稀释。例如：某创业公司天使轮估值1000万，这时候天使投资人投了200万占20%，员工占10%，创始人占70%；到了A轮估值2000万，A轮投资人投了400万占20%，所以原来100%的总池子就只能占80%了，员工就被稀释成了8%，天使投资人变成了16%，创始人变成了56%。不过员工部分虽然原来从10%变成8%，看起来比例降了，但是价值由100万升值为160万，反而倒是更值钱了。不过出于公司持续发展，新人不断进入，需要激励员工的原因，新的投资人一般会要求保持员工的10%不变，那么多出来的2%就需要从创始人和各投资人之间博弈中产生了。</p>
<p>对于员工来说，进入创业公司，一般来说薪水会比正常公司低一些，但是公司会通过给予期权来提供一夜暴富的可能。一般都是预计给你多少多少股（例如一万股），每年给四分之一，头四分之一需要工作满一年之后才有，也有分季度给的，也有两年之后给一半的，也有根据公司业绩和个人表现，在入职一定时间之后再谈的，比较灵活。一般一年内离职，是拿不到期权的。如果公司已经上市，并且员工已经拿到了期权，就可以在解禁期后行权将其变为股票。公司与员工约定的价格成为行权价（exercise price），加入公司越早，行权价越低，甚至可能是0元。每一轮投资之后，由于估值上升，行权价也会上升。但是行权价对特定员工来说是固定的，也就是说，如果当初说的就是0.01刀一股，那么第四年行权价对此员工来说还是0.01刀一股。而第四年新加入的员工可能已经变成10刀一股的行权价了。越早进入收益越大，当然也伴随这更大的风险。同一时期加入的新员工，行权价是一样的，但是期权数量上可能会不一样。员工能赚取的收益，就是（当前每股价格－行权价）×股数-税收。如果运气不好碰到股票价格下降，也可以选择不行权。如果能等到上市，虽然很难，但是回报最高。有时候下一轮投资者进来，员工也会有机会套现一部分，但是套现的比例和对象都是由公司来决定的。虽然说上市最好，但是万一命不好碰上了普通股对美股18比1的稀释，也只有自吞苦水了。还有，期权是有有效期的，必须在规定的时间内行权，否则就作废了。</p>
<p>如果公司还未上市，那就麻烦了。要是员工获取了一些期权后，中途离职呢？一般看公司（创始人）的厚道程度，有这么几种做法：</p>
<ul>
<li>公司折价（例如70%或80%）回购，当然对员工来说非常有利了</li>
<li>保留期权，可以等到最终上市再行权，这样对员工来说也不错，但是对于公司来说，可能就会导致期权都发完了，后入职的员工就拿不到期权了</li>
<li>离职三个月或半年内确定是否行权，若行权则需要员工掏钱。风险较大，若最终未上市，可能股份就变得一文不值了</li>
<li>直接作废……</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://workspace.fx114.net/qa-203-156906.aspx" target="_blank" rel="external">《期权有哪些坑,你知道吗?》</a><br><a href="https://www.zhihu.com/question/23357108/answer/76897476" target="_blank" rel="external">《你该怎么选Offer》</a><br><a href="https://www.zhihu.com/question/19678660/answer/17228691" target="_blank" rel="external">《在创业公司工作，期权怎么发放？》</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;创业公司和一般公司很不一样。第一次加入的小伙伴们如果了解得不够清楚，可能会像我当初那样一脸懵逼。本文主要说的是加入创业公司的一些值得注意的地方。&lt;br&gt;
    
    </summary>
    
      <category term="idea" scheme="http://qinghua.github.io/categories/idea/"/>
    
    
      <category term="soft skill" scheme="http://qinghua.github.io/tags/soft-skill/"/>
    
      <category term="start up" scheme="http://qinghua.github.io/tags/start-up/"/>
    
  </entry>
  
  <entry>
    <title>如何打造一个好氛围的技术团队</title>
    <link href="http://qinghua.github.io/build-tech-team/"/>
    <id>http://qinghua.github.io/build-tech-team/</id>
    <published>2017-01-09T00:41:23.000Z</published>
    <updated>2017-01-10T01:56:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>在创业团队里，由于自身名气不响，聘用到合适的员工是非常困难的。我就曾经遇上过无数约好面试不来的，几个发完offer后不报道也不主动回复的，甚至还有面试过程中接到BAT电话提供offer于是立马拔脚走人的。本文尝试记录一下某创业公司里，从零开始打造一个好氛围的技术团队的一些心得。<br><a id="more"></a></p>
<h2 id="组建团队"><a href="#组建团队" class="headerlink" title="组建团队"></a>组建团队</h2><p>招聘难，并不意味着就要降低标准。与其为了眼前利益而将就着聘用一个不太合适的人，并可能在未来使你自己还要耗费精力紧盯他的工作，让大家都痛苦，倒不如一开始就不要入这个坑。实际上招聘员工还是有一些技巧的。最靠谱的，就是自己认识，或者是同事内部推荐的人。这样的人有自己或者同事的背书，相比简历pk加海选，一般还是靠谱得多的。设置一个还不错的推荐费，更能增加一些推荐的动力。猎头们手上也会有一些不错的资源，就是会比较贵一些。选对合适的招聘时机也很重要。过年之后有不少领了年终奖后由于各种原因要跳槽的人，对于公司来说，可以选择的余地多了不少。当然弊端是这时候的竞争对手也会有很多。不过如果你的公司有足够吸引力的话（要不然你为什么会在那里？），关系也不大。提供差异化的岗位也是一个办法。有时候招聘时会觉得这人挺不错的，但就是不太适合这个职位，这时如果有条件的话，可以把眼光放长远些，留得好萝卜，不怕没有坑。有些工作还可以考虑以外包、合作甚至兼职的方式完成，不一定非得通过招聘来解决。</p>
<p>团队的规模不要太大，不然管理起来又麻烦又累，效率也不高。也不要求每个人都非常资深，工作经验能够均匀地哈希开就可以了。团队成员的性格和技能上最好能够互补。性格上，可以参考<a href="/effective-communication">《人际风格与有效沟通实战》</a>这篇文章，配备各种性格的队员。技能上，最好每个队员都各有所长，这样才能相互学习，促进团队整体的健康发展。</p>
<h2 id="维护团队"><a href="#维护团队" class="headerlink" title="维护团队"></a>维护团队</h2><h3 id="根"><a href="#根" class="headerlink" title="根"></a>根</h3><p>有了团队之后，就需要让队员在团队里有家一般安心的感觉，这样才能集中精力，发挥出团队的战斗力。新招聘的人，由于对这个团队所知不多，根据各自的性格，可能会不敢表达，或者是急于表现。这就首先需要有一个能让新人感觉可靠的人物。虽然不至于时时嘘寒问暖，但是也要针对不同性格适时鼓励或是交代更多的背景知识。每当我去到一个新团队的时候，我就会把认识的人视为“根”，工作或是政策上有问题都会优先找他，就算他解决不了，也会告诉我应该找谁。有的公司会有类似的政策，称之为buddy或者是sponsor，以帮助新人迅速融入环境。所以为每位新人找到一个合适的“根”，让其从“根”上发芽并迅速成长为参天大树，就是团队领袖的任务之一。</p>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>团队成员如果只是通过工作维系在一起，这样的连接就不是那么的可靠。所以我们需要团队建设（team building）来增加工作之外的连接。我记得新团队的第一次团队建设，是参加一个密室逃脱。在游戏中，不仅能看到每个人的特点和配合能力，还能给未来增加不少谈资，从而加强团队成员间的连接。相比起来，如果只是吃顿饭……效果就比较有限了，但总是比没有强。所以许多公司会有针对新人的拓展训练。如果公司层面能够组织旅游那就更理想了，除了提振团队士气，甚至找到自己的另一半也不无可能。团队发展好了，就会自发产生各种活动，甚至邀请团队成员去自己家里玩，从而将同事变成了朋友，在这样的团队里工作相信一定是令人愉悦的享受，而不仅仅是为了养家糊口而工作。</p>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p><a href="http://wiki.mbalib.com/wiki/%E5%9B%A2%E9%98%9F" target="_blank" rel="external">团队是指一种为了实现某一目标而由相互协作的个体所组成的正式群体</a>，所以明确团队的目标是非常重要的，可以说没有目标就没有团队存在的必要。这个目标需要让所有的团队成员都心中有数。曾经有一段时间完成一期的开发工作之后，第二天团队突然发现没有活儿了，于是有人开始焦虑，有人开始懒散，还有人浑浑噩噩，不知道整天都做了些什么。直到PM组织大家开了一个小会，说明了接下来的目标之后，团队才找到了存在的价值，重新振奋士气走下去。实现团队目标的同时，也可以兼顾团队成员个体的目标，尽量使之也能协同实现。</p>
<h3 id="会议"><a href="#会议" class="headerlink" title="会议"></a>会议</h3><p>工作上，新人可能对别人都干了些什么不那么了解，会有一种“不那么透明”的感觉。每天早上团队<a href="https://zh.wikipedia.org/wiki/%E7%AB%99%E4%BC%9A" target="_blank" rel="external">站会（stand-up meeting）</a>是解决这个问题的良方之一。大家轮着说昨天都做了什么，今天要做些什么，遇到了哪些问题，有心的人自然能从中获取到有用的信息。<a href="https://zh.wikipedia.org/wiki/%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B" target="_blank" rel="external">结对编程（pair programming）</a>也有助于在团队成员之间共享信息，但是它的成本比较高，可以在创业公司中将其作为非常规手段，只在必要的时候结对即可。一个迭代或项目完成之后的<a href="https://zh.wikipedia.org/wiki/Scrum#Scrum.E4.BC.9A.E8.AE.AE" target="_blank" rel="external">回顾会议（retrospective）</a>也对改进团队效率、增加团队透明度很有帮助。大致做法如下：</p>
<ol>
<li>如果团队成员之间不很熟悉，或者氛围非常不好，需要做安全度检查，大家匿名打分，如果分数偏低，需要请在场人士中级别最高的人员离场，之后重复打分直至分数较高为止。如果一直都是很低，那团队肯定有问题。这个会也没有必要开了，领导需要在线下解决。这个是担心开会的时候，大家真话说得少，光说套话等。不说真话的会，不如不开，省的浪费大家时间。</li>
<li>主持人组织大家写一些便利贴，一般包含好的（well）、不好的（less well）和不确定的（puzzle）三类，然后将其贴在白板上并进行归类。一个well的例子可能是我们有XXX新人加入，一个less well的例子可能是好久没有团建了，一个puzzle的例子可能是我们好久没有code review了。主持人应该尽量客观，通常尽量少发表自己的看法。他还要负责时间上的控制，不要太发散了，导致问题都聊不完，或者聊太high了。建议主持人轮岗。</li>
<li>让大家都明白白板上的便利贴说的到底都是什么事。</li>
<li>让大家投票选出最想聊的几件事，然后讨论并记下可以做的行动（action）以及负责人。</li>
<li>主持人记录回顾内容并发给大家（wiki或邮件），这样可以在下次回顾会议的时候看看上次的行动进展如何了。</li>
</ol>
<h3 id="分权"><a href="#分权" class="headerlink" title="分权"></a>分权</h3><p>如果管理得太过精细，管理者难免会心力交瘁（有些人除外）。适当地放手，让团队成员自己负责某一块领域，不仅有助于管理者集中精力处理自己的任务，也更能促进团队成员的成长。即使管理者有事不在的时候，也能迅速找到后备者顶上，解决一些迫在眉睫的问题。每个团队成员都不一样，有些人不喜欢总是做一样的事情，这种时候就可以考虑轮岗，增加其技术广度。而有些人可能由于家庭或别的原因，希望稳定一段时间，这种时候就可以让其深入成为某一领域上的专家。所以一对一地聊一聊，确认对方的喜好，以及公司层面可以提供的支持，可以作为领导者的事前功课。</p>
<h3 id="提高效率"><a href="#提高效率" class="headerlink" title="提高效率"></a>提高效率</h3><p>团队的开发效率非常重要，可以说是关系到团队的存亡。这方面可以采用痛点驱动的办法来提高团队效率。例如，如果程序员写的代码，要部署上某个环境非常费劲，那就会迫使程序员尽量少去部署。这时候团队就需要有人站出来，解决部署慢的问题。有许多时候这其实就是个对某原则的妥协，或是对某个工具不太熟悉罢了。例如，当时团队开发app的h5端的时候，部署测试环境需要五分钟，导致调试效率低下。后来通过分析为什么慢，并打出一系列组合拳来解决那些原因，我们将部署时间缩短到了10秒，大家的工作热情很容易就起来了。还有一次由于包引用的关系，导致部署并调试本地环境需要耗时三分钟。分析原因之后，我们放弃了DRY原则，将比较类似的代码分散到了不同的代码库里，极大地提高了本地的调试效率。而被放弃的DRY原则在这种场景下其实并不是那么的适用。</p>
<p>许多程序员倾向于复制/粘贴代码来作为自己的模板。所以如果技术领导者想要大家写出什么样的代码，首先需要让自己的代码成为理想代码的模板。例如，如果我希望大家编写单元测试，那我的代码就需要有单元测试，这样当其他人复制的时候，就需要考虑单元测试怎么写的问题。但如果只是口头说说，很快就会流于形式。而模板当然不可能一口气就写得那么完美，所以当代码审查的时候，需要识别并不断改进烂代码，还要把思想传达给其他人，最终成为团队共同的财富。</p>
<h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><p>仅有工作的热情还不够，程序员其实并不是吃青春饭的职业，而是终身不断学习提高的职业。团队应该能够提供集体学习的环境，例如大家每周三晚上共同学习某一个课程（例如某个特定技术或是在线课程），共同成长。一个人学，学得快；一群人学，学得深。集体学习因为可以相互分享和讨论，学习效果要比个体学习更加突出。</p>
<h3 id="分享"><a href="#分享" class="headerlink" title="分享"></a>分享</h3><p>要想打造一个技术氛围浓厚的团队，适时地举办技术分享会是一个很不错的办法。一开始可能由于各种原因没人响应，这就需要团队领袖走出第一步并持续鼓励大家分享。如果团队成员不太自信，一开始的分享内容可以是非技术的，也可以是较短时间的。只要走出了第一步，后面总会越来越好的。分享除了让团队成员获取知识，更直接的其实是让分享者自身成长，还有助于将自己塑造成此领域的技术专家形象。分享可能会带来一些工作时间上的消耗（准备分享以及大家聚集在一起的时间），但是从长远来看是非常有益于团队成长和技术氛围构筑的。我所在的上一个团队就成功地推出了两档分享品牌，一个是每周五下午一个小时左右的技术主题分享，以及不定期的午间半小时非技术或是小技术分享。除了session形式的分享以外，还可以有workshop类型的分享，大家一起动手完成某个任务，效果更佳。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在创业团队里，由于自身名气不响，聘用到合适的员工是非常困难的。我就曾经遇上过无数约好面试不来的，几个发完offer后不报道也不主动回复的，甚至还有面试过程中接到BAT电话提供offer于是立马拔脚走人的。本文尝试记录一下某创业公司里，从零开始打造一个好氛围的技术团队的一些心得。&lt;br&gt;
    
    </summary>
    
      <category term="idea" scheme="http://qinghua.github.io/categories/idea/"/>
    
    
      <category term="soft skill" scheme="http://qinghua.github.io/tags/soft-skill/"/>
    
      <category term="start up" scheme="http://qinghua.github.io/tags/start-up/"/>
    
      <category term="management" scheme="http://qinghua.github.io/tags/management/"/>
    
  </entry>
  
  <entry>
    <title>性能调优的一些技巧总结</title>
    <link href="http://qinghua.github.io/performance-tuning/"/>
    <id>http://qinghua.github.io/performance-tuning/</id>
    <published>2017-01-06T03:35:34.000Z</published>
    <updated>2017-01-07T12:08:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>程序猿和攻城狮们天天写代码，难免碰到别人反映程序慢。我自己就碰到了许多次这样的问题。现在将一些心得记录总结一下，以便大家和未来的自己参考。总体原则是：不能无的放矢。<br><a id="more"></a></p>
<p>曾经面试过一个人，问对方说如果有一天客服反馈说你编写的页面加载很慢，那你应该怎么办？对方想了想：加缓存呗。可是此时连慢的原因都还不知道呢，加缓存能管用么？不管如何，首先得知道哪里慢，然后针对慢的地方对症下药，才是解决之道。没有数据的性能调优就是耍流氓！就像这几天霾绕帝都，让人想起炒菜油烟的梗。难道所有人不炒菜雾霾就能消失？首先还是要收集数据，到底慢（mái）的主要原（chéng）因（fèn）是什么？</p>
<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>十年前，那会儿还没有chrome呢。当时web页面调得没有什么问题了，然后在客户那边渲染就是很慢。看了一下数据量确实很大，于是用最原始的办法：加上alert()来人肉估计一下运行时间，然后就发现下面这段代码很慢：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123; ... &#125;</div></pre></td></tr></table></figure></p>
<p>可是循环体的内容很简单，怎么看都不太会影响处理速度的样子，那问题出在哪里呢？抱着试试看的想法，把代码变成这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int length = arr.length;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123; ... &#125;</div></pre></td></tr></table></figure>
<p>居然问题就解决了！从此后写js的习惯就变了……当然现代的浏览器都对类似的代码进行了优化，所以这么奇怪的事情已经不太常见了。我们有了强大的chrome，可以用Profiles来测试网页的性能：<br><img src="/img/chrome-profiler.jpg" alt=""></p>
<p>开Profile后，在百度上搜索“性能调优”就能得到上图的结果，从中可以看出到底哪个地方耗时最多，然后采取针对性的措施。有一年除夕夜，大家都早早离开了，可是我还要处理一个页面的性能问题，否则春节期间在客户现场支持的同事就要遭殃了。当时就是用Profile找到速度极慢的函数，发现它还被调用了2+n遍，最后改成了只调用1遍，便把性能提上来了。当然，这两个例子都是在我确切地知道问题发生在前端的时候才用的方式。而网页慢的原因不一定只是前端，所以需要结合Network一起看：<br><img src="/img/chrome-network.jpg" alt=""></p>
<p>如果request持续时间占的比重很大，那就需要跑到后端看看了。如果一个web页面明显慢，但是时间又在前后端分布均匀，那么恭喜你，前后端的调优都得一起做了，否则性能提升恐怕不会那么的明显。这样的机会可不是每个程序员都能得到的。前端的算法也是一个可能会出事故的点。有一次的需求就是页面的一棵树，每个枝叶都有一个checkbox，在选择枝的时候要把叶都选上。如果数据量有可能比较大的话，算法的优劣一般就直接决定了用户的体验。算法因需求而异，这里就不展开细说了，刷刷<a href="https://leetcode.com/" target="_blank" rel="external">LeetCode</a>吧。</p>
<p>有时候，速度慢在资源加载上。例如，一个angular的库就100多k，再加上其它七七八八的类库，还有自己的js代码，一开始需要下载1M的js文件。CDN、minify这些手段之外，还有一种办法就是，让下载大文件在用户的操作期间来做。例如，企业级web应用的统一入口一般都是login页面，这时候用户需要填写自己的凭证信息，而这是需要一段时间的。如果在这段时间内把大文件下载并缓存到浏览器里，虽然还是比较慢，但是并不太会影响用户体验。还可以拆分相对来说不太会变化的代码和变化可能会较频繁的代码，这样在部署新版本之后，不太会变化的代码的缓存就可以重复利用起来了。</p>
<p>上面的办法其实就是异步的思路。有时候代码是这样工作的：一个ajax完成之后，再发另一个ajax以请求其它信息。这时候就可以看看是否这两个ajax请求有依赖，如果没有依赖，完全可以并行运行，如果有依赖，也可以考虑是否能合并为一个更特定一些的请求。</p>
<h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><p>后端可以发挥的空间相对来说更大一些。缓存用好了是一剂良药，用不好就是一剂毒药。毕竟<a href="http://martinfowler.com/bliki/TwoHardThings.html" target="_blank" rel="external">命名和缓存失效是计算机科学里面最难应对的两件事</a>。前一阵子某电商的模块里，从后端获取商品极慢，然后就发现了gateway在获取商品的API里，竟然向商品服务发了几百个请求，不慢才怪呢。统计了一下，这里面至少有90%都是参数相同的重复请求，使用30秒的短缓存，便可以立即减少重复请求，提高90%的性能，这样用户的感知就非常明显了。但实际上，还是需要分析代码，为什么会有这么多的重复请求？多半还是代码写的有问题。缓存是治标之道，立竿见影，但要治本，还是需要从代码上着手，优化代码本身。还有一些可以做的，是提供合并查询的API，例如除了提供getSkuById()以外，再提供一个getSkusByIds()的方法，当然还要小心不要出现<a href="http://stackoverflow.com/questions/97197/what-is-the-n1-selects-issue" target="_blank" rel="external">n+1</a>的问题。还有一个C#里经常会碰到的性能问题，那就是过早地计算linq的实际值。Java 8的流里也有类似的可能。</p>
<p>有时候，性能问题与需求有关系。曾经碰到过的一个需求是：用户注册的时候，要求昵称不能重复。如果重复了，推荐3个以递增数字结尾的新昵称给用户。例如，ggg被注册了，推荐ggg1、ggg2、ggg3给用户。当然还需要判断ggg1、ggg2、ggg3是否也被注册了，否则还得往后加。而验证昵称的代码因为需要访问数据库导致比较慢。有一段时间，用户很喜欢使用这个昵称：༺༻，都排到100号了。每当新用户想使用这个昵称的时候，后台都需要判断100次以上，因为༺༻1到༺༻100都被占用了。这时候就可以跟产品经理讨论讨论，是否需要推荐昵称？是否可以改变推荐昵称的方式？例如增加日期到推荐昵称里以避免重复。必要时，还可以挑战一下：有多少用户使用了我们系统推荐的昵称？如果需求实在是硬邦邦完全不能变，那只能考虑一些技术手段了，例如给数据库里用户表的昵称字段增加索引、缓存常见昵称的当前最大值、甚至动大刀子弄个昵称服务，或是备份数据库等，看看是否付出能够值回票价了。还有一次是推荐好友的功能，要求随机同城异性等级高，说不定还需要考虑年龄星座喜好呢，这些大多是不常用的字段，也滤不掉太多数据，查找起来自然很慢，这样也需要看看业务价值究竟有多大。</p>
<p>后端不像前端那样打开浏览器就能看到性能信息，也很难通过调试的方式来看生产环境为什么慢。这个时候如果框架里有处理时间日志，就会对排除性能问题非常有帮助。如果配置了ELK或者Splunk，就可以轻松找到可疑的接口。用户模块新上线的时候，就曾经直接定位到推荐好友的API速度慢，从而找到那条缓慢的SQL。哪怕是模块正常工作期间，也能通过日志看到一些有用信息。有天晚上从日志里发现用户注册API特别慢，后来知道原来是电信/联通的问题，当天如果通过微信/微博注册的用户，由于网络不通畅，导致整个用户注册响应都有问题。如果部署在阿里云上，云抽风了也并不罕见。另外所有与外部请求有关的模块，都有潜在的性能风险。使用外部请求的模块一般都有微信/微博授权、微信/支付宝付款、SMS网关、埋点、物流/天气接口、各种云服务/CDN等等。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;程序猿和攻城狮们天天写代码，难免碰到别人反映程序慢。我自己就碰到了许多次这样的问题。现在将一些心得记录总结一下，以便大家和未来的自己参考。总体原则是：不能无的放矢。&lt;br&gt;
    
    </summary>
    
      <category term="development" scheme="http://qinghua.github.io/categories/development/"/>
    
    
      <category term="performance tuning" scheme="http://qinghua.github.io/tags/performance-tuning/"/>
    
  </entry>
  
  <entry>
    <title>终端录制工具推荐</title>
    <link href="http://qinghua.github.io/terminal-recorder/"/>
    <id>http://qinghua.github.io/terminal-recorder/</id>
    <published>2016-12-07T13:31:46.000Z</published>
    <updated>2016-12-23T15:37:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>Mac自带的QuickTime Player就有录屏的功能，所以平时如果录一段操作什么的很方便。但是视频嘛，终究是比较大的。如果仅仅是录制命令行的话，可以考虑本文里介绍的工具。<br><a id="more"></a></p>
<h2 id="showterm"><a href="#showterm" class="headerlink" title="showterm"></a>showterm</h2><p><a href="http://showterm.io/" target="_blank" rel="external">showterm</a>是一个用ruby编写的开源命令行录屏工具，用起来超级简单。使用<code>gem</code>来安装：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo gem install showterm</div></pre></td></tr></table></figure></p>
<p>录制更简单：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">showterm</div></pre></td></tr></table></figure></p>
<p>然后就可以自行敲入各种命令来录制了，使用<code>exit</code>或者Ctrl+D快捷键结束录制。showterm会把录制结果直接上传并给出一个网址，如：<a href="http://showterm.io/6ccdbde054d30d825934e" target="_blank" rel="external">http://showterm.io/6ccdbde054d30d825934e</a>，这样就能很方便地分享给朋友们啦。要想嵌入到自己的网页上也没有问题：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://showterm.io/6ccdbde054d30d825934e"</span> <span class="attr">width</span>=<span class="string">"640"</span> <span class="attr">height</span>=<span class="string">"480"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>效果如下：</p>
<iframe src="http://showterm.io/6ccdbde054d30d825934e" width="640" height="480"></iframe>

<h2 id="TermRecord"><a href="#TermRecord" class="headerlink" title="TermRecord"></a>TermRecord</h2><p><a href="https://github.com/theonewolf/TermRecord" target="_blank" rel="external">TermRecord</a>是一个用python编写的开源命令行录屏工具。使用<code>pip</code>来安装：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">brew install ttyrec</div><div class="line">sudo easy_install pip</div><div class="line">sudo pip install TermRecord</div></pre></td></tr></table></figure></p>
<p>有别于showterm，它不会自动上传到网上，而是生成一个html文件，想要分享的话，你可以将其发送给好友。录制同样简单：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">TermRecord -o ggg.html</div></pre></td></tr></table></figure></p>
<p>同样使用<code>exit</code>或者Ctrl+D快捷键结束录制。要想查看录制结果，直接浏览器打开<code>ggg.html</code>就可以了。</p>
<h2 id="asciinema"><a href="#asciinema" class="headerlink" title="asciinema"></a>asciinema</h2><p><a href="https://asciinema.org/docs/getting-started" target="_blank" rel="external">asciinema</a>是一个用ClojureScript编写的开源命令行录屏工具。相比上面的工具，asciinema综合了它们各自的优点，最为强大。使用<code>brew</code>来安装：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew update &amp;&amp; brew install asciinema</div></pre></td></tr></table></figure></p>
<p>用<code>pip3</code>来安装也可以：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo pip3 install asciinema</div></pre></td></tr></table></figure></p>
<p>录制还是简单：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">asciinema rec</div></pre></td></tr></table></figure></p>
<p>还是使用<code>exit</code>或者Ctrl+D快捷键结束录制。与showterm不同的是，它会在结束录制的时候提示，如果要上传的话，敲回车，这样就不至于把废品也上传了。上传之后，asciinema会给出一个网址，如：<a href="https://asciinema.org/a/44nu2i2ieywlmqq9wx5sk5k1e" target="_blank" rel="external">https://asciinema.org/a/44nu2i2ieywlmqq9wx5sk5k1e</a>。要想嵌入到自己的网页上也没有问题：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"https://asciinema.org/a/44nu2i2ieywlmqq9wx5sk5k1e.js"</span> <span class="attr">id</span>=<span class="string">"asciicast-44nu2i2ieywlmqq9wx5sk5k1e"</span> <span class="attr">async</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>效果如下：</p>
<script type="text/javascript" src="https://asciinema.org/a/44nu2i2ieywlmqq9wx5sk5k1e.js" id="asciicast-44nu2i2ieywlmqq9wx5sk5k1e" async></script>

<p>如果不想上传，可以用这条命令将其保存为一个json文件：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">asciinema rec ggg.json</div></pre></td></tr></table></figure></p>
<p>使用以下命令可以查看录制结果：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">asciinema play ggg.json</div></pre></td></tr></table></figure></p>
<p>甚至可以再次上传：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">asciinema upload ggg.json</div></pre></td></tr></table></figure></p>
<p>还能通过<code>asciinema auth</code>命令并在<a href="https://asciinema.org/login/new" target="_blank" rel="external">asciinema</a>上注册账号来管理自己上传的文件，功能上确实是这几个工具中最强大的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mac自带的QuickTime Player就有录屏的功能，所以平时如果录一段操作什么的很方便。但是视频嘛，终究是比较大的。如果仅仅是录制命令行的话，可以考虑本文里介绍的工具。&lt;br&gt;
    
    </summary>
    
      <category term="tool" scheme="http://qinghua.github.io/categories/tool/"/>
    
    
      <category term="showterm" scheme="http://qinghua.github.io/tags/showterm/"/>
    
      <category term="TermRecord" scheme="http://qinghua.github.io/tags/TermRecord/"/>
    
      <category term="asciinema" scheme="http://qinghua.github.io/tags/asciinema/"/>
    
  </entry>
  
  <entry>
    <title>领域驱动设计DDD</title>
    <link href="http://qinghua.github.io/ddd/"/>
    <id>http://qinghua.github.io/ddd/</id>
    <published>2016-12-04T14:14:10.000Z</published>
    <updated>2016-12-23T15:37:43.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Domain-driven_design" target="_blank" rel="external">Domain Driven Design</a>（DDD）是Eric Evans于2004在其同名著作里提出的概念，它指明了让软件设计满足理想需求模型的方向。但是建模、设计这种事本来就很抽象，读懂这样的大作也是需要消耗不少脑细胞。本文希望能尽量以简单加实例的方式介绍DDD里的一些常见概念。<br><a id="more"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="什么是领域"><a href="#什么是领域" class="headerlink" title="什么是领域"></a>什么是领域</h3><p>《领域驱动设计》书里写的是：用户会把软件程序应用于某个主体区域，这个区域就是软件的领域。简单来说，就认为是公司的某块业务好了。如果领域比较大，可以将其拆分为多个子域（Subdomain），子域包含核心域（Core Domain）和支撑子域（Supporting Subdomain），核心域顾名思义，是最重要的子域，我们应该把关注点集中在它上面；其余的子域都是支撑子域。支撑子域里有一类特殊的用于解决通用问题的子域，称为通用子域（Generic Subdomain），例如用户和权限等。不过这些都是相对而言的，对于消费方来说，他的支撑子域有可能就是你的核心域。个别子域可能会有交集，称为共享内核（Shared Kernel），目的是减少重复，但是仍保持两个独立的上下文。由于不同子域的开发团队可能会同时修改共享内核，所以需要小心并注意沟通。</p>
<h3 id="要DDD做什么"><a href="#要DDD做什么" class="headerlink" title="要DDD做什么"></a>要DDD做什么</h3><p>DDD试图解决的是软件的复杂性问题，如果软件比较复杂，或者是预期会很复杂，或者是你不知道，那么都可以开始考虑DDD。否则，由于维系领域模型需要实现大量的封装和隔离，DDD会带来较大的成本。但是，DDD并不是一个笨重的开发过程，它能够和敏捷开发很好地结合起来，另外，DDD也倾向于“测试先行，逐步改进”。</p>
<h2 id="战略建模（Strategic-Modeling）"><a href="#战略建模（Strategic-Modeling）" class="headerlink" title="战略建模（Strategic Modeling）"></a>战略建模（Strategic Modeling）</h2><h3 id="通用语言（Ubiquitous-Language）"><a href="#通用语言（Ubiquitous-Language）" class="headerlink" title="通用语言（Ubiquitous Language）"></a>通用语言（Ubiquitous Language）</h3><p>其实写软件就像是翻译，把领域上的业务需求翻译成软件的各个功能。业务需求来自领域专家（Domain Expert），程序员们需要把领域专家的语言翻译成程序。如果程序员们翻译的时候使用的是自己的语言，而领域专家使用自己的行话，导致术语不一致，就会使得沟通不顺畅，难于消化知识。所以团队需要一种通用语言来进行沟通。这样的通用语言尽量以业务语言为主，而非技术语言。一开始的通用语言可能不尽完美，但它就像是代码一样，经常需要重构。例如：“创建一个订单”就比“插入一条订单数据”更容易让领域专家明白谈话的背景。</p>
<h3 id="限界上下文（Bounded-Context）"><a href="#限界上下文（Bounded-Context）" class="headerlink" title="限界上下文（Bounded Context）"></a>限界上下文（Bounded Context）</h3><p>通用语言里，同一个名词在不同的场景里不一定有相同的意思。比如用户，在推荐好友（可能关注年龄、性别、地域）或是浏览商品（可能关注喜好、历史购买记录）的时候有着不同的含义。所谓的不同的场景，其实就是不同的限界上下文。子域在限界上下文中完成开发。限界上下文主要用来封装通用语言和领域模型，显式地定义了领域模型的边界。不同的限界上下文，都会有一套自己的通用语言。通过这样的划分方式，来让每个限界上下文都尽量保持简单，也算是<a href="https://en.wikipedia.org/wiki/Single_responsibility_principle" target="_blank" rel="external">SRP</a>原则在不同粒度上的一个体现。如果不去做这样的划分，可能最终这个软件就会演变成一个<a href="https://en.wikipedia.org/wiki/Big_ball_of_mud" target="_blank" rel="external">大泥球</a>，或者说是<a href="https://en.wikipedia.org/wiki/Monolithic_application" target="_blank" rel="external">单块系统</a>。尽管如此，对于比较小的业务或项目来说，可能只会有一个限界上下文。现在流行的<a href="https://en.wikipedia.org/wiki/Microservices" target="_blank" rel="external">微服务</a>，很大程度上就是按照限界上下文来划分服务。例如：商品上下文，订单上下文，物流上下文等。当然，如果子域很小，不见得非得微服务化。</p>
<p>不同的限界上下文之间，通过上下文映射图（Context Map）来进行交互。上下文映射图其实就是一个简单的框图，表示限界上下文之间的的映射关系。下面这张图就是一个简单的例子：<br><img src="/img/ddd-context-map.jpg" alt=""></p>
<p>U表示上游（Upstream）的被依赖方，D表示下游（Downstream）的依赖方。由于上下游的限界上下文模型不同，实现时，可以用RPC、Restful、消息机制等集成方式。另外，下游需要防腐层（Anticorruption Layer）来将上游的返回内容翻译为下游的领域模型。如果防腐层过多地使用了各种赋值，从而导致上下游的模型非常类似，那就需要看看是否下游过多地使用了上游的数据，从而导致自己的模型不清晰。</p>
<h2 id="战术建模（Tactical-Modeling）"><a href="#战术建模（Tactical-Modeling）" class="headerlink" title="战术建模（Tactical Modeling）"></a>战术建模（Tactical Modeling）</h2><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><h4 id="实体（Entity）"><a href="#实体（Entity）" class="headerlink" title="实体（Entity）"></a>实体（Entity）</h4><p>所谓领域，反映到代码里就是模型。模型分为实体和值对象两种。实体是有标识（Identity）的，两个拥有相同属性的实体不是相等的，除非它们的标识相等；而不同实体的标识不能相等。例如：某人下了两个相同的订单，里面都购买了相同的商品。这两个订单就是有标识（订单号）的两个实体，虽然内容相同，但它们是两个不同的实体。常用的标识有自增数字、Guid、自然标识（如邮箱、身份证号）等。实体具有生命周期，它们的内容可能在这期间会发生改变，但是标识是永远不会变化的。实体作为领域模型的主体，需要拥有自己的方法，方法名来自于通用语言。通过这些方法来保证自己始终是一致的状态，而非被调用者set来set去。例如：<code>people.runTo(x, y)</code>，而非<code>people.setX(x);people.setY(y);</code></p>
<h4 id="值对象（Value-Object）"><a href="#值对象（Value-Object）" class="headerlink" title="值对象（Value Object）"></a>值对象（Value Object）</h4><p>实体用来表示领域中的一个东西，而值对象只用于描述或度量一个东西。值对象没有任何标识，只要两个值对象的属性相等，那么它们就是相等的。值对象是不可变的，如果要改变值对象的内容，那就重新创建一个值对象。值对象没有生命周期，因为它只是值而已。例如：金额（含数值和货币单位），颜色（含rgb值）等。因为不需要标识，所以它们其实比实体要简单许多。Java里的String类，就具有一个值对象的行为；C#的Struct其实就是一个值对象，不过一般还是会用Class来表示值对象。</p>
<p>不同的领域需求可能会催生不同的建模。例如：考虑一下演出的售票系统。如果需求是对号入座，那么座位就是实体，一旦某张演出票关联了某个座位，那么这个座位就再也不能被其它的演出票所关联了。如果需求是先到先坐，那么座位就是值对象，我们只关心卖了多少张演出票，不要超过座位上限即可，而并不用关心哪个座位被哪张票所关联了。</p>
<p>DDD的一个反模式就是拥有一堆<code>get</code>和<code>set</code>方法的贫血领域对象（Anemic Domain Object）。这样的对象只是一个数据持有器（data holder），而非我们想要的领域模型。值对象和实体一样，都需要有自己的方法。例如：金额值对象，有一个<code>Add</code>的方法，接受一个金额参数，返回一个新的值对象。</p>
<p>实体里可以包含值对象，值对象里也可以包含实体。</p>
<h4 id="领域服务（Domain-Service）"><a href="#领域服务（Domain-Service）" class="headerlink" title="领域服务（Domain Service）"></a>领域服务（Domain Service）</h4><p>有些操作不属于实体或者值对象，那就不用强塞给它们，创建领域服务来提供这些操作吧。留意通用语言，如果里面出现了名词，那一般就是实体或值对象；如果里面出现了动词，那通常就意味着领域服务。例如：支付，这是一个比较明显的业务操作。另外，如果有什么操作会让实体变得臃肿，也可以使用领域服务来解决。但是，不能把所有的东西都堆到领域服务里，过度使用领域服务会导致贫血对象的产生。</p>
<p>据Eric Evans所言，设计良好的领域服务具有以下三个特征：</p>
<ul>
<li>操作不是实体/值对象的一个自然的部分</li>
<li>接口根据领域模型的其它元素定义</li>
<li>操作无状态</li>
</ul>
<p>还需要注意的是，不要把领域服务和应用服务混起来了。我们在领域服务里处理业务逻辑，而并不在应用服务里处理。应用服务是领域模型的直接客户，负责处理事务、安全等操作。</p>
<h4 id="领域事件（Domain-Event）"><a href="#领域事件（Domain-Event）" class="headerlink" title="领域事件（Domain Event）"></a>领域事件（Domain Event）</h4><p>《领域驱动设计》一书出版之后，DDD社区并没有停止前进的步伐。领域事件就是在那之后提出来的。领域事件是一个定义了领域专家所关心的事件的对象。当关心的状态由于模型行为而发生改变时，系统将发布领域事件。如果通用语言里出现了：“当……的时候，需要……”通常就意味着一个领域事件。例如：当订单完成支付时，商品需要出库。这里的订单完成支付就预示着一个OrderPaidEvent，里面持有着这个订单的标识。领域事件代表的是已经发生的事，所以命名上通常都使用过去时（如Paid）。对领域事件的处理就像是一个观察者模式，由领域事件的订阅方来决定。订阅方既可以是本地的限界上下文，也可以是外部的限界上下文。</p>
<h4 id="模块（Module）"><a href="#模块（Module）" class="headerlink" title="模块（Module）"></a>模块（Module）</h4><p>如果领域模型发展得比较快，很难整体来讨论它，因为太大了。我们可以将模块视为Java中的包或是C#中的命名空间。将模型组织到不同的模块中，可以有效地降低领域的复杂性。模块之间应该是低耦合的，而模块内部应该是高内聚的。模块的名称应该是通用语言的组成部分，反映出领域的深层知识。</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><h4 id="聚合（Aggregate）"><a href="#聚合（Aggregate）" class="headerlink" title="聚合（Aggregate）"></a>聚合（Aggregate）</h4><p>聚合就是一组应该呆在一起的对象，聚合根（Aggregate Root）就是聚合在一起的基础，并提供对这个聚合的操作。聚合除了聚合根以外，还有自己的边界（boundary），即聚合里有什么。例如：一个订单可以有多个订单明细，订单明细不可能脱离订单而存在，而订单也不可能没有订单明细。这种情况下，订单和订单明细就是一个聚合，而订单就是这个聚合的聚合根，订单和订单明细就处于这个聚合的边界之内。如果要变更订单明细，我们需要通过操作聚合根订单来实现，如<code>order.changeItemCount()</code>，而非订单明细自身。另外一个例子：一名客户可以有多个订单，订单不可能脱离客户而存在，而客户却可以没有订单。这种情况下，客户和订单就是不同的两个聚合，一个聚合以客户为聚合根，另一个聚合以订单为聚合根，引用客户的标识。客户里并不引用订单的标识，这样将关联减至最少有助于简化对象的关系网。但是带来的一个麻烦就是如果要查找某位客户的所有订单，就不得不从所有的订单里查，而不能从客户这个聚合里直接获得。最后再举一个多对多的例子：一个班级可以有多名学生，学生可以脱离这个班级而存在，而班级不能没有学生，学生也不能不在班级里。这种情况下，班级和学生也是不同的两个聚合，一个聚合以班级为聚合根，引用学生的标识；另一个聚合以学生为聚合根，引用班级的标识，将多对多转换成两个一对多。</p>
<p>聚合是持久化的一个单位，我们需要保证以聚合为单位的数据一致性。如果聚合太大，那就会导致并发修改困难，多人并发修改同一个聚合里的不同项目，结果就是只有第一个提交的人成功修改，其它人不得不重新刷新聚合才能再次修改。大聚合还会导致性能问题，因为操作实体时会将整个大聚合同时加载进内存。珍爱生命，拒绝大聚合。</p>
<p>聚合根必须是实体而非值对象，因为它需要整体持久化，所以一定会有标识。而聚合根里的各个元素，既可能是实体，也可能是值对象。例如：一个订单（聚合根）一般会有订单明细（实体）和送货地址（值对象）。这些元素里可以有对聚合根的引用，但是不能相互引用。任何对其它元素的操作都必须通过聚合根来进行。聚合根里的标识是全局的，聚合根里的实体标识是聚合里唯一的本地标识，因为对它的访问都是通过聚合根来操作的。聚合根拥有自己独立的生命周期，其实体的生命周期从属于其所属的聚合，值对象因为只是值而已，并没有生命周期。</p>
<h4 id="工厂（Factory）"><a href="#工厂（Factory）" class="headerlink" title="工厂（Factory）"></a>工厂（Factory）</h4><p>工厂是生命周期的开始阶段，它可以用来创建复杂的对象或是一整个聚合。复杂对象的创建是领域层的职责，但它并不属于被创建的对象自身的职责。实体和值对象的工厂不太一样，因为值对象是不可变的，所以需要工厂一次性创建一个完整的值对象出来。而实体工厂则可以选择创建之后再补充一些细节。</p>
<h4 id="资源库（Repository）"><a href="#资源库（Repository）" class="headerlink" title="资源库（Repository）"></a>资源库（Repository）</h4><p>资源库是生命周期的结束，它封装了基础设施以提供查询和持久化聚合的操作。这样能够让我们始终聚焦于模型，而把对象的存储和访问都委托给资源库来完成。以订单和订单明细的聚合为例，因为一定是通过订单这个聚合根来获取订单明细，所以可以有订单的资源库，但是不能有订单明细的资源库。也就是说，只有聚合才拥有资源库。需要注意的是，资源库并不是数据库的封装，而是领域层与基础设施之间的桥梁。DDD关心的是领域内的模型，而并非是数据库的操作。理想的资源库对客户（而非开发者）隐藏了内部的工作细节，委托基础设施层来干那些脏活，到关系型数据库、NOSQL、甚至内存里读取和存储数据。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://book.douban.com/subject/5344973/" target="_blank" rel="external">《领域驱动设计》</a><br><a href="https://book.douban.com/subject/25844633/" target="_blank" rel="external">《实现领域驱动设计》</a><br><a href="http://www.infoq.com/cn/minibooks/domain-driven-design-quickly-new" target="_blank" rel="external">《领域驱动设计精简版》</a> by InfoQ<br><a href="http://devlicio.us/blogs/casey/archive/2009/02/09/domain-driven-design-a-step-by-step-guide.aspx" target="_blank" rel="external">《Domain Driven Design: A Step by Step Guide》</a>系列</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Domain-driven_design&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Domain Driven Design&lt;/a&gt;（DDD）是Eric Evans于2004在其同名著作里提出的概念，它指明了让软件设计满足理想需求模型的方向。但是建模、设计这种事本来就很抽象，读懂这样的大作也是需要消耗不少脑细胞。本文希望能尽量以简单加实例的方式介绍DDD里的一些常见概念。&lt;br&gt;
    
    </summary>
    
      <category term="architecture" scheme="http://qinghua.github.io/categories/architecture/"/>
    
    
      <category term="DDD" scheme="http://qinghua.github.io/tags/DDD/"/>
    
  </entry>
  
  <entry>
    <title>轻松上手数据库版本管理工具Flyway</title>
    <link href="http://qinghua.github.io/flyway/"/>
    <id>http://qinghua.github.io/flyway/</id>
    <published>2016-11-13T01:48:21.000Z</published>
    <updated>2016-12-23T15:37:43.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://flywaydb.org/" target="_blank" rel="external">Flyway</a>是一个用Java编写的开源数据库版本管理工具，或者说是数据库结构变更工具，旨在帮助开发和运维更容易地管理数据库演进过程中的各个版本。它的源代码在<a href="https://github.com/flyway/flyway" target="_blank" rel="external">github</a>上。<br><a id="more"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在开发过程中，数据库是不断向前演进的，可以说是拥有“版本”这个概念。通常当在生产环境部署新代码的时候，会由开发或者DBA来做数据库结构变更的操作。当数据库较小，环境数量少的时候，人工操作比较有把握，直接就人肉来做结构变更了。可要是在数据库复杂、环境数量多（开发、测试、预发布、生产……）的情况下，人工处理这样的事就开始有些令人担心了。如何保证所有环境的数据库结构是一致的？如何知道当前环境的数据库是哪个状态？如何知道生产环境的一个关于数据库的hotfix是否也在预发布环境中执行了？Flyway就是用来解决这样的问题的工具。它的原理非常简单，就是在数据库中创建一张自己用的表，例如schema_version，在里面存放数据库当前的状态，以此来管理数据库的版本。Flyway提供了<a href="https://flywaydb.org/getstarted/firststeps/commandline" target="_blank" rel="external">命令行</a>、<a href="https://flywaydb.org/getstarted/firststeps/api" target="_blank" rel="external">API</a>、<a href="https://flywaydb.org/getstarted/firststeps/maven" target="_blank" rel="external">Maven</a>、<a href="https://flywaydb.org/getstarted/firststeps/gradle" target="_blank" rel="external">Gradle</a>、<a href="https://flywaydb.org/getstarted/firststeps/ant" target="_blank" rel="external">Ant</a>、<a href="https://flywaydb.org/getstarted/firststeps/sbt" target="_blank" rel="external">SBT</a>等各种方式，来让我们更容易将其与自己的项目结合。类似的工具还有<a href="http://www.liquibase.org/" target="_blank" rel="external">Liquibase</a>、<a href="http://dbdeploy.com/" target="_blank" rel="external">dbdeploy</a>等。</p>
<p>本文将会用Docker来创建一个mysql的实例，用Maven来创建一个包含数据库的Java项目，并使用Flyway来进行版本管理。</p>
<h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><p>首先请自行安装Docker、Java、Maven和喜欢的IDE。我用的是<a href="https://www.jetbrains.com/idea/download/" target="_blank" rel="external">Intellij IDEA社区版</a>。我用Vagrant启动了一台已经安装过Docker的Ubuntu虚拟机，它的IP是<code>192.168.33.88</code>，可以用以下命令来直接启动mysql容器来提供数据库服务并创建ggg数据库：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker run -d --net=host --name=mysql -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7.12</div><div class="line">docker <span class="built_in">exec</span> -it mysql mysql -uroot -p123456 -e <span class="string">'create database ggg;'</span></div></pre></td></tr></table></figure></p>
<p>接下来新建一个Maven工程helloFlyway：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mvn archetype:generate -B \</div><div class="line">        -DarchetypeGroupId=org.apache.maven.archetypes \</div><div class="line">        -DarchetypeArtifactId=maven-archetype-quickstart \</div><div class="line">        -DarchetypeVersion=1.1 \</div><div class="line">        -DgroupId=org.ggg.flyway \</div><div class="line">        -DartifactId=helloFlyway \</div><div class="line">        -Dversion=1.0-SNAPSHOT \</div><div class="line">        -Dpackage=org.ggg.flyway</div></pre></td></tr></table></figure></p>
<p>在<code>helloFlyway/pom.xml</code>里加入flyway的maven插件和mysql-connector-java的依赖（别忘了根据你自己的数据库来配置jdbc）：<br><figure class="highlight xml"><figcaption><span>pom.xml</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">...</span>&gt;</span></div><div class="line">    ...</div><div class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.flywaydb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flyway-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">url</span>&gt;</span>jdbc:mysql://192.168.33.88:3306/ggg<span class="tag">&lt;/<span class="name">url</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">user</span>&gt;</span>root<span class="tag">&lt;/<span class="name">user</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">password</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">password</span>&gt;</span></div><div class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.38<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">                <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>接下来创建一个数据库版本1的文件：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> helloFlyway</div><div class="line">mkdir -p src/main/resources/db/migration/</div><div class="line">cat &lt;&lt; EOF &gt; src/main/resources/db/migration/V1__Create_person_table.sql</div><div class="line">create table PERSON (</div><div class="line">    ID int not null,</div><div class="line">    NAME varchar(100) not null</div><div class="line">);</div><div class="line">EOF</div></pre></td></tr></table></figure></p>
<p>工程创建好并用intellij导入后，应该是这样的：<br><img src="/img/flyway-new-project.jpg" alt=""></p>
<h2 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h2><p>使用以下命令来运行flyway：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mvn flyway:migrate</div></pre></td></tr></table></figure></p>
<p>出现<strong>BUILD SUCCESS</strong>就说明数据库结构变更已经完成了。我们可以登录到数据库看一看：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> -it mysql mysql -uroot -p123456</div></pre></td></tr></table></figure></p>
<p>运行以下sql就可以看到flyway确实已经起作用了：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">USE</span> ggg</div><div class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLES</span>;</div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> schema_version;</div></pre></td></tr></table></figure></p>
<p>而表schema_version里面也有了一条记录。接下来再创建一个数据库版本2的文件：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cat &lt;&lt; EOF &gt; src/main/resources/db/migration/V2__Add_people.sql</div><div class="line">insert into PERSON (ID, NAME) values (1, <span class="string">'Axel'</span>);</div><div class="line">insert into PERSON (ID, NAME) values (2, <span class="string">'Mr. Foo'</span>);</div><div class="line">insert into PERSON (ID, NAME) values (3, <span class="string">'Ms. Bar'</span>);</div><div class="line">EOF</div></pre></td></tr></table></figure></p>
<p>再次用同一条命令来运行flyway：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mvn flyway:migrate</div></pre></td></tr></table></figure></p>
<p>就会看到日志里显示<strong>Current version of schema `ggg`: 1</strong>和<strong>Migrating schema `ggg` to version 2 - Add people</strong>。如果我们重复运行<code>mvn flyway:migrate</code>，就会看到<strong>Schema `ggg` is up to date. No migration necessary</strong>。现在查看一下两张表：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> PERSON;</div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> schema_version;</div></pre></td></tr></table></figure></p>
<p>PERSON表里已经有了<code>V2__Add_people.sql</code>里的三条记录，而schema_version表里，就可以看到现在的版本为2。通过这样的方式，就可以管理数据库的版本了。</p>
<h2 id="历史数据库"><a href="#历史数据库" class="headerlink" title="历史数据库"></a>历史数据库</h2><p>如果数据库里已经有历史数据了，那就会稍微麻烦一点儿。我们来试试看，首先改造一下ggg数据库：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">RENAME</span> <span class="keyword">TABLE</span> PERSON <span class="keyword">TO</span> STUDENT;</div><div class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> schema_version;</div></pre></td></tr></table></figure></p>
<p>这样一来，数据库的版本便被清空，PERSON表也变成了STUDENT表。如果直接运行<code>mvn flyway:migrate</code>会报错：<strong>org.flywaydb.core.api.FlywayException: Found non-empty schema `ggg` without metadata table</strong>。这时候需要用到另一个命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mvn flyway:baseline</div></pre></td></tr></table></figure></p>
<p>上面的<code>baseline</code>命令会以现在的数据库结构为基础，创建一张schema_version表，标明现在的版本是1。接着运行<code>mvn flyway:migrate</code>还会报错：<strong>Migration of schema <code>ggg</code> to version 2 - Add people failed</strong>。这是因为数据库现在是版本1，所以会忽略<code>V1__Create_person_table.sql</code>而直接执行<code>V2__Add_people.sql</code>，而<code>V2__Add_people.sql</code>依赖于<code>V1__Create_person_table.sql</code>里创建的PERSON表，所以失败了。解决的方法也很简单，改变两个sql文件的版本即可：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mv src/main/resources/db/migration/V1__Create_person_table.sql src/main/resources/db/migration/V1_1__Create_person_table.sql</div><div class="line">mv src/main/resources/db/migration/V2__Add_people.sql src/main/resources/db/migration/V1_2__Add_people.sql</div><div class="line">mvn flyway:migrate</div></pre></td></tr></table></figure></p>
<p>Flyway的命名规范如下：以<code>V</code>开头，<code>.sql</code>结尾，版本号可以使用<code>.</code>或者<code>_</code>，版本号和描述之间用两个下划线<code>__</code>分开。要是执行成功，但是却看不到PERSON表，那很可能是因为schema_version表里的版本已经是一个<strong>错误的</strong>版本2了，运行repair之后再重新migrate即可：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mvn flyway:<span class="keyword">repair</span></div><div class="line">mvn flyway:migrate</div></pre></td></tr></table></figure></p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>Flyway认为<a href="https://flywaydb.org/documentation/faq.html#downgrade" target="_blank" rel="external">没有必要支持回滚</a>。可以通过<code>mvn flyway:info</code>命令来查看数据库的版本和和需要执行的sql脚本。通过<code>mvn flyway:clean</code>来清空数据库，这条命令对于测试很方便，但是<strong>千万要小心生产环境！！！</strong>此外，还有一个较常用的命令：<code>mvn flyway:validate</code>可以验证是否所有的sql都已经在数据库上运行完毕了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://flywaydb.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Flyway&lt;/a&gt;是一个用Java编写的开源数据库版本管理工具，或者说是数据库结构变更工具，旨在帮助开发和运维更容易地管理数据库演进过程中的各个版本。它的源代码在&lt;a href=&quot;https://github.com/flyway/flyway&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github&lt;/a&gt;上。&lt;br&gt;
    
    </summary>
    
      <category term="db" scheme="http://qinghua.github.io/categories/db/"/>
    
    
      <category term="flyway" scheme="http://qinghua.github.io/tags/flyway/"/>
    
      <category term="db" scheme="http://qinghua.github.io/tags/db/"/>
    
      <category term="db migration" scheme="http://qinghua.github.io/tags/db-migration/"/>
    
  </entry>
  
  <entry>
    <title>程序员常见的编码和转义</title>
    <link href="http://qinghua.github.io/encoding-and-escaping/"/>
    <id>http://qinghua.github.io/encoding-and-escaping/</id>
    <published>2016-11-06T01:53:09.000Z</published>
    <updated>2016-12-23T15:37:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名天朝程序员，除了看惯了乱码之外，在日常的工作中经常会碰到编码和转义。如果能掌握这块领域的一些常识，就可以在开发和支持时游刃有余。<br><a id="more"></a></p>
<h2 id="编码（encoding）"><a href="#编码（encoding）" class="headerlink" title="编码（encoding）"></a>编码（encoding）</h2><h3 id="ASCII-amp-EASCII-amp-ISO-8859-1"><a href="#ASCII-amp-EASCII-amp-ISO-8859-1" class="headerlink" title="ASCII &amp; EASCII &amp; ISO-8859-1"></a>ASCII &amp; EASCII &amp; ISO-8859-1</h3><p>要聊编码，就需要从ASCII开始。众所周知，计算机的世界里，数据都是0和1这样的二进制。用它们的组合来表示字母、数字和常用符号的最通用编码标准就是<a href="https://zh.wikipedia.org/wiki/ASCII" target="_blank" rel="external">ASCII</a>（American Standard Code for Information Interchange，美国信息交换标准代码）。完整的ASCII编码可以从<a href="http://www.ascii-code.com/" target="_blank" rel="external">这里</a>找到。Mac或Linux可以用以下命令来查看所有的ASCII字符：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">man ascii</div></pre></td></tr></table></figure></p>
<p>其中，<code>00000000</code>到<code>00011111</code>的前32位字符和<code>01111111</code>是控制字符，<code>00100000</code>到<code>01111110</code>之间的都是可显示字符，一个字符占8位（bit），第1位总是<code>0</code>，这样能够支持2的7次方即128个符号编码。虽然ASCII编码能搞定美国大多数的应用场景，但是对于其它发达国家的语言来说就无能为力了。于是在其上发展出了<a href="https://zh.wikipedia.org/wiki/EASCII" target="_blank" rel="external">EASCII</a>（extended ASCII），通过扩展最前面的一位为<code>1</code>来提供多达256个符号编码的支持。可是这样又带来了两个问题：一来即使是256个编码，对于世界范围尤其是像中日这样的汉字国家来说还是远远不够；二来各个国家规定的EASCII编码都不一样，比如对于希腊来说EASCII表示的就是希腊字母，而对于法国来说可能就是某个带有注音符号的字母。这样的背景下，ISO（International Standard Organization，国际标准化组织）设计了<a href="https://zh.wikipedia.org/wiki/ISO/IEC_8859" target="_blank" rel="external">ISO/IEC 8859</a>字符集（不包含ASCII），力图一统拉丁语系。其实现的编码表<a href="https://zh.wikipedia.org/wiki/ISO_8859-1" target="_blank" rel="external">ISO-8859-1</a>（包含ASCII）应用得非常广泛。</p>
<h3 id="GB2312-amp-GBK-amp-GB18030-amp-ANSI"><a href="#GB2312-amp-GBK-amp-GB18030-amp-ANSI" class="headerlink" title="GB2312 &amp; GBK &amp; GB18030 &amp; ANSI"></a>GB2312 &amp; GBK &amp; GB18030 &amp; ANSI</h3><p>本节介绍的是解决EASCII带来的第一个问题的方法。对于中文来说，8位的编码远远不够，于是就会想到用两个8位来表示一个汉字。为了与ASCII码兼容，如果碰到0~127的字符，需要认定为ASCII编码字符。只有当两个大于127的字符连在一起时，才表示一个汉字。前一个字符称为高字节，后一个称为低字节，这样就诞生了<a href="https://zh.wikipedia.org/wiki/GB_2312" target="_blank" rel="external">GB2312</a>编码。每一个双字节字符就称为一个全角字符，而单字节字符就称为半角字符。再后来，发现编码还是不够用，干脆就允许低字节也使用0~127的字符，反正用高字节就能判断是否是汉字，这样就诞生了<a href="https://zh.wikipedia.org/wiki/GBK" target="_blank" rel="external">GBK</a>（K表示“扩展”）编码。GBK里甚至还包含了日语的假名和俄语字母。GB2312和GBK这两种编码都是单字节（表示ASCII）和双字节（表示汉字）混合使用的编码。我国最新的汉字编码国标是<a href="https://zh.wikipedia.org/wiki/GB_18030" target="_blank" rel="external">GB18030</a>，这是一种类似下文UTF-8那样的变长编码。</p>
<p>虽然中国解决了中文问题，但是世界各国都搞出了一套自己的编码系统，还是不能轻易相互转化。例如台湾用BIG5，日本用Shift-JIS。要想解决EASCII的第二个问题，还需要另寻他途。Window系统的记事本里，默认编码为ANSI，即根据系统语言的不同，而选用不同的编码。</p>
<h3 id="Unicode-amp-UTF-8"><a href="#Unicode-amp-UTF-8" class="headerlink" title="Unicode &amp; UTF-8"></a>Unicode &amp; UTF-8</h3><p>本节说的是解决EASCII带来的第二个问题的方法。ISO带来了一个囊括全球所有文字的编码：Unicode。它最初规定了所有的字符（包括ASCII）都使用两个字节来表示，这个版本称为<a href="https://zh.wikipedia.org/wiki/UCS-2" target="_blank" rel="external">UCS-2</a>（Universal Multiple-Octet Coded Character Set）或UTF-16。对于ASCII码来说，在它的前面加上<code>00000000</code>作为高字节即可。这样的好处是，由于高低字节可以同时包含0~256，能表示的字符数量就更多了，理论上可以达到256×256=65536个。即使如此，也只能说是基本上够用，要囊括所有文明的文字，还需要更多的字节。目前最多支持4个字节代表一个字符，称为<a href="https://zh.wikipedia.org/wiki/UCS-4" target="_blank" rel="external">UCS-4</a>或UTF-32，它的最高位规定必须为0，可以表示65536×65536÷2=2147483648个字符（这样是不是统一银河系也够用了）。与此同时，它包含的字符集也在不断的增加，甚至收录了<a href="https://zh.wikipedia.org/wiki/%E7%B9%AA%E6%96%87%E5%AD%97" target="_blank" rel="external">emoji</a>（绘文字），大大增加了文字符号的表现力，看看😂🐔📸🎸🎁🌀🌤🕘，是不是增加了很多乐趣呢。</p>
<p>Unicode就像是“书同文、车同轨”，极大地方便了各国的交流。可是它也有自身的缺点。一个问题是它与各国自身的标准不兼容（例如GB18030），但是这个问题貌似无解，因为各国的标准本来就是排斥的。另一个问题是随着Unicode标准的发展，出现了4个字节的字符。但是当设计Java的时候，是<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#unicode" target="_blank" rel="external">将unicode当做2个字节的定长字符来看待</a>的。这样就导致Java里需要用两个char来表示一个4字节的字符，如emoji（😂=\uD83D\uDE02）。<a href="http://www.oracle.com/technetwork/articles/javase/index-zh-cn-138452.html" target="_blank" rel="external">Java平台中的增补字符</a>就是Oracle官方写来专门解决长字节Unicode的。打开链接就会看到一堆的乱码，说明编码问题还真是普遍存在并难以解决的啊。好在还有<a href="http://www.oracle.com/technetwork/articles/javase/index-142761.html" target="_blank" rel="external">英文版</a>可供阅读。还有一个问题就是对于英文来说，用高字节为固定值的两个字节来保存数据，就会使原来一个字节的数据量翻倍，对于传输和存储来说都是较大负担。</p>
<p>解决上面这个问题的办法就是UTF-8。它是一种变长的编码方式。如果是ASCII码的字符，就用一个字节表示。否则就在前面增加一个高位字节（但是在8个bit之内）。这回英文符号是满意了，但是中文字符可能就会因为增加的高位字节从Unicode的占用两个字节变成UTF-8的占用三个字节。没有两全其美的事啊！这也是为什么GB2312和GBK今天仍被广泛使用的原因之一，我们也不想增加传输和存储的负担呀。</p>
<p>如果要打开一个文本文件，首先需要知道它的编码。位于文件头的<a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E5%85%83%E7%B5%84%E9%A0%86%E5%BA%8F%E8%A8%98%E8%99%9F" target="_blank" rel="external">BOM</a>（Byte order mark，字节顺序标记）可以用来标记文件的编码类型。它分为<a href="https://en.wikipedia.org/wiki/Endianness#Big-endian" target="_blank" rel="external">BE</a>（big-endian，大端序）和<a href="https://en.wikipedia.org/wiki/Endianness#Little-endian" target="_blank" rel="external">LE</a>（little-endian，小端序），指的是高字节的位置在前还是在后。但是在类Unix系统中，它很可能因为无法被程序识别而带来一系列问题。所以一般的纯文本文件还是建议保存为不带BOM形式的编码。Window系统的记事本里，如果输入<code>联通</code>保存，便会将其保存为无BOM的GB格式，再次用记事本打开此文件时，因为没有BOM信息，记事本就需要自己推断这个文件的编码是什么。显然window是上这个推断很有问题，误认为是UTF-8格式（可以从文件菜单里的“另存为”看出来）。而mac上默认的文本编辑表现还是不错的。如果用word来打开它，便可以在一系列的编码中，自行寻找合适的编码来打开。如果用记事本另存为UTF-8格式，便不会有问题。Sublime Text可以支持用许多不同的编码来打开或是保存，光是UTF系列的就不少，如下图：<br><img src="/img/sublime-text-encoding.png" alt="sublime-text-encoding"></p>
<p>对于Java来说，内部的String编码默认为UTF-16，但如果由于用不着而觉得浪费内存的话，可以在JVM打开<code>-XX:+UseCompressedStrings</code>，就会变成ISO-8859-1了。Intellij IDEA的Preference里，有两个关于encoding的选项：<br><img src="/img/intellij-idea-encoding.jpg" alt="Intellij-IDEA-encoding"></p>
<p>可以通过Project Encoding来指定项目的JVM里String的内部编码，默认为UTF-8。可以通过下面这两个表达式来看到，它们的编码是完全一致的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">"懒"</span>.getBytes()</div><div class="line"><span class="string">"懒"</span>.getBytes(<span class="string">"UTF-8"</span>)</div></pre></td></tr></table></figure></p>
<p>Java里可以用Integer.toHexString来看到汉字的unicode编码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out.println(<span class="string">"\\u"</span> + Integer.toHexString(<span class="string">'懒'</span>));</div><div class="line">System.out.println(<span class="string">"\u61d2"</span>);</div></pre></td></tr></table></figure></p>
<p>通过下面的语句，可以将字节数组byte[]还原为原先的字符串。如果指定错了编码，就会看到乱码产生啦：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">System.out.println(<span class="keyword">new</span> String(<span class="string">"懒"</span>.getBytes(<span class="string">"UTF-8"</span>), <span class="string">"UTF-8"</span>));  <span class="comment">// 正常</span></div><div class="line">System.out.println(<span class="keyword">new</span> String(<span class="string">"懒"</span>.getBytes(<span class="string">"UTF-8"</span>), <span class="string">"UTF-16"</span>)); <span class="comment">// 乱码:�</span></div><div class="line">System.out.println(<span class="keyword">new</span> String(<span class="string">"懒"</span>.getBytes(<span class="string">"UTF-16"</span>), <span class="string">"UTF-8"</span>)); <span class="comment">// 乱码:��a�</span></div></pre></td></tr></table></figure></p>
<p>读文件、流也是一样的道理，知道了它们的编码才能正确地读取，否则只好像微软的记事本那样去猜啦。Java还提供了一个小工具<code>native2ascii</code>，可以把本地编码的文件转换为各种格式：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> 懒程序员 &gt; ggg.txt</div><div class="line">native2ascii -encoding UTF-8 ggg.txt out.txt</div><div class="line">cat out.txt</div><div class="line">native2ascii -reverse -encoding UTF-8 out.txt</div></pre></td></tr></table></figure></p>
<h3 id="base64-amp-UTF-7"><a href="#base64-amp-UTF-7" class="headerlink" title="base64 &amp; UTF-7"></a>base64 &amp; UTF-7</h3><p><a href="https://zh.wikipedia.org/zh-hans/Base64" target="_blank" rel="external">Base64</a>是一种在网络上传递信息时常见的编码。它相当于是一张64条记录的映射表，键从<code>000000</code>到<code>111111</code>，值就是64个不同的字符。编码时，如果原字符的bit数正好能被6整除，那就查表得到每6个bit所对应的值，合起来就是base64编码的结果。如果不能被6整除，那就在末尾用0补足。每补两个0，就在最终结果的后面加一个<code>=</code>号。所以如果一段数据以等号结尾，那十有八九就是base64编码。Mac或Linux可以用以下命令来进行base64编码及解码：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> -n A | base64</div><div class="line"><span class="built_in">echo</span> -n AB | base64</div><div class="line"><span class="built_in">echo</span> -n ABC | base64</div><div class="line"><span class="built_in">echo</span> -n QQ== | base64 --decode</div><div class="line"><span class="built_in">echo</span> -n QUI= | base64 --decode</div><div class="line"><span class="built_in">echo</span> -n QUJD | base64 --decode</div></pre></td></tr></table></figure></p>
<p>JavaScript可以用以下命令来进行base64编码及解码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.btoa(<span class="string">"A"</span>)</div><div class="line"><span class="built_in">window</span>.atob(<span class="string">"QQ=="</span>)</div></pre></td></tr></table></figure></p>
<p><a href="https://zh.wikipedia.org/wiki/UTF-7" target="_blank" rel="external">UTF-7</a>理论上也属于一种base64编码，只不过它的64行映射表不一样罢了。过去的SMTP协议仅能接受7个bit（ASCII）的字符，Unicode无法直接传输。所以通过UTF-7编码的方式，将Unicode字符转换为7个bit以内的字符。UTF-7本身并不是Unicode的标准，现在也已经由于邮件和传输都支持UTF-8而退出历史舞台了。</p>
<p>写到这里感觉得收一下了，不然MD5、SHA什么的都要出来了。对散列、加密有兴趣的童鞋们可以参考我以前写的另一篇文章<a href="http://qinghua.github.io/certificate/">《证书的那些事儿》</a>。</p>
<h2 id="转义（escaping）"><a href="#转义（escaping）" class="headerlink" title="转义（escaping）"></a>转义（escaping）</h2><h3 id="html-amp-url"><a href="#html-amp-url" class="headerlink" title="html &amp; url"></a>html &amp; url</h3><p>下面说说转义，不少人都把它与编码混而一谈，以至于它也算作编码的一部分了。从最简单的html聊起吧。在html里，如果只写上一些文本，那当我们用浏览器打开这个html时，就会完完整整地显示这些文本的内容。我们也知道，html里无论输入多少个空格，只会显示一个空格。因为在html里，把空格当成了特殊字符。在这种情况下，如果想要在html里放上空格，就需要对空格编码，也就是大家熟知的<code>&amp;nbsp;</code>。其中nbsp大名唤作Non-Breaking Space（<a href="https://zh.wikipedia.org/wiki/%E4%B8%8D%E6%8D%A2%E8%A1%8C%E7%A9%BA%E6%A0%BC" target="_blank" rel="external">不换行空格</a>），除了名字以外，它也有自己的编码：<code>&amp;#160;</code>。除了空格，常见的还有代表标签的<code>&lt;</code>和<code>&gt;</code>。完整的html转义可以从<a href="http://www.ascii.cl/htmlcodes.htm" target="_blank" rel="external">这里</a>找到。奇怪的是这么常用的转义，js居然没有原生的函数支持。如果要转义<code>&lt;div&gt;</code>，可以使用下面这条语句来得到<code>&amp;lt;div&amp;gt;</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">htmlEncode</span>(<span class="params">html</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.createElement(<span class="string">'a'</span>).appendChild(<span class="built_in">document</span>.createTextNode(html)).parentNode.innerHTML;</div><div class="line">&#125;;</div><div class="line">htmlEncode(<span class="string">'&lt;div&gt;'</span>);</div></pre></td></tr></table></figure></p>
<p>解码的话，这样做：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">htmlDecode</span>(<span class="params">html</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> a = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</div><div class="line">    a.innerHTML = html;</div><div class="line">    <span class="keyword">return</span> a.textContent;</div><div class="line">&#125;;</div><div class="line">htmlDecode(<span class="string">'&amp;lt;div&amp;gt;'</span>);</div></pre></td></tr></table></figure></p>
<p>如果使用jQuery，思路一致，但是代码可以稍微短一点：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">htmlEncode</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> $(<span class="string">'&lt;div/&gt;'</span>).text(value).html();</div><div class="line">&#125;</div><div class="line">htmlEncode(<span class="string">'&lt;div&gt;'</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">htmlDecode</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> $(<span class="string">'&lt;div/&gt;'</span>).html(value).text();</div><div class="line">&#125;</div><div class="line">htmlDecode(<span class="string">'&amp;lt;div&amp;gt;'</span>);</div></pre></td></tr></table></figure></p>
<p>可惜的是上面的函数并不能解决空格和<code>&amp;nbsp;</code>之间的转换。想要个万能的？也许只好使用replace一个个地慢慢替换了。</p>
<p>想要请求一个html，需要先输入一个url。这里就涉及到了url转义。因为url里可能会有类似<code>?name=ggg</code>这样的参数，所以起码就需要对<code>?</code>和<code>=</code>进行转义。转义之后分别为<code>%3F</code>和<code>%3D</code>，这与ASCII码是相对应的。完整的url编码可以从<a href="http://www.w3school.com.cn/tags/html_ref_urlencode.html" target="_blank" rel="external">这里</a>找到。这回js终于有原生的函数支持了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">encodeURI</span>(<span class="string">'http://qinghua.github.io?name=g gg'</span>);</div><div class="line"><span class="built_in">encodeURIComponent</span>(<span class="string">'http://qinghua.github.io?name=g gg'</span>);</div></pre></td></tr></table></figure></p>
<p>用<code>encodeURI</code>函数的网址，不会去碰<code>http://</code>，所以编码后还是一个合法的网址。而<code>encodeURIComponent</code>会将一切都进行编码，网址也就不是网址了。不过它很适合将网址作为参数来使用。解码的话，这样做：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">decodeURI</span>(<span class="string">'http://qinghua.github.io?name=g%20gg'</span>);</div><div class="line"><span class="built_in">decodeURIComponent</span>(<span class="string">'http%3A%2F%2Fqinghua.github.io%3Fname%3Dg%20gg'</span>);</div></pre></td></tr></table></figure></p>
<p>在Java里可以用以下语句来完成url的转义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">URLEncoder.encode(<span class="string">"懒"</span>, <span class="string">"UTF-8"</span>);</div><div class="line">URLDecoder.decode(<span class="string">"%E6%87%92"</span>, <span class="string">"UTF-8"</span>);</div></pre></td></tr></table></figure></p>
<h3 id="XML-amp-YAML-amp-JSON-amp-CSV"><a href="#XML-amp-YAML-amp-JSON-amp-CSV" class="headerlink" title="XML &amp; YAML &amp; JSON &amp; CSV"></a>XML &amp; YAML &amp; JSON &amp; CSV</h3><p>在这些数据格式中，对xml的转义基本上跟html差不多，这里就不再赘述了。对于yaml来说，规则如下：</p>
<ol>
<li>在一个单引号标注的字符串中，一个单引号需要转义成两个单引号</li>
<li>在一个双引号标注的字符串中，大部分符号都需要用反斜杠来转义</li>
<li>如果字符串中有控制字符（如<code>\0</code>、<code>\n</code>等），需要用双引号来标注</li>
<li>如果字符串看起来像下面的样子，需要用引号（无所谓哪种）来标注：<ul>
<li><code>true</code>或<code>false</code></li>
<li><code>null</code>或<code>~</code></li>
<li>看起来像数字，如<code>2</code>，<code>14.9</code>，<code>12e7</code>等</li>
<li>看起来像日期，如<code>2014-12-31</code></li>
</ul>
</li>
</ol>
<p>完整的规则可以参考<a href="http://www.yaml.org/spec/1.2/spec.html#id2776092" target="_blank" rel="external">yaml规范</a>。</p>
<p>对与json来说，需要转义的字符如下图：<br><img src="http://www.json.org/string.gif" alt="json string escape"></p>
<p>对于csv来说，转义的规则只有两条：</p>
<ol>
<li>如果值里有逗号、换行或是双引号，需要用双引号来标注</li>
<li>如果值里有双引号，需要把它转义成两个双引号<code>&quot;&quot;</code></li>
</ol>
<h3 id="Java-amp-NET-amp-JS-amp-SQL"><a href="#Java-amp-NET-amp-JS-amp-SQL" class="headerlink" title="Java &amp; .NET &amp; JS &amp; SQL"></a>Java &amp; .NET &amp; JS &amp; SQL</h3><p>对于大部分的编程语言，例如Java、.NET还有JavaScript，甚至C、GO、Ruby等等来说，通常的转义都是通过反斜杠<code>\</code>来实现的。一般都包括如下几项：</p>
<ul>
<li>退格: <code>\b</code></li>
<li>换行: <code>\n</code></li>
<li>制表符: <code>\t</code></li>
<li>回车: <code>\r</code></li>
<li>换页: <code>\f</code></li>
<li>双引号: <code>\&quot;</code></li>
<li>反斜杠: <code>\\</code></li>
</ul>
<p>不过C和C++支持的16进制<code>\x</code>，在java里不被支持。所以<code>\x61\xd2</code>的这个“懒”字，在java中可以通以下这两个表达式来得到真实的字符：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">"\u61d2"</span></div><div class="line"><span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">byte</span>[] &#123;(<span class="keyword">byte</span>) <span class="number">0x61</span>, (<span class="keyword">byte</span>) <span class="number">0xd2</span>&#125;, <span class="string">"unicode"</span>)</div></pre></td></tr></table></figure></p>
<p>SQL有些不一样。它从语法层面支持模糊查询，所以即使在完全匹配中使用了<code>%</code>也不需要转义。但是代表字符串的单引号<code>&#39;</code>还是不得不转义成两个单引号<code>&#39;&#39;</code>。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>以上是关于编码和转义的一些常识，<a href="https://www.zhihu.com/question/23374078/answer/69732605#" target="_blank" rel="external">知乎上转的这篇回答</a>，系统地介绍了从ASCII到UTF-8，写得非常赞。平时需要编码和转义的时候，可以使用<a href="http://www.freeformatter.com/" target="_blank" rel="external">这个网站</a>在线转换，也挺方便的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一名天朝程序员，除了看惯了乱码之外，在日常的工作中经常会碰到编码和转义。如果能掌握这块领域的一些常识，就可以在开发和支持时游刃有余。&lt;br&gt;
    
    </summary>
    
      <category term="development" scheme="http://qinghua.github.io/categories/development/"/>
    
    
      <category term="encoding" scheme="http://qinghua.github.io/tags/encoding/"/>
    
  </entry>
  
  <entry>
    <title>人际风格与有效沟通实战</title>
    <link href="http://qinghua.github.io/effective-communication/"/>
    <id>http://qinghua.github.io/effective-communication/</id>
    <published>2016-10-16T05:17:58.000Z</published>
    <updated>2016-12-23T15:37:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>程序猿和工程狮们（还有形形色色的其他角色）的日常工作中，一定会有需要跟别人沟通的时候。因为沟通的问题认为别人sb或者被人当成sb的惨剧应该不少吧？如果有共鸣，可以读一读本文。不少企业都会请有资质的专家，为员工做类似的培训。<br><a id="more"></a></p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>一般来说，一开始都需要给有效沟通下一个定义。干巴巴地说，就是这样：双方或几方针对共同的话题，发出和收集有意义的信息，从而达成一致的行动或共同的认识。我的观点是：沟通就是为了达成共识而采取的行动。官方定义以文为主，行动关注于信息；而我的定义能文能武（当然并不是推荐直接上暴力哈），只要达成共识即可。</p>
<p>沟通是有一个模型的：<br><img src="/img/communication-model.png" alt="沟通模型"></p>
<p>信息的发送者，根据自己的理解，将信息编码成介质（文字、语音、动作等），通过传播媒介（面对面、邮件、微信）发送出去，经过对介质的解码，到了接收者的大脑里。为什么提倡面对面的沟通呢？因为沟通模型里还有一个非常重要的一环：反馈。通过面对面的沟通，可以很容易感知对方的动作、表情、情绪，从而判断对方是否正确地理解了自己想要表达的信息。而这样的反馈，是电子邮件、电话等所难以做到的。</p>
<h2 id="行为风格"><a href="#行为风格" class="headerlink" title="行为风格"></a>行为风格</h2><p>人与人之间是很不一样的。有些话可能某些人就很受用，还有一些人无动于衷，说不定还会令其他人反感。如果能将人类行为模式分类，见人说人话，见鬼说鬼话，想必对有效沟通来说是很有用的。古希腊的希波克拉底最早以火、风、水、土为基础，分别映射到易怒、乐观、冷静和忧郁的情感上，定义了人类具有的四种基本性情。之后的许多行为理论皆以此为基础，但是主要用于专业的精神层面研究。1928年，美国心理学家<a href="https://en.wikipedia.org/wiki/William_Moulton_Marston" target="_blank" rel="external">马斯顿（William Moulton Marston）</a>出版了《常人的情绪》（Emotions of Normal People），为普通人引入了名为<a href="https://en.wikipedia.org/wiki/DISC_assessment" target="_blank" rel="external">DISC</a>的性格测验方法，DISC分别表示支配（Dominance）、影响（Influence）、稳健（Steadiness）与服从（Compliance），由这4种基本因子，可以构成每个人的不同性格。DISC现在是全球广泛采用的性格测评工具之一，许多企业会用之来选择、激励与管理人才。</p>
<p>用控制力的强弱与以人或事为主，便可以画出四个象限：<br><img src="/img/disc.png" alt="DISC"></p>
<p>用动物来表示不同的性格，有趣并且容易记忆。它们是老虎（D）、孔雀（I）、考拉（S）、猫头鹰（C）和变色龙（啥性格都能变）。老虎是产生故事的人，孔雀是讲故事的人，考拉是听故事的人，猫头鹰是分析故事的人。需要注意的是：</p>
<ol>
<li>每个人都有DISC，只是占比不同</li>
<li>没有理想的沟通风格，随心所欲级别的变色龙除外</li>
<li>这些性格都没有好坏、对错、是非之分，不要给人贴标签</li>
<li>不要对考拉太狠了，物极必反</li>
</ol>
<p>性格上面的互补很有用。一只猫头鹰完不成的事，可能另一只猫头鹰也完不成，但是孔雀可能可以轻易完成。团队、婚姻都是如此。西游记里的主角们，其实就代表了这不同的四种性格。猜猜看，谁是那种性格？对了：</p>
<ul>
<li>悟空：老虎，主动，果敢（妖精！吃俺老孙一棒）</li>
<li>唐僧：猫头鹰，以理服人，尽量客观（贫僧乃东土大唐而来）</li>
<li>八戒：孔雀，总是他去化缘，自来熟（女菩萨，也携带我和尚洗洗）</li>
<li>沙僧：考拉，任劳任怨，没有主见（大师兄，师傅被妖怪抓走了）</li>
</ul>
<p>对别人的性格有所了解，沟通起来才能更加有效，事半功倍。</p>
<h2 id="测测自己"><a href="#测测自己" class="headerlink" title="测测自己"></a>测测自己</h2><p>评完别人，可以用下面的方法来简单测评一下自己。在A表和B表的每一组句子中，圈选出一句最像自己的叙述，然后在下面记录选择的数量：</p>
<p>A表</p>
<ol>
<li>我做决定通常很迅速 vs 我喜欢从容做决定</li>
<li>我倾向于说话快速，带着感情丰富的辞藻 vs 我倾向慢条斯理说话，较少用动人心旋话语</li>
<li>坐着没事干，会令我感到难受 vs 我很享受安静、无所事事的时光</li>
<li>我认为自己生活型态很活跃 vs 我认为自己生活型态很低调</li>
<li>同时身兼数职，让我感到精神焕发 vs 我比较喜欢按部就班，一次做一件事</li>
<li>我很容易对步调慢的人失去耐心 vs 我不喜欢被催赶</li>
<li>我会很快地告诉别人自己的想法和感受 vs 我比较保留自己的想法与感受</li>
<li>我喜欢碰运气，尝试新鲜、不同的事物 vs 我不喜欢碰运气，喜欢用熟悉地方法做事</li>
<li>在社交场合，我倾向于向别人自我介绍 vs 在社交场合，我会等别人来介绍我</li>
<li>别人说话的时候，我很难去倾听 vs 别人说话的时候，我很很仔细的听</li>
<li>我喜欢掌控 vs 我比较喜欢遵从指示，尽力支持</li>
<li>我的反应倾向于迅速而随性 vs 我的反应比较趋向缓慢而特意安排</li>
</ol>
<p>A左（F - 快） <strong><strong>__</strong></strong> vs A右（S - 慢） <strong><strong>__</strong></strong></p>
<p>B表</p>
<ol>
<li>我对生活持严肃态度 vs 我对生活持玩乐态度</li>
<li>我倾向于保守自己的感觉 vs 我倾向于对别人分享自己的感觉</li>
<li>我喜欢谈论、听取事实与数据 vs 我喜欢述说与聆听有关人物的故事</li>
<li>我倾向于根据事实、目标与证据做决定 vs 我倾向于根据感觉、经验或人际关系做决定</li>
<li>我对闲聊比较不感兴趣 vs 我比较有兴趣闲聊</li>
<li>我对交往的对象有所节制 vs 我愿意发展新的人际关系，并深入了解他们</li>
<li>一般人可能会认为我很难被了解 vs 一般人可能会认为我很容易被了解</li>
<li>我比较喜欢独自工作 vs 我比较喜欢与别人并透过别人工作</li>
<li>我会讨论当今时事及手中进行的工作 vs 我喜欢谈人物、故事及奇文轶事</li>
<li>我自认是一个比较拘谨的人 vs 我自认是一个比较轻松自在的人</li>
<li>别人把我看成一个重思考的人 vs 别人把我看成一个重感觉的人</li>
<li>完成一件事，是我感觉最棒的时候 vs 当别人接纳我时，我感觉最好</li>
</ol>
<p>B左（T - 任务） <strong><strong>__</strong></strong> vs B右（P - 人际） <strong><strong>__</strong></strong></p>
<p>做完题后，就会得到4个数，例如F8、S4、T7、P5，将FS中的较小值（S4）丢弃，TP中的较小值（P5）丢弃，就变成了F8、T7。然后就可以根据这个坐标在下图中找到自己的象限了。对于F8、T7来说，是老虎：<br><img src="/img/disc-self-accessment.png" alt="DISC自我评测"></p>
<p>需要注意的是：</p>
<ol>
<li>据说它只有70%的准确性（再减20%可就是随机了）</li>
<li>身为一只猫头鹰，真想吐个槽：题目设计还不够科学，如果两张表都是奇数，就不至于出现两个6纠结于最大值了</li>
<li>4个6的话，除了变色龙，还真没法解释了</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;程序猿和工程狮们（还有形形色色的其他角色）的日常工作中，一定会有需要跟别人沟通的时候。因为沟通的问题认为别人sb或者被人当成sb的惨剧应该不少吧？如果有共鸣，可以读一读本文。不少企业都会请有资质的专家，为员工做类似的培训。&lt;br&gt;
    
    </summary>
    
      <category term="idea" scheme="http://qinghua.github.io/categories/idea/"/>
    
    
      <category term="soft skill" scheme="http://qinghua.github.io/tags/soft-skill/"/>
    
  </entry>
  
  <entry>
    <title>监控与管理dubbo服务</title>
    <link href="http://qinghua.github.io/dubbo-3/"/>
    <id>http://qinghua.github.io/dubbo-3/</id>
    <published>2016-10-02T13:46:02.000Z</published>
    <updated>2016-12-23T15:37:43.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/alibaba/dubbo" target="_blank" rel="external">Dubbo</a>是阿里多年前开源的一套服务治理框架，在众多互联网企业里应用广泛。本文介绍了一些如何监控与管理dubbo服务。使用的工具与<a href="http://www.cnblogs.com/yjmyzz/p/dubbo-admin-monitor-deploy.html" target="_blank" rel="external">《dubbox 的各种管理和监管》</a>大致相同，本文更侧重于命令细节与实践。<br><a id="more"></a></p>
<p>首先参考<a href="/dubbo-1">《服务治理框架dubbo上手指南》</a>，实现自己的<code>HelloService</code>服务。在此基础上运行<code>Provider.java</code>启动服务，接下来就可以开始管理工作啦。让我们来下载dubbo的源码并安装：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">clone</span> https://github.com/alibaba/dubbo.git dubbo</div><div class="line"><span class="built_in">cd</span> ~/dubbo</div><div class="line">mvn clean install -Dmaven.test.skip</div></pre></td></tr></table></figure></p>
<h2 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h2><p>Dubbo支持使用telnet来查看服务状态。下面让我们来试一下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">telnet localhost 19880</div></pre></td></tr></table></figure></p>
<p>敲下回车便能看到<code>dubbo&gt;</code>的提示符了。以下命令可以看到服务列表、服务的方法详细信息列表和服务地址列表：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ls</div><div class="line">ls -l org.ggg.hello.service.HelloService</div><div class="line">ps -l</div></pre></td></tr></table></figure></p>
<p>以下命令可以跟踪服务方法的调用情况：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">trace org.ggg.hello.service.HelloService</div></pre></td></tr></table></figure></p>
<p>这时会看见光标停止住了。运行<code>Consumer.java</code>来消费服务，就可以看到跟踪结果啦。详细的命令可以参考<a href="https://github.com/alibaba/dubbo/wiki/user-guide-telnet-cmd-ref" target="_blank" rel="external">Telnet命令参考手册</a>。若是服务端没有开启监控，使用telnet命令对查看甚至配置服务来说，是依赖最少最简便的方式。</p>
<h2 id="简易监控中心"><a href="#简易监控中心" class="headerlink" title="简易监控中心"></a>简易监控中心</h2><p>先前安装过的dubbo项目里包含了<code>dubbo-monitor-simple</code>的包，解压之：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar zxvf dubbo-simple/dubbo-monitor-simple/target/dubbo-monitor-simple-2.5.4-SNAPSHOT-assembly.tar.gz</div></pre></td></tr></table></figure></p>
<p>配置<code>dubbo.properties</code>为自己的zk服务地址：<code>192.168.33.88:2181</code>：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 操作系统是Linux的话</span></div><div class="line">sed -i <span class="string">"s/multicast:\/\/224.5.6.7:1234/zookeeper:\/\/192.168.33.88:2181/"</span> dubbo-monitor-simple-2.5.4-SNAPSHOT/conf/dubbo.properties</div><div class="line"><span class="comment"># 操作系统是OS X的话（接下来的sed命令以OS X为例）</span></div><div class="line">sed -i <span class="string">""</span> <span class="string">"s/multicast:\/\/224.5.6.7:1234/zookeeper:\/\/192.168.33.88:2181/"</span> dubbo-monitor-simple-2.5.4-SNAPSHOT/conf/dubbo.properties</div></pre></td></tr></table></figure></p>
<p>简易监控中心以文件的方式记录监控数据。创建基本文件夹并运行<code>start.sh</code>启动简易监控中心：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mkdir ~/monitor</div><div class="line">dubbo-monitor-simple-2.5.4-SNAPSHOT/bin/start.sh</div></pre></td></tr></table></figure></p>
<p>访问<a href="http://localhost:8080/" target="_blank" rel="external">http://localhost:8080/</a>便能看到简易监控中心的首页了：<br><img src="/img/dubbo-monitor-simple-home.jpg" alt=""></p>
<p>在<code>Applications</code>里可以看到我们先前启动的<code>hello-world-app</code>和<code>simple-monitor</code>自己。可见<code>simple-monitor</code>也是一个dubbo服务，把自己注册到<code>dubbo.properties</code>里指定的配置中心里去。为了接收到监控数据，需要在dubbo服务端打开监控。在<code>provider.xml</code>文件里加入下面这行配置，然后重新启动dubbo服务：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dubbo:monitor</span> <span class="attr">protocol</span>=<span class="string">"registry"</span> /&gt;</span></div></pre></td></tr></table></figure></p>
<p>过一会儿就能看到监控的统计信息和图标了：<br><img src="/img/dubbo-monitor-simple-service-charts.jpg" alt=""></p>
<p>而运行<code>ls ~/monitor/</code>也能看到简易监控中心所生成的文件夹<code>charts</code>和<code>statistics</code>。如果迟迟没有生成这些信息，有一种可能是在多（虚拟）网卡的情况下，simple-monitor绑定到了错误的IP地址去了。万一真是如此，在<code>dubbo.properties</code>里增加一行<code>dubbo.protocol.host</code>的配置即可。</p>
<p>运行<code>stop.sh</code>停止简易监控中心服务：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dubbo-monitor-simple-2.5.4-SNAPSHOT/bin/stop.sh</div></pre></td></tr></table></figure></p>
<h2 id="管理控制台"><a href="#管理控制台" class="headerlink" title="管理控制台"></a>管理控制台</h2><p>Dubbo为服务治理提供了管理控制台。这是一个webapp，可以很轻松地运行在web容器中。经由源代码安装后便会生成<code>dubbo-admin-2.5.4-SNAPSHOT.war</code>文件，将其部署在tomcat容器中即可。这里用docker启动一个tomcat 7：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">docker run -d -p 8080:8080 --name=tomcat tomcat:7</div><div class="line">docker cp dubbo-admin/target/dubbo-admin-2.5.4-SNAPSHOT.war tomcat:/usr/<span class="built_in">local</span>/tomcat/webapps/</div><div class="line">docker <span class="built_in">exec</span> tomcat sed -i <span class="string">"s/127.0.0.1/192.168.33.88/"</span> /usr/<span class="built_in">local</span>/tomcat/webapps/dubbo-admin-2.5.4-SNAPSHOT/WEB-INF/dubbo.properties</div><div class="line">docker restart tomcat</div></pre></td></tr></table></figure></p>
<p>文件<code>dubbo.properties</code>里配置了zookeep的地址，所以用sed将其替换为自己的zk服务地址：<code>192.168.33.88</code>。里面还配置了root账户和guest账户的密码。默认即为<code>root</code>和<code>guest</code>。访问<a href="http://localhost:8080/dubbo-admin-2.5.4-SNAPSHOT/" target="_blank" rel="external">http://localhost:8080/dubbo-admin-2.5.4-SNAPSHOT/</a>并输入<code>root</code>和<code>root</code>，就能看到管理控制台的首页了：<br><img src="/img/dubbo-admin-home.jpg" alt=""></p>
<p>输入<code>hello</code>进行查询，便能看到我们的服务了：<br><img src="/img/dubbo-admin-service-governance.jpg" alt=""></p>
<p>可以在此页面进行各种服务治理操作。更详细的资料，请参考<a href="http://dubbo.io/Administrator+Guide-zh.htm#AdministratorGuide-zh-%E8%BF%90%E7%BB%B4%E6%89%8B%E5%86%8C" target="_blank" rel="external">运维手册</a>。</p>
<p>运行以下命令删除tomcat容器：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rm -f tomcat</div></pre></td></tr></table></figure></p>
<h2 id="dubbo-monitor"><a href="#dubbo-monitor" class="headerlink" title="dubbo-monitor"></a>dubbo-monitor</h2><p>简易监控中心和管理控制台的页面风格看起来还停留在上个世纪。韩都衣舍提供了一个<a href="https://github.com/handuyishe/dubbo-monitor" target="_blank" rel="external">dubbo-monitor</a>，除了更加现代化的页面，还用数据库代替了简易监控中心写文件的方式。除了mysql，还支持<a href="https://github.com/handuyishe/dubbo-monitor/tree/mongo" target="_blank" rel="external">mongo</a>。那我们先来下载代码：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> ..</div><div class="line">git <span class="built_in">clone</span> https://github.com/handuyishe/dubbo-monitor</div><div class="line"><span class="built_in">cd</span> dubbo-monitor</div></pre></td></tr></table></figure></p>
<p>然后启动一个mysql数据库实例：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker run -d --name=mysql -e MYSQL_ROOT_PASSWORD=raycool -v `<span class="built_in">pwd</span>`/sql/create.sql:/create.sql mysql:5.7.12</div><div class="line">docker <span class="built_in">exec</span> -it mysql mysql -uroot -praycool</div></pre></td></tr></table></figure></p>
<p>创建数据库和表（可能需要等数据库启动一小会儿之后才能连上去）：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> dubbokeeper <span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">DEFAULT</span> <span class="keyword">COLLATE</span> utf8_general_ci;</div><div class="line"><span class="keyword">USE</span> dubbokeeper;</div><div class="line">SOURCE /create.sql;</div><div class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLES</span>;</div><div class="line">exit</div></pre></td></tr></table></figure></p>
<p>修改配置文件<code>application.properties</code>并打包（目前版本中spring的引用有问题，所以也需要修改<code>pom.xml</code>）：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">MYSQL_IP=`docker <span class="built_in">exec</span> -it mysql hostname -i | sed <span class="string">'s/.$//'</span>`</div><div class="line">sed -i <span class="string">""</span> -e <span class="string">"s/dubbo.registry.address.*/dubbo.registry.address=zookeeper:\/\/192.168.33.88:2181/"</span> -e <span class="string">"s/default/<span class="variable">$&#123;MYSQL_IP&#125;</span>/"</span> src/main/resources/application.properties</div><div class="line">sed -i <span class="string">""</span> s/4.1.6.RELEASE/3.2.9.RELEASE/<span class="string">" pom.xml</span></div><div class="line">mvn clean package</div></pre></td></tr></table></figure></p>
<p>启动dubbo-monitor：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d -p 8080:8080 -v `<span class="built_in">pwd</span>`/target/dubbo-monitor-x.war:/usr/<span class="built_in">local</span>/tomcat/webapps/dubbo-monitor-x.war --name=tomcat tomcat:7</div></pre></td></tr></table></figure></p>
<p>访问<a href="http://localhost:8080/dubbo-monitor-x/" target="_blank" rel="external">http://localhost:8080/dubbo-monitor-x/</a>并输入<code>admin</code>和<code>admin</code>，就能看到dubbo-monitor的首页了：<br><img src="/img/dubbo-monitor-home.jpg" alt=""></p>
<p>可以在dubbo-monitor提供的页面上监控各种数据，但由于笔者是mac配docker版tomcat的方式，监控的dubbo服务只能绑定在docker内部IP上，导致监控数据过不去（com.alibaba.dubbo.remoting.RemotingException: message can not send, because channel is closed）。真正运行的时候还是使用linux+docker（配合net=host）或是mac+原生tomcat的方式吧。运行以下命令删除mysql和tomcat容器：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rm -f mysql tomcat</div></pre></td></tr></table></figure></p>
<h2 id="DubboKeeper"><a href="#DubboKeeper" class="headerlink" title="DubboKeeper"></a>DubboKeeper</h2><p>除了dubbo-monitor以外，github里还有一个社区版的<a href="https://github.com/dubboclub/dubbokeeper" target="_blank" rel="external">DubboKeeper</a>，功能最为强大。既提供监控功能，又提供服务治理功能。监控数据的持久化除了支持mysql和mongo，还支持lucene。现在下载代码并打包。Dubbokeeper的打包方式略有些不同，需要执行根目录里的<code>install-xxx.sh</code>脚本。这里还是以mysql为例：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> ..</div><div class="line">git <span class="built_in">clone</span> https://github.com/dubboclub/dubbokeeper</div><div class="line"><span class="built_in">cd</span> dubbokeeper</div><div class="line">./install-mysql.sh</div></pre></td></tr></table></figure></p>
<p>首先启动DubboKeeper的UI：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker run -d -p 8080:8080 -v `<span class="built_in">pwd</span>`/target/mysql-dubbokeeper-ui/dubbokeeper-ui-1.0.1.war:/usr/<span class="built_in">local</span>/tomcat/webapps/dubbokeeper-ui-1.0.1.war --name=tomcat tomcat:7</div><div class="line">docker <span class="built_in">exec</span> tomcat sed -i <span class="string">"s/localhost/192.168.33.88/"</span> /usr/<span class="built_in">local</span>/tomcat/webapps/dubbokeeper-ui-1.0.1/WEB-INF/classes/dubbo.properties</div><div class="line">docker restart tomcat</div></pre></td></tr></table></figure></p>
<p>访问<a href="http://localhost:8080/dubbokeeper-ui-1.0.1/index.htm#/statistics" target="_blank" rel="external">http://localhost:8080/dubbokeeper-ui-1.0.1/index.htm#/statistics</a>，就能看到DubboKeeper的首页了：<br><img src="/img/dubbo-keeper-home.jpg" alt=""></p>
<p>很显然在这些UI里，DubboKeeper的逼格是最高的。第二个tab就是<code>Admin</code>（管理）：<br><img src="/img/dubbo-keeper-admin.jpg" alt=""></p>
<p>接下来就是<code>Monitor</code>（监控），不过只有启动过监控数据存储端才能使用，现在点击会报<strong>后端系统出现异常，请稍后再试</strong>的错。接下来启动数据库：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker run -d --name=mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=19890314 -v `<span class="built_in">pwd</span>`/doc/storage/mysql/sql/application.sql:/create.sql mysql:5.7.12</div><div class="line">docker <span class="built_in">exec</span> -it mysql mysql -uroot -p19890314</div></pre></td></tr></table></figure></p>
<p>初始化数据库：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> dubbokeeper;</div><div class="line"><span class="keyword">USE</span> dubbokeeper;</div><div class="line">SOURCE /create.sql;</div><div class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLES</span>;</div><div class="line">exit</div></pre></td></tr></table></figure></p>
<p>修改监控数据存储端的配置并启动之：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sed -i <span class="string">""</span> -e <span class="string">"s/localhost:2181/192.168.33.88:2181/"</span> -e <span class="string">"s/dubbo-monitor/dubbokeeper/"</span> target/mysql-dubbokeeper-server/conf/dubbo-mysql.properties</div><div class="line">chmod +x target/mysql-dubbokeeper-server/bin/start-mysql.sh</div><div class="line">target/mysql-dubbokeeper-server/bin/start-mysql.sh</div></pre></td></tr></table></figure></p>
<p>现在就可以顺利打开监控页面了：<br><img src="/img/dubbo-keeper-monitor.jpg" alt=""></p>
<p>DubboKeeper甚至还提供了ZooKeeper的窥视版<code>ZooPeeper</code>：<br><img src="/img/dubbo-keeper-zoopeeper.jpg" alt=""></p>
<p>最后收尾，Ctrl+C掉监控数据存储端，并删除各个容器：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rm -f mysql tomcat</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/alibaba/dubbo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Dubbo&lt;/a&gt;是阿里多年前开源的一套服务治理框架，在众多互联网企业里应用广泛。本文介绍了一些如何监控与管理dubbo服务。使用的工具与&lt;a href=&quot;http://www.cnblogs.com/yjmyzz/p/dubbo-admin-monitor-deploy.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《dubbox 的各种管理和监管》&lt;/a&gt;大致相同，本文更侧重于命令细节与实践。&lt;br&gt;
    
    </summary>
    
      <category term="architecture" scheme="http://qinghua.github.io/categories/architecture/"/>
    
    
      <category term="dubbo" scheme="http://qinghua.github.io/tags/dubbo/"/>
    
      <category term="service governance" scheme="http://qinghua.github.io/tags/service-governance/"/>
    
      <category term="monitor" scheme="http://qinghua.github.io/tags/monitor/"/>
    
  </entry>
  
  <entry>
    <title>《DevOps实践》出版啦</title>
    <link href="http://qinghua.github.io/practical-devops/"/>
    <id>http://qinghua.github.io/practical-devops/</id>
    <published>2016-09-21T00:48:20.000Z</published>
    <updated>2016-12-23T15:37:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>从开始试译到现在经过了半年多，我和马博文的译作<a href="https://book.douban.com/subject/26878481/" target="_blank" rel="external">《DevOps实践》</a>终于出版啦。这里简要地介绍一下本书，并放篇我为此书所作的译者序，安利一下。<br><a id="more"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>《DevOps实践》介绍了DevOps的起源和概览，并通过一个贯穿全书的例子，从架构开始，到代码的存储、构建、测试、部署、监控，直至流程的跟踪，推荐了许多可用的工具和可行的示范，是一本DevOps实践方面不可多得的参考书籍。</p>
<p>《DevOps实践》面向愿意承担更大责任的开发人员和系统管理员，也很适合愿意更好地支持开发人员的运维人员。无须任何DevOps知识即可快速上手！</p>
<p><img src="/img/practical_devops_en.jpg" alt=""><br><img src="/img/practical_devops_cn.png" alt=""></p>
<h2 id="译者序"><a href="#译者序" class="headerlink" title="译者序"></a>译者序</h2><p>什么是DevOps？我的前同事李光磊将其译为开发自运维，他还写了篇很有意思的博客来说明：<a href="http://liguanglei.name/blogs/2015/04/22/devops-chinese-name/" target="_blank" rel="external">http://liguanglei.name/blogs/2015/04/22/devops-chinese-name/</a>。这个将开发和运维结合起来的词，代表了一种文化，那就是大家共同协作。狭义上的大家，指的是开发和运维，广义上，指的是所有软件生命周期里参与的角色。</p>
<p>“共同协作”是个富有正能量的词。感觉上，随便往哪儿一套都是政治正确的。那为什么要在DevOps里着重强调呢？DevOps到底解决了什么问题？归根结底，就是提高产品质量。爱思考的你，可能心里已经有千万个提高产品质量的方案从脑海里呼啸而过。代码审查、自动化测试、持续集成、代码质量管理工具、程序员鼓励师……对对对，这些方案都能在某种程度上解决一些层次的问题。但是，产品质量的根源在哪儿呢？在于人。如果开发者对自己要做的事情不负责甚至压根儿不知道后果，怎么能指望这样的人能够生产出来高质量的代码呢？举个例子：作为开发者，我知道自己写的代码会由测试部门来进一步测试，在有进度压力的时候，我就会更倾向于去想：“那就先这么凑合吧着，反正有问题的话QA们会说的”。如果我不知道部署和维护产品是怎么一回事，我就不会主动地在产品里写上日志的代码。对于运维人员来说，由于处于软件生命周期的下游，相信对类似的场景感触更甚。DevOps能够做到的事，就是让人有这个意识：需要对产品的质量负责。DevOps能够提供一个平台或机制，让我能够从中找到所需的资源。</p>
<p>“共同协作”也是个虚无缥缈的词。它应该如何落地呢？这就是本书想要给读者们带来的内容。在实践上，从架构开始，到代码的存储、构建、测试、部署、监控，直至流程的跟踪，本书推荐了许多可用的工具和练习，确实无愧于《DevOps实战》之名。细度全文可以有一个全局的概览并充实读者们的DevOps工具箱；而在实际场景中再查阅本书，将其当做一本各种技术的快速参考手册也不失为明智之举。本书的许多实例通过Docker启动，在紧随潮流技术的同时也简化了练习步骤，值得花些时间试试。在企业里，使用自动化和持续交付来提高代码部署频率，降低代码上线间隔。这样的指标是比较容易统计的，在让管理人员满意的同时，也能减少开发和运维的痛苦。只有让各角色都真切地感受到实惠，大家才会更加愿意从心底接受并积极参与到这一过程中。</p>
<p>“共同协作”还是个看上去很美的词。为什么大家还不赶紧拥抱它？因为它的成本可能还挺高的。大型企业在管理上，通常权责分明，从而导致某个角色的成员都不愿意轻易踏足其它领域。流程繁琐，导致一个小小的改进也需要漫长的批复。安全性要求高，引发各种违规，进一步导致没有和其他人分享的意愿。员工操作权限管理精密，上不了网、下不了包、开不了虚拟机……这些问题，虽然不至于疾在骨髓，但起码也在肠胃了。而且，自动化测试、部署流水线等都需要比较大的成本。在看见收益和认清自己之前，可能大多数人也会像蔡桓公那样默认拒绝吧：“医之好治不病以为功”。成本最低的时候，可能就是开始写第一行产品代码的时候。话虽如此，任何时候都是实现DevOps的最佳时机，因为它的成本随企业的扩大和代码库的膨胀，一定是越来越高的。另外，完全地追求技术上的卓越而忽视成本也不是DevOps的推荐做法。读者们在阅读时，也会看到DevOps在一些状况下采取的权衡方案。</p>
<p>你希望在一个大家敞开心胸，相互拥抱的环境里共同协作打造最好的产品，还是守着自己的一亩三分地，与人争辩这是谁的责任，抱怨人们冷漠的同时拒绝其他人的“与你无关”的要求？从本书开始，应用自己获得的知识，并尝试改造这个世界吧！</p>
<h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>感谢作者Joakim Verona，本书涵盖了大量可以练习的实例，想必花了你很多的心血。<br>感谢ThoughtWorks，授人的不止是持续集成、持续交付，还有持续学习。<br>感谢林帆，没有你，我就不会有这样难忘的翻译经历。<a href="https://book.douban.com/subject/26670565/" target="_blank" rel="external">《CoreOS实践之路》</a>只是你的开始，希望能看到更多的佳作问世。<br>感谢永恒的侠少，让我可以集中精力专注于翻译之上，你还为本书想了一个漂亮的副标题。<br>感谢马博文，你的经验与高效让本书的翻译可以提前完成。顺祝你的另一本译作<a href="http://item.jd.com/11935577.html" target="_blank" rel="external">《Scala编程实战》</a>大卖。<br>感谢小伙伴张博，你给我的初稿指出了许多宝贵意见。<br>感谢文心、瑞民、光磊，这篇译者序里也流淌着你们的汗水。<br>感谢张骏，我从你的<a href="https://book.douban.com/subject/26772677/" target="_blank" rel="external">《微服务设计》</a>的代码库里获取了许多宝贵的经验与灵感。<br>感谢家人和朋友们，我永远离不开你们的支持。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从开始试译到现在经过了半年多，我和马博文的译作&lt;a href=&quot;https://book.douban.com/subject/26878481/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《DevOps实践》&lt;/a&gt;终于出版啦。这里简要地介绍一下本书，并放篇我为此书所作的译者序，安利一下。&lt;br&gt;
    
    </summary>
    
      <category term="devops" scheme="http://qinghua.github.io/categories/devops/"/>
    
    
      <category term="book" scheme="http://qinghua.github.io/tags/book/"/>
    
  </entry>
  
  <entry>
    <title>不止于数据库连接池的Druid</title>
    <link href="http://qinghua.github.io/alibaba_druid/"/>
    <id>http://qinghua.github.io/alibaba_druid/</id>
    <published>2016-09-15T09:07:22.000Z</published>
    <updated>2016-12-23T15:37:43.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/alibaba/druid" target="_blank" rel="external">Druid</a>传说中是Java语言中最好的数据库连接池，能够提供强大的监控和扩展功能，甚至可以基于SQL语义来<a href="https://github.com/alibaba/druid/wiki/%E7%AE%80%E4%BB%8B_WallFilter" target="_blank" rel="external">防御SQL注入攻击</a>。它与其它数据库连接池的功能对比可以参考<a href="https://github.com/alibaba/druid/wiki/%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%AF%B9%E6%AF%94" target="_blank" rel="external">各种数据库连接池对比</a>，性能对比可以参考<a href="https://github.com/alibaba/druid/wiki/%E5%90%84%E7%A7%8D%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94%E6%B5%8B%E8%AF%95" target="_blank" rel="external">各种连接池性能对比测试</a>。网上的一些原code.alibabatech.com的链接已经失效，文档都转移到了github上，以<a href="https://github.com/alibaba/druid/wiki/%E9%A6%96%E9%A1%B5" target="_blank" rel="external">wiki</a>+<a href="https://github.com/alibaba/druid/wiki/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98" target="_blank" rel="external">FAQ</a>的方式提供，查起来有些混乱。下面我们来动手了解一下druid所提供的功能。<br><a id="more"></a></p>
<h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><p>既然是数据库连接池，首先要启动一个数据库。用docker来弄简单轻松：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d -e MYSQL_ROOT_PASSWORD=123456 --net=host --name=mysql mysql:5.7.12</div></pre></td></tr></table></figure></p>
<p>进入容器并连接上数据库：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> -it mysql mysql -uroot -p123456</div></pre></td></tr></table></figure></p>
<p>创建用户表并插入一些初始数据：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> spike;</div><div class="line"><span class="keyword">USE</span> spike;</div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> (</div><div class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</div><div class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    gender TINYINT <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    birthday <span class="keyword">TIMESTAMP</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>)</div><div class="line">);</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span>(<span class="keyword">name</span>, gender, birthday) <span class="keyword">VALUES</span>(<span class="string">'ggg'</span>, <span class="string">'1'</span>, <span class="string">'1999-01-01'</span>);</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span>(<span class="keyword">name</span>, gender, birthday) <span class="keyword">VALUES</span>(<span class="string">'Loic'</span>, <span class="string">'1'</span>, <span class="string">'2000-01-01'</span>);</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span>(<span class="keyword">name</span>, gender, birthday) <span class="keyword">VALUES</span>(<span class="string">'Hetty'</span>, <span class="string">'2'</span>, <span class="string">'2001-01-01'</span>);</div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span>;</div><div class="line"></div><div class="line">exit</div></pre></td></tr></table></figure></p>
<p>我在github上创建了一个druid的maven版测试工程，下载到本地并使用自己喜欢的IDE打开：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">clone</span> https://github.com/qinghua/druid</div></pre></td></tr></table></figure></p>
<p>然后打开<code>spring-context-dao.xml</code>文件，把数据源从<code>jdbc:mysql://192.168.33.88:3306/spike</code>替换为自己的本地数据源。</p>
<h2 id="各种监控"><a href="#各种监控" class="headerlink" title="各种监控"></a>各种监控</h2><p>以下命令可以直接启动jetty服务器：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> druid</div><div class="line">mvn jetty:run</div></pre></td></tr></table></figure></p>
<p>打开<a href="http://localhost:8080/hello?id=1" target="_blank" rel="external">http://localhost:8080/hello?id=1</a>便能看见<strong>Hello ggg</strong>，这个是程序的正常功能。</p>
<p>Druid的页面是通过在<code>web.xml</code>里配置<code>DruidStatView</code>的servlet来实现的。参数的具体配置可以参考<a href="https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE_StatViewServlet%E9%85%8D%E7%BD%AE" target="_blank" rel="external">这里</a>。打开<a href="http://localhost:8080/druid/index.html" target="_blank" rel="external">http://localhost:8080/druid/index.html</a>便能看见druid的首页了：<br><img src="/img/druid-index.jpg" alt=""></p>
<p>如果刚才访问过<a href="http://localhost:8080/hello?id=1" target="_blank" rel="external">hello</a>，通过点击<code>数据源</code>便能查看到程序新创建的数据源。可以在IDE里打开<code>spring-context-dao.xml</code>通过<code>dataSource</code>来查看数据源的配置，参数的具体配置可以参考<a href="https://github.com/alibaba/druid/wiki/DruidDataSource%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E5%88%97%E8%A1%A8" target="_blank" rel="external">这里</a>。通过<code>class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;</code>来使用druid。点击<code>SQL监控</code>便能体会到druid引以为傲的强大监控功能：<br><img src="/img/druid-sql-monitor.jpg" alt=""></p>
<p><code>SQL防火墙</code>是用来防止SQL注入的，配置可以参考<a href="https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE-wallfilter" target="_blank" rel="external">这里</a>。还可以通过在<code>web.xml</code>加入以下配置来启用web监控，参数的具体配置可以参考<a href="https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE_%E9%85%8D%E7%BD%AEWebStatFilter" target="_blank" rel="external">这里</a>：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>DruidWebStatFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.alibaba.druid.support.http.WebStatFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>exclusions<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>DruidWebStatFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>除了监控SQL和web，druid还能监控spring的一些调用信息。可以在IDE里打开<code>spring-context-druid.xml</code>查看程序的当前配置。参数的具体配置可以参考<a href="https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE_Druid%E5%92%8CSpring%E5%85%B3%E8%81%94%E7%9B%91%E6%8E%A7%E9%85%8D%E7%BD%AE" target="_blank" rel="external">这里</a>。通过点击<code>spring监控</code>便能查看到方法的调用时间和jdbc的一些状态：<br><img src="/img/druid-spring-monitor.jpg" alt=""></p>
<h2 id="其它功能"><a href="#其它功能" class="headerlink" title="其它功能"></a>其它功能</h2><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>监控里显示的都是敏感信息，可以通过在<code>web.xml</code>里加入以下配置来启用简单的登录功能：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DruidStatView<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.alibaba.druid.support.http.StatViewServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>loginUsername<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>ggg<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>loginPassword<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>这样访问druid界面的时候就需要输入用户名密码啦：<br><img src="/img/druid-login.jpg" alt=""></p>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>如果想在日志里看到执行的sql，可以根据<a href="https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE_LogFilter" target="_blank" rel="external">这里</a>的说明来配置。Druid支持多种<a href="https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AEdruid%E5%86%85%E7%BD%AE%E7%9A%84log%E5%AE%9E%E7%8E%B0" target="_blank" rel="external">日志组件</a>。显示执行的sql是debug级别，如果用的是log4j，可以在<code>log4j.properties</code>里这样配：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">log4j.logger.druid.sql=debug,stdout</div></pre></td></tr></table></figure></p>
<p>访问<a href="http://localhost:8080/hello?id=2" target="_blank" rel="external">hello页面</a>，便可以看到如下日志：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&#123;conn-10005&#125; connected</div><div class="line">&#123;conn-10005&#125; pool-connect</div><div class="line">&#123;conn-10005, pstmt-20000&#125; created. </div><div class="line">SELECT name FROM user WHERE id=?</div><div class="line">&#123;conn-10005, pstmt-20000&#125; Parameters : [2]</div><div class="line">&#123;conn-10005, pstmt-20000&#125; Types : [INTEGER]</div><div class="line">&#123;conn-10005, pstmt-20000&#125; executed. 1.351044 millis. </div><div class="line">SELECT name FROM user WHERE id=?</div><div class="line">&#123;conn-10005, pstmt-20000, rs-50000&#125; open</div><div class="line">&#123;conn-10005, pstmt-20000, rs-50000&#125; Header: [name]</div><div class="line">&#123;conn-10005, pstmt-20000, rs-50000&#125; Result: [Loic]</div><div class="line">&#123;conn-10005, pstmt-20000, rs-50000&#125; closed</div><div class="line">&#123;conn-10005, pstmt-20000&#125; clearParameters. </div><div class="line">&#123;conn-10005&#125; pool-recycle</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/alibaba/druid&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Druid&lt;/a&gt;传说中是Java语言中最好的数据库连接池，能够提供强大的监控和扩展功能，甚至可以基于SQL语义来&lt;a href=&quot;https://github.com/alibaba/druid/wiki/%E7%AE%80%E4%BB%8B_WallFilter&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;防御SQL注入攻击&lt;/a&gt;。它与其它数据库连接池的功能对比可以参考&lt;a href=&quot;https://github.com/alibaba/druid/wiki/%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%AF%B9%E6%AF%94&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;各种数据库连接池对比&lt;/a&gt;，性能对比可以参考&lt;a href=&quot;https://github.com/alibaba/druid/wiki/%E5%90%84%E7%A7%8D%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94%E6%B5%8B%E8%AF%95&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;各种连接池性能对比测试&lt;/a&gt;。网上的一些原code.alibabatech.com的链接已经失效，文档都转移到了github上，以&lt;a href=&quot;https://github.com/alibaba/druid/wiki/%E9%A6%96%E9%A1%B5&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;wiki&lt;/a&gt;+&lt;a href=&quot;https://github.com/alibaba/druid/wiki/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;FAQ&lt;/a&gt;的方式提供，查起来有些混乱。下面我们来动手了解一下druid所提供的功能。&lt;br&gt;
    
    </summary>
    
      <category term="db" scheme="http://qinghua.github.io/categories/db/"/>
    
    
      <category term="druid" scheme="http://qinghua.github.io/tags/druid/"/>
    
  </entry>
  
  <entry>
    <title>用容器快速上手Elasticsearch</title>
    <link href="http://qinghua.github.io/elastic-search/"/>
    <id>http://qinghua.github.io/elastic-search/</id>
    <published>2016-08-28T13:06:34.000Z</published>
    <updated>2016-12-23T15:37:43.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.elastic.co/products/elasticsearch" target="_blank" rel="external">Elasticsearch</a>是用Java开发的基于<a href="https://lucene.apache.org/" target="_blank" rel="external">Apache Lucene</a>的一个近乎实时的分布式搜索分析引擎。维基百科、Stack Overflow、GitHub等都采用它来作为全文搜索引擎。本文旨在用docker来快速入门并尝试Elasticsearch提供的基本功能。</p>
<p>对<a href="http://lucene.apache.org/solr/" target="_blank" rel="external">Apache Solr</a>入门有兴趣的朋友请参考<a href="/solr">用容器快速上手Apache Solr</a>。<br><a id="more"></a></p>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>关于Elasticsearch的入门知识，有一本gitbook：<a href="https://www.gitbook.com/book/fuxiaopang/learnelasticsearch/details" target="_blank" rel="external">《Elasticsearch 权威指南》</a>翻译得不错。本文关心的是实际操作，所以这就开始吧。通过docker，一条命令就可以直接启动Elasticsearch：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d --net=host --name=es elasticsearch:2.3.5</div></pre></td></tr></table></figure></p>
<p>我用的是mac，通过<code>docker-machine env default</code>命令可以看到默认的<code>default docker-machine</code>的IP地址是<code>192.168.99.100</code>，于是便可以通过<a href="http://192.168.99.100:9200/" target="_blank" rel="external">http://192.168.99.100:9200/</a>来从Elasticsearch获得json数据了：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"name"</span> : <span class="string">"Lorvex"</span>,</div><div class="line">  <span class="attr">"cluster_name"</span> : <span class="string">"elasticsearch"</span>,</div><div class="line">  <span class="attr">"version"</span> : &#123;</div><div class="line">    <span class="attr">"number"</span> : <span class="string">"2.3.5"</span>,</div><div class="line">    <span class="attr">"build_hash"</span> : <span class="string">"90f439ff60a3c0f497f91663701e64ccd01edbb4"</span>,</div><div class="line">    <span class="attr">"build_timestamp"</span> : <span class="string">"2016-07-27T10:36:52Z"</span>,</div><div class="line">    <span class="attr">"build_snapshot"</span> : <span class="literal">false</span>,</div><div class="line">    <span class="attr">"lucene_version"</span> : <span class="string">"5.5.0"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">"tagline"</span> : <span class="string">"You Know, for Search"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>也可以使用<code>_cat</code>直接在命令行获取Elasticsearch的健康状态和节点状态：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">curl <span class="string">'192.168.99.100:9200/_cat/health?v'</span></div><div class="line">curl <span class="string">'192.168.99.100:9200/_cat/nodes?v'</span></div></pre></td></tr></table></figure></p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>与Solr不同，Elasticsearch只支持json格式。创建索引的过程，就是向服务器POST数据的过程：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">curl -XPOST <span class="string">'http://192.168.99.100:9200/megacorp/employee'</span> -d <span class="string">'</span></div><div class="line">&#123;</div><div class="line">    "first_name" : "John",</div><div class="line">    "last_name" :  "Smith",</div><div class="line">    "age" :        25,</div><div class="line">    "about" :      "I love to go rock climbing",</div><div class="line">    "interests": [ "sports", "music" ]</div><div class="line">&#125;'</div></pre></td></tr></table></figure></p>
<p>立刻就能得到Elasticsearch返回的结果：<strong>{“_index”:”megacorp”,”_type”:”employee”,”_id”:”AVbK2ssDm7bdYo65QJ6k”,”_version”:1,”_shards”:{“total”:2,”successful”:1,”failed”:0},”created”:true}</strong>。Url里的megacorp是索引的名字（想象成一个数据库），employee是类型的名字（想象成一张表）。返回的<code>_id</code>是Elasticsearch随机创建的一个ID，用于标识数据。</p>
<p>可以通过以下url获取Elasticsearch的索引信息：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl <span class="string">'http://192.168.99.100:9200/_cat/indices?v'</span></div></pre></td></tr></table></figure></p>
<p>修改索引的话，发出PUT请求就可以了（别忘了把ID换成你自己生成的<code>_id</code>）：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">curl -XPUT <span class="string">'http://192.168.99.100:9200/megacorp/employee/AVbK2ssDm7bdYo65QJ6k'</span> -d <span class="string">'</span></div><div class="line">&#123;</div><div class="line">    "first_name" : "Johnie",</div><div class="line">    "last_name" :  "Smithreen",</div><div class="line">    "age" :        38,</div><div class="line">    "about" :      "I do not love to go rock climbing",</div><div class="line">    "interests": []</div><div class="line">&#125;'</div></pre></td></tr></table></figure></p>
<p>如果指定的ID不存在，那么PUT也会新建一条记录。删除索引的话，发出DELETE请求就可以了：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -XDELETE <span class="string">'http://192.168.99.100:9200/megacorp/employee/AVbK2ssDm7bdYo65QJ6k'</span></div></pre></td></tr></table></figure></p>
<p>或者删除整个索引：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -XDELETE <span class="string">'http://192.168.99.100:9200/megacorp'</span></div></pre></td></tr></table></figure></p>
<p>再次获取索引信息，便会看到已经没有索引了。让我们加上三条数据，以备下一节搜索使用：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">curl -XPOST <span class="string">'http://192.168.99.100:9200/megacorp/employee/1'</span> -d <span class="string">'</span></div><div class="line">&#123;</div><div class="line">    "first_name" : "John",</div><div class="line">    "last_name" :  "Smith",</div><div class="line">    "age" :        25,</div><div class="line">    "about" :      "I love to go rock climbing",</div><div class="line">    "interests": [ "sports", "music" ]</div><div class="line">&#125;'</div><div class="line">curl -XPOST <span class="string">'http://192.168.99.100:9200/megacorp/employee/2'</span> -d <span class="string">'</span></div><div class="line">&#123;</div><div class="line">    "first_name" :  "Jane",</div><div class="line">    "last_name" :   "Smith",</div><div class="line">    "age" :         32,</div><div class="line">    "about" :       "I like to collect rock albums",</div><div class="line">    "interests":  [ "music" ]</div><div class="line">&#125;'</div><div class="line">curl -XPOST <span class="string">'http://192.168.99.100:9200/megacorp/employee/3'</span> -d <span class="string">'</span></div><div class="line">&#123;</div><div class="line">    "first_name" :  "Douglas",</div><div class="line">    "last_name" :   "Fir",</div><div class="line">    "age" :         35,</div><div class="line">    "about":        "I like to build cabinets",</div><div class="line">    "interests":  [ "forestry" ]</div><div class="line">&#125;'</div></pre></td></tr></table></figure></p>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>要查看刚刚创建的数据，直接get就可以了：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">curl <span class="string">'http://192.168.99.100:9200/megacorp/employee/1'</span></div><div class="line">curl <span class="string">'http://192.168.99.100:9200/megacorp/employee/2'</span></div><div class="line">curl <span class="string">'http://192.168.99.100:9200/megacorp/employee/3'</span></div></pre></td></tr></table></figure></p>
<p>全部查询改一下url就可以了：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">curl <span class="string">'http://192.168.99.100:9200/megacorp/employee/_search'</span></div><div class="line">curl <span class="string">'http://192.168.99.100:9200/megacorp/_search'</span></div><div class="line">curl <span class="string">'http://192.168.99.100:9200/_search'</span></div></pre></td></tr></table></figure></p>
<h3 id="简易搜索"><a href="#简易搜索" class="headerlink" title="简易搜索"></a>简易搜索</h3><p>上面的命令都只能算查询，还不算搜索。接下来让我们尝试Elasticsearch强大的搜索功能：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">curl <span class="string">'http://192.168.99.100:9200/megacorp/employee/_search?q=last_name:Smith'</span></div><div class="line">curl <span class="string">'http://192.168.99.100:9200/megacorp/employee/_search'</span> -d <span class="string">'</span></div><div class="line">&#123;</div><div class="line">    "query" : &#123;</div><div class="line">        "match" : &#123;</div><div class="line">            "last_name" : "Smith"</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;'</div></pre></td></tr></table></figure></p>
<h3 id="查询DSL"><a href="#查询DSL" class="headerlink" title="查询DSL"></a>查询DSL</h3><p>上面两条命令都是去获取<code>last_name</code>为<code>Smith</code>的数据，但是下面一条用到了<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html" target="_blank" rel="external">查询DSL</a>。这是Elasticsearch提供的DSL查询语言，可以通过它完成更加复杂的搜索。接下来除了<code>Smith</code>以外，我们还要增加30岁以上这一条件：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">curl <span class="string">'http://192.168.99.100:9200/megacorp/employee/_search'</span> -d <span class="string">'</span></div><div class="line">&#123;</div><div class="line">    "query" : &#123;</div><div class="line">        "filtered" : &#123;</div><div class="line">            "filter" : &#123;</div><div class="line">                "range" : &#123;</div><div class="line">                    "age" : &#123; "gt" : 30 &#125; </div><div class="line">                &#125;</div><div class="line">            &#125;,</div><div class="line">            "query" : &#123;</div><div class="line">                "match" : &#123;</div><div class="line">                    "last_name" : "smith" </div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;'</div></pre></td></tr></table></figure></p>
<p>在这里介绍一下<code>filter</code>和<code>query</code>。可以这么理解：<code>filter</code>是精确查找（想象成sql里where子句的=、&lt;、&gt;），速度快，有缓存。<code>query</code>是模糊查找（想象成sql里where子句的like，但是能根据匹配度打分），虽然没有<code>filter</code>那么快，但是查询结果能更准确一些。业务上的查询通常都是同时使用二者，通过<code>filter</code>快速找到对象数据，再通过<code>query</code>来匹配。</p>
<h3 id="全文搜索"><a href="#全文搜索" class="headerlink" title="全文搜索"></a>全文搜索</h3><p>接下来尝试全文搜索，从<code>about</code>的句子里查询想要的数据：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">curl <span class="string">'http://192.168.99.100:9200/megacorp/employee/_search'</span> -d <span class="string">'</span></div><div class="line">&#123;</div><div class="line">    "query" : &#123;</div><div class="line">        "match" : &#123;</div><div class="line">            "about" : "rock climbing"</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;'</div></pre></td></tr></table></figure></p>
<p>查到了两个结果。返回值包含了一项<code>_score</code>，既含有<code>rock</code>又含有<code>climbing</code>的数据，得分明显高于只含有<code>rock</code>的数据。理所当然的，得分高的数据排在上面。如果想要精确匹配<code>rock climbing</code>，把<code>match</code>改为<code>match_phrase</code>就可以了：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">curl <span class="string">'http://192.168.99.100:9200/megacorp/employee/_search'</span> -d <span class="string">'</span></div><div class="line">&#123;</div><div class="line">    "query" : &#123;</div><div class="line">        "match_phrase" : &#123;</div><div class="line">            "about" : "rock climbing"</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;'</div></pre></td></tr></table></figure></p>
<h3 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h3><p>查找最受欢迎的兴趣：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">curl <span class="string">'http://192.168.99.100:9200/megacorp/employee/_search'</span> -d <span class="string">'</span></div><div class="line">&#123;</div><div class="line">  "aggs": &#123;</div><div class="line">    "all_interests": &#123;</div><div class="line">      "terms": &#123; "field": "interests" &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;'</div></pre></td></tr></table></figure></p>
<p>查找每个兴趣的平均年龄：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">curl <span class="string">'http://192.168.99.100:9200/megacorp/employee/_search'</span> -d <span class="string">'</span></div><div class="line">&#123;</div><div class="line">    "aggs" : &#123;</div><div class="line">        "all_interests" : &#123;</div><div class="line">            "terms" : &#123; "field" : "interests" &#125;,</div><div class="line">            "aggs" : &#123;</div><div class="line">                "avg_age" : &#123;</div><div class="line">                    "avg" : &#123; "field" : "age" &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;'</div></pre></td></tr></table></figure></p>
<p>这些数据都是实时计算出来的。就像使用SQL来查询数据库一样，Elasticsearch提供了自己的DSL来让我们基于复杂的条件来搜索。<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html" target="_blank" rel="external">这里</a>是统计功能的官方文档。</p>
<h2 id="中文"><a href="#中文" class="headerlink" title="中文"></a>中文</h2><p>同Solr一样，要想让Elasticsearch支持中文分词，需要使用中文分词组件。这里我们还是用<a href="https://github.com/medcl/elasticsearch-analysis-mmseg" target="_blank" rel="external">mmseg插件</a>。首先下载并解压：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">wget -c https://github.com/medcl/elasticsearch-analysis-mmseg/releases/download/v1.9.4/elasticsearch-analysis-mmseg-1.9.4.zip</div><div class="line">unzip -d elasticsearch-analysis-mmseg-1.9.4 elasticsearch-analysis-mmseg-1.9.4.zip</div><div class="line">sed -i <span class="string">'s/2.3.4/2.3.5/'</span> elasticsearch-analysis-mmseg-1.9.4/plugin-descriptor.properties</div></pre></td></tr></table></figure></p>
<p>1.9.4版的插件只支持Elasticsearch 2.3.4版，要想支持2.3.5，就需要把<code>elasticsearch.version</code>配置改为<code>2.3.5</code>。除此之外，还需要加点儿东西到Elasticsearch的配置文件里：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">cat &lt;&lt; EOF &gt; es.yml</div><div class="line">network.host: 0.0.0.0</div><div class="line">index:</div><div class="line">  analysis:</div><div class="line">    analyzer:</div><div class="line">      mmseg_maxword:</div><div class="line">        <span class="built_in">type</span>: custom</div><div class="line">        filter:</div><div class="line">        - lowercase</div><div class="line">        tokenizer: mmseg_maxword</div><div class="line">      mmseg_maxword_with_cut_letter_digi:</div><div class="line">        <span class="built_in">type</span>: custom</div><div class="line">        filter:</div><div class="line">        - lowercase</div><div class="line">        - cut_letter_digit</div><div class="line">        tokenizer: mmseg_maxword</div><div class="line">EOF</div></pre></td></tr></table></figure></p>
<p>上述配置文件的具体语法可以参考<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis.html" target="_blank" rel="external">这里</a>。接下来就可以启动容器了，分别挂载配置文件和插件：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">docker rm -f es</div><div class="line">docker run -d --net=host --name=es \</div><div class="line">    -v `<span class="built_in">pwd</span>`/es.yml:/usr/share/elasticsearch/config/elasticsearch.yml \</div><div class="line">    -v `<span class="built_in">pwd</span>`/elasticsearch-analysis-mmseg-1.9.4/:/usr/share/elasticsearch/plugins/elasticsearch-analysis-mmseg-1.9.4/ \</div><div class="line">    elasticsearch:2.3.5</div></pre></td></tr></table></figure></p>
<p>Elasticsearch服务启动后，就可以增加索引和<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping.html" target="_blank" rel="external">映射</a>（mapping，可以理解为数据类型，有点像solr的schema），并且插入一些数据了：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">curl -XPUT http://192.168.99.100:9200/index</div><div class="line">curl -XPOST http://192.168.99.100:9200/index/fulltext/_mapping -d<span class="string">'</span></div><div class="line">&#123;</div><div class="line">    "fulltext": &#123;</div><div class="line">        "_all": &#123;</div><div class="line">            "analyzer": "mmseg_maxword",</div><div class="line">            "search_analyzer": "mmseg_maxword",</div><div class="line">            "term_vector": "no",</div><div class="line">            "store": "false"</div><div class="line">        &#125;,</div><div class="line">        "properties": &#123;</div><div class="line">            "content": &#123;</div><div class="line">                "type": "string",</div><div class="line">                "store": "no",</div><div class="line">                "term_vector": "with_positions_offsets",</div><div class="line">                "analyzer": "mmseg_maxword",</div><div class="line">                "search_analyzer": "mmseg_maxword",</div><div class="line">                "include_in_all": "true",</div><div class="line">                "boost": 8</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;'</div><div class="line"></div><div class="line">curl -XPOST http://192.168.99.100:9200/index/fulltext/1 -d<span class="string">'&#123;content:"美国留给伊拉克的是个烂摊子吗"&#125;'</span></div><div class="line">curl -XPOST http://192.168.99.100:9200/index/fulltext/2 -d<span class="string">'&#123;content:"公安部：各地校车将享最高路权"&#125;'</span></div><div class="line">curl -XPOST http://192.168.99.100:9200/index/fulltext/3 -d<span class="string">'&#123;content:"中韩渔警冲突调查：韩警平均每天扣1艘中国渔船"&#125;'</span></div><div class="line">curl -XPOST http://192.168.99.100:9200/index/fulltext/4 -d<span class="string">'&#123;content:"中国驻洛杉矶领事馆遭亚裔男子枪击 嫌犯已自首"&#125;'</span></div></pre></td></tr></table></figure></p>
<p>最后搜索<code>中国</code>看看：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">curl -XPOST http://192.168.99.100:9200/index/fulltext/_search  -d<span class="string">'</span></div><div class="line">&#123;</div><div class="line">    "query" : &#123; "term" : &#123; "content" : "中国" &#125;&#125;,</div><div class="line">    "highlight" : &#123;</div><div class="line">        "pre_tags" : ["&lt;tag1&gt;", "&lt;tag2&gt;"],</div><div class="line">        "post_tags" : ["&lt;/tag1&gt;", "&lt;/tag2&gt;"],</div><div class="line">        "fields" : &#123;</div><div class="line">            "content" : &#123;&#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">'</div></pre></td></tr></table></figure></p>
<p>可以使用<code>_analyze</code>来查看分析的过程：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl <span class="string">"http://192.168.99.100:9200/index/_analyze?analyzer=mmseg_maxword&amp;pretty=true"</span> -d <span class="string">"美国留给伊拉克的是个烂摊子吗"</span></div></pre></td></tr></table></figure></p>
<p>可见，这句话被解析成：美国、留给、伊、拉克、的、是个、烂、摊子、吗，还不是非常完美。<code>伊拉克</code>、<code>烂摊子</code>都没有很好地识别出来。</p>
<p>有兴趣的话，还可以重建容器，跟无中文分词的效果对比一下。除了mmseg，大神medcl还写了一个<a href="https://github.com/medcl/elasticsearch-rtf" target="_blank" rel="external">elasticsearch-rtf版本</a>，涵盖诸多中文分词工具，可以直接使用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.elastic.co/products/elasticsearch&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Elasticsearch&lt;/a&gt;是用Java开发的基于&lt;a href=&quot;https://lucene.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apache Lucene&lt;/a&gt;的一个近乎实时的分布式搜索分析引擎。维基百科、Stack Overflow、GitHub等都采用它来作为全文搜索引擎。本文旨在用docker来快速入门并尝试Elasticsearch提供的基本功能。&lt;/p&gt;
&lt;p&gt;对&lt;a href=&quot;http://lucene.apache.org/solr/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apache Solr&lt;/a&gt;入门有兴趣的朋友请参考&lt;a href=&quot;/solr&quot;&gt;用容器快速上手Apache Solr&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="devops" scheme="http://qinghua.github.io/categories/devops/"/>
    
    
      <category term="elasticsearch" scheme="http://qinghua.github.io/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>用容器轻松搭建redis主从和集群环境</title>
    <link href="http://qinghua.github.io/redis-cluster/"/>
    <id>http://qinghua.github.io/redis-cluster/</id>
    <published>2016-08-24T01:18:57.000Z</published>
    <updated>2016-12-23T15:37:43.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://redis.io/" target="_blank" rel="external">Redis</a>是目前使用得非常广泛的开源分布式缓存。它支持诸多数据结构和数据持久化，并且通过<a href="http://redis.io/topics/sentinel" target="_blank" rel="external">Redis Sentinel</a>和<a href="http://redis.io/topics/cluster-tutorial" target="_blank" rel="external">Redis cluster</a>来支持高可用。本文旨在通过docker轻松搭建redis的主从/集群环境。<br><a id="more"></a></p>
<h2 id="主从"><a href="#主从" class="headerlink" title="主从"></a>主从</h2><p>用容器启动redis实例非常容易：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run --net=host --name=master -d redis:3.2.0</div></pre></td></tr></table></figure></p>
<p>这就搞定了。进去看一看：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> -it master redis-cli</div><div class="line"><span class="built_in">set</span> ggg 123</div><div class="line">keys *</div><div class="line">get ggg</div><div class="line"><span class="built_in">exit</span></div></pre></td></tr></table></figure></p>
<p>可以通过配置文件、启动参数或者命令来新建一个从实例。接下来我们用启动参数的方式：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run --net=host --name=slave -d redis:3.2.0 redis-server --port 6380 --slaveof 127.0.0.1 6379</div></pre></td></tr></table></figure></p>
<p>进去看一看，就能看到刚才创建的ggg已经被同步过来了：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> -it slave redis-cli</div><div class="line">keys *</div><div class="line">get ggg</div><div class="line"><span class="built_in">exit</span></div></pre></td></tr></table></figure></p>
<p>最后把刚刚创建的实例都删除掉：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rm -f master slave</div></pre></td></tr></table></figure></p>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>Redis的集群至少是3个实例。接下来为这3个实例创建3个端口不同的配置文件：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">cat &lt;&lt; EOF &gt; redis1.conf</div><div class="line">port 6381</div><div class="line">cluster-enabled yes</div><div class="line">cluster-config-file nodes.conf</div><div class="line">cluster-node-timeout 5000</div><div class="line">appendonly yes</div><div class="line">EOF</div><div class="line"></div><div class="line">cp redis1.conf redis2.conf</div><div class="line">sed -i <span class="string">'s/6381/6382/'</span> redis2.conf</div><div class="line"></div><div class="line">cp redis1.conf redis3.conf</div><div class="line">sed -i <span class="string">'s/6381/6383/'</span> redis3.conf</div></pre></td></tr></table></figure></p>
<p>通过刚刚创建的配置文件来启动3个redis实例：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker run --net=host --name=redis1 -v `<span class="built_in">pwd</span>`/redis1.conf:/usr/<span class="built_in">local</span>/etc/redis/redis.conf -d redis:3.2.0 redis-server /usr/<span class="built_in">local</span>/etc/redis/redis.conf</div><div class="line">docker run --net=host --name=redis2 -v `<span class="built_in">pwd</span>`/redis2.conf:/usr/<span class="built_in">local</span>/etc/redis/redis.conf -d redis:3.2.0 redis-server /usr/<span class="built_in">local</span>/etc/redis/redis.conf</div><div class="line">docker run --net=host --name=redis3 -v `<span class="built_in">pwd</span>`/redis3.conf:/usr/<span class="built_in">local</span>/etc/redis/redis.conf -d redis:3.2.0 redis-server /usr/<span class="built_in">local</span>/etc/redis/redis.conf</div></pre></td></tr></table></figure></p>
<p>创建集群最简单的方式是用源代码库里的<code>redis-trib.rb</code>脚本。我们需要先下载源代码并安装<code>redis</code>的gem使之能够运行这个脚本：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">clone</span> https://github.com/antirez/redis</div><div class="line"></div><div class="line">sudo gem install redis</div><div class="line"></div><div class="line">ruby redis/src/redis-trib.rb create 127.0.0.1:6381 127.0.0.1:6382 127.0.0.1:6383</div></pre></td></tr></table></figure></p>
<p>运行<code>redis-trib.rb</code>会提示：<strong>Can I set the above configuration? (type ‘yes’ to accept)</strong>，输入<code>yes</code>回车即可。Redis集群就这样搭建好了。我们进去看一看：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> -it redis1 redis-cli -p 6381</div><div class="line">cluster nodes</div><div class="line"><span class="built_in">set</span> ggg 123</div><div class="line"><span class="built_in">set</span> gggg 234</div><div class="line"><span class="built_in">exit</span></div></pre></td></tr></table></figure></p>
<p>第一个ggg可以顺利设置成功，但是第二个gggg就不行了，我们会看到错误：<strong>(error) MOVED 6392 127.0.0.1:6382</strong>。这是由于redis<a href="http://redis.io/topics/cluster-tutorial#redis-cluster-data-sharding" target="_blank" rel="external">分片（sharding）</a>的缘故。如果频繁地在控制台里切换实例也怪麻烦的，幸好<code>redis-cli</code>提供了一个<code>-c</code>的参数，允许以集群的方式连接：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> -it redis1 redis-cli -c -p 6381</div><div class="line"><span class="built_in">set</span> gggg 234</div><div class="line">keys *</div><div class="line"><span class="built_in">exit</span></div></pre></td></tr></table></figure></p>
<p>再次设置gggg，就会看到：<strong>Redirected to slot [6392] located at 127.0.0.1:6382</strong>，它表明redis已经把我们连接到6382的实例上去了。最后把前面创建的实例都删除掉：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rm -f redis1 redis2 redis3</div></pre></td></tr></table></figure></p>
<h2 id="主从集群"><a href="#主从集群" class="headerlink" title="主从集群"></a>主从集群</h2><p>主从集群就是给三个主实例各加一个从实例。现在已经有了三个主实例的配置文件了，再来三个从集群的，一共是6个：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">cp redis1.conf redis4.conf</div><div class="line">cp redis1.conf redis5.conf</div><div class="line">cp redis1.conf redis6.conf</div><div class="line"></div><div class="line">sed -i <span class="string">'s/6381/6384/'</span> redis4.conf</div><div class="line">sed -i <span class="string">'s/6381/6385/'</span> redis5.conf</div><div class="line">sed -i <span class="string">'s/6381/6386/'</span> redis6.conf</div><div class="line"></div><div class="line">docker run --net=host --name=redis1 -v `<span class="built_in">pwd</span>`/redis1.conf:/usr/<span class="built_in">local</span>/etc/redis/redis.conf -d redis:3.2.0 redis-server /usr/<span class="built_in">local</span>/etc/redis/redis.conf</div><div class="line">docker run --net=host --name=redis2 -v `<span class="built_in">pwd</span>`/redis2.conf:/usr/<span class="built_in">local</span>/etc/redis/redis.conf -d redis:3.2.0 redis-server /usr/<span class="built_in">local</span>/etc/redis/redis.conf</div><div class="line">docker run --net=host --name=redis3 -v `<span class="built_in">pwd</span>`/redis3.conf:/usr/<span class="built_in">local</span>/etc/redis/redis.conf -d redis:3.2.0 redis-server /usr/<span class="built_in">local</span>/etc/redis/redis.conf</div><div class="line">docker run --net=host --name=redis4 -v `<span class="built_in">pwd</span>`/redis4.conf:/usr/<span class="built_in">local</span>/etc/redis/redis.conf -d redis:3.2.0 redis-server /usr/<span class="built_in">local</span>/etc/redis/redis.conf</div><div class="line">docker run --net=host --name=redis5 -v `<span class="built_in">pwd</span>`/redis5.conf:/usr/<span class="built_in">local</span>/etc/redis/redis.conf -d redis:3.2.0 redis-server /usr/<span class="built_in">local</span>/etc/redis/redis.conf</div><div class="line">docker run --net=host --name=redis6 -v `<span class="built_in">pwd</span>`/redis6.conf:/usr/<span class="built_in">local</span>/etc/redis/redis.conf -d redis:3.2.0 redis-server /usr/<span class="built_in">local</span>/etc/redis/redis.conf</div></pre></td></tr></table></figure></p>
<p>一条命令即可启动主从集群：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ruby redis/src/redis-trib.rb create --replicas 1 127.0.0.1:6381 127.0.0.1:6382 127.0.0.1:6383 127.0.0.1:6384 127.0.0.1:6385 127.0.0.1:6386</div></pre></td></tr></table></figure></p>
<p>然后就可以在里面随意测试啦。最后把创建的实例都删除掉：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rm -f redis1 redis2 redis3 redis4 redis5 redis6</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://redis.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Redis&lt;/a&gt;是目前使用得非常广泛的开源分布式缓存。它支持诸多数据结构和数据持久化，并且通过&lt;a href=&quot;http://redis.io/topics/sentinel&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Redis Sentinel&lt;/a&gt;和&lt;a href=&quot;http://redis.io/topics/cluster-tutorial&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Redis cluster&lt;/a&gt;来支持高可用。本文旨在通过docker轻松搭建redis的主从/集群环境。&lt;br&gt;
    
    </summary>
    
      <category term="devops" scheme="http://qinghua.github.io/categories/devops/"/>
    
    
      <category term="redis" scheme="http://qinghua.github.io/tags/redis/"/>
    
  </entry>
  
</feed>
