<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>懒程序员改变世界</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://qinghua.github.io/"/>
  <updated>2018-12-16T12:25:53.000Z</updated>
  <id>http://qinghua.github.io/</id>
  
  <author>
    <name>Qinghua Gao</name>
    <email>ggggqh666@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>用AWS创建工作流</title>
    <link href="http://qinghua.github.io/aws-step-functions/"/>
    <id>http://qinghua.github.io/aws-step-functions/</id>
    <published>2018-12-15T01:52:29.000Z</published>
    <updated>2018-12-16T12:25:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>AWS提供了一系列易于使用的服务，其中的Step Functions可以用于创建工作流。本文主要介绍了Step Functions的使用并顺带介绍了其它几个相应的AWS服务。此外，亚马逊提供了为期一年的免费账户，可以访问<a href="https://aws.amazon.com/cn/free/" target="_blank" rel="external">AWS</a>来试用。<br><a id="more"></a></p>
<h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><p>首先假定一个场景：我需要定期抓取亚马逊某商品的价格，并通知自己。传统的实现方式就是写一个爬虫，然后在服务器上cron一下就好了。虽然能使，但是一旦考虑到灵活性（商品应该可定制，通知手段应该灵活）、高可用（服务器挂了也不应该影响到业务）、可视化（提供易于使用的界面，以看当前和历史的执行情况）、可监控（看当前的执行情况、出错了需要通知开发者）等，那就费时费力了。好在AWS给我们提供了一系列的服务，允许我们像Linux的管道那样把服务简单、灵活地拼接起来，从而实现需求。</p>
<h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h2><h3 id="服务介绍"><a href="#服务介绍" class="headerlink" title="服务介绍"></a>服务介绍</h3><p>首先简单介绍一下在这个工作流中我们会涉及到的AWS服务：<br><strong>Step Functions</strong>：用于可视化管理工作流。是本文的核心。<br><strong>SNS</strong>：通知服务，只要给主题（Topic）发消息，主题的订阅者（Subscription）就会通过订阅的渠道（如邮件、短信等）收到消息。<br><strong>Lambda</strong>：无需服务器即可运行代码的计算服务，免去了管理服务器的烦恼。只有在程序运行的时候才收费。<br><strong>CloudWatch</strong>：监控或触发AWS资源的服务。在本文中我们姑且把它当做一个cron服务。</p>
<h3 id="Step-Functions"><a href="#Step-Functions" class="headerlink" title="Step Functions"></a>Step Functions</h3><p>对于本文的需求来说，最简单明了的工作流即是下图：<br><img src="/img/aws-sf-CrawAmazonPrice-v1.png" alt=""></p>
<p>非常直观，一眼就能看出来它会先抓取亚马逊的价格，然后通知自己。对于Step Functions来说，这张流程图的代码很简洁：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"StartAt"</span>: <span class="string">"CrawAmazonPrice"</span>,</div><div class="line">  <span class="attr">"States"</span>: &#123;</div><div class="line">    <span class="attr">"CrawAmazonPrice"</span>: &#123;</div><div class="line">      <span class="attr">"Type"</span>: <span class="string">"Task"</span>,</div><div class="line">      <span class="attr">"Resource"</span>: <span class="string">"arn:aws:lambda:us-east-1:XXX_ACCOUNT_ID_XXX:function:CrawAmazonPrice"</span>,</div><div class="line">      <span class="attr">"Next"</span>: <span class="string">"NotifyMe"</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">"NotifyMe"</span>: &#123;</div><div class="line">      <span class="attr">"Type"</span>: <span class="string">"Task"</span>,</div><div class="line">      <span class="attr">"Resource"</span>: <span class="string">"arn:aws:states:::sns:publish"</span>,</div><div class="line">      <span class="attr">"Parameters"</span>: &#123;</div><div class="line">        <span class="attr">"Message.$"</span>: <span class="string">"$.body"</span>,</div><div class="line">        <span class="attr">"TopicArn"</span>: <span class="string">"arn:aws:sns:us-east-1:XXX_ACCOUNT_ID_XXX:PriceDown"</span></div><div class="line">      &#125;,</div><div class="line">      <span class="attr">"End"</span>: <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h3><p>上面的<code>CrawAmazonPrice</code>指定了<code>Resource</code>是一个名为<code>CrawAmazonPrice</code>的AWS Lambda函数，而<code>NotifyMe</code>则指定了一个名为<code>PriceDown</code>的SNS主题。对这个主题感兴趣的用户（比如说，我）可以用期待的方式（邮件、短信等）订阅它。所以这个流程就是：开始-&gt;CrawAmazonPrice（Lambda）-&gt;NotifyMe（SNS）-&gt;结束。</p>
<p>为了简便起见，我们可以直接通过AWS界面实现<code>CrawAmazonPrice</code>的Lambda函数。直接新建一个Python 3.7的脚本即可：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> json</div><div class="line"><span class="keyword">import</span> re</div><div class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">lambda_handler</span><span class="params">(event, context)</span>:</span></div><div class="line">    req = request.Request(<span class="string">'http://www.amazon.cn/dp/B07FNP8DX4'</span>)</div><div class="line">    req.add_header(<span class="string">'User-Agent'</span>, <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102'</span>)</div><div class="line">    response = request.urlopen(req)</div><div class="line">    html = response.read().decode(<span class="string">'utf-8'</span>)</div><div class="line">    price = re.search(<span class="string">'data-asin-price=\"(.+?)\"'</span>, html).group(<span class="number">1</span>)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="string">'statusCode'</span>: <span class="number">200</span>,</div><div class="line">        <span class="string">'body'</span>: json.dumps(price)</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p><img src="/img/aws-lambda-CrawAmazonPrice.png" alt=""></p>
<h3 id="SNS"><a href="#SNS" class="headerlink" title="SNS"></a>SNS</h3><p>SNS就更简单了，创建一个名为<code>PriceDown</code>的新主题，然后为它创建一个协议为<code>Email</code>的订阅，填入自己的邮箱地址，便会收到AWS给这个邮箱发送的确认订阅邮件。点击邮件中的链接，即可完成订阅。要是日后有其他人对这个主题也感兴趣，增加一个订阅即可。<br><img src="/img/aws-sns-PriceDown.png" alt=""></p>
<h3 id="CloudWatch"><a href="#CloudWatch" class="headerlink" title="CloudWatch"></a>CloudWatch</h3><p>剩下的事情就是创建一个CloudWatch，来定期触发这个Step Functions。直接通过AWS界面创建一个规则（Rule），固定频率为每天，将目标设置为上面的Step Function工作流，取个名字如<code>DailyLookUpPrice</code>就可以啦！<br><img src="/img/aws-cw-DailyLookUpPrice.png" alt=""></p>
<h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><p>每次当CloudWatch被触发时，都会在Step Functions中留下自己的足迹。<br><img src="/img/aws-sf-CrawAmazonPrice-execution.png" alt=""></p>
<p>由上图可以看到，每个状态的进入和退出都清晰可见，非常方便。</p>
<h2 id="需求变更"><a href="#需求变更" class="headerlink" title="需求变更"></a>需求变更</h2><p>假如我们只想在价格低的时候通知自己，除了修改Lambda中定义的代码以外，还可以增加一个Task，以便增强灵活性。例如，公司内部有一个最低价格的服务，但是无法被公司外部（如AWS）调用到。即便如此，Step Functions也可以支持这种应用场景。在任何可以调用公司服务的地方写一段代码，这段代码作为一个活动（Activity）来轮询Step Functions，当执行到该Task时，该代码就被运行，调用公司内部的服务。AWS的实现也很简单，首先新增一个名为<code>EnsureLowestPrice</code>的活动，然后在Step Function的JSON中增加一个Task，并修改<code>CrawAmazonPrice</code>，使其<code>Next</code>指向<code>EnsureLowestPrice</code>：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">"EnsureLowestPrice": &#123;</div><div class="line">  "Type": "Task",</div><div class="line">  "Resource": "arn:aws:states:us-east-1:XXX_ACCOUNT_ID_XXX:activity:EnsureLowestPrice",</div><div class="line">  "Next": "NotifyMe"</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这回的Task就不是Lambda啦，而是自己运行在随意机器上的代码。以Java为例，可以参考<a href="https://docs.aws.amazon.com/zh_cn/step-functions/latest/dg/tutorial-creating-activity-state-machine.html" target="_blank" rel="external">AWS官方文档</a>来实现。</p>
<p>“价格低于最低价”的服务，在这里只是一个表示内部服务的示例罢了。当然，如果真要实现一个类似的服务，用AWS的DynamoDB甚至S3可以很方便地实现。</p>
<p>假如需要并行查询多种商品价格，Step Functions也能轻易支持：<br><img src="/img/aws-sf-CrawAmazonPrice-v2.png" alt=""></p>
<p>并行的代码如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">"CrawAmazonPrice": &#123;</div><div class="line">  "Type": "Parallel",</div><div class="line">  "Next": "EnsureLowestPrice",</div><div class="line">  "Branches": [</div><div class="line">    &#123;</div><div class="line">      "StartAt": "CrawPrice1",</div><div class="line">      "States": &#123;</div><div class="line">        "CrawPrice1": &#123;</div><div class="line">          "Type": "Task",</div><div class="line">          "Resource": "arn:aws:lambda:us-east-1:XXX_ACCOUNT_ID_XXX:function:CrawAmazonPrice",</div><div class="line">          "End": true</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">      "StartAt": "CrawPrice2",</div><div class="line">      "States": &#123;</div><div class="line">        "CrawPrice2": &#123;</div><div class="line">          "Type": "Task",</div><div class="line">          "Resource": "arn:aws:lambda:us-east-1:XXX_ACCOUNT_ID_XXX:function:CrawAmazonPrice",</div><div class="line">          "End": true</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于<code>Branches</code>及<code>States</code>的灵活性，再复杂的工作流也不在话下。</p>
<h2 id="进阶功能"><a href="#进阶功能" class="headerlink" title="进阶功能"></a>进阶功能</h2><h3 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h3><p>如果代码出现死循环之类的问题，可能会导致工作流无法继续流动下去。这时可以通过给该状态设置超时<code>TimeoutSeconds</code>以使之到时退出。合理地设置这个值需要考虑某个状态可能需要运行的时间、是否有人工步骤等。默认的<code>TimeoutSeconds</code>为99999999。</p>
<h3 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h3><p>如果程序可能运行数个小时，也许你难以知道现在的状态是运行中，还是程序挂掉了。这时可以通过设置心跳<code>HeartbeatSeconds</code>来使Step Functions知道当前的运行状况，以便及时把挂掉了（没有心跳了）的任务分发给其它节点。当然为了这个功能，程序中需要增加相对应的逻辑（定期发送心跳）。</p>
<h3 id="重试"><a href="#重试" class="headerlink" title="重试"></a>重试</h3><p>有时候程序出错，可能只需要重试一下就好了。这时我们可以使用Step Functions提供的重试<code>Retry</code>机制。如以下程序所示：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">"Retry" : [</div><div class="line">  &#123;</div><div class="line">    "ErrorEquals": [ "States.TaskFailed", "States.Timeout" ],</div><div class="line">    "IntervalSeconds": 600,</div><div class="line">    "MaxAttempts": 3</div><div class="line">  &#125;</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p><code>Retry</code>是一个集合，所以可以为不同的错误定义不同的重试机制。</p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>如果重试还是不行，那还有一个招式就是异常处理机制<code>Catch</code>。它与重试类似，可以为不同的错误定义不同的状态流向:<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">"Catch": [</div><div class="line">  &#123;</div><div class="line">    "ErrorEquals": [ "States.ALL" ],</div><div class="line">    "Next": "NotifyError"</div><div class="line">  &#125;</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>在上面的代码里，只要出错了（并且重试也没有成功），就跳转到<code>NotifyError</code>的状态，可以通过SNS通知订阅者了。</p>
<h3 id="错误状态"><a href="#错误状态" class="headerlink" title="错误状态"></a>错误状态</h3><p>在异常处理中由于跳转到了<code>NotifyError</code>，并且通知成功，反而倒让这个工作流从异常变成正常了。想让工作流失败，只需在<code>NotifyError</code>的后面接一步简单的<code>FailExecution</code>状态就可以了。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">"FailExecution": &#123;</div><div class="line">  "Type": "Fail"</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="最终工作流"><a href="#最终工作流" class="headerlink" title="最终工作流"></a>最终工作流</h3><p><img src="/img/aws-sf-CrawAmazonPrice-v3.png" alt=""></p>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>最求完美，永无止境。例如，这些服务我们现在都是在AWS界面上点来点去的，其实这些人工操作可以通过<code>CloudFormation</code>来变成自动化的脚本。如此，便可以实现我们的基础设施即代码，做到一键部署了。另外，随着需求的演化，如果要更新Step Functions的工作流，还可能需要考虑到对其进行版本管理。还有，当处理活动的节点数较多时，如果能够把某次执行的机器名输出到工作流中，也有助于错误排查。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AWS提供了一系列易于使用的服务，其中的Step Functions可以用于创建工作流。本文主要介绍了Step Functions的使用并顺带介绍了其它几个相应的AWS服务。此外，亚马逊提供了为期一年的免费账户，可以访问&lt;a href=&quot;https://aws.amazon.com/cn/free/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AWS&lt;/a&gt;来试用。&lt;br&gt;
    
    </summary>
    
      <category term="development" scheme="http://qinghua.github.io/categories/development/"/>
    
    
      <category term="aws" scheme="http://qinghua.github.io/tags/aws/"/>
    
  </entry>
  
  <entry>
    <title>未来的软件开发什么样</title>
    <link href="http://qinghua.github.io/future-software-development/"/>
    <id>http://qinghua.github.io/future-software-development/</id>
    <published>2018-11-24T09:01:59.000Z</published>
    <updated>2018-11-24T13:02:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>前一阵子经常看到各种文章说以后人工智能如何如何强大，人类各种失业，要么凄惨，要么极乐，软件开发也无法幸免。那么开挂后未来的软件开发究竟会如何演进？其实我们可以借助传统制造业来推演一下。<br><a id="more"></a></p>
<h2 id="过去"><a href="#过去" class="headerlink" title="过去"></a>过去</h2><p>软件开发和制造业在一定程度上是有相似性的。只不过制造业的历史更悠久、经历更丰富，它的革命总是更早地发生，这就足够让我们有所参照了。</p>
<p>传统制造业的原始阶段呢，最初都是以个体或家庭为单位，把整个产品都制造出来，比如毛皮，斧子等，没有统一标准，但是凑活都能用。哪一天不保暖或者不锋利了，那就再缝一缝或者磨一磨。软件开发的原始阶段呢，一开始都是单枪匹马，搞出来一个程序，凑活就能用。哪天出了个新情况，那就在原来的基础上改巴改巴，争取无需大改就能对付过去。</p>
<p>过了这个原始阶段，随着需求的演进，我们需要的产品更加地精细了。传统的制造方式难以为继，分工合作成为主流。每个人并不都会制造一个大整体，那也不现实；但是可以制造一个个符合标准的零件，最终将它们拼接成一个复杂的整体。而软件开发呢，也发展到了另一个阶段：一个人或一个小团队已经难以对复杂的单体系统进行开发维护的工作了，那就需要引入模块化或者是微服务化，降低各个组件的复杂度，以便可以更容易地让人掌握。市场上也有许多符合标准的开源及收费的包或服务，可在软件开发过程中使用。从这个角度上说，其实程序员们也都是流水线上的工人，只不过制造的是软件罢了。但是注意，传统的开发方式并没有消亡，因为还是会源源不断地冒出需求，人家就要一个斧子，干嘛组件化那么麻烦？能用就行了。就像现在还有许多的个体软件开发者，各自拥有一些框架，要建站？单枪匹马几百元就能搞定！</p>
<h2 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h2><p>到了现在这个阶段，制造业迎来的就是机器人时代。2011年，富士康就提出了十年内的“百万机器人计划”，计划投入百万台机器人到生产线上，以取代部分工人，解决用工荒的问题。而现在的软件业呢，也喜迎人工智能时代，各种AI加入软件，不跟它沾点儿边还真不好意思跟别的程序员打招呼。机器人能把高效地把最容易重复的部分完成，也能在高危环境中大展身手。人工智能呢，现阶段也是把容易重复或是根据经验估计的部分逐步取代。有时候软件开发人员也会问问自己，未来我会不会被AI所取代？</p>
<h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>不可否认，未来机器人会取代相当一部分人类。但与此同时，机器人也解放了人类，可以让他们创造新的工作类型。无法胜任的人类，会被残酷地淘汰掉，也许会演变为暴乱、战争……本文就不讨论这些了。而AI也将解放出许多软件工程师，这事是注定的，虽然那一天的到来还比较遥远。而那些专业知识不精、无法持续学习的程序员们，也将被AI的洪流无情碾轧。那未来的程序员们如何与AI共处呢？</p>
<h3 id="合作"><a href="#合作" class="headerlink" title="合作"></a>合作</h3><p>现在的机器人时代，一些生产线的机器人并非是“替代”人类生产，而是“协助”。在软件开发中，写个小工具或利用现有的工具来辅助自己开发是最正常不过的事情了，跟AI还扯不上关系。但与此同时，AI辅助程序员编程，也已经开始萌芽——<a href="https://kite.com/" target="_blank" rel="external">Kite</a>了解一下？</p>
<p>现在的教育平台，就如雨后春笋般地冒出来。孩子就读的小学，各科的老师们已经推荐了不下五款的app用来辅助学习。这些教育平台会降低老师的重要性吗？并不。事实上老师们正在用这些app提高教学效率。这正是一个典型的双赢合作啊。未来的软件工程师也可以轻松地在更加智能的AI的配合下，完成可视化的设计、模板代码、用户手册等。</p>
<h3 id="创新"><a href="#创新" class="headerlink" title="创新"></a>创新</h3><p>在制造业中，工厂里的机器人取代了劳动力，但是也产生了相当多的数据，需要许多人来分析和监控这些数据，还需要许多人来维护这些机器人。这是由于机器人存在而被人们创造出来的新岗位啊，尽管新岗位的数量远远小于原先的岗位数量。未来的AI可以使用多种方法来迅速实现各种需求，而软件工程师们可能更多负责评审、验证、监控这些程序的运行，当然还要编写、改进那些真正干活儿的AI，就像维护机器人一样。虽然说当人工智能强大到可以自我进化的时候，也许就不需要人类了，可是离那一天还早着呢。</p>
<h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>“合并”在这里的语境看起来有点儿吓人。现在的制造业中，已经出现了一些外骨骼机器人，在军事上也有一些可佩戴单兵装备还在研发中。而未来更可能会出现半机器人时代，也就是说，你身体的任何一个部位，都可以被机器替换，从而获得更快的奔跑速度、更大的力量、增强的感官等等。当你的大脑中的某个部分被AI替换时，也许你会拥有永不遗忘的记忆，极快的计算速度，各种知识信手拈来……这时候的软件工程师，也许舒舒服服地躺在海边，随便想一想，便能迅速获得一堆代码及所需的环境，甚至AI已经帮你自动测试完毕了。我们所剩下的，也许就只有思考了。</p>
<h3 id="斗争"><a href="#斗争" class="headerlink" title="斗争"></a>斗争</h3><p>想想《黑客帝国》……我是一个乐观派，这么黑暗的话题还是不要展开了。未来也许是：与AI斗，其乐无穷？</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前一阵子经常看到各种文章说以后人工智能如何如何强大，人类各种失业，要么凄惨，要么极乐，软件开发也无法幸免。那么开挂后未来的软件开发究竟会如何演进？其实我们可以借助传统制造业来推演一下。&lt;br&gt;
    
    </summary>
    
      <category term="idea" scheme="http://qinghua.github.io/categories/idea/"/>
    
    
      <category term="idea" scheme="http://qinghua.github.io/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>Java 11时代，这些编程习惯可以改一改了</title>
    <link href="http://qinghua.github.io/java-11/"/>
    <id>http://qinghua.github.io/java-11/</id>
    <published>2018-10-14T02:12:08.000Z</published>
    <updated>2018-10-17T00:46:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>还在用着Java 8吗？09月26日Oracle的长期支持版Java 11已经出炉，将一直支持到2026年9月。对广大的程序员们来说，从Java 9~11，日常的编码都有什么变化呢？一起来看看吧。<br><a id="more"></a></p>
<h2 id="var关键字"><a href="#var关键字" class="headerlink" title="var关键字"></a>var关键字</h2><p>Java 10引进了<code>var</code>关键字来指代任意类型，让它朝C#又迈进了一步。以下是两个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var abc = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line"><span class="keyword">for</span> (var character : abc) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>var</code>并不仅仅能类型推断，它还能完成以前做不到的事——引用匿名类的变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var o = <span class="keyword">new</span> Object() &#123;</div><div class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</div><div class="line">&#125;;</div><div class="line">System.out.println(o.a);</div></pre></td></tr></table></figure></p>
<p>在所有可能的地方都用上<code>var</code>也许并不是一个好实践。一种做法是：如果后面的表达式一眼就能看出来是啥类型，我们就用<code>var</code>；否则，就还是老老实实地写声明，一眼扫过就能明白的代码更具可读性。</p>
<p>更详细的用法请参考<a href="https://developer.oracle.com/java/jdk-10-local-variable-type-inference" target="_blank" rel="external">Oracle官方文档</a>。Java 11更是<a href="https://bugs.java.com/view_bug.do?bug_id=JDK-8193259" target="_blank" rel="external">允许对lambda的参数使用<code>var</code></a>。</p>
<h2 id="集合字面量"><a href="#集合字面量" class="headerlink" title="集合字面量"></a>集合字面量</h2><p>一直以来我们都是老老实实地用以下这些方法来初始化一个已知的不可变集合：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这样挺方便，就是语义上稍欠优雅</span></div><div class="line">List&lt;String&gt; abc1 = Arrays.asList(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>);</div><div class="line"></div><div class="line"><span class="comment">// 这样构建的是Collection，可以传入可变集合</span></div><div class="line">Collection&lt;String&gt; abc2 = Collections.unmodifiableCollection(abc1);</div><div class="line"></div><div class="line"><span class="comment">// 更优雅的Guava方案</span></div><div class="line">List&lt;String&gt; abc3 = ImmutableList.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>);</div></pre></td></tr></table></figure></p>
<p>可变集合：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 最基本的方法，就是有点长，令人不爽</span></div><div class="line">List&lt;String&gt; abc4 = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">abc4.add(<span class="string">"A"</span>);</div><div class="line">abc4.add(<span class="string">"B"</span>);</div><div class="line">abc4.add(<span class="string">"C"</span>);</div><div class="line"></div><div class="line"><span class="comment">// 构造函数</span></div><div class="line">List&lt;String&gt; abc5 = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>));</div><div class="line"></div><div class="line"><span class="comment">// 匿名内部类</span></div><div class="line">List&lt;String&gt; abc6 = <span class="keyword">new</span> ArrayList&lt;&gt;()&#123;&#123; add(<span class="string">"A"</span>);add(<span class="string">"B"</span>);add(<span class="string">"C"</span>); &#125;&#125;</div><div class="line"></div><div class="line"><span class="comment">// 利用Java 8的Stream</span></div><div class="line">List&lt;String&gt; abc7 = Stream.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>).collect(Collectors.toList());</div><div class="line"></div><div class="line"><span class="comment">// 更优雅的Guava方案</span></div><div class="line">List&lt;String&gt; abc8 = Lists.newArrayList(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>);</div></pre></td></tr></table></figure></p>
<p>对于不可变集合，Java 9引入了集合的工厂方法<code>of</code>，这回终于可以用上原装的了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; abc1 = List.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>);</div><div class="line">Set&lt;String&gt; abc2 = Set.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>);</div><div class="line">Map&lt;String, Integer&gt; abc3 = Map.of(<span class="string">"A"</span>, <span class="number">1</span>, <span class="string">"B"</span>, <span class="number">2</span>, <span class="string">"C"</span>, <span class="number">3</span>);</div><div class="line">Map&lt;String, Integer&gt; abc4 = Map.ofEntries(Map.entry(<span class="string">"A"</span>, <span class="number">1</span>),</div><div class="line">                                          Map.entry(<span class="string">"B"</span>, <span class="number">2</span>),</div><div class="line">                                          Map.entry(<span class="string">"C"</span>, <span class="number">3</span>));</div></pre></td></tr></table></figure></p>
<p>值得注意的是，<code>List</code>不允许通过<code>of</code>传入<code>null</code>，<code>Map</code>不允许传入相同的键。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">List.of(<span class="string">"A"</span>, <span class="keyword">null</span>); <span class="comment">// NullPointerException</span></div><div class="line">Map.of(<span class="string">"A"</span>, <span class="number">1</span>, <span class="string">"A"</span>, <span class="number">2</span>); <span class="comment">// IllegalArgumentException: duplicate key: A</span></div></pre></td></tr></table></figure></p>
<p>Java 10引入了<code>copyOf</code>方法，也能方便地从可变集合中创建出不可变集合：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var abcMutable = <span class="keyword">new</span> ArrayList&lt;&gt;(List.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>))</div><div class="line">var abcImmutable = List.copyOf(abcMutable);</div></pre></td></tr></table></figure></p>
<p>Java 10还在<code>Collectors</code>类中增加了<code>toUnmodifiableList</code>/<code>toUnmodifiableMap</code>/<code>toUnmodifiableSet</code>方法，可以直接从<code>Stream</code>创建一个不可变集合：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; abc = Stream.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>).collect(Collectors.toUnmodifiableList());</div></pre></td></tr></table></figure></p>
<h2 id="Deprecated"><a href="#Deprecated" class="headerlink" title="Deprecated"></a>Deprecated</h2><p>这个相对简单，就是给<code>@Deprecated</code>注解增加了两个字段：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Deprecated</span>(since=<span class="string">"1.1"</span>, forRemoval = <span class="keyword">true</span>)</div></pre></td></tr></table></figure></p>
<p>前者表示从哪个版本起不建议使用，后者表示未来是否会将其删除。</p>
<h2 id="接口的private方法"><a href="#接口的private方法" class="headerlink" title="接口的private方法"></a>接口的private方法</h2><p>从Java 8起，允许给接口增加<code>default</code>方法。从Java 9起，接口又增加了一项能力：可以定义<code>private</code>方法了。示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Dog</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"bowwow"</span>);</div><div class="line">        wagTail();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"walk"</span>);</div><div class="line">        wagTail();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">wagTail</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"wag"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>既然如此，它跟抽象类还有什么区别吗？接口的优势就是允许子类实现多个接口，而抽象类因为可以拥有可变字段（接口的字段是<code>final</code>的）而更为强大。我们在接口定义方法时，也应当让其尽可能简洁。</p>
<h2 id="Optional的新方法"><a href="#Optional的新方法" class="headerlink" title="Optional的新方法"></a>Optional的新方法</h2><p>从Java 9起，<code>Optional</code>终于可以通过<code>stream()</code>方法返回一个<code>Stream</code>了，这样它就可以用上<code>Stream</code>提供的许多API了。原来只能这么做：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Optional&lt;String&gt; optional = Optional.of(<span class="string">"ggg"</span>);</div><div class="line"></div><div class="line"><span class="comment">// java 8</span></div><div class="line">Stream&lt;String&gt; texts = optional.map(Stream::of).orElseGet(Stream::empty);</div><div class="line"></div><div class="line"><span class="comment">// java 9</span></div><div class="line">Stream&lt;String&gt; texts = optional.stream();</div></pre></td></tr></table></figure></p>
<p>另一个可以耍耍的方法是<code>ifPresentOrElse</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// java 8</span></div><div class="line"><span class="keyword">if</span> (optional.isPresent()) &#123;</div><div class="line">    System.out.print(optional.get());</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    System.out.println();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// java 9</span></div><div class="line">optional.ifPresentOrElse(System.out::print, System.out::println);</div></pre></td></tr></table></figure></p>
<p>Java 9还新增了一个方法<code>or</code>，与原来的<code>orElse</code>类似，但是返回的是一个<code>Optional</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// java 8</span></div><div class="line">String name = optional.orElse(<span class="string">"n/a"</span>);</div><div class="line"></div><div class="line"><span class="comment">// java 9</span></div><div class="line">Optional&lt;String&gt; name = optional.or(() -&gt; Optional.of(<span class="string">"n/a"</span>));</div></pre></td></tr></table></figure></p>
<h2 id="HttpClient"><a href="#HttpClient" class="headerlink" title="HttpClient"></a>HttpClient</h2><p>Java 11引进了HttpClient，http请求变得简单了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">HttpClient client = HttpClient.newHttpClient();</div><div class="line">HttpRequest request = HttpRequest.newBuilder().uri(URI.create(uri)).build();</div><div class="line">HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());</div><div class="line"></div><div class="line">System.out.println(response.body());</div></pre></td></tr></table></figure></p>
<p>异步也很简单，返回一个<code>CompletableFuture</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">HttpClient client = HttpClient.newHttpClient();</div><div class="line">HttpRequest request = HttpRequest.newBuilder().uri(URI.create(uri)).build();</div><div class="line">CompletableFuture&lt;Void&gt; futureResponse = client.sendAsync(request, HttpResponse.BodyHandlers.ofString())</div><div class="line">        .thenApply(HttpResponse::body)</div><div class="line">        .thenAccept(System.out::println);</div><div class="line"></div><div class="line">futureResponse.get();</div></pre></td></tr></table></figure></p>
<p>原生的<code>HttpURLConnection</code>可以抛弃了。Apache的<code>HttpClient</code>也许也可以雪藏了。</p>
<h2 id="可过期的CompletableFuture"><a href="#可过期的CompletableFuture" class="headerlink" title="可过期的CompletableFuture"></a>可过期的CompletableFuture</h2><p>上一小节中，我们可以得到一个<code>CompletableFuture</code>。从Java 9起，它可以设置过期时间了。可以把上面的<code>futureResponse.get()</code>替换如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CompletableFuture&lt;Void&gt; timeoutFuture = futureResponse.orTimeout(<span class="number">1</span>, TimeUnit.SECONDS);</div><div class="line">timeoutFuture.get();</div></pre></td></tr></table></figure></p>
<p>如果没有在设置的时间内获得结果，便会抛出<code>java.util.concurrent.ExecutionException: java.util.concurrent.TimeoutException</code>。如果想在过期时不抛异常而是设一个默认值，可以这样做：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CompletableFuture&lt;String&gt; futureResponse = client.sendAsync(request, HttpResponse.BodyHandlers.ofString())</div><div class="line">        .thenApply(HttpResponse::body)</div><div class="line">CompletableFuture&lt;String&gt; timeoutFuture = futureResponse.completeOnTimeout(<span class="string">"default value"</span>, <span class="number">1</span>, TimeUnit.MILLISECONDS);</div><div class="line">timeoutFuture.get();</div></pre></td></tr></table></figure></p>
<h2 id="Process-API"><a href="#Process-API" class="headerlink" title="Process API"></a>Process API</h2><p>Process API是元老级的API了，但是功能一直不够完整，无法获取进程的PID、用户、命令等。Java 9引入了<code>ProcessHandle</code>，可以查询进程，甚至允许在进程退出时执行方法。它提供了获取当前进程的<code>current</code>方法，以及获取全部进程的<code>allProcesses</code>方法。用法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Optional&lt;String&gt; currentUser = ProcessHandle.current().info().user();</div><div class="line">ProcessHandle.allProcesses()</div><div class="line">        .filter(p -&gt; p.info().user().equals(currentUser))</div><div class="line">        .forEach(p -&gt; System.out.println(String.valueOf(p.pid()) + <span class="string">" "</span> + p.info().command()));</div></pre></td></tr></table></figure></p>
<p>如果在Mac中打开了一个<code>TextEdit</code>，便可以看到类似这样的输出结果：<strong>1234 Optional[/Applications/TextEdit.app/Contents/MacOS/TextEdit]</strong>。Windows的话可以打开<code>notepad.exe</code>，也能看到：<strong>1234 Optional[C:\Windows\System32\notepad.exe]</strong>。可以用以下方法在该进程退出时打印一些信息：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Optional&lt;ProcessHandle&gt; optionalProcessHandle = ProcessHandle.of(<span class="number">1234</span>);</div><div class="line">CompletableFuture&lt;Void&gt; future = optionalProcessHandle.get()</div><div class="line">        .onExit().thenAccept(x -&gt; System.out.println(x.pid()));</div><div class="line">future.get();</div></pre></td></tr></table></figure></p>
<p>甚至还能用<code>optionalProcessHandle.get().destroy()</code>来摧毁进程。如此这般，Java外部打开的<code>TextEdit</code>或<code>notepad.exe</code>都会被退出。由于其它用户的进程无法使用<code>ProcessHandle.of</code>来获取，所以只能杀掉自己的进程。对安全方面感兴趣的话可以参考一下<a href="https://docs.oracle.com/en/java/javase/11/core/process-api1.html#GUID-FB7E1852-6C0F-4681-8B35-E2F1ABF483D5" target="_blank" rel="external">官方文档</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;还在用着Java 8吗？09月26日Oracle的长期支持版Java 11已经出炉，将一直支持到2026年9月。对广大的程序员们来说，从Java 9~11，日常的编码都有什么变化呢？一起来看看吧。&lt;br&gt;
    
    </summary>
    
      <category term="development" scheme="http://qinghua.github.io/categories/development/"/>
    
    
      <category term="Java" scheme="http://qinghua.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>手稿秒变html的Sketch 2 Code</title>
    <link href="http://qinghua.github.io/sketch2code/"/>
    <id>http://qinghua.github.io/sketch2code/</id>
    <published>2018-09-12T13:10:58.000Z</published>
    <updated>2018-09-13T00:37:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>可以把手稿变成html的<a href="https://sketch2code.azurewebsites.net/" target="_blank" rel="external">Sketch 2 Code</a>出世了，这是微软在<a href="https://github.com/Microsoft/ailab" target="_blank" rel="external">GitHub上的C#开源代码</a>。听说它能够把前端都凉掉？我很兴奋地尝了尝鲜，写下了这篇小文。咱们来看看它有没有传说中的那么高大上。<br><a id="more"></a></p>
<p>官网上放出来的示例当然是最佳了：<br><img src="/img/sketch-2-code-official.png" alt=""></p>
<p>能有这样的效果那是相当的不错呀，布局、文字、图像都识别得很不错，但也并非完美：</p>
<ol>
<li>布局：PRODUCT CATALOG变成了竖排，搜索按钮也没有对齐</li>
<li>文字：三幅画下面的第一个PRODUCT识别成了RODUCT，最后一个3变成了S。$19.5左边多了一个8</li>
<li>图像：原图上明明有三个段落嘛，html变成了两个</li>
</ol>
<p>那我自己画一幅，用网站提供的TAKE A PICTURE功能上传试试：<br><img src="/img/sketch-2-code-1st-try.png" alt=""></p>
<p>这是什么鬼？敢情什么都没识别出来？是我的画风太清奇了吗？不死心，同一幅图再拍一次：<br><img src="/img/sketch-2-code-2nd-try.png" alt=""></p>
<p>这次有限地成功了，看来位置、方向、大小、光影上的一点点细微差别，也会很大地影响最终的结果。后来又试了几次，最完美的识别也就是上面这幅图了，要我是草图设计师，用这玩意儿还是挺跟它较劲的。倒是处理速度还挺快，几秒之内就能搞定。</p>
<p>接下来试一试中文：<br><img src="/img/sketch-2-code-chinese-try.png" alt=""></p>
<p>果然是不支持中文呀。从下图中我们能看到，尽管中文都能够识别成Lable，但确实对中文的OCR无能为力。<br><img src="/img/sketch-2-code-chinese-analysis.png" alt=""></p>
<p>再试试横线本，看来背景的横线是可以被过滤掉的：<br><img src="/img/sketch-2-code-lines-try.png" alt=""></p>
<p>最后试着参考GitHub的注册首页画一幅手稿：<br><img src="/img/sketch-2-code-github-try.png" alt=""></p>
<p>上面的html是试过几遍之后最好的解析了。生成的html代码中引用了bootstrap的css，所以网页看上去还比较顺眼。但是格式有点乱，有一些连续空行、缩进等问题。不过这些问题相信都很容易解决。最大的问题是目前的实用程度还不太高。想要让前端变凉，数据量应该还不太够（大家多多上传草图吧），而且还应该有不少工作能做。希望它能早日实用化，让前端们投入到更有意义的工作中去。</p>
<p>最终结论：未来很美好，但是现在的实用性还有待提高。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;可以把手稿变成html的&lt;a href=&quot;https://sketch2code.azurewebsites.net/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Sketch 2 Code&lt;/a&gt;出世了，这是微软在&lt;a href=&quot;https://github.com/Microsoft/ailab&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub上的C#开源代码&lt;/a&gt;。听说它能够把前端都凉掉？我很兴奋地尝了尝鲜，写下了这篇小文。咱们来看看它有没有传说中的那么高大上。&lt;br&gt;
    
    </summary>
    
      <category term="tool" scheme="http://qinghua.github.io/categories/tool/"/>
    
    
      <category term="AI" scheme="http://qinghua.github.io/tags/AI/"/>
    
      <category term="OCR" scheme="http://qinghua.github.io/tags/OCR/"/>
    
  </entry>
  
  <entry>
    <title>组合型软件架构</title>
    <link href="http://qinghua.github.io/composable-software-architecture/"/>
    <id>http://qinghua.github.io/composable-software-architecture/</id>
    <published>2018-08-12T02:56:40.000Z</published>
    <updated>2018-08-14T01:20:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>以前玩游戏的时候，总是希望在高手后面看他怎么操作，以提高自己的水平。当时悟出了一个道理：菜鸟看老鸟，只觉得每一步都顺理成章。但是菜鸟自己上时，老鸟却是看得频频摇头。今天这个标题讲的就是这么个理所当然的架构，源于我的同事对当前系统的思考。<br><a id="more"></a></p>
<h2 id="单体系统→微服务→平台"><a href="#单体系统→微服务→平台" class="headerlink" title="单体系统→微服务→平台"></a>单体系统→微服务→平台</h2><p>随着IT的不断发展，软件能解决的问题越来越多也越来越大。在大型软件开发中，人们发现要与一大坨代码共舞变得越来越困难，于是微服务架构兴起并持续火热，许多单体系统也纷纷挤上风口随之演进，不管是新服务单提出去还是老服务逐步拆分，总之他们都渐渐走到分布式系统的大道上了。服务的数量上去了，便带来了一个问题：你的服务跟别人的服务应该如何集成呢？最简单粗暴直截了当的做法就是直接调用。但是这样缺少定制化支持。对方有什么，你可能就只能凑合着用什么。要不，就得等对方把你的需求排上档期。</p>
<p>总这样不行呀，缺胳膊少腿的服务和只能傻傻等待着跟不上节奏的服务没法儿工作呀。为了满足不同客户的多方面需求，服务的平台化就成了一个自然而然的选择。作为平台方，不止提供服务，而且提供客户在平台上的定制化功能，客户成为了平台的租户。一般来说，租户需要在平台那边写点儿为自己的需求而定制的代码或是DSL，以便支持自己的业务场景。</p>
<p>如果你是一个平台的所有者，如何才能让别人在你的平台上顺利安营扎寨，而你无需提供太多的支持工作呢？</p>
<h2 id="构建组合型平台"><a href="#构建组合型平台" class="headerlink" title="构建组合型平台"></a>构建组合型平台</h2><p>首先要问自己一下，你的平台，也就是你拥有的服务，面向的客户是什么人呢？从技术维度上来说，无非是这几类：</p>
<ul>
<li>非技术人员：你的服务只对非技术人员开放，对方想要的是一个大而全的系统，而不希望在不同的服务间来回奔波。以操作系统为例的话，那就是需要一个Windows。</li>
<li>技术人员：你的服务只对技术人员开放，对方想要的是更加灵活，别人的烂代码不要影响到自己的代码。Unix/Linux就是一个典型的例子。</li>
<li>混合型人员：你的服务对技术人员及非技术人员开放，大家各取所需，当然对你的要求也比较高了。举个例子就是OSX。</li>
</ul>
<p>出于简单起见，我们先考虑前两种类型。实际情况是，第一类其实就是许多第二类的聚合。你可能有许多微服务，但是作为网关的微服务其实数量不多。这样，我们便把要解决的大部分平台问题归类于对技术人员开放的服务了。第三类的混合型也很类似。其实对于微服务来说，我根本不在乎对方的实现方式、架构方式，能提供稳定的服务就可以了。但是，一旦它是个平台，并且我需要在其上定制代码，那我也就不得不关心一下了。还是先分两个类：</p>
<ul>
<li>非组合型软件架构：平台代码和租户代码的耦合比较紧，类比的话，就是EJB。平台升级很可能需要租户代码一起改。于是，能不升级就不升级，因为租户很多，升级可能会很繁琐。</li>
<li>组合型软件架构：可能由多种服务组成，对于每种服务而言，SRP是最重要的事，把一件简单的事情做好。其实“简单”是相对而言的，不管内部有多复杂，但是开放出去的接口，或者是允许租户在其中实现的能力，都应该只专注于一件事情。举个例子，亚马逊AWS的S3。作为使用者而言，还是非常简单的。虽然程序员们都知道要维护这样一个服务其实是相当复杂的。这些服务之间是松耦合的，像Linux的管道一样，灵活组合，对外提供平台的能力。</li>
</ul>
<p>如果一个租户的代码挂掉了，从而影响到其他的租户甚至是你的平台，那这个平台就是很有问题的。这句话看起来理所当然，但确实有不少所谓的平台并不是这样设计的。在这种情况下，租户要往这个平台提交代码，就需要接受平台的代码审查，以免待提交的代码影响到其他人。而平台方就不得不耗费人力审查代码、部署代码，当租户的数量多起来时，平台根本就无法提供足够的可伸缩性，势必需要排优先级。于是各种抱怨就纷至沓来，自己的技术人员也苦不堪言。所以，我们希望租户拥有对自己代码的审查和部署的所有权，不希望当租户代码变化时需要平台人员人力审核。</p>
<p>如果你需要开发一个平台，如何能够做到让租户之间不相互影响呢？最佳的租户隔离方式是向租户提供服务级别的隔离。一个租户服务的倒掉不至于影响到其他租户的服务，只是影响已损坏服务的分支业务自己而已（自己的代码挂掉，当然自己承担喽）。如果由于某些原因无法为所有租户都提供服务级别的隔离，那么也可以尝试进程级别的隔离，例如Docker。一个损坏的进程在许多情况下都不太至于影响到平台为其他租户进程提供的服务。如果很不幸的是不得不与租户在同一个进程里，那么起码还可以用DSL来限制租户的能力，让租户的代码不能有太大的破坏性。要是租户也能用平台的语言，还在同一个进程中，那么搞砸平台的服务只是时间问题罢了。</p>
<p>在DevOps的光茫照耀下，我们当然要提倡自动化，这是平台和租户双方的责任。平台提供的是从代码提交到部署测试环境乃至生产环境的自动化能力，而租户需要实现的是自动化测试。一个典型的应用场景就是：平台上的租户代码提交，触发了该租户的持续交付流水线，于是在测试环境上自动部署平台的租户代码，接下来运行租户自己实现的自动化测试，一旦通过，租户便可以决定是否要在平台的生产环境上自动部署这次提交的代码。</p>
<p>最后，作为平台，提供的是能力。不要强迫租户使用你的能力，而要提供稳定的服务，让租户心甘情愿地使用你的能力。向Unix那样，把一个个稳定的服务组合起来，以提供整体的服务；同时，允许租户自由替换其中的某些服务以实现灵活性。能做到这一点的平台就相当成熟了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以前玩游戏的时候，总是希望在高手后面看他怎么操作，以提高自己的水平。当时悟出了一个道理：菜鸟看老鸟，只觉得每一步都顺理成章。但是菜鸟自己上时，老鸟却是看得频频摇头。今天这个标题讲的就是这么个理所当然的架构，源于我的同事对当前系统的思考。&lt;br&gt;
    
    </summary>
    
      <category term="idea" scheme="http://qinghua.github.io/categories/idea/"/>
    
    
      <category term="idea" scheme="http://qinghua.github.io/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>用JaVers比较对象</title>
    <link href="http://qinghua.github.io/javers/"/>
    <id>http://qinghua.github.io/javers/</id>
    <published>2018-07-14T11:57:57.000Z</published>
    <updated>2018-07-14T11:58:43.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://javers.org/" target="_blank" rel="external">JaVers</a>是一个轻量级的对象比较/审计框架，非常易于使用。当前的JaVers版本3是用Java 8编写的，只能运行在JRE 8或以上版本。2.9.2是最后一个和Java 7兼容的版本。源代码<a href="https://github.com/javers/javers" target="_blank" rel="external">在此</a>。<br><a id="more"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>如果你需要实时比较生产环境的处理结果和备份环境的处理结果，或是在新系统中重放生产环境的请求，或者像代码一样对对象进行版本管理，那么JaVers就可以成为你的好朋友。它不仅可以比较对象，也可以将比较结果存储在数据库中以便审计。审计是这样的一种需求：</p>
<blockquote>
<p>作为用户，我希望知道谁改变了状态，<br>是什么时候改变的，以及原先的状态是什么。</p>
</blockquote>
<p>本文仅关注于比较部分，对审计部分就不具体展开了。</p>
<h2 id="快速一览"><a href="#快速一览" class="headerlink" title="快速一览"></a>快速一览</h2><p>新建Maven工程，往pom.xml中增加dependency，最后的pom.xml看起来就像这样：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></div><div class="line">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.ggg.javers<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>helloJaVers<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>helloJaVers<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.javers<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javers-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>25.0-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>假设我们有一个名为<code>Staff</code>的POJO如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ToString</span></div><div class="line"><span class="meta">@Builder</span></div><div class="line"><span class="meta">@Data</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Staff</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">    <span class="keyword">private</span> Double height;</div><div class="line">    <span class="keyword">private</span> BigDecimal salary;</div><div class="line">    <span class="keyword">private</span> Staff manager;</div><div class="line">    <span class="keyword">private</span> List&lt;String&gt; hobbies;</div><div class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; phones;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在<code>main</code>函数中如下编写：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Staff tommy = Staff.builder()</div><div class="line">                   .name(<span class="string">"Tommy"</span>)</div><div class="line">                   .age(<span class="number">18</span>)</div><div class="line">                   .height(<span class="number">180</span>d)</div><div class="line">                   .salary(<span class="keyword">new</span> BigDecimal(<span class="string">"10000"</span>))</div><div class="line">                   .hobbies(Lists.newArrayList(<span class="string">"film"</span>, <span class="string">"game"</span>))</div><div class="line">                   .phones(ImmutableMap.of(<span class="string">"home"</span>, <span class="string">"1234"</span>, <span class="string">"office"</span>, <span class="string">"4321"</span>))</div><div class="line">                   .manager(Staff.builder().name(<span class="string">"ok"</span>).build())</div><div class="line">                   .build();</div><div class="line">Staff ggg = Staff.builder()</div><div class="line">                 .name(<span class="string">"ggg"</span>)</div><div class="line">                 .age(<span class="number">17</span>)</div><div class="line">                 .height(<span class="number">180.000000001</span>d)</div><div class="line">                 .hobbies(Lists.newArrayList(<span class="string">"game"</span>, <span class="string">"music"</span>, <span class="string">"travel"</span>))</div><div class="line">                 .phones(ImmutableMap.of(<span class="string">"mobile"</span>, <span class="string">"4321"</span>, <span class="string">"home"</span>, <span class="string">"1235"</span>))</div><div class="line">                 .manager(Staff.builder().name(<span class="string">"ok"</span>).build())</div><div class="line">                 .build();</div><div class="line"></div><div class="line">Javers javers = JaversBuilder.javers().build();</div><div class="line">Diff diff = javers.compare(tommy, ggg);</div><div class="line">System.out.println(diff);</div></pre></td></tr></table></figure></p>
<p>即可得到以下输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Diff:</div><div class="line">* changes on org.ggg.javers.Staff/ :</div><div class="line">  - &apos;age&apos; changed from &apos;18&apos; to &apos;17&apos;</div><div class="line">  - &apos;height&apos; changed from &apos;180.0&apos; to &apos;180.000000001&apos;</div><div class="line">  - &apos;hobbies&apos; collection changes :</div><div class="line">    0. &apos;film&apos; changed to &apos;game&apos;</div><div class="line">    1. &apos;game&apos; changed to &apos;music&apos;</div><div class="line">    2. &apos;travel&apos; added</div><div class="line">  - &apos;name&apos; changed from &apos;Tommy&apos; to &apos;ggg&apos;</div><div class="line">  - &apos;phones&apos; map changes :</div><div class="line">    &apos;home&apos; -&gt; &apos;1234&apos; changed to &apos;1235&apos;</div><div class="line">    &apos;mobile&apos; -&gt; &apos;4321&apos; added</div><div class="line">    &apos;office&apos; -&gt; &apos;4321&apos; removed</div><div class="line">  - &apos;salary&apos; changed from &apos;10000&apos; to &apos;&apos;</div></pre></td></tr></table></figure></p>
<p>大部分的代码都是我们创建对象所用的，可见JaVers非常易于使用。</p>
<h2 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h2><p>根据DDD，JaVers把要比较的对象分为三种类型：实体（Entity）、值对象（Value Object）和值（Value）。每种类型都有不同的比较方法。值最简单，就是看它们是否是<code>Object.equals()</code>的。实体和值对象都是按属性依次比较。它们俩的区别是实体拥有标识（Entity Id），而值对象并没有。标识不同的实体就会被认为是不同的对象，从而不再继续比较其余的字段。从DDD的角度上严格来说值对象不能单独存在，需要依附于实体。好在JaVers并不教条，值对象也可以用来单独比较。上面的代码其实就是把Staff对象当作值对象来比较。如果我们在<code>Staff</code>类中，给<code>name</code>添加一个<code>@Id</code>的注解（所有的注解都在<code>org.javers.core.metamodel.annotation</code>包里），那么比较结果就会不同：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Diff:</div><div class="line">* new object: org.ggg.javers.Staff/ggg</div><div class="line">* object removed: org.ggg.javers.Staff/Tommy</div></pre></td></tr></table></figure></p>
<p>只有当<code>name</code>属性相同的时候，这两个对象才会被当成同一实体，从而依次比较其余属性。如果没有权限修改实体以增加<code>@Id</code>注解，也可以用这样的方法来注册，效果相同：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Javers javers = JaversBuilder.javers()</div><div class="line">                             .registerEntity(<span class="keyword">new</span> EntityDefinition(Staff.class, <span class="string">"name"</span>))</div><div class="line">                             .build();</div></pre></td></tr></table></figure></p>
<p>如果<code>registerEntity</code>的属性和<code>@Id</code>注解都存在，那么以<code>registerEntity</code>所注册的属性为准。</p>
<p>JaVers完全兼容<a href="http://www.groovy-lang.org/" target="_blank" rel="external">Groovy</a>，可以参考其<a href="https://javers.org/documentation/diff-examples/#groovy-diff-example" target="_blank" rel="external">文档</a>来了解用例。</p>
<h2 id="自定义比较方式"><a href="#自定义比较方式" class="headerlink" title="自定义比较方式"></a>自定义比较方式</h2><h3 id="忽略属性"><a href="#忽略属性" class="headerlink" title="忽略属性"></a>忽略属性</h3><p>从业务上说，有些属性新、旧系统本来就不一样，或者是不关心，这时候我们可以在比较中“忽略”这些属性。如果有权限修改要比较的对象类，可以简单地在属性上面增加一个<code>@DiffIgnores</code>，比较的时候就会将其忽略。<code>@DiffIgnores</code>相当于黑名单，<code>@DiffInclude</code>起到了白名单的效果。如果没有修改类的权限，那么也可以用这样的方法来注册，效果相同：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Javers javers = JaversBuilder.javers()</div><div class="line">                             .registerValueObject(<span class="keyword">new</span> ValueObjectDefinition(Staff.class, Lists.newArrayList(<span class="string">"hobbies"</span>, <span class="string">"phones"</span>)))</div><div class="line">                             .build();</div></pre></td></tr></table></figure></p>
<p>这里我们注册的是个值对象ValueObject，与上一个例子的实体Entity的区别就是有没有标识属性。</p>
<h3 id="比较算法"><a href="#比较算法" class="headerlink" title="比较算法"></a>比较算法</h3><p>一开始细心的读者们就可能注意到了，<code>Lists.newArrayList(&quot;film&quot;, &quot;game&quot;)</code>和<code>Lists.newArrayList(&quot;game&quot;, &quot;music&quot;, &quot;travel&quot;)</code>的比较结果居然是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- &apos;hobbies&apos; collection changes :</div><div class="line">  0. &apos;film&apos; changed to &apos;game&apos;</div><div class="line">  1. &apos;game&apos; changed to &apos;music&apos;</div><div class="line">  2. &apos;travel&apos; added</div></pre></td></tr></table></figure></p>
<p>这当然也是可以配置的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Javers javers = JaversBuilder.javers()</div><div class="line">                             .withListCompareAlgorithm(ListCompareAlgorithm.LEVENSHTEIN_DISTANCE)</div><div class="line">                             .build();</div></pre></td></tr></table></figure></p>
<p>这样的话，结果就变成了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- &apos;hobbies&apos; collection changes :</div><div class="line">  2. &apos;travel&apos; added</div><div class="line">  1. &apos;music&apos; added</div><div class="line">  0. &apos;film&apos; removed</div></pre></td></tr></table></figure></p>
<p>值得注意的是，这种算法在列表元素过多的时候可能会影响性能。</p>
<h3 id="定制比较"><a href="#定制比较" class="headerlink" title="定制比较"></a>定制比较</h3><p>我们可以注册自定义的比较器，例如，如果在业务上认为两个<code>Double</code>类型的<code>1.000000001</code>和<code>1</code>相等，这时候我们可以注册一个如下的类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomDoubleIgnorePrecisionComparator</span> <span class="keyword">implements</span> <span class="title">CustomPropertyComparator</span>&lt;<span class="title">Double</span>, <span class="title">ValueChange</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> DELTA = <span class="number">0.00001</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> ValueChange <span class="title">compare</span><span class="params">(<span class="keyword">final</span> Double left, <span class="keyword">final</span> Double right, <span class="keyword">final</span> GlobalId affectedId, <span class="keyword">final</span> Property property)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">double</span> diff = Math.abs(left - right);</div><div class="line">        <span class="keyword">if</span> (diff &lt;= DELTA) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ValueChange(affectedId, property.getName(), left, right);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>GlobalId</code>是当前比较对象的标识，如值对象的<code>org.ggg.javers.Staff/</code>或是以name为标识的实体的<code>org.ggg.javers.Staff/ggg</code>。<code>Property</code>是当前比较的属性。可以通过这两个值来设置比较属性的黑名单或是白名单。然后注册进JaVers就好了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Javers javers = JaversBuilder.javers()</div><div class="line">                             .registerCustomComparator(<span class="keyword">new</span> CustomDoubleIgnorePrecisionComparator(), Double.class)</div><div class="line">                             .build();</div></pre></td></tr></table></figure></p>
<p>需要注意的是，<code>Double</code>与<code>double</code>是不同的，如果<code>Staff</code>中的<code>height</code>是<code>double</code>类型，那么需要在调用<code>registerCustomComparator</code>时传入<code>double.class</code>。自定义的比较在许多场合都比较有用，比如String类型的不同格式的日期等。</p>
<h3 id="关联字段比较"><a href="#关联字段比较" class="headerlink" title="关联字段比较"></a>关联字段比较</h3><p>关联字段就是说，如果几个字段之间有关联，我们就认为它们一样。比如说我们虚构一个需求：对于一个拥有<code>int x</code>和<code>int y</code>的<code>Rectangle</code>类来说，如果<code>x * y</code>也就是面积相等，我们就认为它们相等。在这种情况下，JaVers似乎并没有原生提供关联字段比较的办法。有一种办法是新建一个包装类，比如说<code>RectangleWrapper</code>，里面有一个<code>Rectangle rectangle</code>和一个<code>int area</code>字段，分别赋值为要比较的对象和其<code>x * y</code>。注册<code>Javers</code>的时候，把<code>Rectangle</code>类的<code>x</code>和<code>y</code>忽略即可。如果有更复杂的需求，例如当面积不同时需要报<code>x</code>和<code>y</code>不同而不是<code>area</code>不同，那也可以通过生成多个<code>Javers</code>对象，并多次调用来解决。<code>Javers#compare</code>方法返回的是一个<code>Diff</code>对象，从中可以很方便地查看某些字段是否存在变化。就是要多写点代码咯。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://javers.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JaVers&lt;/a&gt;是一个轻量级的对象比较/审计框架，非常易于使用。当前的JaVers版本3是用Java 8编写的，只能运行在JRE 8或以上版本。2.9.2是最后一个和Java 7兼容的版本。源代码&lt;a href=&quot;https://github.com/javers/javers&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;在此&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="development" scheme="http://qinghua.github.io/categories/development/"/>
    
    
      <category term="JaVers" scheme="http://qinghua.github.io/tags/JaVers/"/>
    
  </entry>
  
  <entry>
    <title>逆向工作法</title>
    <link href="http://qinghua.github.io/working-backwards/"/>
    <id>http://qinghua.github.io/working-backwards/</id>
    <published>2018-06-22T12:09:58.000Z</published>
    <updated>2018-06-23T02:17:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们经常听到以客户为中心，可是说来容易做来难。“地球上最以客户为中心的公司”亚马逊是怎么做的呢？这可不是喊喊口号就完事了，逆向工作法（Working Backwards）了解一下？<br><a id="more"></a></p>
<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>Working backwards原本的意思是，从最终要解决的事情开始，每次回退一步，直到最初。</p>
<blockquote>
<p><a href="https://mathgeekmama.com/problem-solving-by-working-backwards/" target="_blank" rel="external">Working backwards is to start with the final solution and work back one step at a time to get to the beginning.</a></p>
</blockquote>
<p>在亚马逊，这个概念变得更加具体，成为了如何实现“以客户为中心”的一系列过程。它的产出是三份材料：</p>
<ol>
<li>新闻稿（Press Release，PR）：通过用户的语言描述一个想法，如产品、服务或功能</li>
<li>常见问题解答（Frequently Asked Questions，FAQs）：用户和参与方可能会问的问题</li>
<li>视觉资料（Visuals）：形式多样，有助于大家沟通想法</li>
</ol>
<p>这三份材料在产品的生命周期中，随着一次次的迭代而不断地演进。在<a href="/working-backwards/#准备文档">准备文档</a>一节中，我们会更详细地介绍它们。</p>
<h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><p>为什么要使用逆向工作法？简单来说，因为要“以客户为中心”。逆向工作法是一种行之有效的方法，能够把重点放在客户真正关心的问题上，进而交付用户体验极佳的产品。它是亚马逊成功的关键。</p>
<p>逆向工作法的最终目标就是取悦用户。没错，取悦用户能够带来巨大的价值。对亚马逊来说，它力争成为地球上最以客户为中心的公司，与逆向工作法天然契合。如果你的愿景并非如此，那也不妨看看人家是怎么做的。不过你也需要知道，逆向工作法需要很大的工作量，但是它号称可以节省更多的未来工作量。</p>
<h2 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h2><h3 id="了解用户"><a href="#了解用户" class="headerlink" title="了解用户"></a>了解用户</h3><p>一开始其实跟<a href="https://zh.wikipedia.org/wiki/%E8%85%A6%E5%8A%9B%E6%BF%80%E7%9B%AA%E6%B3%95" target="_blank" rel="external">头脑风暴法（Brainstorming）</a>很像，在打破时间、预算、资源（含技术）等限制的情况下，尽可能发散地提出各种想法。比如Kindle的首要设计理念，就是让用户感觉不到它的存在，从而能够专心读书。它连音乐播放器都没有！之后，亚马逊花了三年时间打造无线和电子屏技术，才推出了这一革命性产品。</p>
<p>你知道你的用户究竟是什么人吗？有一个很典型的答案：所有人都是我的潜在用户。这话倒是没错，但是这个答案对深入了解用户并没有太大的帮助。考虑一些特定用户的情况，如上班族、网络不好的用户、残疾人等等。思考其面对的问题，他们想要的是什么？问问自己，时间、地点和用户的现状会怎样影响其需求？让最终用户受益，是让参与方各个团队通力合作的基础。以后的团队合作开发中，如果大家有分歧，这正是一个大家达成一致的关键。</p>
<p>如果不知道用户要的究竟是什么，那你很可能就是在浪费时间。用户想要的可能是需求，也可能是方案，一定要搞清楚。这两者之间的区别可能非常小。如果你不知道这到底是需求还是方案，那就问问自己：为什么用户需要它？这个问题的答案有可能就是需求。汽车大王福特有一句名言：“如果我当年去问顾客他们想要什么，他们肯定会告诉我：一匹更快的马。这就是典型的方案，而不是需求。如果不考虑用户的需求而直接转向方案，那很可能就会痛失一个改善用户体验的机会。</p>
<blockquote>
<p>“If I had asked people what they wanted, they would have said faster horses.” ― Henry Ford</p>
</blockquote>
<p>需求有时会表现为痛点。例如，用户说他总是不知道中午应该上哪儿吃饭去。那么用户的需求是什么？一个帮他做决定的人？点评网站？外卖app？还是一个骰子？这些都是方案，用户的需求其实只是希望让决定中午上哪儿吃饭这件事变得非常简单自然。</p>
<p>如果你能回答关于用户的这五个问题，那这一步就差不多了：</p>
<ol>
<li>谁是你的用户？</li>
<li>他遇到了什么问题？</li>
<li>他的核心诉求是什么？可能有许多的诉求，但我们只挑一个最核心的需求。</li>
<li>你怎么知道他想要的是什么？搜集数据，让数据说话。</li>
<li>用户体验应该是怎么样的？这个主要是通过视觉资料来展示，我们将在下面的<a href="/working-backwards/#视觉资料">视觉资料</a>一节中再详细探讨。</li>
</ol>
<h3 id="准备文档"><a href="#准备文档" class="headerlink" title="准备文档"></a>准备文档</h3><h4 id="新闻稿"><a href="#新闻稿" class="headerlink" title="新闻稿"></a>新闻稿</h4><p>虽然这里说的新闻稿是内部人员写的内部文档，但是看起来应该跟即将公开发布的新闻稿差不多。市场人员几乎无需修改便可以直接使用。想象用户正在看这篇新闻稿的心理活动，避免使用行业术语，因为用户很可能并不了解这些术语。</p>
<p>写好新闻稿需要花时间，也需要重复地练习。多向别人要反馈吧！今天的一点点改进可能会节省未来花在上面的大量时间。一份好的新闻稿描述了你的想法是什么，以及为什么要这样做。一般一页纸就够了，不要长篇大论。避免模棱两可的词（weasel words），如一些，许多，经常，可能，显然，一般，等等等等。用数据来代替它们吧。</p>
<p>这里有一些关键内容：</p>
<ul>
<li>用户心声（Customer Testimonial）：先写这个部分。虽然它是虚构的，但是要设身处地地为用户着想，以增加可信度。</li>
<li>问题/机会（Problem/Opportunity）：描述一个问题或机会，别夸大。可以这样开头：“用户们以前只能…”</li>
<li>方案（Solution）：描述能够使用户受益的观点。可以这样开头：“现在，用户们可以…”</li>
<li>标题（Headline）：最后写的部分，要求简短有力。</li>
</ul>
<p>请注意，所有的文档都不是固定不变的，它们是一直演进的。把最重要的内容放在第一段。保证其他人哪怕只看了第一段也能对你的想法有所了解。想一想<a href="https://en.wikipedia.org/wiki/Elevator_pitch" target="_blank" rel="external">电梯游说（Elevator pitch）</a>，怎样在很短的时间内表达出你的想法？写文档像写代码一样，要尽量简单。</p>
<h4 id="常见问题解答"><a href="#常见问题解答" class="headerlink" title="常见问题解答"></a>常见问题解答</h4><p>新闻稿描写了愿景，而FAQ提供更详细的说明。FAQ包含了两个部分：客户会问的问题以及内部参与方会问的问题。关于前者，你需要站在客户的角度上，思考其究竟会问出什么样的问题。例如，我怎么参与进去呢？有了问题我应该找谁呢？我要花钱吗？要像回答真正的客户一样来回答这些问题。关于后者，那就是你的老大、兄弟团队或是投资人应该会问的问题。例如，为什么能够提高用户体验呢？如何验证项目是否成功呢？为什么现在是推行的最佳时期？执行计划是什么？越是常见的问题，放在越上面。</p>
<p>别害怕尖锐的问题，都写上吧。比如说什么问题你最不希望被人问到？有没有你还没找到答案的问题？为什么要这样做，而不是那样做？别藏着掖着，都亮出来吧。这样别人才能更容易地看到这个想法的亮点和痛点。对于暂时还是无解的问题，那就诚实地写下：“我不知道。我还在通过XXX来寻找答案”。在寻求反馈的时候，其他人说不定就能够解决这个问题。但是如果不写，我们不但失去了解决它的机会，而且增加了未来的风险。</p>
<h4 id="视觉资料"><a href="#视觉资料" class="headerlink" title="视觉资料"></a>视觉资料</h4><p>视觉资料包括但不限于：白板、<a href="https://en.wikipedia.org/wiki/Storyboard" target="_blank" rel="external">分镜（Storyboard）</a>、<a href="https://zhuanlan.zhihu.com/p/24536517" target="_blank" rel="external">用户体验历程图（Customer Journey Map）</a>、<a href="https://en.wikipedia.org/wiki/Website_wireframe" target="_blank" rel="external">线框图（Wireframe）</a>、<a href="https://www.zhihu.com/question/31609683" target="_blank" rel="external">高保真UI（High-Fidelity UI）</a>、技术架构图（Technical Architecture Diagram）等等。分镜是一系列草图的组合，能够呈现端到端的用户体验。到了后期，还可以引入技术架构图等来描述一个复杂的系统。不用拘泥于形式，任何有助于表达的东西都是我们的工具。</p>
<p>视觉资料可以让我们对用户体验有一个直观的认识。可以的话，让设计师尽早参与吧。一开始手绘即可，不需要那么高保真。不然大家的讨论容易集中在页面风格上，而不是客户体验上。高保真图是随着迭代的更替和讨论的深入而慢慢成型的。选择保真度有一个小窍门：保真度应该跟你的想法成熟度相匹配。越不成型的想法应该采用的视觉资料就应该越低保真。草图是最简单有效的开始。别怕画得难看，它能帮你加深对自己想法的认识。记住，画得好看与否并不是关键，清晰地表达你的想法才是。</p>
<h3 id="提供反馈"><a href="#提供反馈" class="headerlink" title="提供反馈"></a>提供反馈</h3><p>许多会议一开始都是先花个两三盏茶左右的时间来阅读新闻稿和FAQ。与更多取决于演讲者个人魅力的PPT不同，阅读可以让所有人都处在同一起跑线上。提供反馈时，最好直来直往，别拐弯抹角。如果你有些地方看不明白，尽管说出来。别因为自己跟对方的关系而束手束脚，我们对事不对人。另外在这个时候，我们更多地关注在想法本身，而较少对语法错误、错别字挑刺，这一点与代码审查略有不同。代码审查啥都挑，但要是低级错误太多是要打回去重写的。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>我们先前说过，做好这些事情需要时间练习。如果你一时想不出什么点子，上文提过的中午上哪儿吃饭的问题应该怎么解决？亲爱的读者，你有什么想法吗？</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们经常听到以客户为中心，可是说来容易做来难。“地球上最以客户为中心的公司”亚马逊是怎么做的呢？这可不是喊喊口号就完事了，逆向工作法（Working Backwards）了解一下？&lt;br&gt;
    
    </summary>
    
      <category term="idea" scheme="http://qinghua.github.io/categories/idea/"/>
    
    
      <category term="idea" scheme="http://qinghua.github.io/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>挖掘IntelliJ IDEA的调试功能</title>
    <link href="http://qinghua.github.io/intellij-idea-debug/"/>
    <id>http://qinghua.github.io/intellij-idea-debug/</id>
    <published>2018-05-05T02:51:32.000Z</published>
    <updated>2018-05-15T02:23:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了<a href="https://www.jetbrains.com/idea/" target="_blank" rel="external">IntelliJ IDEA</a>的一些相对不那么广为人知，但是又很实用的调试功能。希望能让你的IDE发挥出最大的功效！本文使用的IDEA版本是<code>2018.1</code>社区版，快捷键是<code>Mac OS X</code>。本文的兄弟篇是<a href="/intellij-idea-utilities">挖掘IntelliJ IDEA的实用功能</a>。<br><a id="more"></a></p>
<h2 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h2><h3 id="断点类型"><a href="#断点类型" class="headerlink" title="断点类型"></a>断点类型</h3><p>一般来说调试时，我们都是在代码行上鼠标一点，然后运行测试，遇断点所在的行即停，这就是所谓的行断点。IDEA支持以下几种断点类型：</p>
<ol>
<li>行断点（Line Breakpoints）：就是我们最经常用的方式。</li>
<li>方法断点（Method Breakpoints）：如果你看到代码调用了一个接口，但不知道具体会跑在哪个实现上，便可以在接口上设置断点，这样不管哪个子类运行到这个方法都会停下来。</li>
<li>异常断点（Exception Breakpoints）：可以在<strong>Run</strong> -&gt; <strong>View Breakpoints</strong>中的<strong>Java Exception Breakpoints</strong>里添加异常的具体类型。这样的话，程序中一旦发生了这种异常马上就会停下来。</li>
<li>字段断点（Field Watchpoints）：可以设置在字段上，这样读写字段都可以触发。需要注意的是，默认只有写才会停下，想要让读取时也停下，需要右击断点，在<strong>Watch</strong>的<strong>Field access</strong>上打勾才行。</li>
</ol>
<h3 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h3><p>断点是可以设置条件的，这样便可以只在关心的时候停下来。比如说循环里处理一堆字符串，但是只关心特定的字符串，那条件断点便可以派上用场。按住Shift键设置断点，或是右击断点之后选择<strong>More</strong>来打开以下界面：<br><img src="/img/idea-debug-conditional-breakpoint.jpg" alt=""></p>
<p>上图就是设置条件断点的界面，直接在<strong>Condition</strong>里输入条件即可，如<code>&quot;ggg&quot;.equals(name)</code>。需要注意的是，<strong>Suspend</strong>默认是没有打勾的，必须勾选上才能让程序暂停。另外，辛辛苦苦设置的特定断点，是可以拖拽到别的地方去的，这样就省的到处敲来敲去的了。还有一个小技巧是按住Alt的同时设置断点，可以让断点仅停一次便自动消失。在设置临时断点时有点用。</p>
<h3 id="无断点暂停"><a href="#无断点暂停" class="headerlink" title="无断点暂停"></a>无断点暂停</h3><p>如果在很长的循环时不知道程序运行到哪里了，可以在调试时点击调试窗口上的<strong>Pause Program</strong>，这样程序便能在当前执行的地方暂停。另外，运行到光标（Run to cursor）也可以在没有设置断点的时候让程序运行到光标所在行时暂停。</p>
<h2 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h2><p>下面介绍一些调试的小技巧。</p>
<h3 id="智能进入（Smart-step-into）"><a href="#智能进入（Smart-step-into）" class="headerlink" title="智能进入（Smart step into）"></a>智能进入（Smart step into）</h3><p>当调试程序运行到类似这样的句子时，如果你想看的是<code>actor.action</code>方法，那么进入这个方法就相对麻烦一些。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">actor.action(actionProvider.provide(action.getName()));</div></pre></td></tr></table></figure></p>
<p>这时可以使用调试窗口上的智能进入，程序会弹出一个对话框，我们选择需要的调用处即可。算是一个提升调试效率的小技巧。</p>
<p>官方文档传送门：<a href="https://www.jetbrains.com/help/idea/debugging-code.html#d181035e286" target="_blank" rel="external">https://www.jetbrains.com/help/idea/debugging-code.html#d181035e286</a></p>
<h3 id="表达式评估（Evaluate-expression）"><a href="#表达式评估（Evaluate-expression）" class="headerlink" title="表达式评估（Evaluate expression）"></a>表达式评估（Evaluate expression）</h3><p>这应该是大部分人都知道的技巧了，可以通过表达式评估来重新赋值当前的变量，以便让程序运行到其它的分支去。当然也可以在<strong>Variables</strong>窗口中，右击想要改变的变量，选择<strong>Set Value</strong>。不过表达式评估里可以轻松增加新变量、动态import新类库等，功能更加强大。</p>
<p>官方文档传送门：<a href="https://www.jetbrains.com/help/idea/evaluating-expressions.html" target="_blank" rel="external">https://www.jetbrains.com/help/idea/evaluating-expressions.html</a></p>
<h3 id="远程调试（Remote-debug）"><a href="#远程调试（Remote-debug）" class="headerlink" title="远程调试（Remote debug）"></a>远程调试（Remote debug）</h3><p>如果运行的实例在其它机器（或者虚拟机、docker）上，只要实例设置了以下参数，就可以通过远程调试连接到<code>8000</code>端口进行调试。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-Xdebug -Xrunjdwp:transport=dt_socket,address=8000,server=y,<span class="built_in">suspend</span>=y</div></pre></td></tr></table></figure></p>
<p>官方文档传送门：<a href="https://www.jetbrains.com/help/idea/debugging-code.html#d181035e408" target="_blank" rel="external">https://www.jetbrains.com/help/idea/debugging-code.html#d181035e408</a></p>
<p>对于IDEA来说，只需要在<strong>Run</strong> -&gt; <strong>Edit Configuration</strong>里，增加一个<strong>Remote</strong>，设置主机<strong>Host</strong>和端口<strong>Port</strong>，然后调试它即可。</p>
<h3 id="弃栈帧（Drop-frame）"><a href="#弃栈帧（Drop-frame）" class="headerlink" title="弃栈帧（Drop frame）"></a>弃栈帧（Drop frame）</h3><p>Visual Studio好的一点是调试时可以拖拽当前执行的位置，方便反复查看。虽然IDEA没有这样的功能，但是它可以使用弃栈帧来把当前调用栈的第一栈帧丢弃掉，相当于重新开始当前调试的方法。使用方法也算简单，在要丢弃的栈帧上右击，选择<strong>Drop Frame</strong>即可。或者直接单击调试窗口的<strong>Drop Frame</strong>按钮。不过需要注意的是，如果对象在子方法运行时发生了变化，是不会再变回去的。</p>
<p>官方文档传送门：<a href="https://www.jetbrains.com/help/idea/debugging-code.html#d181035e308" target="_blank" rel="external">https://www.jetbrains.com/help/idea/debugging-code.html#d181035e308</a></p>
<h3 id="强制抛异常（Throw-an-exception）："><a href="#强制抛异常（Throw-an-exception）：" class="headerlink" title="强制抛异常（Throw an exception）："></a>强制抛异常（Throw an exception）：</h3><p>这是IDEA 2018年加入的新功能，可以直接在调试中抛出指定的异常。使用方法跟上面的弃栈帧类似，右击栈帧并选择<strong>Throw Exception</strong>，然后输入如下代码即可：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException()</div></pre></td></tr></table></figure></p>
<p>官方文档传送门：<a href="https://www.jetbrains.com/help/idea/altering-the-program-s-execution-flow.html#throw_exception" target="_blank" rel="external">https://www.jetbrains.com/help/idea/altering-the-program-s-execution-flow.html#throw_exception</a></p>
<h3 id="强制返回（Force-return）："><a href="#强制返回（Force-return）：" class="headerlink" title="强制返回（Force return）："></a>强制返回（Force return）：</h3><p>这是IDEA2015版时增加的功能，类似上面的手动抛异常，只不过是返回一个指定值罢了。使用方法跟上面也都类似，右击栈帧并选择<strong>Force Return</strong>，然后输入要返回的值即可。如果是<code>void</code>的方法那就更简单了，连返回值都不用输。</p>
<p>官方文档传送门：<a href="https://www.jetbrains.com/help/idea/altering-the-program-s-execution-flow.html" target="_blank" rel="external">https://www.jetbrains.com/help/idea/altering-the-program-s-execution-flow.html</a></p>
<h3 id="自动载入变化代码（Reload-changes）"><a href="#自动载入变化代码（Reload-changes）" class="headerlink" title="自动载入变化代码（Reload changes）"></a>自动载入变化代码（Reload changes）</h3><p>利用Java虚拟机提供的HotSwap功能，我们可以做到一边调试一边改代码。只要在修改完代码之后，点击<strong>Run</strong> -&gt; <strong>Reload Changed Classes</strong>即可。不过HotSwap有一些限制，例如不支持static的字段和方法等。</p>
<p>官方文档传送门：<a href="https://www.jetbrains.com/help/idea/altering-the-program-s-execution-flow.html#reload_classes" target="_blank" rel="external">https://www.jetbrains.com/help/idea/altering-the-program-s-execution-flow.html#reload_classes</a></p>
<h3 id="显示方法返回值（Show-method-return-values）"><a href="#显示方法返回值（Show-method-return-values）" class="headerlink" title="显示方法返回值（Show method return values）"></a>显示方法返回值（Show method return values）</h3><p>调试窗口里的<strong>Settings</strong> -&gt; <strong>Show Method Return Values</strong>开关可以显示方法的返回值。例如以下方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">random</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Math.random();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>只要在<code>return</code>上设断点然后<strong>Step Over</strong>，或者在方法内部的任何地方设断点然后<strong>Step Out</strong>一下，便可以在调用处的变量窗口看到一个类似于这样的值：<code>Test.random() = 0.28735657504865864</code>。在这个方法调用没有赋值给变量时（如<code>if (random() &lt; 10)</code>）还挺有用的。</p>
<h3 id="调试流（Trace-Current-Stream-Chain）"><a href="#调试流（Trace-Current-Stream-Chain）" class="headerlink" title="调试流（Trace Current Stream Chain）"></a>调试流（Trace Current Stream Chain）</h3><p>前面说了Visual Studio的好，但是它调试时不能看lambda的值也真是挺恶心的，据说2015版以后开始支持有限的lambda了。IDEA在这方面就做的非常到位。Java 8带来的Stream里面到底是什么，有时候很难知道。通过IDEA提供的这个功能，我们可以很轻松地看到流在各个步骤之间的变化。如下图：<br><img src="/img/idea-debug-lambda.jpg" alt=""></p>
<p>展平模式（Flat Mode）更是提供了全局的视角：<br><img src="/img/idea-debug-lambda-flat-mode.jpg" alt=""></p>
<p>使用这个功能也非常简单，当程序在lambda表达式的任意处停下时，单击调试窗口的<strong>Trace Current Stream Chain</strong>按钮即可。</p>
<p>官方文档传送门：<a href="https://www.jetbrains.com/help/idea/analyze-java-stream-operations.html" target="_blank" rel="external">https://www.jetbrains.com/help/idea/analyze-java-stream-operations.html</a></p>
<h3 id="调试内存泄漏（Memory-View）"><a href="#调试内存泄漏（Memory-View）" class="headerlink" title="调试内存泄漏（Memory View）"></a>调试内存泄漏（Memory View）</h3><p>内存泄漏是一个比较头疼的问题，好在IDEA提供了内存分析工具，只要单击调试窗口右上角的<strong>Restore ‘Memory’ View</strong>就能看到内存窗口，然后点击其中的<strong>Click to load the classes list</strong>就能看到当前内存的对象分布情况。然后可以据此分析到底是哪个类的对象数量看起来有问题。</p>
<p>官方文档传送门：<a href="https://www.jetbrains.com/help/idea/analyze-objects-in-the-jvm-heap.html" target="_blank" rel="external">https://www.jetbrains.com/help/idea/analyze-objects-in-the-jvm-heap.html</a></p>
<h3 id="调试lombok"><a href="#调试lombok" class="headerlink" title="调试lombok"></a>调试lombok</h3><p>如果只是想暂停一下set或get方法，可以使用字段断点，只不过可能会在调试中报错：<strong>Source code does not match the bytecode</strong>，但它能够工作。</p>
<p>如果想设断点的是<code>toString</code>、<code>hashCode</code>等方法，可以在注解上设置断点，也可以在调试时使用：<strong>Refactor</strong> -&gt; <strong>Delombok</strong>并选择相对应的注解，然后再使用上文介绍的HotSwap功能，就可以生成代码并按需调试了。最后别忘记把代码恢复回来。</p>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>调试异步、线程、死锁、活锁等高级功能，官网上面有详细的教程，可以在用到时参考。</p>
<p>官方文档传送门：<a href="https://www.jetbrains.com/help/idea/tutorial-java-debugging-deep-dive.html" target="_blank" rel="external">https://www.jetbrains.com/help/idea/tutorial-java-debugging-deep-dive.html</a></p>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>功能熟悉了以后，熟练使用快捷键能够大幅提高效率。以下是笔者调试时经常使用的快捷键：</p>
<ul>
<li>F7：进入调用的方法</li>
<li>F8：单步运行</li>
<li>F9：继续运行</li>
<li>Shift+F7：智能进入调用的方法</li>
<li>Shift+F8：跳出当前方法</li>
<li>Alt+F8：表达式评估</li>
<li>Alt+F9：运行到光标</li>
<li>Ctrl+Shift+F9：调试当前光标所在方法或类</li>
<li>Ctrl+Shift+F10：运行当前光标所在方法或类</li>
<li>Shift+F9：调试上次运行的测试</li>
<li>Shift+F10：运行上次运行的测试</li>
<li>Command+Shift+T：切换测试和实现</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍了&lt;a href=&quot;https://www.jetbrains.com/idea/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;IntelliJ IDEA&lt;/a&gt;的一些相对不那么广为人知，但是又很实用的调试功能。希望能让你的IDE发挥出最大的功效！本文使用的IDEA版本是&lt;code&gt;2018.1&lt;/code&gt;社区版，快捷键是&lt;code&gt;Mac OS X&lt;/code&gt;。本文的兄弟篇是&lt;a href=&quot;/intellij-idea-utilities&quot;&gt;挖掘IntelliJ IDEA的实用功能&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="tool" scheme="http://qinghua.github.io/categories/tool/"/>
    
    
      <category term="IntelliJ IDEA" scheme="http://qinghua.github.io/tags/IntelliJ-IDEA/"/>
    
  </entry>
  
  <entry>
    <title>软件开发有没有高下</title>
    <link href="http://qinghua.github.io/it-depends/"/>
    <id>http://qinghua.github.io/it-depends/</id>
    <published>2018-04-21T14:23:28.000Z</published>
    <updated>2018-11-06T00:51:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>俗话说“文无第一，武无第二”，软件开发归类于“文”，还是“武”？这个问题本身就有争议。想痛快地吵上一吵吗？进来看看吧。<br><a id="more"></a></p>
<h2 id="大家都来吵"><a href="#大家都来吵" class="headerlink" title="大家都来吵"></a>大家都来吵</h2><p>软件涉及到的领域太广，以至于程序员之间、程序之间很多时候难分伯仲。你可能也经常会听见一些牛逼的程序员们互相吵来吵去，很多时候并不是自己拥有一个完美的解决方案，而是觉得对方的解决方案在特定情况下不好。当然没有十全十美的方案。举个简单的例子，我们奉行的DRY（Don’t Repeat Yourself）原则，要求我们不要WET（Write Everything Twice或者We Enjoy Typing）。可即便是这么通用的原则，也可以被质疑：这样就失去了两边各自变化的能力了。听起来似乎有些道理，但是回头想想，两边各自变化的可能性有多大？这样的可能性在每个人的眼中是不一样的。因为大家的背景不一样，也许某人知道更多的未来需求，也许某人预见业务增长将会很快，也许某人曾经在这上面吃过亏……不一而足。</p>
<p>像DRY这样，但是更加令人难以决断的例子还有很多，列了一些常见的如下：</p>
<ul>
<li><strong>缩进用空格还是TAB？</strong><br><a href="https://stackoverflow.blog/2017/06/15/developers-use-spaces-make-money-use-tabs/" target="_blank" rel="external">据说用空格的程序员收入比用TAB的多</a>，你还打算继续用TAB吗？</li>
<li><strong>Java的变量名要不要默认加final？</strong><br>加上去是有它的好处，但是很烦不是吗？它的价值是否能抵过你的烦恼？这有一个<a href="http://www.javapractices.com/topic/TopicAction.do?Id=23" target="_blank" rel="external">最佳实践</a>，但是否应该采用？</li>
<li><strong>应该测试先行地去TDD，还是补上单元测试就好了？</strong><br>测试驱动开发当然是<a href="http://www.extremeprogramming.org/rules/testfirst.html" target="_blank" rel="external">测试先行</a>，但现实中往往有许多不容易写第一个测试的情况。怎么破？</li>
<li><strong>要不要写注释？</strong><br><a href="https://refactoring.guru/smells/comments" target="_blank" rel="external">重构</a>告诉我们注释很可能是坏味道，应该先尝试重构以让注释变得多余。但就有极端人士认为<a href="https://softwareengineering.stackexchange.com/questions/1/comments-are-a-code-smell" target="_blank" rel="external">所有代码中的注释都是多余</a>的。我们的观点呢？</li>
<li><strong>用不用设计模式？</strong><br>你有没有这样的经历，学完设计模式以后，编程时总想着套到什么地方去？到底应该何时用、怎么用、用多少？</li>
<li><strong>要不要尽量内联（inline）？</strong><br>有一种编程风格是尽量inline所有的变量，除非很不好懂，需要用变量名来解释。例如：<pre><code class="java">String name = someService.getName();
String result = otherService.getResult(name);
<span class="keyword">return</span> result;
</code></pre>
需要重构为：<pre><code class="java"><span class="keyword">return</span> otherService.getResult(someService.getName());
</code></pre>
因为比较简洁嘛。我原来也倾向于使用这种风格。但是新团队的风格是尽量抽变量，理由是方便调试。比如一行中要是出错了呢？调试时要是想知道返回值呢？当然可以查看<code>otherService.getResult(someService.getName())</code>，但是这个操作要是不幂等呢？似乎也有几分道理。</li>
<li><strong>要不要用Java 8的Lambda？</strong><br>曾经有人对我说，最好别用Lambda，因为会的员工不多，不好维护。站在他当时的立场上看，这个理由确实成立。但如果总是这样，新技术岂不是永远都上不了台了？</li>
<li><strong>用异常还是返回值来处理验证逻辑？</strong><br>这也是个比较经典的问题，原来认为<a href="https://stackoverflow.com/questions/299068/how-slow-are-java-exceptions" target="_blank" rel="external">异常影响性能</a>，但随着时代的演进，我们更倾向于<a href="https://stackoverflow.com/questions/4670987/why-is-it-better-to-throw-an-exception-rather-than-return-an-error-code" target="_blank" rel="external">使用异常</a>了。当然<a href="https://softwareengineering.stackexchange.com/questions/184654/ive-been-told-that-exceptions-should-only-be-used-in-exceptional-cases-how-do" target="_blank" rel="external">争论还在继续</a>。</li>
<li><strong>代码覆盖率要不要100%？</strong><br>追求100％的代码覆盖率究竟有没有意义？上80％可能比较轻松，但是最后的20％可能需要付出额外80％的劳动，值得不值得？那么，<a href="https://stackoverflow.com/questions/90002/what-is-a-reasonable-code-coverage-for-unit-tests-and-why" target="_blank" rel="external">代码覆盖率设置为多少比较合理</a>?</li>
<li><strong>要不要结对编程？</strong><br>一人工作一人看，结对编程效率低。但是结对的关键不是效率，而是质量。这又涉及到下面这个问题：</li>
<li><strong>如何衡量软件质量？</strong><br>代码行数、代码覆盖率、缺陷率、圈复杂度……但是它们足够吗？应该如何看待这些值？换个问题，如何衡量软件复杂性？这个问题又涉及到下面的问题：</li>
<li><strong>如何衡量程序员的KPI？</strong><br><a href="https://softwareengineering.stackexchange.com/questions/26596/metric-by-which-to-hold-developers-accountable" target="_blank" rel="external">这很难</a>。只能参考而无绝对。</li>
<li><strong>软件该如何收费？</strong><br>虽然现在看起来有点而离谱，但是很早以前曾经任职的公司确实是按行数收费的，行数＝编写的代码行数＋自动生成的代码×系数（如20％）。更加透明一点的是按工时收费。</li>
<li><strong>可以不用QA吗？</strong><br>曾任职的公司开展过一场“去QA化”运动，现在也不提了。这里的<a href="https://www.zhihu.com/question/19666055/answer/13399364" target="_blank" rel="external">回答</a>很有意思。</li>
<li><strong>是否把修复CI当做第一优先级的事情？</strong><br>这是测试别人是不是了解CI的三个问题之一。当然修复CI的优先级很高。但是有多高呢？我们在实践中是根据具体情况有所取舍的。线上生产环境的问题，才是第一优先级的事情。甚至就连上面这句话有时也不成立。</li>
<li><strong>要不要代码审查？如何审查？</strong><br>大部分人还是认同代码审查的，但是审查方式可以有很多种。最直接的是团队成员都围着电脑看代码，让一个没参与的人来讲解。但是可能费时很多，而且不是所有人都能进入状态，有的人喜欢一起看，有的人喜欢单独看。有一种方式是工具的支持，可以进行一对一的审查，这个可以挖个坑单写一片文章了。</li>
<li><strong>要不要鼓励项目中使用多种技术，比如多种测试框架，版本管理工具等？</strong><br>这里存在着工作效率与提升技能之间的小冲突。使用已经用过的技术当然开发起来更快，但是也是去了尝新的机会，或者说是乐趣。而过量的技术运用到一个项目中，也会带来沉重的负担。</li>
<li><strong>PHP是不是世界上最好的语言？</strong><br>我还是不评论了吧，免得挨揍。</li>
</ul>
<h2 id="底线还得有"><a href="#底线还得有" class="headerlink" title="底线还得有"></a>底线还得有</h2><p>对于永远稳定不会变化的需求（尽管很少，但这样的需求确实存在）而言，软件开发也许就能够分出高下来。举个例子：一个确定不会被重用的小工具。在这种情况下，可以适用的原则是：<strong>越快越好</strong>。我们甚至可以适当允许一些bug的存在，因为修复它们所需的时间可能大于手动修复运行结果所需的时间。另外，永远稳定不会变化的需求真的就永远不会变化吗？未必。但是在开发的某个时间点上，它确实是被认为是永远不会再变化的了。唯一不变的是变化本身。</p>
<p>曾经有同事去印度当了几个月的程序员讲师，回来后告诉我，在回答学员们的问题时，讲师们说得最多的就是这句话：“It depends.”。这基本上是一个放之四海而皆准的原则：<strong>具体情况具体分析</strong>。那是不是所有的问题都直接无脑地“具体情况具体分析”就完了？当然可以，但这是一种思想上的懒，不是我这“懒程序员”的“懒”。因为这句话对解决问题并不能有太多实质上的帮助嘛。关键是，我们还得就着“具体情况”来“分析”。所以，我们可以在其上再构建一些原则，来覆盖特定的情况。</p>
<p>比如说设计模式，它是对特定问题的特定解决方案。不要一股脑儿就往上套，好的经验是在发现坏味道以后，重构到设计模式，甚至是重构了一半，就已经消除掉坏味道了。原则：<strong>越简单越好</strong>。<br>比如说final，它并不能带来明显可观的价值，所以应该以大多数人的习惯为先。原则：<strong>贴近大多数人的习惯</strong>。<br>比如说lambda，明显它是更加先进的生产力，所以上面的原则就不适用了，应该以先进的生产力为先。原则：<strong>采用先进的生产力</strong>。<br>比如说代码覆盖率，高覆盖率自然是好，但是值得吗？比如Java可能就很难做到100％，但JS就能轻松一些。原则：<strong>采用性价比高的方案</strong>。<br>从“代码审查”中我们也可以看到，每个人都是不一样的，我在<a href="/effective-communication">人际风格与有效沟通实战</a>中也曾提到不同风格的人。原则：<strong>因人而异</strong>。<br>从“尽量内联”、“异常或返回值”中我们也可以看到，应该保持开放的心态来调整各原则。原则：<strong>原则需要与时俱进</strong>。<br>比如说要不要写注释，大多数情况下，组织得当的方法名、变量名已经能够说明问题了，这时的注释就显得多余。但偶尔还是需要介绍一块代码的来龙去脉，这时的注释就是必要的。原则：<strong>具体情况具体分析</strong>。</p>
<p>我们现在已经有了好几条原则了：</p>
<ul>
<li><strong>越快越好</strong></li>
<li><strong>越简单越好</strong></li>
<li><strong>贴近大多数人的习惯</strong></li>
<li><strong>采用先进的生产力</strong></li>
<li><strong>采用性价比高的方案</strong></li>
<li><strong>因人而异</strong></li>
<li><strong>原则需要与时俱进</strong></li>
<li><strong>具体情况具体分析</strong></li>
</ul>
<p>有些原则可能在特定的情况下是冲突的，需要自己思考究竟哪条原则更加符合现实情况。在适当的时候使用适当的原则（就像设计模式一样），而不是拿着锤子看见啥都像钉子（也像设计模式一样）。另外，需求是变化的，我们的原则也不必一成不变。有句话说“规则是用来打破的”。我想说的是，在充分理解规则之后，再来决定是不是打破它，并承担相应的后果。或者，考虑是不是用更高级的规则（如“具体情况具体分析”）来约束它，或是用更低级的规则来覆盖它吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;俗话说“文无第一，武无第二”，软件开发归类于“文”，还是“武”？这个问题本身就有争议。想痛快地吵上一吵吗？进来看看吧。&lt;br&gt;
    
    </summary>
    
      <category term="idea" scheme="http://qinghua.github.io/categories/idea/"/>
    
    
      <category term="idea" scheme="http://qinghua.github.io/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>挖掘IntelliJ IDEA的实用功能</title>
    <link href="http://qinghua.github.io/intellij-idea-utilities/"/>
    <id>http://qinghua.github.io/intellij-idea-utilities/</id>
    <published>2018-03-03T05:52:49.000Z</published>
    <updated>2018-05-04T00:42:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了<a href="https://www.jetbrains.com/idea/" target="_blank" rel="external">IntelliJ IDEA</a>的一些相对不那么广为人知的实用功能。希望能让你的IDE发挥出最大的功效！本文使用的IDEA版本是<code>2017.2.6</code>社区版，快捷键是<code>Mac OS X</code>。本文的兄弟篇是<a href="/intellij-idea-debug">挖掘IntelliJ IDEA的调试功能</a>。<br><a id="more"></a></p>
<h2 id="多重选择"><a href="#多重选择" class="headerlink" title="多重选择"></a>多重选择</h2><p>Sublime Text有一个非常好用的功能，就是可以选择多个光标，允许一起编辑。IDEA也向其学习，提供了类似的功能。只要按住<strong>Alt+Shift</strong>时，用鼠标点击其它位置即可。还可以通过<strong>Ctrl+G</strong>选择下一个相同的字符串，或是<strong>Ctrl+Command+G</strong>选择所有相同的字符串。如下图：<br><img src="/img/idea-multiple-selections.png" alt=""></p>
<p>还有一个功能是纵向选择，可以通过<strong>Command+Shift+8</strong>来开关。之后的效果如下：<br><img src="/img/idea-column-selection.png" alt=""></p>
<p>有一个注意事项就是，多重选择的时候不要用IDE自带的重构功能。</p>
<p>官方文档传送门：<a href="https://www.jetbrains.com/help/idea/editor-basics.html#editor_lines_code_blocks" target="_blank" rel="external">https://www.jetbrains.com/help/idea/editor-basics.html#editor_lines_code_blocks</a></p>
<h2 id="文件比较器"><a href="#文件比较器" class="headerlink" title="文件比较器"></a>文件比较器</h2><p>比较两个项目中的文件很简单，选中这两个文件，然后<strong>Command+D</strong>就可以了。JAR文件、文件夹也能够进行比较：<br><img src="/img/idea-compare-folders.png" alt=""></p>
<p>如果只有一个文件在项目中，那就选中它，然后<strong>Command+D</strong>，再从对话框中打开项目外的文件即可。如果另一个文件在剪贴板，那就打开项目中的文件，然后右击编辑器选择<strong>Compare with Clipboard</strong>即可。</p>
<p>如果两个文件都不在项目中……那好歹复制一个进去呗。</p>
<p>官方文档传送门：<a href="https://www.jetbrains.com/help/idea/comparing-files.html" target="_blank" rel="external">https://www.jetbrains.com/help/idea/comparing-files.html</a></p>
<h2 id="正则校验器"><a href="#正则校验器" class="headerlink" title="正则校验器"></a>正则校验器</h2><p>如果你写了个（或搜了个）炫酷的正则表达式，除了单元测试，IDEA也提供了简便的测试方式。比如对于如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Pattern EMAIL_PATTERN = Pattern.compile(<span class="string">"^([a-zA-Z0-9_\\-\\.]+)@([a-zA-Z0-9_\\-\\.]+)\\.([a-zA-Z]&#123;2,5&#125;)$"</span>);</div></pre></td></tr></table></figure></p>
<p>在正则的字符串中按下<strong>Alt+Enter</strong>，选择<strong>Check RegExp</strong>，然后填入想校验的字符串即可：<br><img src="/img/idea-check-regexp.png" alt=""></p>
<p>官方文档传送门：<a href="https://www.jetbrains.com/help/idea/regular-expression-syntax-reference.html#tips-tricks" target="_blank" rel="external">https://www.jetbrains.com/help/idea/regular-expression-syntax-reference.html#tips-tricks</a></p>
<h2 id="Emmet"><a href="#Emmet" class="headerlink" title="Emmet"></a>Emmet</h2><p>还在写这样的html吗？早就out了……<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">id</span>=<span class="string">"users"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">tr</span> <span class="attr">class</span>=<span class="string">"user"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>只要输入<code>table#users&gt;tr.user&gt;td*3</code>然后按下<strong>TAB</strong>就行了。能自动生成的，我们就不自己写。不过这个功能只在后缀名为<code>html</code>或<code>xml</code>的文件编辑器中生效，所以创建一个html文件然后再试试吧。</p>
<p>这里有一张Emmet的语法表：<a href="https://docs.emmet.io/cheat-sheet/" target="_blank" rel="external">https://docs.emmet.io/cheat-sheet/</a></p>
<p>官方文档传送门：<a href="https://www.jetbrains.com/help/idea/emmet.html" target="_blank" rel="external">https://www.jetbrains.com/help/idea/emmet.html</a></p>
<h2 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h2><p>如果你看到这样的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> name + <span class="string">" is "</span> + age + <span class="string">" years old."</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>就会忍不住想把它变成这样的话：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> StringBuilder().append(name)</div><div class="line">                          .append(<span class="string">" is "</span>)</div><div class="line">                          .append(age)</div><div class="line">                          .append(<span class="string">" years old."</span>)</div><div class="line">                          .toString();</div></pre></td></tr></table></figure></p>
<p>只要在等号后面的语句中按下<strong>Alt+Enter</strong>，选择<strong>Replace ‘+’ with ‘StringBuilder.append()’</strong>即可。也可以选择<strong>Replace ‘+’ with ‘String.format()’</strong>，来把它变成这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> String.format(<span class="string">"%s is %d years old."</span>, name, age);</div></pre></td></tr></table></figure></p>
<p>所以当你准备拼接字符串了，考虑这个功能吧，比自己慢慢写要顺手多了。其实<strong>Alt+Enter</strong>这个万能快捷键在不同的代码下支持许多不同的功能，没事在代码上随便敲一敲，你会发现惊喜的。</p>
<h2 id="本地历史"><a href="#本地历史" class="headerlink" title="本地历史"></a>本地历史</h2><p>通过<strong>VCS</strong>菜单中，<strong>Local History</strong>的<strong>Show History</strong>，可以打开当前文件的本地修改历史。如果某个版本你并没有提交过，只是在本地曾经改过，但是又改掉了，就可以利用这个功能将其找回。甚至还可以针对字段、方法、文件夹、乃至整个项目来查看。所以保存量是比较大的，IDEA默认就保留五个工作日的本地历史，有一周一般来说也就够了吧。这个值也能通过传给JVM的参数<code>localHistory.daysToKeep</code>来修改。如果因为磁盘不够等原因不想要，也可以把它设置为0。<br><img src="/img/idea-local-history.png" alt=""></p>
<p>官方文档传送门：<a href="https://www.jetbrains.com/help/idea/local-history.html" target="_blank" rel="external">https://www.jetbrains.com/help/idea/local-history.html</a></p>
<h2 id="测试覆盖率"><a href="#测试覆盖率" class="headerlink" title="测试覆盖率"></a>测试覆盖率</h2><p>通过<strong>Run</strong>菜单里的<strong>Run ‘xxxTest’ with Coverage</strong>，可以在运行测试时顺便跑出测试覆盖率。通过<strong>Analyze</strong>菜单里的<strong>Show Coverage Data</strong>，可以查看覆盖率的大致情况。而通过<strong>Generate Coverage Report</strong>，可以生成测试报告，在报告里可以看到具体的每一行是否运行过。这是覆盖率数据：<br><img src="/img/idea-coverage-data.png" alt=""></p>
<p>这是测试报告：<br><img src="/img/idea-coverage-report.png" alt=""></p>
<p>官方文档传送门：<a href="https://www.jetbrains.com/help/idea/viewing-code-coverage-results.html" target="_blank" rel="external">https://www.jetbrains.com/help/idea/viewing-code-coverage-results.html</a></p>
<h2 id="生产力指南"><a href="#生产力指南" class="headerlink" title="生产力指南"></a>生产力指南</h2><p>点击<strong>Help</strong>菜单里的<strong>Productivity Guide</strong>，就能看到一张大表，记录着各功能的使用情况。注意一下使用频率低的，了解一下从未使用过的，很快就能成为Intellij IDEA的砖家了。<br><img src="/img/idea-productivity-guide.png" alt=""></p>
<p>官方文档传送门：<a href="https://www.jetbrains.com/help/idea/productivity-guide.html" target="_blank" rel="external">https://www.jetbrains.com/help/idea/productivity-guide.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍了&lt;a href=&quot;https://www.jetbrains.com/idea/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;IntelliJ IDEA&lt;/a&gt;的一些相对不那么广为人知的实用功能。希望能让你的IDE发挥出最大的功效！本文使用的IDEA版本是&lt;code&gt;2017.2.6&lt;/code&gt;社区版，快捷键是&lt;code&gt;Mac OS X&lt;/code&gt;。本文的兄弟篇是&lt;a href=&quot;/intellij-idea-debug&quot;&gt;挖掘IntelliJ IDEA的调试功能&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="tool" scheme="http://qinghua.github.io/categories/tool/"/>
    
    
      <category term="IntelliJ IDEA" scheme="http://qinghua.github.io/tags/IntelliJ-IDEA/"/>
    
  </entry>
  
  <entry>
    <title>敲最少的键，编最多的码</title>
    <link href="http://qinghua.github.io/type-less-code-more/"/>
    <id>http://qinghua.github.io/type-less-code-more/</id>
    <published>2018-02-04T05:42:53.000Z</published>
    <updated>2018-03-03T06:28:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道在软件开发中，效率是很重要的环节。结对编程时，有些手快的人想到哪里就能编到哪里，恨不得分分钟从手慢的人那儿把键盘抢过来。今天的这篇文章主要是如何用好<a href="https://www.jetbrains.com/idea/" target="_blank" rel="external">IntelliJ IDEA</a>这个著名的IDE，以实现：“敲最少的键，编最多的码”。虽说本文的示例是Java，其它语言区别也不大，尤其是当现在的<a href="https://www.jetbrains.com/products.html" target="_blank" rel="external">JET BRAINS全家桶</a>已经是如此齐备时。<br><a id="more"></a></p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>废话不多说，在环境准备好的情况下，假设我们来测试驱动开发一个计算一天有多少个小时的API。参见以下的两分半小视频：</p>
<iframe frameborder="0" width="640" height="498" src="https://v.qq.com/iframe/player.html?vid=s0545lt9r2e&tiny=0&auto=0" allowfullscreen></iframe>

<p>要是视频不清晰或看不到，就直接到<a href="https://v.qq.com/x/page/s0545lt9r2e.html" target="_blank" rel="external">腾讯视频</a>中看720P吧。</p>
<p>如何才能做到”敲最少的键，编最多的码“呢？除了掌握技巧之外，就是多练习实践了。以下就是技巧的内容。</p>
<h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><p>首先把环境准备一下。只要有<code>src</code>和<code>test</code>即可。我自己是一个默认的Maven新项目，在<code>pom</code>中引用了<code>junit</code>。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"> &lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></div><div class="line">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.ggg<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ggg<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>专业版的IDEA支持项目模板，如果你对默认的模板不满意，项目模板能够节省你的一部分操作。</p>
<h2 id="步骤分解"><a href="#步骤分解" class="headerlink" title="步骤分解"></a>步骤分解</h2><ol>
<li>快捷键：在<code>test/java</code>中用快捷键<strong>Ctrl+N</strong>生成文件。</li>
<li>文件模版：选择的<code>JUnit</code>正是我事先创建好的文件模板，内容见下文的“功能简介”。这里的一个小诀窍是先按下<strong>u</strong>，可以过滤掉不需要的模板。</li>
<li>输入：输入<code>HoursCalculatorTest</code>并回车，测试文件就此生成。</li>
<li>代码自动生成：移动光标到合适位置，用快捷键<strong>Ctrl+N</strong>自动生成<strong>Test Method</strong>。</li>
<li>输入：将测试方法命名为<code>should_get_24_hours_for_1_day</code>。</li>
<li>输入：这里需要新建一个测试目标，即<code>new HoursCalculator()</code>。</li>
<li>快捷键：因为<code>HoursCalculator</code>类还不存在，所以会报错，用快捷键<strong>F2</strong>移动到下一个错误处，再用快捷键<strong>Alt+Enter</strong>自动修复错误，选择<strong>Create class ‘HoursCalculator’</strong>。</li>
<li>代码自动生成：输入<code>org.ggg</code>自动生成<code>HoursCalculator</code>类。</li>
<li>快捷键：<strong>Ctrl+Tab</strong>回到上一个文件即我们的测试类。<strong>Command+Alt+V</strong>将<code>new HoursCalculator()</code>抽取为一个变量<code>hoursCalculator</code>，<strong>Command+Shift+Enter</strong>结束本行，将光标跳至下一行开头。</li>
<li>输入：输入<code>int hoursByDay = hoursCalculator.getHoursByDay(1)</code>来获取计算结果。小诀窍是只要输入<code>hc</code>，IDEA就会提示<code>hoursCalculator</code>。</li>
<li>代码自动生成：还是<strong>Alt+Enter</strong>自动修复错误，选择<strong>Create method ‘getHoursByDay’</strong>，便能在<code>HoursCalculator</code>类中自动生成<code>getHoursByDay</code>方法。</li>
<li>输入：一路回车，可以把参数名改为<code>days</code>。</li>
<li>快捷键：还是<strong>Ctrl+Tab</strong>回到测试类，然后<strong>Command+Shift+Enter</strong>结束本行（分号会自动补齐）。</li>
<li>输入：输入<code>assertEquals(24,hoursByDay)</code>，还是<strong>Command+Shift+Enter</strong>结束本行（还会调整格式）。</li>
<li>快捷键：<strong>Ctrl+Shift+F10</strong>运行测试，红了。用<strong>Ctrl+Tab</strong>回到<code>HoursCalculator</code>类准备修改实现。</li>
<li>输入：把返回值从<code>0</code>改为<code>24</code>。</li>
<li>快捷键：<strong>Shift+F10</strong>运行上个测试，这回绿了。用<strong>Ctrl+Tab</strong>回到我们的测试类，准备编写下一个测试。</li>
<li>活动模板：将光标移动到合适的位置，输入<strong>test</strong>和<strong>TAB</strong>键。可以看到生成了另一个测试方法。当然我们在此也可以用上面的“代码自动生成”，这里不过是用了另一种方法而已。<code>test</code>是我事先创建好的活动模板，内容见下文的“功能简介”。</li>
<li>输入：将方法命名为<code>should_get_48_hours_for_2_days</code>。之后按照类似上文的方式，实现并执行测试，红了。令方法返回<code>24 * day</code>并再次执行测试，绿了。移动光标到测试方法之外，执行全部测试，都绿了，保证后一个实现不会破坏前一个实现。</li>
<li>快捷键：现在是tdd的重构阶段。<code>24</code>是一个magic number，所以我们要用<strong>Command+Alt+C</strong>将其变成一个常量，如<code>hoursInDay</code>。不过常量应该还是大写的蛇式比较符合惯例，于是可以<strong>Shift+F6</strong>改名。</li>
<li>插件：我事先安装了<strong>string-manipulation</strong>插件，所以可以直接使用快捷键<strong>Alt+M</strong>并选择<strong>4. To SCREAMING_SNAKE_CASE</strong>将变量改名为<code>HOURS_IN_DAY</code>。其实现在版本的IDEA已经会在快捷键改名时提示<code>HOURS_IN_DAY</code>了，但是插件支持的功能更加丰富一些，并且也能在编辑非java文件时使用。</li>
<li>快捷键：用<strong>Shift+F10</strong>运行上次运行的全部测试，依然是绿的。</li>
<li>快捷键：测试文件还不在包中，用<strong>F6</strong>将其移入<code>org.ggg</code>中。还可以用<strong>Command+Alt+O</strong>来优化import部分。</li>
<li>快捷键：再次用<strong>Shift+F10</strong>运行测试，依然是绿的，重构完成。</li>
</ol>
<h2 id="用到的IDE功能简介"><a href="#用到的IDE功能简介" class="headerlink" title="用到的IDE功能简介"></a>用到的IDE功能简介</h2><h3 id="快捷键（Shortcuts）"><a href="#快捷键（Shortcuts）" class="headerlink" title="快捷键（Shortcuts）"></a>快捷键（<a href="https://resources.jetbrains.com/storage/products/intellij-idea/docs/IntelliJIDEA_ReferenceCard.pdf" target="_blank" rel="external">Shortcuts</a>）</h3><p>我用的是<strong>Mac OS X</strong>的Keymap。常用的快捷键要牢记，很多时候它决定了程序员的效率如何。JET BRAINS的各种语言的IDE快捷键都比较类似，花点精力记住它决不会吃亏。</p>
<h3 id="文件模板（File-Templates）"><a href="#文件模板（File-Templates）" class="headerlink" title="文件模板（File Templates）"></a>文件模板（<a href="https://www.jetbrains.com/help/idea/file-and-code-templates.html" target="_blank" rel="external">File Templates</a>）</h3><p>顾名思义，文件模板即是新建文件时使用到的模板。我们在上面的步骤中使用的<code>JUnit</code>活动模板如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#if ($&#123;PACKAGE_NAME&#125; &amp;&amp; $&#123;PACKAGE_NAME&#125; != "")package $&#123;PACKAGE_NAME&#125;;#end</div><div class="line"></div><div class="line">import org.junit.Test;</div><div class="line"></div><div class="line">import static org.junit.Assert.*;</div><div class="line">#parse("File Header.java")</div><div class="line">public class $&#123;NAME&#125; &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它的语法基于<a href="http://velocity.apache.org/engine/devel/user-guide.html#Velocity_Template_Language_VTL:_An_Introduction" target="_blank" rel="external">Apache Velocity</a>，支持变量，如<code>${PACKAGE_NAME}</code>表示包名，<code>${NAME}</code>表示用户输入的名称，等等。</p>
<p>可以通过在<strong>Preferences</strong>中搜索<strong>File and Code Templates</strong>，来创建或修改文件模板。也可以在一开始<strong>Ctrl+N</strong>时选择<strong>Edit File Templates…</strong>。</p>
<h3 id="活动模板（Live-Templates）"><a href="#活动模板（Live-Templates）" class="headerlink" title="活动模板（Live Templates）"></a>活动模板（<a href="https://www.jetbrains.com/help/idea/live-templates.html" target="_blank" rel="external">Live Templates</a>）</h3><p>活动模板与文件模板类似，但它不需要新建文件，可以在文件的任何地方激活，只需要输入名字后加一个<strong>TAB</strong>即可。我们在上面的步骤中使用的<code>test</code>活动模板如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> $NAME$() &#123;</div><div class="line">    $END$</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中的<code>$END$</code>表示最后光标会出现在哪里。在此，表示光标最后会出现在方法体内，以便于继续编写实现。</p>
<p>可以通过在<strong>Preferences</strong>中搜索<strong>Live Templates</strong>，来创建或修改活动模板。</p>
<h3 id="代码自动生成（Generating-Code）"><a href="#代码自动生成（Generating-Code）" class="headerlink" title="代码自动生成（Generating Code）"></a>代码自动生成（<a href="https://www.jetbrains.com/help/idea/generating-code.html" target="_blank" rel="external">Generating Code</a>）</h3><p>有许多常用的代码，例如getter、setter、constructor、equals&amp;hashCode等等，IDEA都能够通过这个功能帮助自动生成。</p>
<p>我们在上面的步骤中使用了<strong>Ctrl+N</strong>生成了junit的测试方法，用<strong>Alt+Enter</strong>通过修复错误的方式来生成类和方法。</p>
<h3 id="插件（Plugins）"><a href="#插件（Plugins）" class="headerlink" title="插件（Plugins）"></a>插件（<a href="https://www.jetbrains.com/help/idea/managing-plugins.html" target="_blank" rel="external">Plugins</a>）</h3><p>IDEA支持<a href="https://plugins.jetbrains.com/idea_ce" target="_blank" rel="external">许多插件</a>。插件的功能强大，能够做到从修改字符串到语言级别的支持。比如我们用的版本控制系统VCS就是用插件的方式开发的。</p>
<p>我们在上面的步骤中使用了<a href="https://plugins.jetbrains.com/plugin/2162-string-manipulation" target="_blank" rel="external"><strong>string-manipulation</strong>插件</a>。安装完插件，别忘了重启IntelliJ IDEA。你也可以<a href="https://www.jetbrains.com/help/idea/creating-a-project-for-plugin-development.html" target="_blank" rel="external">编写自己的插件</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道在软件开发中，效率是很重要的环节。结对编程时，有些手快的人想到哪里就能编到哪里，恨不得分分钟从手慢的人那儿把键盘抢过来。今天的这篇文章主要是如何用好&lt;a href=&quot;https://www.jetbrains.com/idea/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;IntelliJ IDEA&lt;/a&gt;这个著名的IDE，以实现：“敲最少的键，编最多的码”。虽说本文的示例是Java，其它语言区别也不大，尤其是当现在的&lt;a href=&quot;https://www.jetbrains.com/products.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JET BRAINS全家桶&lt;/a&gt;已经是如此齐备时。&lt;br&gt;
    
    </summary>
    
      <category term="tool" scheme="http://qinghua.github.io/categories/tool/"/>
    
    
      <category term="IntelliJ IDEA" scheme="http://qinghua.github.io/tags/IntelliJ-IDEA/"/>
    
      <category term="TDD" scheme="http://qinghua.github.io/tags/TDD/"/>
    
  </entry>
  
  <entry>
    <title>个人的技术债</title>
    <link href="http://qinghua.github.io/personal-tech-debt/"/>
    <id>http://qinghua.github.io/personal-tech-debt/</id>
    <published>2018-01-01T03:12:13.000Z</published>
    <updated>2018-01-01T07:01:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zh.wikipedia.org/wiki/%E6%8A%80%E6%9C%AF%E8%B4%9F%E5%80%BA" target="_blank" rel="external">技术债</a>是一个借用了财务债的绝妙隐喻（<a href="http://www.extremeprogramming.org/rules/metaphor.html" target="_blank" rel="external">极限编程XP的实践</a>之一），表示当我们为了短期利益（如按时完成开发），而在技术上对软件的长期质量进行的妥协。它一般用于项目管理，但其实也广泛地存在于各个地方，比如每个人的身上。<br><a id="more"></a></p>
<h2 id="项目的技术债"><a href="#项目的技术债" class="headerlink" title="项目的技术债"></a>项目的技术债</h2><p>技术债的起源和后果、解决方式等，网上一搜一大把，我这里就不再赘述了。这里总结一点常见的误区：</p>
<ul>
<li>技术债是邪恶的：这里借用维基百科的一小段话：“第一次发布代码，就好比借了一笔钱。只要通过不断重写来偿还债务，小额负债可以加速开发。但久未偿还债务会引发危险。复用马马虎虎的代码，类似于负债的利息”。健康的债务是好事，谁买房子不贷款（土豪请随意）？</li>
<li>技术债必须偿还：有时候你写一段小程序，只希望尽快跑起来看看，然后将之抛弃。程序由于没有重构，而充斥着各种反模式（它们都是技术债！）。我自己就写了不少，用毕即弃。这里面的债……反正我自己是没有兴趣也没有时间偿还。有些项目的代码，你知道永远也不会有人会动（当然这个很主观，并且取决于你的经验），或者是很快就要完蛋的，我也倾向于先不还这个债，真的到了出现万一的时候，那就再还吧。还债是有成本的，如果感觉还债成本将要上升，也许就应该还这个债了。有没有一种lazy的感觉？</li>
<li>开发新功能优先于偿还技术债：这是一个it depends的问题，谁高谁低取决于对债和利息的判断及不同角色间的博弈。如果利息趋近于零，当然可以先不考虑还债；如果新功能的投资预期带来大把的收益，当然可以先开发新功能。</li>
<li>技术债可以避免：如果这样的话，只要没有新功能，就永远不必发新版本了。没有完美的人，没有完美的程序。别想躲开它，想想怎么处理它。</li>
</ul>
<h2 id="个人的技术债"><a href="#个人的技术债" class="headerlink" title="个人的技术债"></a>个人的技术债</h2><p>Martin Fowler把<a href="https://martinfowler.com/bliki/TechnicalDebt.html" target="_blank" rel="external">技术债</a>分为<a href="https://martinfowler.com/bliki/TechnicalDebtQuadrant.html" target="_blank" rel="external">四个象限</a>，如下图所示：<br><img src="/img/tech-debt-quadrant.png" alt=""></p>
<p>项目在不断前进，做项目的人也是不断前进的。项目需要还债来让自己运转良好，人不也一样需要还债让自己进步吗？参考上图，我也画了张个人的技术债四象限，如下图所示：<br><img src="/img/personal-tech-debt-quadrant.png" alt=""></p>
<p>这四个象限不都是技术债的源头吗？下面我们来具体分析一下每一个象限：</p>
<p><strong>有意的－慎重的：清理</strong>。例如，我知道项目上需要用到drools，它对未来的项目可能会很有用，可惜当时没条件深入学习。又或者项目上用到了JJTree，它有些过时了，以后也基本用不上，不需要浪费时间在这上面。这是两个不同的例子，因为你是有意地做出了选择，所以凭你的经验来决定吧，是否应该把它放到你的个人技术债上。<br><strong>有意的－草率的：思考</strong>。例如，当时工作太忙，虽然知道docker能够解决这个问题，但没时间去学，至于项目嘛，凑合能用就好了。现在回头想想，还能凑合吗？因为草率，所以需要思考；因为有意，所以还要选择。是否放入你的个人技术债，你自己决定吧。<br><strong>无心的－慎重的：复盘</strong>。例如，当时不知道其实AWS可以满足项目的需求，但是现在知道了，很可能用AWS可以节省一大部分的开发和运维成本，但也可能有坑。在这种情况下，我们可以做一次复盘，如果项目再来一遍应该怎样？把收获到的经验用到下一个项目中吧。<br><strong>无心的－草率的：求知</strong>。例如，我并不知道前端技术大爆炸有那么多的框架可选，现在我也不太了解，反正有活儿我就上JQuery。用一句绕口的话总结就是：不知道自己不知道什么。如果是这样，那么就应该先高层次地了解一下背景知识，起码让自己不至于抓瞎吧。之后再慢慢将自己的知识体系建立起来。</p>
<p>接下来就该给你的债排优先级，用<a href="http://wiki.mbalib.com/wiki/%E6%97%B6%E9%97%B4%E2%80%9C%E5%9B%9B%E8%B1%A1%E9%99%90%E2%80%9D%E6%B3%95" target="_blank" rel="external">时间“四象限”法</a>，XY轴分别是重要性和紧急性。重要又紧急的债先还；重要不紧急的债可以制定计划；紧急但不重要的，不值得投入大把的时间，够用就好；不重要不紧急的就尽量放弃吧，除非这个债是你的兴趣爱好之所在。</p>
<p>2017年已经远离，是不是在收获了许多成果的同时，也留下了一些遗憾？2018年的余额也已充值完毕，去年（说不定去了好几年呢）欠下的债，该考虑怎么还一还了吧？</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%8A%80%E6%9C%AF%E8%B4%9F%E5%80%BA&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;技术债&lt;/a&gt;是一个借用了财务债的绝妙隐喻（&lt;a href=&quot;http://www.extremeprogramming.org/rules/metaphor.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;极限编程XP的实践&lt;/a&gt;之一），表示当我们为了短期利益（如按时完成开发），而在技术上对软件的长期质量进行的妥协。它一般用于项目管理，但其实也广泛地存在于各个地方，比如每个人的身上。&lt;br&gt;
    
    </summary>
    
      <category term="idea" scheme="http://qinghua.github.io/categories/idea/"/>
    
    
      <category term="idea" scheme="http://qinghua.github.io/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>《Java函数式编程》出版啦</title>
    <link href="http://qinghua.github.io/functional-programming-in-java/"/>
    <id>http://qinghua.github.io/functional-programming-in-java/</id>
    <published>2017-12-24T02:04:22.000Z</published>
    <updated>2017-12-24T02:48:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>从2017年年初到年底，我的新译作<a href="https://book.douban.com/subject/27594722/" target="_blank" rel="external">《Java函数式编程》</a>终于出版啦。这里简要地介绍一下本书，并放篇我为此书所作的译者序，安利一下。<br><a id="more"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>《Java函数式编程》并不是一本关于Java的书，而是一本关于函数式编程的书。作者由浅入深地介绍了函数式编程的思维方式，并引导读者通过易于掌握的例子、练习和图表来学习和巩固函数式编程的基本原则和最佳实践。读者甚至可以在阅读的同时编写出自己的函数式类库！</p>
<p>与<a href="https://book.douban.com/subject/26346017/" target="_blank" rel="external">《Java 8函数式编程》</a>相比（这是一本Java 8的函数式用法的入门佳作），本书侧重的是函数式的思维与实践，而非是Java 8的语法。如果你是一位看完基础语法书后喜欢接着看“Effective”系列的程序员，那么本书就有几分类似于“Effective”版，只不过它讲的是函数式而非是Java 8的“Effective”。语言容易过时或被淘汰，但是思想永存。</p>
<p><img src="/img/functional_programming_in_java_en.jpg" alt=""><br><img src="/img/functional_programming_in_java_cn.jpg" alt=""></p>
<h2 id="译者序"><a href="#译者序" class="headerlink" title="译者序"></a>译者序</h2><p>有幸受邀翻译本书。初见书名，心中不免有几分疑虑，难道又是一本教你怎么使用Java 8 lambda来函数式编程的书吗？翻了几页，方觉自己大误。本书其实意在如何从零开始，逐步理清函数式编程的思维方式并编写基础类库，不仅授之以鱼，而且授之以渔。只不过由于Java的受众实在太广，所以才使用这门语言罢了。</p>
<p>函数式编程有一个至关重要的前提，那就是函数的输出只能取决于函数的参数（我们会在书中看到生成随机数的例子）。初看上去似乎与Java这门面向对象的语言不搭。但语言只是工具而已，正如你也可以在Haskell中编写命令式风格的代码。在一个不太复杂、甚至非并发的常规Java系统中，由于程序内部状态的改变，多次调用同一个方法的返回值很可能是不一样的，更不用说所带来的副作用了。函数式编程中，确定的输入决定了确定的输出，就意味着只要参数对了，结果一定在预期中。也就是说，函数式编程没有无法重现的bug。在这样的前提下，单元测试相对容易实现，而且能极大地增强你的信心。（想想你对目前所在项目的单元测试有多大的信心？）许多个这样的函数复合起来，在不改变信心的同时能够提供更多更强大的功能，进而带来更大的收益，如无状态的线程安全、必要时才计算的惰性求值、加快多次执行速度的记忆化等等。</p>
<p>传统的命令式编程是计算机硬件的抽象，源自图灵机，其实就是外部输入、内部状态、对外部的输出以及对内部状态的改变。函数式编程源自λ演算，即将变量和函数替换为或值表达式并根据运算符计算。函数式编程相比命令式编程代码更简洁、可读性更强，这是因为它的思维方式更倾向于描述要什么，而不是怎么做。所以学习过程反而更加自然，并且不需要多么高深的数学基础。可是我们也知道，软件开发没有银弹。新的方法论也会带来新的问题，需要运用新知识来解决。幸运的是，新知识的坑已经有人帮你踩过了，高阶函数、偏应用函数、复合函数、柯里化、闭包……软件开发从来不缺术语。幸好它们并非高不可攀，作者将会在第二章中扫清你的疑虑，并在后续章节中挑战惰性求值、记忆化、状态处理、应用作用还有actor等更高级的技术。你说Monad？作者才不告诉你它究竟是什么，但是看完本书你自然就领悟了。</p>
<p>函数式编程不是万能药。它有自己擅长的领域，也有自己的弱项。函数式编程是级别更高的抽象。高级别抽象带来的收益就是易读、好写，可是有些低级别的事情（如果你真的需要的话）可能就不容易完成。函数式编程没有副作用，导致无法完成输入/输出操作。尽管如此，你也会在本书中看到一些解决办法。函数式编程没有变量，因此无法改变循环的终止条件，故而没有循环，严重依赖于用递归来抽象循环。在某些情况下可能会影响性能，所以你还会在本书中看到一些性能与情怀之间的权衡。绝大部分的编程最佳实践都是针对某个特定的场景而言的。因此脱离业务场景直接讨论技术并不可取。拥有函数式编程的思维，你就拥有了解决问题的另一种选择，但是条条大路通罗马，千万别钻牛角尖。程序是对现实世界的建模，“不要让世界适应你的模型。让你的模型适应世界。”</p>
<h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>感谢作者Pierre-Yves Saumont，不仅写了这样一本令程序员们受益匪浅的书，而且耗费精力维护本书的后续重构，还耐心地回答我对书中的疑问，使我有机会提高中文版的翻译质量。<br>感谢永恒的侠少和刘舫，让我可以集中精力专注于翻译之上，并让本书得以出版。<br>感谢瑞民，虽然世事变幻莫测，但是你始终扮演了非常重要的角色。<br>感谢家人和朋友们，我永远离不开你们的鼓励和支持。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从2017年年初到年底，我的新译作&lt;a href=&quot;https://book.douban.com/subject/27594722/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《Java函数式编程》&lt;/a&gt;终于出版啦。这里简要地介绍一下本书，并放篇我为此书所作的译者序，安利一下。&lt;br&gt;
    
    </summary>
    
      <category term="development" scheme="http://qinghua.github.io/categories/development/"/>
    
    
      <category term="book" scheme="http://qinghua.github.io/tags/book/"/>
    
  </entry>
  
  <entry>
    <title>懒程序员笔记</title>
    <link href="http://qinghua.github.io/lazy-programmer/"/>
    <id>http://qinghua.github.io/lazy-programmer/</id>
    <published>2017-12-06T13:09:58.000Z</published>
    <updated>2017-12-28T01:26:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>坚持更新“懒程序员改变世界”的博客已经两年了，近期准备和老友办一个“懒程序员笔记”的订阅号，既然都是“懒程序员”的主题，那就围绕着它写点儿什么吧。<br><img src="/img/lazy-programmer-notes-qrcode.png" alt=""><br><a id="more"></a></p>
<p>有一篇文章叫<a href="http://www.jiemian.com/article/427711.html" target="_blank" rel="external">《世界是由懒人创造的》</a>（真的是马云分享的吗？），大致意思就是懒人推动了世界的发展。因为懒，才能创造出一堆的发明，来让我们的生活更方便。当然了，文章弥漫着浓浓的调侃氛围。赞赏、批判这篇文章的人都有不少，至于我的观点嘛，想必从本文的标题中也能看出一二。但是请别忘记，原文最后也写了：“要懒出风格，懒出境界”。</p>
<p>在程序员的世界中，偷懒尤其重要。懒得造轮子？网上大把大把的开源库等着你试用。不想稍微改点代码就从头到位测一遍？那就用自动化测试吧。不想每次部署的时候手忙脚乱？那就上持续交付。不想每次总跟客户扯皮？那就搞敏捷，把客户变成团队的一员。不想让开发和运维互斗？那就拥抱DevOps，大家都在一条船上。可以说，“偷懒”是技术进步的原动力。有些人喜欢说“痛点驱动”，其实它们是一回事，因为没法儿偷懒，所以很“痛”啊。程序员们也非常厌恶重复性的劳动，例如填写工时、定期发送邮件、给别人权限、教新人如何配置环境等等等等。</p>
<p>可是光靠偷懒能够解决问题吗？要是你不想做那么无聊的事情，但是又没有解决的办法，如何才能推动世界进步呢？有道是“创新靠懒，实现靠勤”。唯有学习和思考不能偷懒。你有一个工具箱，你懒，那就用工具箱里的工具来让你懒得其所。可如果你的工具箱是空的，你怎么偷懒啊？有些人看上去非常的勤奋，整天忙个不停，似乎非常充实。但是，偶尔夜深失眠的时候，可能内心也会感觉到一阵恐慌吧。因为忙碌占据了他全部的时间，而真正需要的沉淀、思考、总结的时间基本没有。这样的人只是用勤奋来自欺欺人，掩盖自己懒得思考的本质。有个词叫“低品质勤奋者”很好地涵盖了这一类人。我也曾是其中一员，现在还不时会偷懒，但我已经知道了，不要“用身体的勤奋掩盖思想的懒惰”。</p>
<p>偷懒节省出来的时间都上哪儿去了？学习、思考、与家人相伴。偶尔的放纵没什么关系，但是主旋律还是要保持清醒的大脑，经常使其运转，如果大脑平时不怎么动，可能在关键时刻也就转不动了。如何开始恢复大脑的正常运转？从每天给自己留点独处的时间，深度思考一下今天做了什么有意义的事情，怎样还能做得更好开始吧。一定要坚持，无论刮风下雨，生病加班，因为以我自己的经验来看，一旦破例，很容易便会再次破例，从而使曾经的坚持迅速土崩瓦解。但是可以根据当天的状况灵活控制时间。写文章也是一种有效的思考总结的方法，在此也推荐给大家。试试看，只要走出第一步，总能找到一条适合自己的路。</p>
<p>最后让我们来膜拜一下著名的懒程序员们吧。</p>
<ul>
<li>Nihad Abbasov在<a href="https://github.com/NARKOZ/hacker-scripts" target="_blank" rel="external">github</a>上分享了一个项目，里面包含了一堆的脚本，包括加班时给太太发短信、宿醉时给自己请假、根据自己从工位走到咖啡机的用时来煮咖啡……</li>
<li>Etherable在<a href="https://workplace.stackexchange.com/questions/93696/is-it-unethical-for-me-to-not-tell-my-employer-i-ve-automated-my-job" target="_blank" rel="external">StackExchange</a>上表示，他偷偷写了一段程序，使它十分钟就能完成过去一个人月才能完成的工作。而自己每周改改规范、发发邮件什么的只需一两个小时就够了。于是在程序员中掀起了一场道德辩论，究竟应不应该告诉老板？</li>
<li><a href="http://money.163.com/13/0117/08/8LDJ5PPO00252V0H.html" target="_blank" rel="external">美最懒程序员不干活 支付1/5薪水工作全外包中国</a>。这样的懒程序员，虽然不是本文提倡的类型，但也懒出了风格，堪称跨界人才。</li>
<li>阿里的4位程序员，懒得跟大家抢购月饼，写了段js脚本，<a href="https://www.zhihu.com/question/50600301" target="_blank" rel="external">结果</a>大家都知道了……</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;坚持更新“懒程序员改变世界”的博客已经两年了，近期准备和老友办一个“懒程序员笔记”的订阅号，既然都是“懒程序员”的主题，那就围绕着它写点儿什么吧。&lt;br&gt;&lt;img src=&quot;/img/lazy-programmer-notes-qrcode.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="idea" scheme="http://qinghua.github.io/categories/idea/"/>
    
    
      <category term="idea" scheme="http://qinghua.github.io/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>SSH妙用</title>
    <link href="http://qinghua.github.io/ssh-tricks/"/>
    <id>http://qinghua.github.io/ssh-tricks/</id>
    <published>2017-11-25T07:29:42.000Z</published>
    <updated>2018-05-24T06:27:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近方才了解到，原来可以通过SSH以配置SOCKS代理的方式，不用开VPN便能够科学上网，于是便搜集了一些SSH的用法，以供未来参考。<br><a id="more"></a></p>
<h2 id="无密码登录"><a href="#无密码登录" class="headerlink" title="无密码登录"></a>无密码登录</h2><p>只要把自己的公钥保存在远程主机上就可以了，如果本机尚未生成公私钥对（可以通过<code>ls ~/.ssh</code>查看是否存在以<code>pub</code>为扩展名的文件），可以通过<code>ssh-keygen</code>生成一个。之后把这个<code>pub</code>文件的内容全部复制到远程主机上的<code>~/.ssh/authorized_keys</code>中就能够实现无密码登录了。复制的过程也可以用以下命令实现：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-copy-id user@remote.host.name</div></pre></td></tr></table></figure></p>
<p>Mac上默认没有<code>ssh-copy-id</code>，可以通过以下命令安装：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install ssh-copy-id</div></pre></td></tr></table></figure></p>
<h2 id="远程执行命令"><a href="#远程执行命令" class="headerlink" title="远程执行命令"></a>远程执行命令</h2><p>配置完无密码登录后，在远程主机上执行命令很简单，只要在最后面加一个字符串即可：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh remote.host.name <span class="string">"hostname"</span></div></pre></td></tr></table></figure></p>
<p>如果命令很长，是个脚本，那就这么搞：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> -e <span class="string">"ls\necho ggg"</span> &gt; cmd.txt</div><div class="line"></div><div class="line">ssh remote.host.name <span class="string">"`cat cmd.txt`"</span></div><div class="line">ssh remote.host.name &lt; cmd.txt</div><div class="line">cat cmd.txt | ssh remote.host.name</div></pre></td></tr></table></figure></p>
<p>下面分享一段调试时查看远程日志的实用代码。如果你不知道自己的请求会被负载均衡到哪台服务器上去，可以试试下面这个ssh到所有服务器上执行<code>tail -F</code>的小脚本（当然也能用<code>cat</code>了）：<br><figure class="highlight sh"><figcaption><span>tail_log</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="built_in">set</span> -e</div><div class="line"></div><div class="line"><span class="keyword">if</span> [ -z <span class="variable">$1</span> ]; <span class="keyword">then</span></div><div class="line">  <span class="built_in">echo</span> <span class="string">"usage: <span class="variable">$(basename $0)</span> [log path] [optional grep message]"</span></div><div class="line">  <span class="built_in">echo</span> <span class="string">"sample: <span class="variable">$(basename $0)</span> /abc/def/application.log* Execption"</span></div><div class="line">  <span class="built_in">exit</span> 1</div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line">log_path=<span class="variable">$1</span></div><div class="line">grep_message=<span class="variable">$&#123;2-"''"&#125;</span></div><div class="line"></div><div class="line">hosts=(</div><div class="line">  <span class="string">"remote1.host.name"</span></div><div class="line">  <span class="string">"remote2.host.name"</span></div><div class="line">  <span class="string">"remote3.host.name"</span></div><div class="line">)</div><div class="line"></div><div class="line">remote_command=<span class="string">"tail -F <span class="variable">$&#123;log_path&#125;</span> | grep --line-buffered <span class="variable">$&#123;grep_message&#125;</span>"</span></div><div class="line"><span class="keyword">for</span> host <span class="keyword">in</span> <span class="string">"<span class="variable">$&#123;hosts[@]&#125;</span>"</span></div><div class="line"><span class="keyword">do</span></div><div class="line">  <span class="built_in">exec</span> <span class="string">"ssh -fo StrictHostKeyChecking=no <span class="variable">$&#123;host&#125;</span> \"<span class="variable">$&#123;remote_command&#125;</span>\" &amp;"</span></div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure></p>
<p>当然看完日志以后，别忘了把ssh的进程杀掉：<br><figure class="highlight sh"><figcaption><span>kill_log</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="built_in">kill</span> -9 $(ps -ef | grep <span class="string">"[s]sh -fo StrictHostKeyChecking=no"</span> | awk <span class="string">'&#123;print $2&#125;'</span>)</div></pre></td></tr></table></figure></p>
<p>稍微解释一下以上的两个参数：</p>
<ul>
<li><code>ssh -f</code>: 让SSH在后台执行，之所以在后面再加一个<code>&amp;</code>，是因为想让所有机器并行来tail日志。</li>
<li><code>ssh -o StrictHostKeyChecking=no</code>: 这样就看不到由于第一次连接或是机器指纹变更而出现的<strong>Are you sure you want to continue connecting (yes/no)?</strong></li>
</ul>
<h2 id="SSH隧道"><a href="#SSH隧道" class="headerlink" title="SSH隧道"></a>SSH隧道</h2><h3 id="配置SOCKS代理"><a href="#配置SOCKS代理" class="headerlink" title="配置SOCKS代理"></a>配置SOCKS代理</h3><p>超级简单：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -D 9999 remote.host.name</div></pre></td></tr></table></figure></p>
<p>这样便可以通过如下系统设置通过远程主机上网了（以mac为例）：<br><img src="/img/mac_proxy.jpg" alt=""></p>
<p>浏览器代理也是一样（以chrome插件SwitchyOmega为例）：<br><img src="/img/switchy_omega.jpg" alt=""></p>
<h3 id="本地端口转发"><a href="#本地端口转发" class="headerlink" title="本地端口转发"></a>本地端口转发</h3><p>如果你想让本地经由remote1访问remote2，可以这么做：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -L 9999:remote2.host.name:80 remote1.host.name</div></pre></td></tr></table></figure></p>
<p><code>-L</code>后面的参数，表示<strong>本地端口:目标主机：目标主机端口</strong>，也就是说，往本地9999端口发出去的请求，会经由remote1传给remote2的80端口。为什么我们会需要这样的东东呢？原因可能有几种：</p>
<ul>
<li>本地访问不了remote2（或remote2的指定端口），但是本地可以访问remote1，并且remote1可以访问remote2。如果公司的网络分为几块，互相之间操作有限制，可能就需要一些remote1作为跳板／堡垒机（bastion）来做这样的脏活儿。</li>
<li>被邪恶的防火墙挡住了去路的时候。</li>
<li>希望能够比较安全的时候。</li>
<li>有时候目标机器由于安全原因或其它原因，某个端口只能开放给自己。这时候就可以将remote1和remote2合而为一。例如，当Java调试所用的5050端口不对外开放时，就可以用以下命令让IDE在localhost的5050端口进行调试：<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -L 5050:localhost:5050 remote.host.name</div></pre></td></tr></table></figure>
</li>
</ul>
<p>中间的localhost是相对remote.host.name而言的，也就是它自己。</p>
<h3 id="远程端口转发"><a href="#远程端口转发" class="headerlink" title="远程端口转发"></a>远程端口转发</h3><p>在你的本地可以连通远程主机remote1和另一台远程主机remote2，而它们俩不能相互访问的情况下，如果你想让remote1能够访问remote2，就可以这么做：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -R 9999:remote2.host.name:80 remote1.host.name</div></pre></td></tr></table></figure></p>
<p>这样的话，remote1的本地用户便可以便可以通过你的9999端口，访问remote2的80端口了。相当于你把自己变成了一台堡垒机！如果你有权限在其它机器上运行远程端口转发的命令，那你也可以把它变成堡垒机，把你自己的客户机变成remote1了。</p>
<h2 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h2><p>SSH当然是可以用来复制文件的：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat file | ssh -e none remote-host <span class="string">"cat &gt; file"</span></div></pre></td></tr></table></figure></p>
<p>其中的参数<code>-e none</code>，表示不转义任何字符。SSH默认会通过<code>~</code>来转义一些控制语句。</p>
<p>但是既然我们有<code>scp</code>，还用<code>ssh</code>图个什么，用专业工具吧。</p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>可以用<a href="https://github.com/libfuse/sshfs" target="_blank" rel="external">sshfs</a>来将远程的文件系统通过SFTP加载到本地。对于mac而言，可以用<a href="https://osxfuse.github.io/" target="_blank" rel="external">FUSE for macOS</a>来实现。我还没有那样的需求，没试过，据说比较简单。有兴趣的读者可以自行尝试。</p>
<h2 id="其它环境"><a href="#其它环境" class="headerlink" title="其它环境"></a>其它环境</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>Windows的话，你可以就得试试<a href="http://www.putty.org/" target="_blank" rel="external">Putty</a>了。</p>
<h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><p>用手机和平板来运维？你值得拥有！<br><a href="https://juicessh.com/" target="_blank" rel="external">JuiceSSH</a>的基本功能时免费的，但是要想端口转发什么的就得收费了。用户体验很不错。<br><a href="https://play.google.com/store/apps/details?id=org.connectbot" target="_blank" rel="external">ConnectBot</a>是完全免费的。</p>
<h3 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h3><p><a href="https://itunes.apple.com/us/app/prompt-2/id917437289?mt=8" target="_blank" rel="external">Prompt</a>都说好，收费。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://matt.might.net/articles/ssh-hacks/" target="_blank" rel="external">SSH: More than secure shell</a><br><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html" target="_blank" rel="external">SSH原理与运用（二）：远程操作与端口转发</a><br><a href="https://blog.urfix.com/25-ssh-commands-tricks/" target="_blank" rel="external">25 Best SSH Commands / Tricks</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近方才了解到，原来可以通过SSH以配置SOCKS代理的方式，不用开VPN便能够科学上网，于是便搜集了一些SSH的用法，以供未来参考。&lt;br&gt;
    
    </summary>
    
      <category term="tool" scheme="http://qinghua.github.io/categories/tool/"/>
    
    
      <category term="ssh" scheme="http://qinghua.github.io/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>用Tampermonkey实现自动化网页操作</title>
    <link href="http://qinghua.github.io/tampermonkey/"/>
    <id>http://qinghua.github.io/tampermonkey/</id>
    <published>2017-10-21T07:42:45.000Z</published>
    <updated>2017-10-22T13:25:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://tampermonkey.net/" target="_blank" rel="external">Tampermonkey</a>是一个<a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo?hl=en" target="_blank" rel="external">浏览器插件</a>，可以在网页上嵌入自己编写的js脚本，支持除IE以外的大部分浏览器。还有一个更早的<a href="https://en.wikipedia.org/wiki/Greasemonkey" target="_blank" rel="external">Greasemonkey</a>（油猴）功能类似，可惜它只适用于<a href="https://addons.mozilla.org/en-US/firefox/addon/greasemonkey/" target="_blank" rel="external">Firefox</a>。Tampermonkey的源代码在<a href="https://github.com/Tampermonkey/tampermonkey" target="_blank" rel="external">Github</a>上。<br><a id="more"></a></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>原理其实很简单，就是在宿主页面载入完毕后，运行自己的js脚本罢了，从而实现对浏览器渲染后的html进行改变。除了让你浏览的网页更加个性化以外，还能为你提供一键解决实际问题的需求，例如隐藏广告、自动签到薅羊毛、抢票、每天/每周在网页上填写考勤表等。</p>
<p>Tampermonkey不仅允许使用这些脚本，并且可以编写、管理及同步。安装步骤与一般的插件无异。安装好后，下面拿一个例子练手。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>我们试试在<a href="https://www.baidu.com/" target="_blank" rel="external">百度</a>上增加“Google一下”的按钮。首先单击插件图标，点击“添加新脚本”，于是便进入了Tampermonkey的编辑器。上面的几行注释就是Tampermonkey自己的语法，保存了一些元数据，包括脚本的名字、版本、在满足什么规则的网页上生效等。我们把<code>@match</code>的内容修改为<code>https://www.baidu.com/*</code>，这样便能在百度域名下的所有网页中生效啦。</p>
<p>打开百度，可以看到“百度一下”的按钮：<code>id=&quot;su&quot;</code>，我们将“Google一下”插入到其后即可。在<code>// Your code here...</code>后面编写如下js代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'#su'</span>).after(<span class="string">'&lt;input type="button" id="google" value="Google一下" class="btn self-btn bg s_btn" style="background-color:grey;" onclick="googleIt" /&gt;'</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">googleIt</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="string">'google'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>保存并刷新百度，顺利地看到了灰色的“Google一下”。这说明我们的脚本起作用了。在插件图标的位置上页显示了一个红色的<code>1</code>，说明当前网页上的生效脚本数量为1。但是点击“Google一下”什么也没有弹出。在控制台上可以看到出错了：<strong>Uncaught ReferenceError: googleIt is not defined</strong>。这是因为所有代码都是<a href="https://stackoverflow.com/questions/16704209/onclick-added-with-tampermonkey-is-not-calling-the-function" target="_blank" rel="external">作为一个字符串被<code>eval</code></a>的，所以应该使用动态的方式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'#su'</span>).after(<span class="string">'&lt;input type="button" id="google" value="Google一下" class="btn self-btn bg s_btn" style="background-color:grey;" /&gt;'</span>);</div><div class="line">$(<span class="string">"#google"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    googleIt();</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这回点击按钮就能够正常工作了！我们现在要做的，就是把<code>alert</code>替换为打开Google页面即可：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">googleIt</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> searchText = <span class="built_in">document</span>.querySelector(<span class="string">'#kw'</span>).value;</div><div class="line">    location.href = getGoogleUrl(searchText);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGoogleUrl</span>(<span class="params">searchText</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'https://www.google.com/search?q='</span> + searchText;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>短短几行代码，就搞定了。Tampermonkey内置了一些对象与函数，可以让我们很方便地实现一些功能，如打开新窗口可以使用<code>GM_openInTab</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">googleIt</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> searchText = <span class="built_in">document</span>.querySelector(<span class="string">'#kw'</span>).value;</div><div class="line">    GM_openInTab(getGoogleUrl(searchText), <span class="literal">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第二个参数可以决定当前的焦点是老窗口还是新窗口。在使用内置函数之前，需要先<code>@grant</code>一下，如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// @grant        GM_openInTab</span></div></pre></td></tr></table></figure></p>
<p>否则无法生效。更多的内置函数可以在<a href="http://tampermonkey.net/documentation.php" target="_blank" rel="external">官方文档</a>中查看。</p>
<p>我们新写的代码并不会直接出现在控制台中，如果需要调试，可以在代码中增加<code>debugger;</code>，这样运行时就能自动停在这一行了。百度主页有引用jQuery，所以我们可以直接在代码中使用<code>$</code>。如果需要的页面上没有jQuery，那么可以通过这行命令引入：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//      @include https://code.jquery.com/jquery-3.2.1.min.js</span></div></pre></td></tr></table></figure></p>
<p>完整的代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ==UserScript==</span></div><div class="line"><span class="comment">// @name         Google on baidu</span></div><div class="line"><span class="comment">// @namespace    http://tampermonkey.net/</span></div><div class="line"><span class="comment">// @version      0.1</span></div><div class="line"><span class="comment">// @description  Google it!</span></div><div class="line"><span class="comment">// @author       ggg</span></div><div class="line"><span class="comment">// @match        https://www.baidu.com/*</span></div><div class="line"><span class="comment">// @grant        GM_openInTab</span></div><div class="line"><span class="comment">// ==/UserScript==</span></div><div class="line"></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="meta">    'use strict'</span>;</div><div class="line"></div><div class="line">    $(<span class="string">'#su'</span>).after(<span class="string">'&lt;input type="button" id="google" value="Google一下" class="btn self-btn bg s_btn" style="background-color:grey;" /&gt;'</span>);</div><div class="line">    $(<span class="string">"#google"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        googleIt();</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">googleIt</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> searchText = $(<span class="string">'#kw'</span>).val();</div><div class="line">        GM_openInTab(getGoogleUrl(searchText), <span class="literal">false</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getGoogleUrl</span>(<span class="params">searchText</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'https://www.google.com/search?q='</span> + searchText;</div><div class="line">    &#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p>不过这种做法存在两个问题：</p>
<ol>
<li>如果宿主网页变化，脚本需要随之变化。这也没办法，谁叫我们依赖它呢。好在宿主网页没事也不会经常变化。</li>
<li>“Google一下”的按钮会比原生的“百度一下”延迟一些才出来，体验上稍微差一些。毕竟相对而言我们的脚本只是二等公民。</li>
</ol>
<p>但是获益的巨大几乎可以让我们完全无视这些缺陷。</p>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>脚本也是代码，也有自己的版本，也能被多人所共享使用。只要它在因特网上的url以<code>.user.js</code>结尾，即可轻易分享给其他人。上面的这个例子我就放到了<a href="https://github.com/qinghua/tamperMonkeyScript/raw/master/googleit.user.js" target="_blank" rel="external">Github</a>中。分享出去的时候，如果对方安装了tampermonkey，就可以看到脚本的安装界面了。更多的共享脚本可以单击插件图标，点击“获取新脚本”，或是参考<a href="https://tampermonkey.net/scripts.php" target="_blank" rel="external">这里</a>来获得。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://tampermonkey.net/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Tampermonkey&lt;/a&gt;是一个&lt;a href=&quot;https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo?hl=en&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;浏览器插件&lt;/a&gt;，可以在网页上嵌入自己编写的js脚本，支持除IE以外的大部分浏览器。还有一个更早的&lt;a href=&quot;https://en.wikipedia.org/wiki/Greasemonkey&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Greasemonkey&lt;/a&gt;（油猴）功能类似，可惜它只适用于&lt;a href=&quot;https://addons.mozilla.org/en-US/firefox/addon/greasemonkey/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Firefox&lt;/a&gt;。Tampermonkey的源代码在&lt;a href=&quot;https://github.com/Tampermonkey/tampermonkey&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Github&lt;/a&gt;上。&lt;br&gt;
    
    </summary>
    
      <category term="development" scheme="http://qinghua.github.io/categories/development/"/>
    
    
      <category term="tampermonkey" scheme="http://qinghua.github.io/tags/tampermonkey/"/>
    
      <category term="js" scheme="http://qinghua.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>代码还是数据</title>
    <link href="http://qinghua.github.io/code-or-data/"/>
    <id>http://qinghua.github.io/code-or-data/</id>
    <published>2017-10-01T13:03:01.000Z</published>
    <updated>2017-10-01T13:42:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>这段逻辑是代码还是数据，对我来说从来都不曾是个问题，直到遇上了这么一个项目。<br><a id="more"></a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>一般来说，我们写程序，都是连同测试代码一起提交，至少也是一起代码审查。有一个关于收费的项目，偏偏反其道而行之。这个项目的一些背景如下：</p>
<ol>
<li>收费的逻辑通过DSL配置在代码库中。</li>
<li>对于这些逻辑，没有单元测试，但是有集成测试。</li>
<li>集成测试里面包含了request与response，在测试的时候回放request并比较response是否匹配。</li>
<li>集成测试是json文件，放在S3上。</li>
</ol>
<p>如果有一个对费率的修改，那么程序员除了往代码库中提交修改后的DSL，还会往S3更新json测试文件。这就带来了几个问题：</p>
<ul>
<li>代码审查者只能看到代码库的变动，除非再去S3上看测试数据，不然并不知道这段DSL的测试情况。而在S3上看测试数据相对比较繁琐，这样的机制可以说是鼓励代码审查者不去看测试数据。</li>
<li>没有版本管理（或者说由于S3与代码库的版本管理机制差别较大），导致这些测试不容易追踪，也不容易查看历史记录。</li>
<li>持续集成通过与否依赖于S3的数据。所以集成测试失败时，不一定能在解决时复原到失败时的状态。</li>
<li>DEV提交代码和更新测试数据这两步变成了一个原子操作，需要一起完成，至少在代码提交后、CI上运行集成测试之前更新S3。而在提交代码前更新S3又有破坏别人正在运行测试的风险。</li>
</ul>
<p>那么，为什么这个项目会选用这样的方案呢？原来，在设计的时候是这么考虑的：费率修改的需求来自于产品经理，希望测试数据能够由PM们提供。所以将会开发一个面向PM们的小系统，后台就是这个S3数据，这样的话到时候修改费率，就增加了一层来自需求方的保障。如果测试数据来自于代码库，那就很难通过页面来修改并提交代码库了。初衷还是不错的，但是仔细推敲下来，DEV自己的测试哪儿去了？这样运转起来后，是不是只会养成DEV把测试推给PM的习惯？</p>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>我觉得这里面有一个误区，就是把DEV自己的测试和PM的测试混为一谈了。实际上应该将它们分开来。为什么呢？DEV自己的测试其实本来就应该是代码的一部分，应该保存在代码库中。而PM的测试其实是对程序员测试的补充，也应该算是代码的一部分，如果能够放在代码库中固然是好，但是我们也不能对所有的PM们都抱有提交代码这样不切实际的期望，所以在这种情况下，S3算是一个权衡的方案。而CI上应该有两步，其一是DEV的测试，其二是PM的测试（在PM修改测试数据的小系统还没上线之前，可以暂不配置这个测试）。它们之间是顺序执行还是并发执行倒是无关紧要。但这样也有不尽如人意的地方：</p>
<ul>
<li>修改代码需要DEV和PM同时协作，最好一起修改，否则CI会红。但这正是DevOps运动所提倡的，不是么？</li>
<li>背景一节介绍的一些缺点在PM的测试中仍然存在。PM修改测试数据的小系统需要更加完善的版本管理和审计。这部分的开销可能还不小。</li>
</ul>
<p>顺便提一句，传统的PM测试数据是由DEV提供一个CSV格式，让PM填完之后由DEV添加到代码库中。在忽略DEV和PM的用户体验的情况下，这也是一个可行的方案。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到底什么样的逻辑应该进代码库，什么样的逻辑应该持久化呢？其实我们应该把逻辑区分为程序、配置和数据。</p>
<p>程序：<br>在代码库中，提供服务的主要功能。对其的修改通常都是改bug或是引入新功能。</p>
<p>配置：<br>在配置服务器中，但是配置的默认值很可能是在代码库中。经常需要修改，修改其值可以让程序表现出不同的处理逻辑。需要易于修改。</p>
<p>数据：<br>在持久化存储（一般是数据库）中，因用户而异，数量可能会比较大。随用户的操作而变化。需要有备份机制。</p>
<p>反推到上文所说：“收费的逻辑通过DSL配置在代码库中”。这段逻辑，也许应该是配置而非程序，因为它会经常需要修改。收费记录毋庸置疑，一定是数据了。从逻辑分类的角度上出发，你是否会发现其实自己现在的代码库中包含了太多的配置？</p>
<p>另外，虽然代码库似乎也可以用于配置或数据，但是最好还是别这么干，这里有一篇<a href="https://stackoverflow.com/questions/20151158/using-git-repository-as-a-database-backend" target="_blank" rel="external">stack overflow的问答</a>，解释得挺清楚的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这段逻辑是代码还是数据，对我来说从来都不曾是个问题，直到遇上了这么一个项目。&lt;br&gt;
    
    </summary>
    
      <category term="idea" scheme="http://qinghua.github.io/categories/idea/"/>
    
    
      <category term="soft skill" scheme="http://qinghua.github.io/tags/soft-skill/"/>
    
  </entry>
  
  <entry>
    <title>用JGit生成patch文件</title>
    <link href="http://qinghua.github.io/git-patch/"/>
    <id>http://qinghua.github.io/git-patch/</id>
    <published>2017-09-12T11:59:02.000Z</published>
    <updated>2017-09-12T09:51:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>上篇博文介绍了<a href="/jgit">JGit</a>，之后就开始做项目了。遇到的第一个问题是如何用JGit生成patch文件。<br><a id="more"></a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我希望在项目中能够实现这样的功能：用户发送一个request，服务器就帮用户生成代码并生成一个commit到用户本地的git中，但是这不太可能，因为用户的环境并不是服务器的环境。进一步的方案是直接在服务器端clone git仓库（或是维持一份最新代码），服务器本地生成commit并push，这样做会有一些安全方面需要考虑的因素。我采用的是退一步的方案，即让服务器生成一个patch文件并上传到<a href="https://aws.amazon.com/s3/" target="_blank" rel="external">S3</a>，以便用户稍后下载并apply到本地。</p>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><h3 id="api-command"><a href="#api-command" class="headerlink" title="api command"></a>api command</h3><p>打开JGit的<a href="https://github.com/eclipse/jgit/tree/master/org.eclipse.jgit/src/org/eclipse/jgit/api" target="_blank" rel="external">api包</a>一看，各种git命令应有尽有，如apply、cherry-pick等。但惟独没有format-patch命令。网上一搜，甚少有人有这样的需求或问题，只有<a href="http://www.codeaffine.com/2016/06/16/jgit-diff/" target="_blank" rel="external">这篇文章</a>比较靠谱，但是它介绍的侧重于diff而非生成patch。</p>
<h3 id="Patch"><a href="#Patch" class="headerlink" title="Patch"></a>Patch</h3><p>还是得找找patch相关的代码。源代码搜遍也就这个<a href="https://github.com/eclipse/jgit/blob/master/org.eclipse.jgit/src/org/eclipse/jgit/patch/Patch.java" target="_blank" rel="external">Patch.java</a>应该是patch文件的JGit模型，但是读完后发现，它只能把patch文件映射成这个模型，并不能反向从模型序列化为patch文件。</p>
<h3 id="DiffFormatter-DiffEntry"><a href="#DiffFormatter-DiffEntry" class="headerlink" title="DiffFormatter / DiffEntry"></a>DiffFormatter / DiffEntry</h3><p>DiffCommand其实上还是调用的DiffFormatter和DiffEntry，所以看看这俩是否能够支持什么样的参数，来生成patch文件呢？可惜还是无果。DiffFormatter的API也不太直观，不容易理解。但是它能够做一些diff commit这样的事情。</p>
<h3 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h3><p>走投无路之际，在<a href="https://git-scm.com/docs/git-format-patch" target="_blank" rel="external">git-format-patch</a>上看到，这个命令其实是用来生成<strong>用邮件发送</strong>的patch文件。难怪patch文件的前几行看起来有From，有Subject什么的，也许它们不是必须的？那就可以试试把diff的结果当作patch直接写入文件。</p>
<h2 id="动手时间"><a href="#动手时间" class="headerlink" title="动手时间"></a>动手时间</h2><p>首先创建一个git环境，a、b、c三个文件用来测试改删增：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">mkdir -p /tmp/ggg</div><div class="line"><span class="built_in">cd</span> /tmp/ggg</div><div class="line">git init</div><div class="line"><span class="built_in">echo</span> line a1 &gt; a.txt</div><div class="line"><span class="built_in">echo</span> line a2 &gt;&gt; a.txt</div><div class="line"><span class="built_in">echo</span> line b1 &gt; b.txt</div><div class="line">git add .</div><div class="line">git commit -m <span class="string">"first commit wiht a.txt and b.txt"</span></div><div class="line"><span class="built_in">echo</span> line a3 &gt;&gt; a.txt</div><div class="line"><span class="built_in">echo</span> line c1 &gt; c.txt</div><div class="line">rm b.txt</div><div class="line">git diff</div></pre></td></tr></table></figure></p>
<p>运行完成后就能看到diff文件的内容了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">diff --git a/a.txt b/a.txt</div><div class="line">index 7a3d45f..c723fac 100644</div><div class="line">--- a/a.txt</div><div class="line">+++ b/a.txt</div><div class="line">@@ -1,2 +1,3 @@</div><div class="line"> line a1</div><div class="line"> line a2</div><div class="line">+line a3</div><div class="line">diff --git a/b.txt b/b.txt</div><div class="line">deleted file mode 100644</div><div class="line">index b45d9fa..0000000</div><div class="line">--- a/b.txt</div><div class="line">+++ /dev/null</div><div class="line">@@ -1 +0,0 @@</div><div class="line">-line b1</div></pre></td></tr></table></figure></p>
<p>在程序中，如此这般运行git diff命令：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Git git = Git.init().setDirectory(<span class="keyword">new</span> File(<span class="string">"/tmp/ggg"</span>)).call();</div><div class="line">git.diff().setOutputStream(System.out).call();</div></pre></td></tr></table></figure></p>
<p>发现JGit的diff和Git的diff还是不太一样的。JGit的diff包含了新增文件的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">diff --git a/a.txt b/a.txt</div><div class="line">index 7a3d45f..c723fac 100644</div><div class="line">--- a/a.txt</div><div class="line">+++ b/a.txt</div><div class="line">@@ -1,2 +1,3 @@</div><div class="line"> line a1</div><div class="line"> line a2</div><div class="line">+line a3</div><div class="line">diff --git a/b.txt b/b.txt</div><div class="line">deleted file mode 100644</div><div class="line">index b45d9fa..0000000</div><div class="line">--- a/b.txt</div><div class="line">+++ /dev/null</div><div class="line">@@ -1 +0,0 @@</div><div class="line">-line b1</div><div class="line">diff --git a/c.txt b/c.txt</div><div class="line">new file mode 100644</div><div class="line">index 0000000..8e37e08</div><div class="line">--- /dev/null</div><div class="line">+++ b/c.txt</div><div class="line">@@ -0,0 +1 @@</div><div class="line">+line c1</div></pre></td></tr></table></figure></p>
<p>这就非常合适了。只要证明它能够被作为patch导入到git中即可。首先修改代码输出到文件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">File patch = <span class="keyword">new</span> File(<span class="string">"/tmp/jgit.patch"</span>);</div><div class="line">Git git = Git.init().setDirectory(<span class="keyword">new</span> File(<span class="string">"/tmp/ggg"</span>)).call();</div><div class="line"><span class="keyword">try</span> (OutputStream outputStream = <span class="keyword">new</span> FileOutputStream(patch)) &#123;</div><div class="line">    git.diff().setOutputStream(outputStream).call();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后清空修改过的文件：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /tmp/ggg</div><div class="line">git checkout .</div><div class="line">git clean -df</div><div class="line">git status</div></pre></td></tr></table></figure></p>
<p>现在尝试apply patch：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git apply /tmp/jgit.patch</div><div class="line">git status</div></pre></td></tr></table></figure></p>
<p>果然成功了。在不考虑冲突的情况下，看起来这一招还是管用的。但是由于缺失了commit的信息，所以运行<code>git am /tmp/jgit.patch</code>就会报错：<em>Patch format detection failed.</em>有没有办法解决这个问题呢？当然了。我们现在知道了patch只不过是多了一些邮件信息罢了，那我们自己就可以生成。在<code>try</code>内增加如下代码，模拟<code>git format-patch</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">    outputStream.write(<span class="string">"From: GGG &lt;ggg@somewhere.com&gt;\n"</span>.getBytes());</div><div class="line">    outputStream.write(<span class="string">"Date: Tue, 12 Sep 2017 20:16:10 +0800\n"</span>.getBytes());</div><div class="line">    outputStream.write(<span class="string">"Subject: [PATCH] ggg is not here. Turn left and ask JGit\n"</span>.getBytes());</div><div class="line">    outputStream.write(<span class="string">"\n---\n\n"</span>.getBytes());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行一下，然后尝试使用<code>git am</code>：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git am /tmp/jgit.patch</div><div class="line">git <span class="built_in">log</span></div><div class="line">git show HEAD</div></pre></td></tr></table></figure></p>
<p>果然可以直接生成commit。Mission Complete!</p>
<h2 id="patch-amp-diff"><a href="#patch-amp-diff" class="headerlink" title="patch &amp; diff"></a>patch &amp; diff</h2><p>其实Linux已经提供了一个<code>patch</code>命令，无需git即可直接应用patch文件：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git reset HEAD^ --hard</div><div class="line">ls</div><div class="line">patch &lt; /tmp/jgit.patch</div></pre></td></tr></table></figure></p>
<p>而且还支持回滚（git apply也支持）：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">patch -R &lt; /tmp/jgit.patch</div><div class="line">ls</div></pre></td></tr></table></figure></p>
<p>实际上patch文件一般是使用<code>diff</code>命令来生成的：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">diff -u a.txt c.txt &gt; diff.patch</div><div class="line">cat diff.patch</div></pre></td></tr></table></figure></p>
<p>这两个命令网上的教程不少，有兴趣的话可以自行搜索阅读。最后还是把环境恢复：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rm -rf /tmp/ggg /tmp/jgit.patch</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇博文介绍了&lt;a href=&quot;/jgit&quot;&gt;JGit&lt;/a&gt;，之后就开始做项目了。遇到的第一个问题是如何用JGit生成patch文件。&lt;br&gt;
    
    </summary>
    
      <category term="development" scheme="http://qinghua.github.io/categories/development/"/>
    
    
      <category term="JGit" scheme="http://qinghua.github.io/tags/JGit/"/>
    
      <category term="git" scheme="http://qinghua.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>用JGit通过Java来操作Git</title>
    <link href="http://qinghua.github.io/jgit/"/>
    <id>http://qinghua.github.io/jgit/</id>
    <published>2017-08-13T01:59:02.000Z</published>
    <updated>2017-08-14T00:22:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://eclipse.org/jgit/" target="_blank" rel="external">JGit</a>是一个由<a href="https://www.eclipse.org/org/" target="_blank" rel="external">Eclipse基金会</a>开发、用于操作git的纯Java库。它本身也是Eclispe的一部分，实际上Eclipse的插件<a href="http://www.eclipse.org/egit/" target="_blank" rel="external">EGit</a>便是基于JGit的。如果你像我这样有使用代码来操作git的需求，那就准备好拥抱JGit吧。目前来看别的竞品没它靠谱。<br><a id="more"></a></p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>从用户指南的<a href="http://wiki.eclipse.org/JGit/User_Guide#Concepts" target="_blank" rel="external">概念</a>一节中可以看到，JGit的基本概念如下：</p>
<ul>
<li>Git对象（Git Objects）：就是git的对象。它们在git中用SHA-1来表示。在JGit中用<code>AnyObjectId</code>和<code>ObjectId</code>表示。而它又包含了四种类型：<ol>
<li>二进制大对象（blob）：文件数据</li>
<li>树（tree）：指向其它的tree和blob</li>
<li>提交（commit）：指向某一棵tree</li>
<li>标签（tag）：把一个commit标记为一个标签</li>
</ol>
</li>
<li>引用（Ref）：对某一个git对象的引用。</li>
<li>仓库（Repository）：顾名思义，就是用于存储所有git对象和Ref的仓库。</li>
<li>RevWalk：该类用于从commit的关系图（graph）中遍历commit。晦涩难懂？看到范例就清楚了。</li>
<li>RevCommit：表示一个git的commit</li>
<li>RevTag：表示一个git的tag</li>
<li>RevTree：表示一个git的tree</li>
<li>TreeWalk：类似RevWalk，但是用于遍历一棵tree</li>
</ul>
<h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><p>让我们从一个最典型的用例开始吧。首先在<code>/tmp/jgit/repo</code>中创建一个git仓库：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mkdir -p /tmp/jgit/repo</div><div class="line">cd /tmp/jgit/repo</div><div class="line">git init --bare</div></pre></td></tr></table></figure></p>
<p>再创建一个clone该仓库的客户端：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd /tmp/jgit/</div><div class="line">git clone repo client</div><div class="line">cd client</div></pre></td></tr></table></figure></p>
<p>输入<code>git status</code>应该能够看到<strong>Initial commit</strong>，这样环境就没有问题了。然后提交一个文件，给仓库里来点库存：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">echo hello &gt; hello.txt</div><div class="line">git add hello.txt</div><div class="line">git commit -m "hello"</div><div class="line">git push</div></pre></td></tr></table></figure></p>
<h2 id="动手"><a href="#动手" class="headerlink" title="动手"></a>动手</h2><h3 id="获取仓库"><a href="#获取仓库" class="headerlink" title="获取仓库"></a>获取仓库</h3><p>动手时间。新建Maven工程，往pom.xml中增加dependency，最后的pom.xml看起来就像这样：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></div><div class="line">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.ggg.jgit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>helloJgit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jgit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>org.eclipse.jgit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.8.0.201706111038-r<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>让我们先尝试clone一下这个仓库。因为client分为已经存在以及重新clone的两种，所以我们在src/main/java中新增一个<code>RepositoryProvider</code>接口，用两种不同实现以示区分：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RepositoryProvider</span> </span>&#123;</div><div class="line">    <span class="function">Repository <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>并实现之：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RepositoryProviderCloneImpl</span> <span class="keyword">implements</span> <span class="title">RepositoryProvider</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String repoPath;</div><div class="line">    <span class="keyword">private</span> String clientPath;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RepositoryProviderCloneImpl</span><span class="params">(String repoPath, String clientPath)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.repoPath = repoPath;</div><div class="line">        <span class="keyword">this</span>.clientPath = clientPath;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Repository <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        File client = <span class="keyword">new</span> File(clientPath);</div><div class="line">        client.mkdir();</div><div class="line"></div><div class="line">        <span class="keyword">try</span> (Git result = Git.cloneRepository()</div><div class="line">                .setURI(repoPath)</div><div class="line">                .setDirectory(client)</div><div class="line">                .call()) &#123;</div><div class="line">            <span class="keyword">return</span> result.getRepository();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>新增一个<code>HelloJGit</code>主程序类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloJGit</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RepositoryProvider repoProvider = <span class="keyword">new</span> RepositoryProviderCloneImpl(<span class="string">"/tmp/jgit/repo"</span>, <span class="string">"/tmp/jgit/clientJava"</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">try</span> (Git git = <span class="keyword">new</span> Git(repoProvider.get())) &#123;</div><div class="line">            git.pull().call();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>直接运行<code>HelloJGit</code>的<code>main</code>函数，<code>ls /tmp/jgit/</code>应该就能看到新clone出来的<code>clientJava</code>文件夹了。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd /tmp/jgit/clientJava</div><div class="line">ls</div><div class="line">git status</div></pre></td></tr></table></figure></p>
<p>我们当然不希望总是在使用的时候才重新clone一个仓库，因为当仓库很大的时候可能会非常耗时。让我们在<code>client</code>中再提交一个commit：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">echo hello2 &gt; hello2.txt</div><div class="line">git add hello2.txt</div><div class="line">git commit -m "hello again"</div><div class="line">git push</div></pre></td></tr></table></figure></p>
<p>然后尝试直接从刚刚clone下来的clientJava中创建Repository：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RepositoryProviderExistingClientImpl</span> <span class="keyword">implements</span> <span class="title">RepositoryProvider</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String clientPath;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RepositoryProviderExistingClientImpl</span><span class="params">(String clientPath)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.clientPath = clientPath;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Repository <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">try</span> (Repository repo = <span class="keyword">new</span> FileRepository(clientPath)) &#123;</div><div class="line">            <span class="keyword">return</span> repo;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后把<code>HelloJGit</code>的<code>repoProvider</code>实例替换为<code>RepositoryProviderExistingClientImpl</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> RepositoryProvider repoProvider = <span class="keyword">new</span> RepositoryProviderExistingClientImpl(<span class="string">"/tmp/jgit/clientJava/.git"</span>);</div></pre></td></tr></table></figure></p>
<p>注意这次的路径中需要加上<code>.git</code>才行。再次运行<code>HelloJGit</code>的<code>main</code>函数，便可以通过<code>ls /tmp/jgit/clientJava</code>看到新提交的<code>hello2.txt</code>文件了。</p>
<h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><p>接下来尝试<code>git add</code>、<code>git commit</code>和<code>git push</code>这几个最常用的命令。让我们往<code>clientJava</code>中添加一个<code>hello3.txt</code>文件并提交。如下修改<code>HelloJGit</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="keyword">try</span> (Repository repo = repoProvider.get();</div><div class="line">         Git git = <span class="keyword">new</span> Git(repo)) &#123;</div><div class="line">        createFileFromGitRoot(repo, <span class="string">"hello3.txt"</span>, <span class="string">"hello3"</span>);</div><div class="line">        git.add()</div><div class="line">                .addFilepattern(<span class="string">"hello3.txt"</span>)</div><div class="line">                .call();</div><div class="line"></div><div class="line">        git.commit()</div><div class="line">                .setMessage(<span class="string">"hello3"</span>)</div><div class="line">                .call();</div><div class="line"></div><div class="line">        git.push()</div><div class="line">                .call();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createFileFromGitRoot</span><span class="params">(Repository repo, String filename, String content)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</div><div class="line">    File hello3 = <span class="keyword">new</span> File(repo.getDirectory().getParent(), filename);</div><div class="line">    <span class="keyword">try</span> (PrintWriter out = <span class="keyword">new</span> PrintWriter(hello3)) &#123;</div><div class="line">        out.println(content);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>虽然操作多了，但是有了<code>Repository</code>和<code>Git</code>对象之后，看起来它们的实现都非常直观。运行<code>main</code>函数之后，可以到<code>client</code>文件夹中校验一下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cd /tmp/jgit/client</div><div class="line">git pull</div><div class="line">cat hello3.txt</div><div class="line">git log</div></pre></td></tr></table></figure></p>
<p>在我的机器上运行<code>git log</code>，可以得到：<strong>commit 7841b8b80a77918f2ec45bcedb934e2723b16b5c (HEAD -&gt; master, origin/master)</strong>，以及另外两个commit。有兴趣的读者们可以自行尝试其它的git命令。</p>
<h3 id="其它对象"><a href="#其它对象" class="headerlink" title="其它对象"></a>其它对象</h3><p>虽然上面两小节的内容对于普通需求来说已经大致上够用了，但是在<a href="/jgit/#概念">概念一节</a>中介绍到的其它概念，如Git对象、引用等还没有出场呢。我们再新建一个<code>WalkJGit</code>的类，在<code>main</code>函数中编写如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> (Repository repo = repoProvider.get()) &#123;</div><div class="line">    Ref ref = repo.getAllRefs().get(Constants.HEAD);</div><div class="line">    ObjectId objectId = ref.getObjectId();</div><div class="line">    System.out.println(objectId);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这回，<code>Ref</code>和<code>ObjectId</code>都出现了。在我的机器上，运行以上程序打印出来了<strong>AnyObjectId[7841b8b80a77918f2ec45bcedb934e2723b16b5c]</strong>。我们可以看到，取得<code>HEAD</code>的<code>Ref</code>，其<code>ObjectId</code>其实就是在<code>client</code>文件夹中运行<code>git log</code>之后结果。除了<code>HEAD</code>以外，<code>repo.getAllRefs()</code>返回的<code>Map</code>实例中还有<code>refs/heads/master</code>和<code>refs/remotes/origin/master</code>，在目前的情况下，它们的<code>ObjectId</code>完全相同。那么如何获取其它的commit呢？那就是<code>RevWalk</code>出场的时候。把<code>main</code>函数中的内容替换为如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> (Repository repo = repoProvider.get()) &#123;</div><div class="line">    Ref ref = repo.getAllRefs().get(Constants.HEAD);</div><div class="line"></div><div class="line">    <span class="keyword">try</span> (RevWalk revWalk = <span class="keyword">new</span> RevWalk(repo)) &#123;</div><div class="line">        RevCommit lastCommit = revWalk.parseCommit(ref.getObjectId());</div><div class="line">        revWalk.markStart(lastCommit);</div><div class="line">        revWalk.forEach(System.out::println);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到<code>RevWalk</code>本身是实现了<code>Iterable</code>接口的。通过对该对象进行循环，就可以获取所有的commit的<code>RevCommit</code>对象。可以到<code>client</code>文件夹确认一下，这些SHA-1字符串应该跟刚才<code>git log</code>命令的结果相同。<code>RevCommit</code>对象本身含有这个commit的所有信息，所以可以如下打印出来：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">revWalk.forEach(c -&gt; &#123;</div><div class="line">    System.out.println(<span class="string">"commit "</span> + c.getName());</div><div class="line">    System.out.printf(<span class="string">"Author: %s &lt;%s&gt;\n"</span>, c.getAuthorIdent().getName(), c.getAuthorIdent().getEmailAddress());</div><div class="line">    System.out.println(<span class="string">"Date: "</span> + LocalDateTime.ofEpochSecond(c.getCommitTime(), <span class="number">0</span>, ZoneOffset.UTC));</div><div class="line">    System.out.println(<span class="string">"\t"</span> + c.getShortMessage() + <span class="string">"\n"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这样看起来是不是很有<code>git log</code>的感觉呢？需要注意的是，<code>RevWalk</code>线程不安全，并且像<code>Stream</code>那样，只能使用一次。<a href="https://github.com/eclipse/jgit/blob/master/org.eclipse.jgit/src/org/eclipse/jgit/revwalk/RevWalk.java#L77" target="_blank" rel="external">如果想要再来一次</a>，就需要重新创建<code>RevWalk</code>对象或是调用其<code>reset</code>方法（还得重新<code>markStart</code>！）。</p>
<p>要想看到每个commit中有什么内容，那就需要用到<code>TreeWalk</code>了，它的思路和<code>RevWalk</code>类似。尝试如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (RevCommit commit : revWalk) &#123;</div><div class="line">    System.out.println(<span class="string">"\ncommit: "</span> + commit.getName());</div><div class="line">    <span class="keyword">try</span> (TreeWalk treeWalk = <span class="keyword">new</span> TreeWalk(repo)) &#123;</div><div class="line">        treeWalk.addTree(commit.getTree());</div><div class="line">        treeWalk.setRecursive(<span class="keyword">true</span>);</div><div class="line">        <span class="keyword">while</span> (treeWalk.next()) &#123;</div><div class="line">            System.out.println(<span class="string">"filename: "</span> + treeWalk.getPathString());</div><div class="line">            ObjectId objectId = treeWalk.getObjectId(<span class="number">0</span>);</div><div class="line">            ObjectLoader loader = repo.open(objectId);</div><div class="line">            loader.copyTo(System.out);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样便可以显示仓库在每个commit时候的状态了。如果需要diff，那么还将需要用到<code>DiffEntry</code>等类，本文就不再赘述了，有兴趣的读者可以参考<a href="https://github.com/centic9/jgit-cookbook/blob/master/src/main/java/org/dstadler/jgit/porcelain/ShowChangedFilesBetweenCommits.java" target="_blank" rel="external">这个类</a>。</p>
<p>最后将环境还原：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rm -rf /tmp/jgit</div></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/centic9/jgit-cookbook" target="_blank" rel="external">这个代码库</a>里有很全面的、基本可以直接用于生产环境的范例。<br><a href="https://github.com/eclipse/jgit" target="_blank" rel="external">JGit的源码</a>和<a href="http://wiki.eclipse.org/JGit/User_Guide" target="_blank" rel="external">用户指南</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://eclipse.org/jgit/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JGit&lt;/a&gt;是一个由&lt;a href=&quot;https://www.eclipse.org/org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Eclipse基金会&lt;/a&gt;开发、用于操作git的纯Java库。它本身也是Eclispe的一部分，实际上Eclipse的插件&lt;a href=&quot;http://www.eclipse.org/egit/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;EGit&lt;/a&gt;便是基于JGit的。如果你像我这样有使用代码来操作git的需求，那就准备好拥抱JGit吧。目前来看别的竞品没它靠谱。&lt;br&gt;
    
    </summary>
    
      <category term="development" scheme="http://qinghua.github.io/categories/development/"/>
    
    
      <category term="JGit" scheme="http://qinghua.github.io/tags/JGit/"/>
    
      <category term="git" scheme="http://qinghua.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>《智能时代》读后感</title>
    <link href="http://qinghua.github.io/intelligence-age-book-review/"/>
    <id>http://qinghua.github.io/intelligence-age-book-review/</id>
    <published>2017-07-02T08:51:23.000Z</published>
    <updated>2017-07-06T01:01:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>上个月刚刚读完吴军的<a href="https://book.douban.com/subject/26838557/" target="_blank" rel="external">《智能时代》</a>，本文总结并记录一些笔记及感想。<br><a id="more"></a></p>
<h2 id="数据、信息、知识和智能"><a href="#数据、信息、知识和智能" class="headerlink" title="数据、信息、知识和智能"></a>数据、信息、知识和智能</h2><p>在谈论数据时，人们经常将其与信息相混淆。其实信息来源于数据，但是并非所有的数据都承载着有用的信息。例如，对于<code>dd if=/dev/zero of=ggg.txt bs=1k count=10000</code>这样的一个10M文件来说，里面的每一个bit都为0，所以并不能提供什么有意义的信息。而且，无意义和伪造的数据都会干扰和影响我们。通过对信息的处理，可以获取知识，以推动人类文明的发展。例如：通过测量星球的位置和对应的时间，我们可以得到数据；通过处理这些数据得到星球运动的轨迹，就是信息；通过信息总结出开普勒三定律，则是知识。而人类的智能往往体现在：获取数据→分析数据→建立模型→预测未知上。</p>
<p>现在我们所说的人工智能有两个定义：狭义的人工智能指的是20世纪五六十年代的研究机器智能的特定方法，即传统人工智能方法，专注于让机器像人一样地去思考；广义的人工智能指的是任何可以让计算机通过图灵测试的方法，即让一台机器和一个人在幕后，一位裁判同时与他们交流，看看裁判是否能够分辨出自己交流的对象是机器还是人。以翻译为例：传统的方法就是针对某两种语言编写大量的规则，以反映人类的思考方式；而现代的方法则是通过数据驱动，用机器学习的方式训练出翻译模型的各种参数。在互联网出现以前，很难获取到大量的有效数据，因而实用性不高。但是在如今的大数据时代，获取大量数据已经成为了可能。越来越多的信息可以使模型越来越准确，进而使翻译的效果越来越好。这里有个大数据预测美国大选的例子：2012年有人把互联网上公开的新闻、Facebook、Twitter等选战数据按照州来整理，竟然成功地预测了全部50+1个州的选举结果。</p>
<p>数据的作用过去常常被人们所忽视。首先是由于过去的数据量不足（少了大数据的大，Vast）；其次是数据缺乏相关性（少了多维度，即多样性Variety）。而现在的数据量由于计算机本身的数据、传感器的数据以及旧信息的数字化，比过去增加了许多，使量变足以成为了质变。数据驱动方法过去的死穴在于，使用基于概率统计的模型会有很多小概率事件覆盖不到。只有提高数据的完备性才行。这在以前是很难做到的，比如搜集全国所有人的面孔。但是如今这样的事情也并非遥不可及。所以我们也许需要重新认识穷举法，在大数据时代它并不像想象中的那样笨。数据的相关性也非常重要。我上班的时候会经过一家广东肠粉的小吃店，招牌上“广”字的一点已经脱落，成了“厂东肠粉”。我们的智能当然能够判断出来这是广东而不是厂东，但是大数据呢？首先它并不能找到什么有意义的“厂东”，但是能找到广东，并且“厂”和“广”字形非常接近。但是这样也无法否定是不是有个小地方叫“厂东”，或是老板的名字叫“厂东”。所以需要交叉验证。接下来发现“广东”和“肠粉”两字经常出现，有相关性。这样数据的相关性便大大提升了可信度。要是有图片，还能根据“厂”的字形比另外三个字稍扁来做进一步的交叉验证，准确性就能够更上一层楼。实际上如果在baidu搜索“厂东肠粉”的时候，它已经会问你“您要找的是不是: 广东肠粉”。Google虽然并不提示你，但显示的搜索结果也都是广东肠粉。当大家都意识到数据的重要性后，市场上的竞争就从技术的竞争转变成了数据的竞争，智能问题已经演变成了数据问题。<br><img src="/img/intelligence-age-guang-dong.png" alt=""></p>
<h2 id="智能革命"><a href="#智能革命" class="headerlink" title="智能革命"></a>智能革命</h2><p>我们现在说起机械思维，总觉得它是个贬义词。但其实它正是以前推动工业革命的要素。机械思维认为世界变化的规律是确定的，因此规律可以被认识，并且可以用公式或语言描述清楚，放之四海而皆准。但成也萧何败萧何，它的局限性正是否认了不确定性和不可知性。世界的不确定性首先来自影响世界的变量实在太多，以至于无法套用公式算出结果。其次世界本身也是不确定的，人类对于世界的观察将会改变世界本身，如量子力学的不确定性原理。但是不确定并不意味着没有规律可循。香农在概率论的基础上，用信息论将世界的不确定性与信息联系了起来，给了人们一种看待世界和处理问题的全新思路。</p>
<p>新思路为我们带来了大数据思维。它的核心是：数据中所包含的信息可以帮助我们消除不确定性，而数据之间的相关性在某种程度上可以取代原来的因果关系，帮助我们得到想知道的答案。例如，根据大数据的统计结果，可以发现在视频网站上投放零食的广告效果很好，我们可以据此猜出人们在看视频时喜欢吃零食。所以这种新的思维方法允许我们在不知道原因的情况下直接从大量数据中寻找答案，即无监督学习。虽然机器推算出来相关的事情只有一定的概率，但是世界本身就充满了不确定性，100%的准确率固然是好，但是90%的结果也是非常有价值的。这就是思维的革命。</p>
<p>还有产业的革命。套用一个公式：<strong>现有产业 + 新技术 = 新产业</strong>。例如：</p>
<ul>
<li>第一次工业革命：现有产业 + 蒸汽机 = 新产业</li>
<li>第二次工业革命：现有产业 + 电 = 新产业</li>
<li>现今的信息革命：现有产业 + 摩尔定律 = 新产业</li>
<li>由大数据引发的智能革命：<ul>
<li>现有产业 + 大数据 = 新产业</li>
<li>现有产业 + 机器智能 = 新产业</li>
</ul>
</li>
</ul>
<p>在瓦特改良万能蒸汽机之后，很多上千年历史的古老行业都通过使用蒸汽机而变为新产业，如纺织业冲击了几千年来的家庭纺织业，而瓷器则由白色黄金变成了日用品等。并不需要每一个工厂都去制造蒸汽机，而大多数工厂都会受益于蒸汽机。到了19世纪末，电力的应用也催生了各种新产业，如建筑业通过使用电梯使人们可以把楼盖高，交通运输业通过电车、地铁等公共交通促进了城市的发展，形成了大都市。但是也不需要太多的供电公司，对于美国而言就是通用电气和西屋电气，而大多数公司都会受益于电。“二战”之后，许多产业在使用计算机之后产生了质的变化，如金融业、通信业等。计算机处理器是信息革命的代表产品，但是同样并不需要有很多生产它的公司，今天大部分的处理器都是来自Intel或AMD以及ARM公司所设计的产品，而大部分电脑和智能设备都离不开它们。正在到来的智能革命，也将催生和改造出许多的新产业，但同样，并不是所有公司都会掌握大数据或是培养出机器智能，而大多数公司都将受益于大数据和机器智能。</p>
<h2 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h2><p>新革命的到来当然不会是一帆风顺的，首先要解决的是技术上的挑战。大量的数据必然需要大量的存储，并使查找和使用数据的时间剧增。早期存储数据的磁带和软盘根本不可能承担起存储如此海量数据的任务。硬盘虽然容量上去了，但是其存取速度仍然受限于机械运动。直到SSD的崛起和平价化，才使得在存储技术上适应了大数据。数据的传输也是一个挑战，直到移动互联网和WIFI技术的兴起，才使得大量数据的传输成为可能。而对数据的处理，则受益于摩尔定律，处理器速度增加并越来越便宜，从而导致并行处理技术如Map Reduce等的发展。也有目前还没完全解决的问题，如数据的标准化等。Google设计了一种称为<a href="https://github.com/google/protobuf" target="_blank" rel="external">Protocal Buffer</a>的数据格式，并已开源供大家使用。</p>
<p>技术问题解决后，就是商业问题了。如何获得一个全集的大数据呢？例如，为了了解电视的收视率，显然不能再一个个地去发传单、打电话了。最好的方法是通过机顶盒记录用户的收视情况。但是掌握这些数据的生产厂商和有线电视运营商当然不会轻易地把这些数据分享出来。所以Google推出了自己的电视机顶盒Google TV，为获取数据进入电视广告市场做准备，但是销售结果很糟糕，据说后来每个季度退回来的机顶盒比卖出去的还多。以至于Google在2014年斥巨资收购了还在亏损状态的nest公司，以获取nest公司的产品（恒温器）在每一个家庭的数据。一些公司已经敏锐地发现了数据的价值，而另一些公司却捧着金饭碗要饭。</p>
<p>还有数据的安全。首先由于数据量大，数据一旦丢失或被盗，损失将是巨大的。一种行之有效的方式就是利用大数据本身的特点来保护大数据的信息安全。如果外来的入侵者侵入了计算机系统，由于对业务的不熟悉，他的操作很可能与众不同，因此可以通过与大数据的对比而被发现，从而被制止。还有就是对于隐私的保护。如果导航系统能够帮人们导航并避开拥堵路段，那也说明它知道每个人的行踪。一旦这些信息暴露出来，这是非常危险的。再比如说<a href="http://www.sohu.com/a/117859356_469880" target="_blank" rel="external">《大数据高手塔吉特：我知道你怀孕了！》</a>。现在的很多公司都或多或少具备了这样的能力，只是大家不知道或者不注意而已。甚至连淘宝的商家都有可能收集到你的信息，从而决定给你寄真货还是寄假货。</p>
<p>最后，随着生产力的进一步发展，机器将会抢掉许多人的饭碗：工人、医生、律师、翻译、编辑、中间商等等。特斯拉的汽车装配厂都是由机器人操作，很少雇佣汽车行业的人员，而所雇的都是IT人员。机器将会从大数据中学习到各种专家的知识，甚至表现得更好。那未来如此多失业的人将会怎么办？目前人类还没有很好的办法，只能靠“拖”字决。一两代之后，无法掌握新技能的人也已经到了退休年龄了。AI会有更好的办法么？也许AI会发现只需要让大家陷入深深的睡眠就可以了。《黑客帝国》又向现实迈进了一步。但是AI毕竟来自于大数据，而不是全数据。有朝一日醒来的人类，也许能够通过制造不常见的场景，引发AI的bug，就像李世石曾经战胜AlphaGo的那一盘围棋一样。而埃隆·马斯克用“<a href="https://www.huxiu.com/article/201384.html" target="_blank" rel="external">脑机接口</a>”的宏伟蓝图来应对AI。既然人类可能最终会被AI消灭，那不如就让人类与AI成为一体。</p>
<p>“2%的人将控制未来，成为他们或被淘汰”。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上个月刚刚读完吴军的&lt;a href=&quot;https://book.douban.com/subject/26838557/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《智能时代》&lt;/a&gt;，本文总结并记录一些笔记及感想。&lt;br&gt;
    
    </summary>
    
      <category term="AI" scheme="http://qinghua.github.io/categories/AI/"/>
    
    
      <category term="AI" scheme="http://qinghua.github.io/tags/AI/"/>
    
  </entry>
  
</feed>
