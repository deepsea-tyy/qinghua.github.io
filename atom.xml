<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>懒程序员改变世界</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://qinghua.github.io/"/>
  <updated>2018-04-18T01:51:45.000Z</updated>
  <id>http://qinghua.github.io/</id>
  
  <author>
    <name>Qinghua Gao</name>
    <email>ggggqh666@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>软件开发有没有高下</title>
    <link href="http://qinghua.github.io/it-depends/"/>
    <id>http://qinghua.github.io/it-depends/</id>
    <published>2018-04-08T13:09:58.000Z</published>
    <updated>2018-04-18T01:51:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>俗话说“文无第一，武无第二”，软件开发归类于“文”，还是“武”？这个问题本身就有争议。想痛快地吵上一吵吗？进来看看吧。<br><a id="more"></a></p>
<h2 id="大家都来吵"><a href="#大家都来吵" class="headerlink" title="大家都来吵"></a>大家都来吵</h2><p>软件涉及到的领域太广，以至于程序员之间、程序之间很多时候难分伯仲。你可能也经常会听见一些牛逼的程序员们互相吵来吵去，很多时候并不是自己拥有一个完美的解决方案，而是觉得对方的解决方案在特定情况下不好。当然没有十全十美的方案。举个简单的例子，我们奉行的DRY（Don’t Repeat Yourself）原则，要求我们不要WET（Write Everything Twice或者We Enjoy Typing）。可即便是这么通用的原则，也可以被质疑：这样就失去了两边各自变化的能力了。听起来似乎有些道理，但是回头想想，两边各自变化的可能性有多大？这样的可能性在每个人的眼中是不一样的。因为大家的背景不一样，也许某人知道更多的未来需求，也许某人预见业务增长将会很快，也许某人曾经在这上面吃过亏……不一而足。</p>
<p>像DRY这样，但是更加令人难以决断的例子还有很多，列了一些常见的如下：</p>
<ul>
<li><strong>缩进用空格还是TAB？</strong><br><a href="https://stackoverflow.blog/2017/06/15/developers-use-spaces-make-money-use-tabs/" target="_blank" rel="external">据说用空格的程序员收入比用TAB的多</a>，你还打算继续用TAB吗？</li>
<li><strong>Java的变量名要不要默认加final？</strong><br>加上去是有它的好处，但是很烦不是吗？它的价值是否能抵过你的烦恼？这有一个<a href="http://www.javapractices.com/topic/TopicAction.do?Id=23" target="_blank" rel="external">最佳实践</a>，但是否应该采用？</li>
<li><strong>应该测试先行地去TDD，还是补上单元测试就好了？</strong><br>测试驱动开发当然是<a href="http://www.extremeprogramming.org/rules/testfirst.html" target="_blank" rel="external">测试先行</a>，但现实中往往有许多不容易写第一个测试的情况。怎么破？</li>
<li><strong>要不要写注释？</strong><br><a href="https://refactoring.guru/smells/comments" target="_blank" rel="external">重构</a>告诉我们注释很可能是坏味道，应该先尝试重构以让注释变得多余。但就有极端人士认为<a href="https://softwareengineering.stackexchange.com/questions/1/comments-are-a-code-smell" target="_blank" rel="external">所有代码中的注释都是多余</a>的。我们的观点呢？</li>
<li><strong>用不用设计模式？</strong><br>你有没有这样的经历，学完设计模式以后，编程时总想着套到什么地方去？到底应该何时用、怎么用、用多少？</li>
<li><strong>要不要尽量内联（inline）？</strong><br>有一种编程风格是尽量inline所有的变量，除非很不好懂，需要用变量名来解释。例如：<pre><code class="java">String name = someService.getName();
String result = otherService.getResult(name);
<span class="keyword">return</span> result;
</code></pre>
需要重构为：<pre><code class="java"><span class="keyword">return</span> otherService.getResult(someService.getName());
</code></pre>
因为比较简洁嘛。我原来也倾向于使用这种风格。但是新团队的风格是尽量抽变量，理由是方便调试。比如一行中要是出错了呢？调试时要是想知道返回值呢？当然可以查看<code>otherService.getResult(someService.getName())</code>，但是这个操作要是不幂等呢？似乎也有几分道理。</li>
<li><strong>要不要用Java 8的Lambda？</strong><br>曾经有人对我说，最好别用Lambda，因为会的员工不多，不好维护。站在他当时的立场上看，这个理由确实成立。但如果总是这样，新技术岂不是永远都上不了台了？</li>
<li><strong>用异常还是返回值来处理验证逻辑？</strong><br>这也是个比较经典的问题，原来认为<a href="https://stackoverflow.com/questions/299068/how-slow-are-java-exceptions" target="_blank" rel="external">异常影响性能</a>，但随着时代的演进，我们更倾向于<a href="https://stackoverflow.com/questions/4670987/why-is-it-better-to-throw-an-exception-rather-than-return-an-error-code" target="_blank" rel="external">使用异常</a>了。当然<a href="https://softwareengineering.stackexchange.com/questions/184654/ive-been-told-that-exceptions-should-only-be-used-in-exceptional-cases-how-do" target="_blank" rel="external">争论还在继续</a>。</li>
<li><strong>代码覆盖率要不要100%？</strong><br>追求100％的代码覆盖率究竟有没有意义？上80％可能比较轻松，但是最后的20％可能需要付出额外80％的劳动，值得不值得？那么，<a href="https://stackoverflow.com/questions/90002/what-is-a-reasonable-code-coverage-for-unit-tests-and-why" target="_blank" rel="external">代码覆盖率设置为多少比较合理</a>?</li>
<li><strong>要不要结对编程？</strong><br>一人工作一人看，结对编程效率低。但是结对的关键不是效率，而是质量。这又涉及到下面这个问题：</li>
<li><strong>如何衡量软件质量？</strong><br>代码行数、代码覆盖率、缺陷率、圈复杂度……但是它们足够吗？应该如何看待这些值？换个问题，如何衡量软件复杂性？这个问题又涉及到下面的问题：</li>
<li><strong>如何衡量程序员的KPI？</strong><br><a href="https://softwareengineering.stackexchange.com/questions/26596/metric-by-which-to-hold-developers-accountable" target="_blank" rel="external">这很难</a>。只能参考而无绝对。</li>
<li><strong>软件该如何收费？</strong><br>虽然现在看起来有点而离谱，但是很早以前曾经任职的公司确实是按行数收费的，行数＝编写的代码行数＋自动生成的代码×系数（如20％）。更加透明一点的是按工时收费。</li>
<li><strong>可以不用QA吗？</strong><br>曾任职的公司开展过一场“去QA化”运动，现在也不提了。这里的<a href="https://www.zhihu.com/question/19666055/answer/13399364" target="_blank" rel="external">回答</a>很有意思。</li>
<li><strong>是否把修复CI当做第一优先级的事情？</strong><br>这是测试别人是不是了解CI的三个问题之一。当然修复CI的优先级很高。但是有多高呢？我们在实践中是根据具体情况有所取舍的。线上生产环境的问题，才是第一优先级的事情。甚至就连上面这句话有时也不成立。</li>
<li><strong>要不要代码审查？如何审查？</strong><br>大部分人还是认同代码审查的，但是审查方式可以有很多种。最直接的是团队成员都围着电脑看代码，让一个没参与的人来讲解。但是可能费时很多，而且不是所有人都能进入状态，有的人喜欢一起看，有的人喜欢单独看。有一种方式是工具的支持，可以进行一对一的审查，这个可以挖个坑单写一片文章了。</li>
<li><strong>要不要鼓励项目中使用多种技术，比如多种测试框架，版本管理工具等？</strong><br>这里存在着工作效率与提升技能之间的小冲突。使用已经用过的技术当然开发起来更快，但是也是去了尝新的机会，或者说是乐趣。而过量的技术运用到一个项目中，也会带来沉重的负担。</li>
<li><strong>PHP是不是世界上最好的语言？</strong><br>我还是不评论了吧，免得挨揍。</li>
</ul>
<h2 id="底线还得有"><a href="#底线还得有" class="headerlink" title="底线还得有"></a>底线还得有</h2><p>对于永远稳定不会变化的需求（尽管很少，但这样的需求确实存在）而言，软件开发也许就能够分出高下来。举个例子：一个确定不会被重用的小工具。在这种情况下，可以适用的原则是：<strong>越快越好</strong>。我们甚至可以适当允许一些bug的存在，因为修复它们所需的时间可能大于手动修复运行结果所需的时间。另外，永远稳定不会变化的需求真的就永远不会变化吗？未必。但是在开发的某个时间点上，它确实是被认为是永远不会再变化的了。唯一不变的是变化本身。</p>
<p>曾经有同事去印度当了几个月的程序员讲师，回来后告诉我，在回答学员们的问题时，讲师们说得最多的就是这句话：“It depends.”。这基本上是一个放之四海而皆准的原则：<strong>具体情况具体分析</strong>。那是不是所有的问题都直接无脑地“具体情况具体分析”就完了？当然可以，但这是一种思想上的懒，不是我这“懒程序员”的“懒”。因为这句话对解决问题并不能有太多实质上的帮助嘛。关键是，我们还得就着“具体情况”来“分析”。所以，我们可以在其上再构建一些原则，来覆盖特定的情况。</p>
<p>比如说设计模式，它是对特定问题的特定解决方案。不要一股脑儿就往上套，好的经验是在发现坏味道以后，重构到设计模式，甚至是重构了一半，就已经消除掉坏味道了。原则：<strong>越简单越好</strong>。<br>比如说final，它并不能带来明显可观的价值，所以应该以大多数人的习惯为先。原则：<strong>贴近大多数人的习惯</strong>。<br>比如说lambda，明显它是更加先进的生产力，所以上面的原则就不适用了，应该以先进的生产力为先。原则：<strong>采用先进的生产力</strong>。<br>比如说代码覆盖率，高覆盖率自然是好，但是值得吗？比如Java可能就很难做到100％，但JS就能轻松一些。原则：<strong>采用性价比高的方案</strong>。<br>从“代码审查”中我们也可以看到，每个人都是不一样的，我在<a href="/effective-communication">人际风格与有效沟通实战</a>中也曾提到不同风格的人。原则：<strong>因人而异</strong>。<br>从“尽量内联”、“异常或返回值”中我们也可以看到，应该保持开放的心态来调整各原则。原则：<strong>原则需要与时俱进</strong>。<br>比如说要不要写注释，大多数情况下，组织得当的方法名、变量名已经能够说明问题了，这时的注释就显得多余。但偶尔还是需要介绍一块代码的来龙去脉，这时的注释就是必要的。原则：<strong>具体情况具体分析</strong>。</p>
<p>我们现在已经有了好几条原则了：</p>
<ul>
<li><strong>越快越好</strong></li>
<li><strong>越简单越好</strong></li>
<li><strong>贴近大多数人的习惯</strong></li>
<li><strong>采用先进的生产力</strong></li>
<li><strong>采用性价比高的方案</strong></li>
<li><strong>因人而异</strong></li>
<li><strong>原则需要与时俱进</strong></li>
<li><strong>具体情况具体分析</strong></li>
</ul>
<p>有些原则可能在特定的情况下是冲突的，需要自己思考究竟哪条原则更加符合现实情况。在适当的时候使用适当的原则（就像设计模式一样），而不是拿着锤子看见啥都像钉子（也像设计模式一样）。另外，需求是变化的，我们的原则也不必一成不变。有句话说“规则是用来打破的”。我想说的是，在充分理解规则之后，再来决定是不是打破它，并承担相应的后果。或者，考虑是不是用更高级的规则（如“具体情况具体分析”）来约束它，或是用更低级的规则来覆盖它吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;俗话说“文无第一，武无第二”，软件开发归类于“文”，还是“武”？这个问题本身就有争议。想痛快地吵上一吵吗？进来看看吧。&lt;br&gt;
    
    </summary>
    
      <category term="idea" scheme="http://qinghua.github.io/categories/idea/"/>
    
    
      <category term="idea" scheme="http://qinghua.github.io/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>挖掘IntelliJ IDEA的实用功能</title>
    <link href="http://qinghua.github.io/intellij-idea-utilities/"/>
    <id>http://qinghua.github.io/intellij-idea-utilities/</id>
    <published>2018-03-03T05:52:49.000Z</published>
    <updated>2018-03-03T06:27:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了<a href="https://www.jetbrains.com/idea/" target="_blank" rel="external">IntelliJ IDEA</a>的一些相对不那么广为人知的实用功能。希望能让你的IDE发挥出最大的功效！下文使用的IDEA版本是<code>2017.2.6</code>社区版，快捷键是<code>Mac OS X</code>。<br><a id="more"></a></p>
<h2 id="多重选择"><a href="#多重选择" class="headerlink" title="多重选择"></a>多重选择</h2><p>Sublime Text有一个非常好用的功能，就是可以选择多个光标，允许一起编辑。IDEA也向其学习，提供了类似的功能。只要按住<strong>Alt+Shift</strong>时，用鼠标点击其它位置即可。还可以通过<strong>Ctrl+G</strong>选择下一个相同的字符串，或是<strong>Ctrl+Command+G</strong>选择所有相同的字符串。如下图：<br><img src="/img/idea-multiple-selections.png" alt=""></p>
<p>还有一个功能是纵向选择，可以通过<strong>Command+Shift+8</strong>来开关。之后的效果如下：<br><img src="/img/idea-column-selection.png" alt=""></p>
<p>有一个注意事项就是，多重选择的时候不要用IDE自带的重构功能。</p>
<p>官方文档传送门：<a href="https://www.jetbrains.com/help/idea/editor-basics.html#editor_lines_code_blocks" target="_blank" rel="external">https://www.jetbrains.com/help/idea/editor-basics.html#editor_lines_code_blocks</a></p>
<h2 id="文件比较器"><a href="#文件比较器" class="headerlink" title="文件比较器"></a>文件比较器</h2><p>比较两个项目中的文件很简单，选中这两个文件，然后<strong>Command+D</strong>就可以了。JAR文件、文件夹也能够进行比较：<br><img src="/img/idea-compare-folders.png" alt=""></p>
<p>如果只有一个文件在项目中，那就选中它，然后<strong>Command+D</strong>，再从对话框中打开项目外的文件即可。如果另一个文件在剪贴板，那就打开项目中的文件，然后右击编辑器选择<strong>Compare with Clipboard</strong>即可。</p>
<p>如果两个文件都不在项目中……那好歹复制一个进去呗。</p>
<p>官方文档传送门：<a href="https://www.jetbrains.com/help/idea/comparing-files.html" target="_blank" rel="external">https://www.jetbrains.com/help/idea/comparing-files.html</a></p>
<h2 id="正则校验器"><a href="#正则校验器" class="headerlink" title="正则校验器"></a>正则校验器</h2><p>如果你写了个（或搜了个）炫酷的正则表达式，除了单元测试，IDEA也提供了简便的测试方式。比如对于如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Pattern EMAIL_PATTERN = Pattern.compile(<span class="string">"^([a-zA-Z0-9_\\-\\.]+)@([a-zA-Z0-9_\\-\\.]+)\\.([a-zA-Z]&#123;2,5&#125;)$"</span>);</div></pre></td></tr></table></figure></p>
<p>在正则的字符串中按下<strong>Alt+Enter</strong>，选择<strong>Check RegExp</strong>，然后填入想校验的字符串即可：<br><img src="/img/idea-check-regexp.png" alt=""></p>
<p>官方文档传送门：<a href="https://www.jetbrains.com/help/idea/regular-expression-syntax-reference.html#tips-tricks" target="_blank" rel="external">https://www.jetbrains.com/help/idea/regular-expression-syntax-reference.html#tips-tricks</a></p>
<h2 id="Emmet"><a href="#Emmet" class="headerlink" title="Emmet"></a>Emmet</h2><p>还在写这样的html吗？早就out了……<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">id</span>=<span class="string">"users"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">tr</span> <span class="attr">class</span>=<span class="string">"user"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>只要输入<code>table#users&gt;tr.user&gt;td*3</code>然后按下<strong>TAB</strong>就行了。能自动生成的，我们就不自己写。不过这个功能只在后缀名为<code>html</code>或<code>xml</code>的文件编辑器中生效，所以创建一个html文件然后再试试吧。</p>
<p>这里有一张Emmet的语法表：<a href="https://docs.emmet.io/cheat-sheet/" target="_blank" rel="external">https://docs.emmet.io/cheat-sheet/</a></p>
<p>官方文档传送门：<a href="https://www.jetbrains.com/help/idea/emmet.html" target="_blank" rel="external">https://www.jetbrains.com/help/idea/emmet.html</a></p>
<h2 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h2><p>如果你看到这样的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> name + <span class="string">" is "</span> + age + <span class="string">" years old."</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>就会忍不住想把它变成这样的话：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> StringBuilder().append(name)</div><div class="line">                          .append(<span class="string">" is "</span>)</div><div class="line">                          .append(age)</div><div class="line">                          .append(<span class="string">" years old."</span>)</div><div class="line">                          .toString();</div></pre></td></tr></table></figure></p>
<p>只要在等号后面的语句中按下<strong>Alt+Enter</strong>，选择<strong>Replace ‘+’ with ‘StringBuilder.append()’</strong>即可。也可以选择<strong>Replace ‘+’ with ‘String.format()’</strong>，来把它变成这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> String.format(<span class="string">"%s is %d years old."</span>, name, age);</div></pre></td></tr></table></figure></p>
<p>所以当你准备拼接字符串了，考虑这个功能吧，比自己慢慢写要顺手多了。其实<strong>Alt+Enter</strong>这个万能快捷键在不同的代码下支持许多不同的功能，没事在代码上随便敲一敲，你会发现惊喜的。</p>
<h2 id="本地历史"><a href="#本地历史" class="headerlink" title="本地历史"></a>本地历史</h2><p>通过<strong>VCS</strong>菜单中，<strong>Local History</strong>的<strong>Show History</strong>，可以打开当前文件的本地修改历史。如果某个版本你并没有提交过，只是在本地曾经改过，但是又改掉了，就可以利用这个功能将其找回。甚至还可以针对字段、方法、文件夹、乃至整个项目来查看。所以保存量是比较大的，IDEA默认就保留五个工作日的本地历史，有一周一般来说也就够了吧。这个值也能通过传给JVM的参数<code>localHistory.daysToKeep</code>来修改。如果因为磁盘不够等原因不想要，也可以把它设置为0。<br><img src="/img/idea-local-history.png" alt=""></p>
<p>官方文档传送门：<a href="https://www.jetbrains.com/help/idea/local-history.html" target="_blank" rel="external">https://www.jetbrains.com/help/idea/local-history.html</a></p>
<h2 id="测试覆盖率"><a href="#测试覆盖率" class="headerlink" title="测试覆盖率"></a>测试覆盖率</h2><p>通过<strong>Run</strong>菜单里的<strong>Run ‘xxxTest’ with Coverage</strong>，可以在运行测试时顺便跑出测试覆盖率。通过<strong>Analyze</strong>菜单里的<strong>Show Coverage Data</strong>，可以查看覆盖率的大致情况。而通过<strong>Generate Coverage Report</strong>，可以生成测试报告，在报告里可以看到具体的每一行是否运行过。这是覆盖率数据：<br><img src="/img/idea-coverage-data.png" alt=""></p>
<p>这是测试报告：<br><img src="/img/idea-coverage-report.png" alt=""></p>
<p>官方文档传送门：<a href="https://www.jetbrains.com/help/idea/viewing-code-coverage-results.html" target="_blank" rel="external">https://www.jetbrains.com/help/idea/viewing-code-coverage-results.html</a></p>
<h2 id="生产力指南"><a href="#生产力指南" class="headerlink" title="生产力指南"></a>生产力指南</h2><p>点击<strong>Help</strong>菜单里的<strong>Productivity Guide</strong>，就能看到一张大表，记录着各功能的使用情况。注意一下使用频率低的，了解一下从未使用过的，很快就能成为Intellij IDEA的砖家了。<br><img src="/img/idea-productivity-guide.png" alt=""></p>
<p>官方文档传送门：<a href="https://www.jetbrains.com/help/idea/productivity-guide.html" target="_blank" rel="external">https://www.jetbrains.com/help/idea/productivity-guide.html</a></p>
<p>IntelliJ IDEA还有许多的插件、调试技巧等，这里先挖个坑，等以后的文章再填吧～</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍了&lt;a href=&quot;https://www.jetbrains.com/idea/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;IntelliJ IDEA&lt;/a&gt;的一些相对不那么广为人知的实用功能。希望能让你的IDE发挥出最大的功效！下文使用的IDEA版本是&lt;code&gt;2017.2.6&lt;/code&gt;社区版，快捷键是&lt;code&gt;Mac OS X&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="tool" scheme="http://qinghua.github.io/categories/tool/"/>
    
    
      <category term="IntelliJ IDEA" scheme="http://qinghua.github.io/tags/IntelliJ-IDEA/"/>
    
  </entry>
  
  <entry>
    <title>敲最少的键，编最多的码</title>
    <link href="http://qinghua.github.io/type-less-code-more/"/>
    <id>http://qinghua.github.io/type-less-code-more/</id>
    <published>2018-02-04T05:42:53.000Z</published>
    <updated>2018-03-03T06:28:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道在软件开发中，效率是很重要的环节。结对编程时，有些手快的人想到哪里就能编到哪里，恨不得分分钟从手慢的人那儿把键盘抢过来。今天的这篇文章主要是如何用好<a href="https://www.jetbrains.com/idea/" target="_blank" rel="external">IntelliJ IDEA</a>这个著名的IDE，以实现：“敲最少的键，编最多的码”。虽说本文的示例是Java，其它语言区别也不大，尤其是当现在的<a href="https://www.jetbrains.com/products.html" target="_blank" rel="external">JET BRAINS全家桶</a>已经是如此齐备时。<br><a id="more"></a></p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>废话不多说，在环境准备好的情况下，假设我们来测试驱动开发一个计算一天有多少个小时的API。参见以下的两分半小视频：</p>
<iframe frameborder="0" width="640" height="498" src="https://v.qq.com/iframe/player.html?vid=s0545lt9r2e&tiny=0&auto=0" allowfullscreen></iframe>

<p>要是视频不清晰或看不到，就直接到<a href="https://v.qq.com/x/page/s0545lt9r2e.html" target="_blank" rel="external">腾讯视频</a>中看720P吧。</p>
<p>如何才能做到”敲最少的键，编最多的码“呢？除了掌握技巧之外，就是多练习实践了。以下就是技巧的内容。</p>
<h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><p>首先把环境准备一下。只要有<code>src</code>和<code>test</code>即可。我自己是一个默认的Maven新项目，在<code>pom</code>中引用了<code>junit</code>。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"> &lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></div><div class="line">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.ggg<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ggg<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>专业版的IDEA支持项目模板，如果你对默认的模板不满意，项目模板能够节省你的一部分操作。</p>
<h2 id="步骤分解"><a href="#步骤分解" class="headerlink" title="步骤分解"></a>步骤分解</h2><ol>
<li>快捷键：在<code>test/java</code>中用快捷键<strong>Ctrl+N</strong>生成文件。</li>
<li>文件模版：选择的<code>JUnit</code>正是我事先创建好的文件模板，内容见下文的“功能简介”。这里的一个小诀窍是先按下<strong>u</strong>，可以过滤掉不需要的模板。</li>
<li>输入：输入<code>HoursCalculatorTest</code>并回车，测试文件就此生成。</li>
<li>代码自动生成：移动光标到合适位置，用快捷键<strong>Ctrl+N</strong>自动生成<strong>Test Method</strong>。</li>
<li>输入：将测试方法命名为<code>should_get_24_hours_for_1_day</code>。</li>
<li>输入：这里需要新建一个测试目标，即<code>new HoursCalculator()</code>。</li>
<li>快捷键：因为<code>HoursCalculator</code>类还不存在，所以会报错，用快捷键<strong>F2</strong>移动到下一个错误处，再用快捷键<strong>Alt+Enter</strong>自动修复错误，选择<strong>Create class ‘HoursCalculator’</strong>。</li>
<li>代码自动生成：输入<code>org.ggg</code>自动生成<code>HoursCalculator</code>类。</li>
<li>快捷键：<strong>Ctrl+Tab</strong>回到上一个文件即我们的测试类。<strong>Command+Alt+V</strong>将<code>new HoursCalculator()</code>抽取为一个变量<code>hoursCalculator</code>，<strong>Command+Shift+Enter</strong>结束本行，将光标跳至下一行开头。</li>
<li>输入：输入<code>int hoursByDay = hoursCalculator.getHoursByDay(1)</code>来获取计算结果。小诀窍是只要输入<code>hc</code>，IDEA就会提示<code>hoursCalculator</code>。</li>
<li>代码自动生成：还是<strong>Alt+Enter</strong>自动修复错误，选择<strong>Create method ‘getHoursByDay’</strong>，便能在<code>HoursCalculator</code>类中自动生成<code>getHoursByDay</code>方法。</li>
<li>输入：一路回车，可以把参数名改为<code>days</code>。</li>
<li>快捷键：还是<strong>Ctrl+Tab</strong>回到测试类，然后<strong>Command+Shift+Enter</strong>结束本行（分号会自动补齐）。</li>
<li>输入：输入<code>assertEquals(24,hoursByDay)</code>，还是<strong>Command+Shift+Enter</strong>结束本行（还会调整格式）。</li>
<li>快捷键：<strong>Ctrl+Shift+F10</strong>运行测试，红了。用<strong>Ctrl+Tab</strong>回到<code>HoursCalculator</code>类准备修改实现。</li>
<li>输入：把返回值从<code>0</code>改为<code>24</code>。</li>
<li>快捷键：<strong>Shift+F10</strong>运行上个测试，这回绿了。用<strong>Ctrl+Tab</strong>回到我们的测试类，准备编写下一个测试。</li>
<li>活动模板：将光标移动到合适的位置，输入<strong>test</strong>和<strong>TAB</strong>键。可以看到生成了另一个测试方法。当然我们在此也可以用上面的“代码自动生成”，这里不过是用了另一种方法而已。<code>test</code>是我事先创建好的活动模板，内容见下文的“功能简介”。</li>
<li>输入：将方法命名为<code>should_get_48_hours_for_2_days</code>。之后按照类似上文的方式，实现并执行测试，红了。令方法返回<code>24 * day</code>并再次执行测试，绿了。移动光标到测试方法之外，执行全部测试，都绿了，保证后一个实现不会破坏前一个实现。</li>
<li>快捷键：现在是tdd的重构阶段。<code>24</code>是一个magic number，所以我们要用<strong>Command+Alt+C</strong>将其变成一个常量，如<code>hoursInDay</code>。不过常量应该还是大写的蛇式比较符合惯例，于是可以<strong>Shift+F6</strong>改名。</li>
<li>插件：我事先安装了<strong>string-manipulation</strong>插件，所以可以直接使用快捷键<strong>Alt+M</strong>并选择<strong>4. To SCREAMING_SNAKE_CASE</strong>将变量改名为<code>HOURS_IN_DAY</code>。其实现在版本的IDEA已经会在快捷键改名时提示<code>HOURS_IN_DAY</code>了，但是插件支持的功能更加丰富一些，并且也能在编辑非java文件时使用。</li>
<li>快捷键：用<strong>Shift+F10</strong>运行上次运行的全部测试，依然是绿的。</li>
<li>快捷键：测试文件还不在包中，用<strong>F6</strong>将其移入<code>org.ggg</code>中。还可以用<strong>Command+Alt+O</strong>来优化import部分。</li>
<li>快捷键：再次用<strong>Shift+F10</strong>运行测试，依然是绿的，重构完成。</li>
</ol>
<h2 id="用到的IDE功能简介"><a href="#用到的IDE功能简介" class="headerlink" title="用到的IDE功能简介"></a>用到的IDE功能简介</h2><h3 id="快捷键（Shortcuts）"><a href="#快捷键（Shortcuts）" class="headerlink" title="快捷键（Shortcuts）"></a>快捷键（<a href="https://resources.jetbrains.com/storage/products/intellij-idea/docs/IntelliJIDEA_ReferenceCard.pdf" target="_blank" rel="external">Shortcuts</a>）</h3><p>我用的是<strong>Mac OS X</strong>的Keymap。常用的快捷键要牢记，很多时候它决定了程序员的效率如何。JET BRAINS的各种语言的IDE快捷键都比较类似，花点精力记住它决不会吃亏。</p>
<h3 id="文件模板（File-Templates）"><a href="#文件模板（File-Templates）" class="headerlink" title="文件模板（File Templates）"></a>文件模板（<a href="https://www.jetbrains.com/help/idea/file-and-code-templates.html" target="_blank" rel="external">File Templates</a>）</h3><p>顾名思义，文件模板即是新建文件时使用到的模板。我们在上面的步骤中使用的<code>JUnit</code>活动模板如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#if ($&#123;PACKAGE_NAME&#125; &amp;&amp; $&#123;PACKAGE_NAME&#125; != "")package $&#123;PACKAGE_NAME&#125;;#end</div><div class="line"></div><div class="line">import org.junit.Test;</div><div class="line"></div><div class="line">import static org.junit.Assert.*;</div><div class="line">#parse("File Header.java")</div><div class="line">public class $&#123;NAME&#125; &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它的语法基于<a href="http://velocity.apache.org/engine/devel/user-guide.html#Velocity_Template_Language_VTL:_An_Introduction" target="_blank" rel="external">Apache Velocity</a>，支持变量，如<code>${PACKAGE_NAME}</code>表示包名，<code>${NAME}</code>表示用户输入的名称，等等。</p>
<p>可以通过在<strong>Preferences</strong>中搜索<strong>File and Code Templates</strong>，来创建或修改文件模板。也可以在一开始<strong>Ctrl+N</strong>时选择<strong>Edit File Templates…</strong>。</p>
<h3 id="活动模板（Live-Templates）"><a href="#活动模板（Live-Templates）" class="headerlink" title="活动模板（Live Templates）"></a>活动模板（<a href="https://www.jetbrains.com/help/idea/live-templates.html" target="_blank" rel="external">Live Templates</a>）</h3><p>活动模板与文件模板类似，但它不需要新建文件，可以在文件的任何地方激活，只需要输入名字后加一个<strong>TAB</strong>即可。我们在上面的步骤中使用的<code>test</code>活动模板如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> $NAME$() &#123;</div><div class="line">    $END$</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中的<code>$END$</code>表示最后光标会出现在哪里。在此，表示光标最后会出现在方法体内，以便于继续编写实现。</p>
<p>可以通过在<strong>Preferences</strong>中搜索<strong>Live Templates</strong>，来创建或修改活动模板。</p>
<h3 id="代码自动生成（Generating-Code）"><a href="#代码自动生成（Generating-Code）" class="headerlink" title="代码自动生成（Generating Code）"></a>代码自动生成（<a href="https://www.jetbrains.com/help/idea/generating-code.html" target="_blank" rel="external">Generating Code</a>）</h3><p>有许多常用的代码，例如getter、setter、constructor、equals&amp;hashCode等等，IDEA都能够通过这个功能帮助自动生成。</p>
<p>我们在上面的步骤中使用了<strong>Ctrl+N</strong>生成了junit的测试方法，用<strong>Alt+Enter</strong>通过修复错误的方式来生成类和方法。</p>
<h3 id="插件（Plugins）"><a href="#插件（Plugins）" class="headerlink" title="插件（Plugins）"></a>插件（<a href="https://www.jetbrains.com/help/idea/managing-plugins.html" target="_blank" rel="external">Plugins</a>）</h3><p>IDEA支持<a href="https://plugins.jetbrains.com/idea_ce" target="_blank" rel="external">许多插件</a>。插件的功能强大，能够做到从修改字符串到语言级别的支持。比如我们用的版本控制系统VCS就是用插件的方式开发的。</p>
<p>我们在上面的步骤中使用了<a href="https://plugins.jetbrains.com/plugin/2162-string-manipulation" target="_blank" rel="external"><strong>string-manipulation</strong>插件</a>。安装完插件，别忘了重启IntelliJ IDEA。你也可以<a href="https://www.jetbrains.com/help/idea/creating-a-project-for-plugin-development.html" target="_blank" rel="external">编写自己的插件</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道在软件开发中，效率是很重要的环节。结对编程时，有些手快的人想到哪里就能编到哪里，恨不得分分钟从手慢的人那儿把键盘抢过来。今天的这篇文章主要是如何用好&lt;a href=&quot;https://www.jetbrains.com/idea/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;IntelliJ IDEA&lt;/a&gt;这个著名的IDE，以实现：“敲最少的键，编最多的码”。虽说本文的示例是Java，其它语言区别也不大，尤其是当现在的&lt;a href=&quot;https://www.jetbrains.com/products.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JET BRAINS全家桶&lt;/a&gt;已经是如此齐备时。&lt;br&gt;
    
    </summary>
    
      <category term="tool" scheme="http://qinghua.github.io/categories/tool/"/>
    
    
      <category term="IntelliJ IDEA" scheme="http://qinghua.github.io/tags/IntelliJ-IDEA/"/>
    
      <category term="TDD" scheme="http://qinghua.github.io/tags/TDD/"/>
    
  </entry>
  
  <entry>
    <title>个人的技术债</title>
    <link href="http://qinghua.github.io/personal-tech-debt/"/>
    <id>http://qinghua.github.io/personal-tech-debt/</id>
    <published>2018-01-01T03:12:13.000Z</published>
    <updated>2018-01-01T07:01:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zh.wikipedia.org/wiki/%E6%8A%80%E6%9C%AF%E8%B4%9F%E5%80%BA" target="_blank" rel="external">技术债</a>是一个借用了财务债的绝妙隐喻（<a href="http://www.extremeprogramming.org/rules/metaphor.html" target="_blank" rel="external">极限编程XP的实践</a>之一），表示当我们为了短期利益（如按时完成开发），而在技术上对软件的长期质量进行的妥协。它一般用于项目管理，但其实也广泛地存在于各个地方，比如每个人的身上。<br><a id="more"></a></p>
<h2 id="项目的技术债"><a href="#项目的技术债" class="headerlink" title="项目的技术债"></a>项目的技术债</h2><p>技术债的起源和后果、解决方式等，网上一搜一大把，我这里就不再赘述了。这里总结一点常见的误区：</p>
<ul>
<li>技术债是邪恶的：这里借用维基百科的一小段话：“第一次发布代码，就好比借了一笔钱。只要通过不断重写来偿还债务，小额负债可以加速开发。但久未偿还债务会引发危险。复用马马虎虎的代码，类似于负债的利息”。健康的债务是好事，谁买房子不贷款（土豪请随意）？</li>
<li>技术债必须偿还：有时候你写一段小程序，只希望尽快跑起来看看，然后将之抛弃。程序由于没有重构，而充斥着各种反模式（它们都是技术债！）。我自己就写了不少，用毕即弃。这里面的债……反正我自己是没有兴趣也没有时间偿还。有些项目的代码，你知道永远也不会有人会动（当然这个很主观，并且取决于你的经验），或者是很快就要完蛋的，我也倾向于先不还这个债，真的到了出现万一的时候，那就再还吧。还债是有成本的，如果感觉还债成本将要上升，也许就应该还这个债了。有没有一种lazy的感觉？</li>
<li>开发新功能优先于偿还技术债：这是一个it depends的问题，谁高谁低取决于对债和利息的判断及不同角色间的博弈。如果利息趋近于零，当然可以先不考虑还债；如果新功能的投资预期带来大把的收益，当然可以先开发新功能。</li>
<li>技术债可以避免：如果这样的话，只要没有新功能，就永远不必发新版本了。没有完美的人，没有完美的程序。别想躲开它，想想怎么处理它。</li>
</ul>
<h2 id="个人的技术债"><a href="#个人的技术债" class="headerlink" title="个人的技术债"></a>个人的技术债</h2><p>Martin Fowler把<a href="https://martinfowler.com/bliki/TechnicalDebt.html" target="_blank" rel="external">技术债</a>分为<a href="https://martinfowler.com/bliki/TechnicalDebtQuadrant.html" target="_blank" rel="external">四个象限</a>，如下图所示：<br><img src="/img/tech-debt-quadrant.png" alt=""></p>
<p>项目在不断前进，做项目的人也是不断前进的。项目需要还债来让自己运转良好，人不也一样需要还债让自己进步吗？参考上图，我也画了张个人的技术债四象限，如下图所示：<br><img src="/img/personal-tech-debt-quadrant.png" alt=""></p>
<p>这四个象限不都是技术债的源头吗？下面我们来具体分析一下每一个象限：</p>
<p><strong>有意的－慎重的：清理</strong>。例如，我知道项目上需要用到drools，它对未来的项目可能会很有用，可惜当时没条件深入学习。又或者项目上用到了JJTree，它有些过时了，以后也基本用不上，不需要浪费时间在这上面。这是两个不同的例子，因为你是有意地做出了选择，所以凭你的经验来决定吧，是否应该把它放到你的个人技术债上。<br><strong>有意的－草率的：思考</strong>。例如，当时工作太忙，虽然知道docker能够解决这个问题，但没时间去学，至于项目嘛，凑合能用就好了。现在回头想想，还能凑合吗？因为草率，所以需要思考；因为有意，所以还要选择。是否放入你的个人技术债，你自己决定吧。<br><strong>无心的－慎重的：复盘</strong>。例如，当时不知道其实AWS可以满足项目的需求，但是现在知道了，很可能用AWS可以节省一大部分的开发和运维成本，但也可能有坑。在这种情况下，我们可以做一次复盘，如果项目再来一遍应该怎样？把收获到的经验用到下一个项目中吧。<br><strong>无心的－草率的：求知</strong>。例如，我并不知道前端技术大爆炸有那么多的框架可选，现在我也不太了解，反正有活儿我就上JQuery。用一句绕口的话总结就是：不知道自己不知道什么。如果是这样，那么就应该先高层次地了解一下背景知识，起码让自己不至于抓瞎吧。之后再慢慢将自己的知识体系建立起来。</p>
<p>接下来就该给你的债排优先级，用<a href="http://wiki.mbalib.com/wiki/%E6%97%B6%E9%97%B4%E2%80%9C%E5%9B%9B%E8%B1%A1%E9%99%90%E2%80%9D%E6%B3%95" target="_blank" rel="external">时间“四象限”法</a>，XY轴分别是重要性和紧急性。重要又紧急的债先还；重要不紧急的债可以制定计划；紧急但不重要的，不值得投入大把的时间，够用就好；不重要不紧急的就尽量放弃吧，除非这个债是你的兴趣爱好之所在。</p>
<p>2017年已经远离，是不是在收获了许多成果的同时，也留下了一些遗憾？2018年的余额也已充值完毕，去年（说不定去了好几年呢）欠下的债，该考虑怎么还一还了吧？</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%8A%80%E6%9C%AF%E8%B4%9F%E5%80%BA&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;技术债&lt;/a&gt;是一个借用了财务债的绝妙隐喻（&lt;a href=&quot;http://www.extremeprogramming.org/rules/metaphor.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;极限编程XP的实践&lt;/a&gt;之一），表示当我们为了短期利益（如按时完成开发），而在技术上对软件的长期质量进行的妥协。它一般用于项目管理，但其实也广泛地存在于各个地方，比如每个人的身上。&lt;br&gt;
    
    </summary>
    
      <category term="idea" scheme="http://qinghua.github.io/categories/idea/"/>
    
    
      <category term="idea" scheme="http://qinghua.github.io/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>《Java函数式编程》出版啦</title>
    <link href="http://qinghua.github.io/functional-programming-in-java/"/>
    <id>http://qinghua.github.io/functional-programming-in-java/</id>
    <published>2017-12-24T02:04:22.000Z</published>
    <updated>2017-12-24T02:48:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>从2017年年初到年底，我的新译作<a href="https://book.douban.com/subject/27594722/" target="_blank" rel="external">《Java函数式编程》</a>终于出版啦。这里简要地介绍一下本书，并放篇我为此书所作的译者序，安利一下。<br><a id="more"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>《Java函数式编程》并不是一本关于Java的书，而是一本关于函数式编程的书。作者由浅入深地介绍了函数式编程的思维方式，并引导读者通过易于掌握的例子、练习和图表来学习和巩固函数式编程的基本原则和最佳实践。读者甚至可以在阅读的同时编写出自己的函数式类库！</p>
<p>与<a href="https://book.douban.com/subject/26346017/" target="_blank" rel="external">《Java 8函数式编程》</a>相比（这是一本Java 8的函数式用法的入门佳作），本书侧重的是函数式的思维与实践，而非是Java 8的语法。如果你是一位看完基础语法书后喜欢接着看“Effective”系列的程序员，那么本书就有几分类似于“Effective”版，只不过它讲的是函数式而非是Java 8的“Effective”。语言容易过时或被淘汰，但是思想永存。</p>
<p><img src="/img/functional_programming_in_java_en.jpg" alt=""><br><img src="/img/functional_programming_in_java_cn.jpg" alt=""></p>
<h2 id="译者序"><a href="#译者序" class="headerlink" title="译者序"></a>译者序</h2><p>有幸受邀翻译本书。初见书名，心中不免有几分疑虑，难道又是一本教你怎么使用Java 8 lambda来函数式编程的书吗？翻了几页，方觉自己大误。本书其实意在如何从零开始，逐步理清函数式编程的思维方式并编写基础类库，不仅授之以鱼，而且授之以渔。只不过由于Java的受众实在太广，所以才使用这门语言罢了。</p>
<p>函数式编程有一个至关重要的前提，那就是函数的输出只能取决于函数的参数（我们会在书中看到生成随机数的例子）。初看上去似乎与Java这门面向对象的语言不搭。但语言只是工具而已，正如你也可以在Haskell中编写命令式风格的代码。在一个不太复杂、甚至非并发的常规Java系统中，由于程序内部状态的改变，多次调用同一个方法的返回值很可能是不一样的，更不用说所带来的副作用了。函数式编程中，确定的输入决定了确定的输出，就意味着只要参数对了，结果一定在预期中。也就是说，函数式编程没有无法重现的bug。在这样的前提下，单元测试相对容易实现，而且能极大地增强你的信心。（想想你对目前所在项目的单元测试有多大的信心？）许多个这样的函数复合起来，在不改变信心的同时能够提供更多更强大的功能，进而带来更大的收益，如无状态的线程安全、必要时才计算的惰性求值、加快多次执行速度的记忆化等等。</p>
<p>传统的命令式编程是计算机硬件的抽象，源自图灵机，其实就是外部输入、内部状态、对外部的输出以及对内部状态的改变。函数式编程源自λ演算，即将变量和函数替换为或值表达式并根据运算符计算。函数式编程相比命令式编程代码更简洁、可读性更强，这是因为它的思维方式更倾向于描述要什么，而不是怎么做。所以学习过程反而更加自然，并且不需要多么高深的数学基础。可是我们也知道，软件开发没有银弹。新的方法论也会带来新的问题，需要运用新知识来解决。幸运的是，新知识的坑已经有人帮你踩过了，高阶函数、偏应用函数、复合函数、柯里化、闭包……软件开发从来不缺术语。幸好它们并非高不可攀，作者将会在第二章中扫清你的疑虑，并在后续章节中挑战惰性求值、记忆化、状态处理、应用作用还有actor等更高级的技术。你说Monad？作者才不告诉你它究竟是什么，但是看完本书你自然就领悟了。</p>
<p>函数式编程不是万能药。它有自己擅长的领域，也有自己的弱项。函数式编程是级别更高的抽象。高级别抽象带来的收益就是易读、好写，可是有些低级别的事情（如果你真的需要的话）可能就不容易完成。函数式编程没有副作用，导致无法完成输入/输出操作。尽管如此，你也会在本书中看到一些解决办法。函数式编程没有变量，因此无法改变循环的终止条件，故而没有循环，严重依赖于用递归来抽象循环。在某些情况下可能会影响性能，所以你还会在本书中看到一些性能与情怀之间的权衡。绝大部分的编程最佳实践都是针对某个特定的场景而言的。因此脱离业务场景直接讨论技术并不可取。拥有函数式编程的思维，你就拥有了解决问题的另一种选择，但是条条大路通罗马，千万别钻牛角尖。程序是对现实世界的建模，“不要让世界适应你的模型。让你的模型适应世界。”</p>
<h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>感谢作者Pierre-Yves Saumont，不仅写了这样一本令程序员们受益匪浅的书，而且耗费精力维护本书的后续重构，还耐心地回答我对书中的疑问，使我有机会提高中文版的翻译质量。<br>感谢永恒的侠少和刘舫，让我可以集中精力专注于翻译之上，并让本书得以出版。<br>感谢瑞民，虽然世事变幻莫测，但是你始终扮演了非常重要的角色。<br>感谢家人和朋友们，我永远离不开你们的鼓励和支持。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从2017年年初到年底，我的新译作&lt;a href=&quot;https://book.douban.com/subject/27594722/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《Java函数式编程》&lt;/a&gt;终于出版啦。这里简要地介绍一下本书，并放篇我为此书所作的译者序，安利一下。&lt;br&gt;
    
    </summary>
    
      <category term="development" scheme="http://qinghua.github.io/categories/development/"/>
    
    
      <category term="book" scheme="http://qinghua.github.io/tags/book/"/>
    
  </entry>
  
  <entry>
    <title>懒程序员笔记</title>
    <link href="http://qinghua.github.io/lazy-programmer/"/>
    <id>http://qinghua.github.io/lazy-programmer/</id>
    <published>2017-12-06T13:09:58.000Z</published>
    <updated>2017-12-28T01:26:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>坚持更新“懒程序员改变世界”的博客已经两年了，近期准备和老友办一个“懒程序员笔记”的订阅号，既然都是“懒程序员”的主题，那就围绕着它写点儿什么吧。<br><img src="/img/lazy-programmer-notes-qrcode.png" alt=""><br><a id="more"></a></p>
<p>有一篇文章叫<a href="http://www.jiemian.com/article/427711.html" target="_blank" rel="external">《世界是由懒人创造的》</a>（真的是马云分享的吗？），大致意思就是懒人推动了世界的发展。因为懒，才能创造出一堆的发明，来让我们的生活更方便。当然了，文章弥漫着浓浓的调侃氛围。赞赏、批判这篇文章的人都有不少，至于我的观点嘛，想必从本文的标题中也能看出一二。但是请别忘记，原文最后也写了：“要懒出风格，懒出境界”。</p>
<p>在程序员的世界中，偷懒尤其重要。懒得造轮子？网上大把大把的开源库等着你试用。不想稍微改点代码就从头到位测一遍？那就用自动化测试吧。不想每次部署的时候手忙脚乱？那就上持续交付。不想每次总跟客户扯皮？那就搞敏捷，把客户变成团队的一员。不想让开发和运维互斗？那就拥抱DevOps，大家都在一条船上。可以说，“偷懒”是技术进步的原动力。有些人喜欢说“痛点驱动”，其实它们是一回事，因为没法儿偷懒，所以很“痛”啊。程序员们也非常厌恶重复性的劳动，例如填写工时、定期发送邮件、给别人权限、教新人如何配置环境等等等等。</p>
<p>可是光靠偷懒能够解决问题吗？要是你不想做那么无聊的事情，但是又没有解决的办法，如何才能推动世界进步呢？有道是“创新靠懒，实现靠勤”。唯有学习和思考不能偷懒。你有一个工具箱，你懒，那就用工具箱里的工具来让你懒得其所。可如果你的工具箱是空的，你怎么偷懒啊？有些人看上去非常的勤奋，整天忙个不停，似乎非常充实。但是，偶尔夜深失眠的时候，可能内心也会感觉到一阵恐慌吧。因为忙碌占据了他全部的时间，而真正需要的沉淀、思考、总结的时间基本没有。这样的人只是用勤奋来自欺欺人，掩盖自己懒得思考的本质。有个词叫“低品质勤奋者”很好地涵盖了这一类人。我也曾是其中一员，现在还不时会偷懒，但我已经知道了，不要“用身体的勤奋掩盖思想的懒惰”。</p>
<p>偷懒节省出来的时间都上哪儿去了？学习、思考、与家人相伴。偶尔的放纵没什么关系，但是主旋律还是要保持清醒的大脑，经常使其运转，如果大脑平时不怎么动，可能在关键时刻也就转不动了。如何开始恢复大脑的正常运转？从每天给自己留点独处的时间，深度思考一下今天做了什么有意义的事情，怎样还能做得更好开始吧。一定要坚持，无论刮风下雨，生病加班，因为以我自己的经验来看，一旦破例，很容易便会再次破例，从而使曾经的坚持迅速土崩瓦解。但是可以根据当天的状况灵活控制时间。写文章也是一种有效的思考总结的方法，在此也推荐给大家。试试看，只要走出第一步，总能找到一条适合自己的路。</p>
<p>最后让我们来膜拜一下著名的懒程序员们吧。</p>
<ul>
<li>Nihad Abbasov在<a href="https://github.com/NARKOZ/hacker-scripts" target="_blank" rel="external">github</a>上分享了一个项目，里面包含了一堆的脚本，包括加班时给太太发短信、宿醉时给自己请假、根据自己从工位走到咖啡机的用时来煮咖啡……</li>
<li>Etherable在<a href="https://workplace.stackexchange.com/questions/93696/is-it-unethical-for-me-to-not-tell-my-employer-i-ve-automated-my-job" target="_blank" rel="external">StackExchange</a>上表示，他偷偷写了一段程序，使它十分钟就能完成过去一个人月才能完成的工作。而自己每周改改规范、发发邮件什么的只需一两个小时就够了。于是在程序员中掀起了一场道德辩论，究竟应不应该告诉老板？</li>
<li><a href="http://money.163.com/13/0117/08/8LDJ5PPO00252V0H.html" target="_blank" rel="external">美最懒程序员不干活 支付1/5薪水工作全外包中国</a>。这样的懒程序员，虽然不是本文提倡的类型，但也懒出了风格，堪称跨界人才。</li>
<li>阿里的4位程序员，懒得跟大家抢购月饼，写了段js脚本，<a href="https://www.zhihu.com/question/50600301" target="_blank" rel="external">结果</a>大家都知道了……</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;坚持更新“懒程序员改变世界”的博客已经两年了，近期准备和老友办一个“懒程序员笔记”的订阅号，既然都是“懒程序员”的主题，那就围绕着它写点儿什么吧。&lt;br&gt;&lt;img src=&quot;/img/lazy-programmer-notes-qrcode.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="idea" scheme="http://qinghua.github.io/categories/idea/"/>
    
    
      <category term="idea" scheme="http://qinghua.github.io/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>SSH妙用</title>
    <link href="http://qinghua.github.io/ssh-tricks/"/>
    <id>http://qinghua.github.io/ssh-tricks/</id>
    <published>2017-11-25T07:29:42.000Z</published>
    <updated>2017-11-26T03:28:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近方才了解到，原来可以通过SSH以配置SOCKS代理的方式，不用开VPN便能够科学上网，于是便搜集了一些SSH的用法，以供未来参考。<br><a id="more"></a></p>
<h2 id="无密码登录"><a href="#无密码登录" class="headerlink" title="无密码登录"></a>无密码登录</h2><p>只要把自己的公钥保存在远程主机上就可以了，如果本机尚未生成公私钥对（可以通过<code>ls ~/.ssh</code>查看是否存在以<code>pub</code>为扩展名的文件），可以通过<code>ssh-keygen</code>生成一个。之后把这个<code>pub</code>文件的内容全部复制到远程主机上的<code>~/.ssh/authorized_keys</code>中就能够实现无密码登录了。复制的过程也可以用以下命令实现：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-copy-id user@remote.host.name</div></pre></td></tr></table></figure></p>
<p>Mac上默认没有<code>ssh-copy-id</code>，可以通过以下命令安装：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install ssh-copy-id</div></pre></td></tr></table></figure></p>
<h2 id="远程执行命令"><a href="#远程执行命令" class="headerlink" title="远程执行命令"></a>远程执行命令</h2><p>配置完无密码登录后，在远程主机上执行命令很简单，只要在最后面加一个字符串即可：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh remote.host.name <span class="string">"hostname"</span></div></pre></td></tr></table></figure></p>
<p>如果命令很长，是个脚本，那就这么搞：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> -e <span class="string">"ls\necho ggg"</span> &gt; cmd.txt</div><div class="line">ssh remote.host.name <span class="string">"`cat cmd.txt`"</span></div></pre></td></tr></table></figure></p>
<p>下面分享一段调试时查看远程日志的实用代码。如果你不知道自己的请求会被负载均衡到哪台服务器上去，可以试试下面这个ssh到所有服务器上执行<code>tail -F</code>的小脚本（当然也能用<code>cat</code>了）：<br><figure class="highlight sh"><figcaption><span>tail_log</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="built_in">set</span> -e</div><div class="line"></div><div class="line"><span class="keyword">if</span> [ -z <span class="variable">$1</span> ]; <span class="keyword">then</span></div><div class="line">  <span class="built_in">echo</span> <span class="string">"usage: <span class="variable">$(basename $0)</span> [log path] [optional grep message]"</span></div><div class="line">  <span class="built_in">echo</span> <span class="string">"sample: <span class="variable">$(basename $0)</span> /abc/def/application.log* Execption"</span></div><div class="line">  <span class="built_in">exit</span> 1</div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line">log_path=<span class="variable">$1</span></div><div class="line">grep_message=<span class="variable">$&#123;2-"''"&#125;</span></div><div class="line"></div><div class="line">hosts=(</div><div class="line">  <span class="string">"remote1.host.name"</span></div><div class="line">  <span class="string">"remote2.host.name"</span></div><div class="line">  <span class="string">"remote3.host.name"</span></div><div class="line">)</div><div class="line"></div><div class="line">remote_command=<span class="string">"tail -F <span class="variable">$&#123;log_path&#125;</span> | grep --line-buffered <span class="variable">$&#123;grep_message&#125;</span>"</span></div><div class="line"><span class="keyword">for</span> host <span class="keyword">in</span> <span class="string">"<span class="variable">$&#123;hosts[@]&#125;</span>"</span></div><div class="line"><span class="keyword">do</span></div><div class="line">  <span class="built_in">exec</span> <span class="string">"ssh -fo StrictHostKeyChecking=no <span class="variable">$&#123;host&#125;</span> \"<span class="variable">$&#123;remote_command&#125;</span>\" &amp;"</span></div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure></p>
<p>当然看完日志以后，别忘了把ssh的进程杀掉：<br><figure class="highlight sh"><figcaption><span>kill_log</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="built_in">kill</span> -9 $(ps -ef | grep <span class="string">"[s]sh -fo StrictHostKeyChecking=no"</span> | awk <span class="string">'&#123;print $2&#125;'</span>)</div></pre></td></tr></table></figure></p>
<p>稍微解释一下以上的两个参数：</p>
<ul>
<li><code>ssh -f</code>: 让SSH在后台执行，之所以在后面再加一个<code>&amp;</code>，是因为想让所有机器并行来tail日志。</li>
<li><code>ssh -o StrictHostKeyChecking=no</code>: 这样就看不到由于第一次连接或是机器指纹变更而出现的<strong>Are you sure you want to continue connecting (yes/no)?</strong></li>
</ul>
<h2 id="SSH隧道"><a href="#SSH隧道" class="headerlink" title="SSH隧道"></a>SSH隧道</h2><h3 id="配置SOCKS代理"><a href="#配置SOCKS代理" class="headerlink" title="配置SOCKS代理"></a>配置SOCKS代理</h3><p>超级简单：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -D 9999 remote.host.name</div></pre></td></tr></table></figure></p>
<p>这样便可以通过如下系统设置通过远程主机上网了（以mac为例）：<br><img src="/img/mac_proxy.jpg" alt=""></p>
<p>浏览器代理也是一样（以chrome插件SwitchyOmega为例）：<br><img src="/img/switchy_omega.jpg" alt=""></p>
<h3 id="本地端口转发"><a href="#本地端口转发" class="headerlink" title="本地端口转发"></a>本地端口转发</h3><p>如果你想让本地经由remote1访问remote2，可以这么做：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -L 9999:remote2.host.name:80 remote1.host.name</div></pre></td></tr></table></figure></p>
<p><code>-L</code>后面的参数，表示<strong>本地端口:目标主机：目标主机端口</strong>，也就是说，往本地9999端口发出去的请求，会经由remote1传给remote2的80端口。为什么我们会需要这样的东东呢？原因可能有几种：</p>
<ul>
<li>本地访问不了remote2（或remote2的指定端口），但是本地可以访问remote1，并且remote1可以访问remote2。如果公司的网络分为几块，互相之间操作有限制，可能就需要一些remote1作为跳板／堡垒机（bastion）来做这样的脏活儿。</li>
<li>被邪恶的防火墙挡住了去路的时候。</li>
<li>希望能够比较安全的时候。</li>
<li>有时候目标机器由于安全原因或其它原因，某个端口只能开放给自己。这时候就可以将remote1和remote2合而为一。例如，当Java调试所用的5050端口不对外开放时，就可以用以下命令让IDE在localhost的5050端口进行调试：<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -L 5050:localhost:5050 remote.host.name</div></pre></td></tr></table></figure>
</li>
</ul>
<p>中间的localhost是相对remote.host.name而言的，也就是它自己。</p>
<h3 id="远程端口转发"><a href="#远程端口转发" class="headerlink" title="远程端口转发"></a>远程端口转发</h3><p>在你的本地可以连通远程主机remote1和另一台远程主机remote2，而它们俩不能相互访问的情况下，如果你想让remote1能够访问remote2，就可以这么做：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -R 9999:remote2.host.name:80 remote1.host.name</div></pre></td></tr></table></figure></p>
<p>这样的话，remote1的本地用户便可以便可以通过你的9999端口，访问remote2的80端口了。相当于你把自己变成了一台堡垒机！如果你有权限在其它机器上运行远程端口转发的命令，那你也可以把它变成堡垒机，把你自己的客户机变成remote1了。</p>
<h2 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h2><p>SSH当然是可以用来复制文件的：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat file | ssh -e none remote-host <span class="string">"cat &gt; file"</span></div></pre></td></tr></table></figure></p>
<p>其中的参数<code>-e none</code>，表示不转义任何字符。SSH默认会通过<code>~</code>来转义一些控制语句。</p>
<p>但是既然我们有<code>scp</code>，还用<code>ssh</code>图个什么，用专业工具吧。</p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>可以用<a href="https://github.com/libfuse/sshfs" target="_blank" rel="external">sshfs</a>来将远程的文件系统通过SFTP加载到本地。对于mac而言，可以用<a href="https://osxfuse.github.io/" target="_blank" rel="external">FUSE for macOS</a>来实现。我还没有那样的需求，没试过，据说比较简单。有兴趣的读者可以自行尝试。</p>
<h2 id="其它环境"><a href="#其它环境" class="headerlink" title="其它环境"></a>其它环境</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>Windows的话，你可以就得试试<a href="http://www.putty.org/" target="_blank" rel="external">Putty</a>了。</p>
<h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><p>用手机和平板来运维？你值得拥有！<br><a href="https://juicessh.com/" target="_blank" rel="external">JuiceSSH</a>的基本功能时免费的，但是要想端口转发什么的就得收费了。用户体验很不错。<br><a href="https://play.google.com/store/apps/details?id=org.connectbot" target="_blank" rel="external">ConnectBot</a>是完全免费的。</p>
<h3 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h3><p><a href="https://itunes.apple.com/us/app/prompt-2/id917437289?mt=8" target="_blank" rel="external">Prompt</a>都说好，收费。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://matt.might.net/articles/ssh-hacks/" target="_blank" rel="external">SSH: More than secure shell</a><br><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html" target="_blank" rel="external">SSH原理与运用（二）：远程操作与端口转发</a><br><a href="https://blog.urfix.com/25-ssh-commands-tricks/" target="_blank" rel="external">25 Best SSH Commands / Tricks</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近方才了解到，原来可以通过SSH以配置SOCKS代理的方式，不用开VPN便能够科学上网，于是便搜集了一些SSH的用法，以供未来参考。&lt;br&gt;
    
    </summary>
    
      <category term="tool" scheme="http://qinghua.github.io/categories/tool/"/>
    
    
      <category term="ssh" scheme="http://qinghua.github.io/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>用Tampermonkey实现自动化网页操作</title>
    <link href="http://qinghua.github.io/tampermonkey/"/>
    <id>http://qinghua.github.io/tampermonkey/</id>
    <published>2017-10-21T07:42:45.000Z</published>
    <updated>2017-10-22T13:25:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://tampermonkey.net/" target="_blank" rel="external">Tampermonkey</a>是一个<a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo?hl=en" target="_blank" rel="external">浏览器插件</a>，可以在网页上嵌入自己编写的js脚本，支持除IE以外的大部分浏览器。还有一个更早的<a href="https://en.wikipedia.org/wiki/Greasemonkey" target="_blank" rel="external">Greasemonkey</a>（油猴）功能类似，可惜它只适用于<a href="https://addons.mozilla.org/en-US/firefox/addon/greasemonkey/" target="_blank" rel="external">Firefox</a>。Tampermonkey的源代码在<a href="https://github.com/Tampermonkey/tampermonkey" target="_blank" rel="external">Github</a>上。<br><a id="more"></a></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>原理其实很简单，就是在宿主页面载入完毕后，运行自己的js脚本罢了，从而实现对浏览器渲染后的html进行改变。除了让你浏览的网页更加个性化以外，还能为你提供一键解决实际问题的需求，例如隐藏广告、自动签到薅羊毛、抢票、每天/每周在网页上填写考勤表等。</p>
<p>Tampermonkey不仅允许使用这些脚本，并且可以编写、管理及同步。安装步骤与一般的插件无异。安装好后，下面拿一个例子练手。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>我们试试在<a href="https://www.baidu.com/" target="_blank" rel="external">百度</a>上增加“Google一下”的按钮。首先单击插件图标，点击“添加新脚本”，于是便进入了Tampermonkey的编辑器。上面的几行注释就是Tampermonkey自己的语法，保存了一些元数据，包括脚本的名字、版本、在满足什么规则的网页上生效等。我们把<code>@match</code>的内容修改为<code>https://www.baidu.com/*</code>，这样便能在百度域名下的所有网页中生效啦。</p>
<p>打开百度，可以看到“百度一下”的按钮：<code>id=&quot;su&quot;</code>，我们将“Google一下”插入到其后即可。在<code>// Your code here...</code>后面编写如下js代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'#su'</span>).after(<span class="string">'&lt;input type="button" id="google" value="Google一下" class="btn self-btn bg s_btn" style="background-color:grey;" onclick="googleIt" /&gt;'</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">googleIt</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="string">'google'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>保存并刷新百度，顺利地看到了灰色的“Google一下”。这说明我们的脚本起作用了。在插件图标的位置上页显示了一个红色的<code>1</code>，说明当前网页上的生效脚本数量为1。但是点击“Google一下”什么也没有弹出。在控制台上可以看到出错了：<strong>Uncaught ReferenceError: googleIt is not defined</strong>。这是因为所有代码都是<a href="https://stackoverflow.com/questions/16704209/onclick-added-with-tampermonkey-is-not-calling-the-function" target="_blank" rel="external">作为一个字符串被<code>eval</code></a>的，所以应该使用动态的方式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'#su'</span>).after(<span class="string">'&lt;input type="button" id="google" value="Google一下" class="btn self-btn bg s_btn" style="background-color:grey;" /&gt;'</span>);</div><div class="line">$(<span class="string">"#google"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    googleIt();</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这回点击按钮就能够正常工作了！我们现在要做的，就是把<code>alert</code>替换为打开Google页面即可：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">googleIt</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> searchText = <span class="built_in">document</span>.querySelector(<span class="string">'#kw'</span>).value;</div><div class="line">    location.href = getGoogleUrl(searchText);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGoogleUrl</span>(<span class="params">searchText</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'https://www.google.com/search?q='</span> + searchText;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>短短几行代码，就搞定了。Tampermonkey内置了一些对象与函数，可以让我们很方便地实现一些功能，如打开新窗口可以使用<code>GM_openInTab</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">googleIt</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> searchText = <span class="built_in">document</span>.querySelector(<span class="string">'#kw'</span>).value;</div><div class="line">    GM_openInTab(getGoogleUrl(searchText), <span class="literal">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第二个参数可以决定当前的焦点是老窗口还是新窗口。在使用内置函数之前，需要先<code>@grant</code>一下，如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// @grant        GM_openInTab</span></div></pre></td></tr></table></figure></p>
<p>否则无法生效。更多的内置函数可以在<a href="http://tampermonkey.net/documentation.php" target="_blank" rel="external">官方文档</a>中查看。</p>
<p>我们新写的代码并不会直接出现在控制台中，如果需要调试，可以在代码中增加<code>debugger;</code>，这样运行时就能自动停在这一行了。百度主页有引用jQuery，所以我们可以直接在代码中使用<code>$</code>。如果需要的页面上没有jQuery，那么可以通过这行命令引入：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//      @include https://code.jquery.com/jquery-3.2.1.min.js</span></div></pre></td></tr></table></figure></p>
<p>完整的代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ==UserScript==</span></div><div class="line"><span class="comment">// @name         Google on baidu</span></div><div class="line"><span class="comment">// @namespace    http://tampermonkey.net/</span></div><div class="line"><span class="comment">// @version      0.1</span></div><div class="line"><span class="comment">// @description  Google it!</span></div><div class="line"><span class="comment">// @author       ggg</span></div><div class="line"><span class="comment">// @match        https://www.baidu.com/*</span></div><div class="line"><span class="comment">// @grant        GM_openInTab</span></div><div class="line"><span class="comment">// ==/UserScript==</span></div><div class="line"></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="meta">    'use strict'</span>;</div><div class="line"></div><div class="line">    $(<span class="string">'#su'</span>).after(<span class="string">'&lt;input type="button" id="google" value="Google一下" class="btn self-btn bg s_btn" style="background-color:grey;" /&gt;'</span>);</div><div class="line">    $(<span class="string">"#google"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        googleIt();</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">googleIt</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> searchText = $(<span class="string">'#kw'</span>).val();</div><div class="line">        GM_openInTab(getGoogleUrl(searchText), <span class="literal">false</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getGoogleUrl</span>(<span class="params">searchText</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'https://www.google.com/search?q='</span> + searchText;</div><div class="line">    &#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p>不过这种做法存在两个问题：</p>
<ol>
<li>如果宿主网页变化，脚本需要随之变化。这也没办法，谁叫我们依赖它呢。好在宿主网页没事也不会经常变化。</li>
<li>“Google一下”的按钮会比原生的“百度一下”延迟一些才出来，体验上稍微差一些。毕竟相对而言我们的脚本只是二等公民。</li>
</ol>
<p>但是获益的巨大几乎可以让我们完全无视这些缺陷。</p>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>脚本也是代码，也有自己的版本，也能被多人所共享使用。只要它在因特网上的url以<code>.user.js</code>结尾，即可轻易分享给其他人。上面的这个例子我就放到了<a href="https://github.com/qinghua/tamperMonkeyScript/raw/master/googleit.user.js" target="_blank" rel="external">Github</a>中。分享出去的时候，如果对方安装了tampermonkey，就可以看到脚本的安装界面了。更多的共享脚本可以单击插件图标，点击“获取新脚本”，或是参考<a href="https://tampermonkey.net/scripts.php" target="_blank" rel="external">这里</a>来获得。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://tampermonkey.net/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Tampermonkey&lt;/a&gt;是一个&lt;a href=&quot;https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo?hl=en&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;浏览器插件&lt;/a&gt;，可以在网页上嵌入自己编写的js脚本，支持除IE以外的大部分浏览器。还有一个更早的&lt;a href=&quot;https://en.wikipedia.org/wiki/Greasemonkey&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Greasemonkey&lt;/a&gt;（油猴）功能类似，可惜它只适用于&lt;a href=&quot;https://addons.mozilla.org/en-US/firefox/addon/greasemonkey/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Firefox&lt;/a&gt;。Tampermonkey的源代码在&lt;a href=&quot;https://github.com/Tampermonkey/tampermonkey&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Github&lt;/a&gt;上。&lt;br&gt;
    
    </summary>
    
      <category term="development" scheme="http://qinghua.github.io/categories/development/"/>
    
    
      <category term="tampermonkey" scheme="http://qinghua.github.io/tags/tampermonkey/"/>
    
      <category term="js" scheme="http://qinghua.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>代码还是数据</title>
    <link href="http://qinghua.github.io/code-or-data/"/>
    <id>http://qinghua.github.io/code-or-data/</id>
    <published>2017-10-01T13:03:01.000Z</published>
    <updated>2017-10-01T13:42:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>这段逻辑是代码还是数据，对我来说从来都不曾是个问题，直到遇上了这么一个项目。<br><a id="more"></a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>一般来说，我们写程序，都是连同测试代码一起提交，至少也是一起代码审查。有一个关于收费的项目，偏偏反其道而行之。这个项目的一些背景如下：</p>
<ol>
<li>收费的逻辑通过DSL配置在代码库中。</li>
<li>对于这些逻辑，没有单元测试，但是有集成测试。</li>
<li>集成测试里面包含了request与response，在测试的时候回放request并比较response是否匹配。</li>
<li>集成测试是json文件，放在S3上。</li>
</ol>
<p>如果有一个对费率的修改，那么程序员除了往代码库中提交修改后的DSL，还会往S3更新json测试文件。这就带来了几个问题：</p>
<ul>
<li>代码审查者只能看到代码库的变动，除非再去S3上看测试数据，不然并不知道这段DSL的测试情况。而在S3上看测试数据相对比较繁琐，这样的机制可以说是鼓励代码审查者不去看测试数据。</li>
<li>没有版本管理（或者说由于S3与代码库的版本管理机制差别较大），导致这些测试不容易追踪，也不容易查看历史记录。</li>
<li>持续集成通过与否依赖于S3的数据。所以集成测试失败时，不一定能在解决时复原到失败时的状态。</li>
<li>DEV提交代码和更新测试数据这两步变成了一个原子操作，需要一起完成，至少在代码提交后、CI上运行集成测试之前更新S3。而在提交代码前更新S3又有破坏别人正在运行测试的风险。</li>
</ul>
<p>那么，为什么这个项目会选用这样的方案呢？原来，在设计的时候是这么考虑的：费率修改的需求来自于产品经理，希望测试数据能够由PM们提供。所以将会开发一个面向PM们的小系统，后台就是这个S3数据，这样的话到时候修改费率，就增加了一层来自需求方的保障。如果测试数据来自于代码库，那就很难通过页面来修改并提交代码库了。初衷还是不错的，但是仔细推敲下来，DEV自己的测试哪儿去了？这样运转起来后，是不是只会养成DEV把测试推给PM的习惯？</p>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>我觉得这里面有一个误区，就是把DEV自己的测试和PM的测试混为一谈了。实际上应该将它们分开来。为什么呢？DEV自己的测试其实本来就应该是代码的一部分，应该保存在代码库中。而PM的测试其实是对程序员测试的补充，也应该算是代码的一部分，如果能够放在代码库中固然是好，但是我们也不能对所有的PM们都抱有提交代码这样不切实际的期望，所以在这种情况下，S3算是一个权衡的方案。而CI上应该有两步，其一是DEV的测试，其二是PM的测试（在PM修改测试数据的小系统还没上线之前，可以暂不配置这个测试）。它们之间是顺序执行还是并发执行倒是无关紧要。但这样也有不尽如人意的地方：</p>
<ul>
<li>修改代码需要DEV和PM同时协作，最好一起修改，否则CI会红。但这正是DevOps运动所提倡的，不是么？</li>
<li>背景一节介绍的一些缺点在PM的测试中仍然存在。PM修改测试数据的小系统需要更加完善的版本管理和审计。这部分的开销可能还不小。</li>
</ul>
<p>顺便提一句，传统的PM测试数据是由DEV提供一个CSV格式，让PM填完之后由DEV添加到代码库中。在忽略DEV和PM的用户体验的情况下，这也是一个可行的方案。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到底什么样的逻辑应该进代码库，什么样的逻辑应该持久化呢？其实我们应该把逻辑区分为程序、配置和数据。</p>
<p>程序：<br>在代码库中，提供服务的主要功能。对其的修改通常都是改bug或是引入新功能。</p>
<p>配置：<br>在配置服务器中，但是配置的默认值很可能是在代码库中。经常需要修改，修改其值可以让程序表现出不同的处理逻辑。需要易于修改。</p>
<p>数据：<br>在持久化存储（一般是数据库）中，因用户而异，数量可能会比较大。随用户的操作而变化。需要有备份机制。</p>
<p>反推到上文所说：“收费的逻辑通过DSL配置在代码库中”。这段逻辑，也许应该是配置而非程序，因为它会经常需要修改。收费记录毋庸置疑，一定是数据了。从逻辑分类的角度上出发，你是否会发现其实自己现在的代码库中包含了太多的配置？</p>
<p>另外，虽然代码库似乎也可以用于配置或数据，但是最好还是别这么干，这里有一篇<a href="https://stackoverflow.com/questions/20151158/using-git-repository-as-a-database-backend" target="_blank" rel="external">stack overflow的问答</a>，解释得挺清楚的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这段逻辑是代码还是数据，对我来说从来都不曾是个问题，直到遇上了这么一个项目。&lt;br&gt;
    
    </summary>
    
      <category term="idea" scheme="http://qinghua.github.io/categories/idea/"/>
    
    
      <category term="soft skill" scheme="http://qinghua.github.io/tags/soft-skill/"/>
    
  </entry>
  
  <entry>
    <title>用JGit生成patch文件</title>
    <link href="http://qinghua.github.io/git-patch/"/>
    <id>http://qinghua.github.io/git-patch/</id>
    <published>2017-09-12T11:59:02.000Z</published>
    <updated>2017-09-12T09:51:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>上篇博文介绍了<a href="/jgit">JGit</a>，之后就开始做项目了。遇到的第一个问题是如何用JGit生成patch文件。<br><a id="more"></a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我希望在项目中能够实现这样的功能：用户发送一个request，服务器就帮用户生成代码并生成一个commit到用户本地的git中，但是这不太可能，因为用户的环境并不是服务器的环境。进一步的方案是直接在服务器端clone git仓库（或是维持一份最新代码），服务器本地生成commit并push，这样做会有一些安全方面需要考虑的因素。我采用的是退一步的方案，即让服务器生成一个patch文件并上传到<a href="https://aws.amazon.com/s3/" target="_blank" rel="external">S3</a>，以便用户稍后下载并apply到本地。</p>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><h3 id="api-command"><a href="#api-command" class="headerlink" title="api command"></a>api command</h3><p>打开JGit的<a href="https://github.com/eclipse/jgit/tree/master/org.eclipse.jgit/src/org/eclipse/jgit/api" target="_blank" rel="external">api包</a>一看，各种git命令应有尽有，如apply、cherry-pick等。但惟独没有format-patch命令。网上一搜，甚少有人有这样的需求或问题，只有<a href="http://www.codeaffine.com/2016/06/16/jgit-diff/" target="_blank" rel="external">这篇文章</a>比较靠谱，但是它介绍的侧重于diff而非生成patch。</p>
<h3 id="Patch"><a href="#Patch" class="headerlink" title="Patch"></a>Patch</h3><p>还是得找找patch相关的代码。源代码搜遍也就这个<a href="https://github.com/eclipse/jgit/blob/master/org.eclipse.jgit/src/org/eclipse/jgit/patch/Patch.java" target="_blank" rel="external">Patch.java</a>应该是patch文件的JGit模型，但是读完后发现，它只能把patch文件映射成这个模型，并不能反向从模型序列化为patch文件。</p>
<h3 id="DiffFormatter-DiffEntry"><a href="#DiffFormatter-DiffEntry" class="headerlink" title="DiffFormatter / DiffEntry"></a>DiffFormatter / DiffEntry</h3><p>DiffCommand其实上还是调用的DiffFormatter和DiffEntry，所以看看这俩是否能够支持什么样的参数，来生成patch文件呢？可惜还是无果。DiffFormatter的API也不太直观，不容易理解。但是它能够做一些diff commit这样的事情。</p>
<h3 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h3><p>走投无路之际，在<a href="https://git-scm.com/docs/git-format-patch" target="_blank" rel="external">git-format-patch</a>上看到，这个命令其实是用来生成<strong>用邮件发送</strong>的patch文件。难怪patch文件的前几行看起来有From，有Subject什么的，也许它们不是必须的？那就可以试试把diff的结果当作patch直接写入文件。</p>
<h2 id="动手时间"><a href="#动手时间" class="headerlink" title="动手时间"></a>动手时间</h2><p>首先创建一个git环境，a、b、c三个文件用来测试改删增：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">mkdir -p /tmp/ggg</div><div class="line"><span class="built_in">cd</span> /tmp/ggg</div><div class="line">git init</div><div class="line"><span class="built_in">echo</span> line a1 &gt; a.txt</div><div class="line"><span class="built_in">echo</span> line a2 &gt;&gt; a.txt</div><div class="line"><span class="built_in">echo</span> line b1 &gt; b.txt</div><div class="line">git add .</div><div class="line">git commit -m <span class="string">"first commit wiht a.txt and b.txt"</span></div><div class="line"><span class="built_in">echo</span> line a3 &gt;&gt; a.txt</div><div class="line"><span class="built_in">echo</span> line c1 &gt; c.txt</div><div class="line">rm b.txt</div><div class="line">git diff</div></pre></td></tr></table></figure></p>
<p>运行完成后就能看到diff文件的内容了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">diff --git a/a.txt b/a.txt</div><div class="line">index 7a3d45f..c723fac 100644</div><div class="line">--- a/a.txt</div><div class="line">+++ b/a.txt</div><div class="line">@@ -1,2 +1,3 @@</div><div class="line"> line a1</div><div class="line"> line a2</div><div class="line">+line a3</div><div class="line">diff --git a/b.txt b/b.txt</div><div class="line">deleted file mode 100644</div><div class="line">index b45d9fa..0000000</div><div class="line">--- a/b.txt</div><div class="line">+++ /dev/null</div><div class="line">@@ -1 +0,0 @@</div><div class="line">-line b1</div></pre></td></tr></table></figure></p>
<p>在程序中，如此这般运行git diff命令：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Git git = Git.init().setDirectory(<span class="keyword">new</span> File(<span class="string">"/tmp/ggg"</span>)).call();</div><div class="line">git.diff().setOutputStream(System.out).call();</div></pre></td></tr></table></figure></p>
<p>发现JGit的diff和Git的diff还是不太一样的。JGit的diff包含了新增文件的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">diff --git a/a.txt b/a.txt</div><div class="line">index 7a3d45f..c723fac 100644</div><div class="line">--- a/a.txt</div><div class="line">+++ b/a.txt</div><div class="line">@@ -1,2 +1,3 @@</div><div class="line"> line a1</div><div class="line"> line a2</div><div class="line">+line a3</div><div class="line">diff --git a/b.txt b/b.txt</div><div class="line">deleted file mode 100644</div><div class="line">index b45d9fa..0000000</div><div class="line">--- a/b.txt</div><div class="line">+++ /dev/null</div><div class="line">@@ -1 +0,0 @@</div><div class="line">-line b1</div><div class="line">diff --git a/c.txt b/c.txt</div><div class="line">new file mode 100644</div><div class="line">index 0000000..8e37e08</div><div class="line">--- /dev/null</div><div class="line">+++ b/c.txt</div><div class="line">@@ -0,0 +1 @@</div><div class="line">+line c1</div></pre></td></tr></table></figure></p>
<p>这就非常合适了。只要证明它能够被作为patch导入到git中即可。首先修改代码输出到文件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">File patch = <span class="keyword">new</span> File(<span class="string">"/tmp/jgit.patch"</span>);</div><div class="line">Git git = Git.init().setDirectory(<span class="keyword">new</span> File(<span class="string">"/tmp/ggg"</span>)).call();</div><div class="line"><span class="keyword">try</span> (OutputStream outputStream = <span class="keyword">new</span> FileOutputStream(patch)) &#123;</div><div class="line">    git.diff().setOutputStream(outputStream).call();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后清空修改过的文件：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /tmp/ggg</div><div class="line">git checkout .</div><div class="line">git clean -df</div><div class="line">git status</div></pre></td></tr></table></figure></p>
<p>现在尝试apply patch：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git apply /tmp/jgit.patch</div><div class="line">git status</div></pre></td></tr></table></figure></p>
<p>果然成功了。在不考虑冲突的情况下，看起来这一招还是管用的。但是由于缺失了commit的信息，所以运行<code>git am /tmp/jgit.patch</code>就会报错：<em>Patch format detection failed.</em>有没有办法解决这个问题呢？当然了。我们现在知道了patch只不过是多了一些邮件信息罢了，那我们自己就可以生成。在<code>try</code>内增加如下代码，模拟<code>git format-patch</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">    outputStream.write(<span class="string">"From: GGG &lt;ggg@somewhere.com&gt;\n"</span>.getBytes());</div><div class="line">    outputStream.write(<span class="string">"Date: Tue, 12 Sep 2017 20:16:10 +0800\n"</span>.getBytes());</div><div class="line">    outputStream.write(<span class="string">"Subject: [PATCH] ggg is not here. Turn left and ask JGit\n"</span>.getBytes());</div><div class="line">    outputStream.write(<span class="string">"\n---\n\n"</span>.getBytes());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行一下，然后尝试使用<code>git am</code>：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git am /tmp/jgit.patch</div><div class="line">git <span class="built_in">log</span></div><div class="line">git show HEAD</div></pre></td></tr></table></figure></p>
<p>果然可以直接生成commit。Mission Complete!</p>
<h2 id="patch-amp-diff"><a href="#patch-amp-diff" class="headerlink" title="patch &amp; diff"></a>patch &amp; diff</h2><p>其实Linux已经提供了一个<code>patch</code>命令，无需git即可直接应用patch文件：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git reset HEAD^ --hard</div><div class="line">ls</div><div class="line">patch &lt; /tmp/jgit.patch</div></pre></td></tr></table></figure></p>
<p>而且还支持回滚（git apply也支持）：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">patch -R &lt; /tmp/jgit.patch</div><div class="line">ls</div></pre></td></tr></table></figure></p>
<p>实际上patch文件一般是使用<code>diff</code>命令来生成的：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">diff -u a.txt c.txt &gt; diff.patch</div><div class="line">cat diff.patch</div></pre></td></tr></table></figure></p>
<p>这两个命令网上的教程不少，有兴趣的话可以自行搜索阅读。最后还是把环境恢复：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rm -rf /tmp/ggg /tmp/jgit.patch</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇博文介绍了&lt;a href=&quot;/jgit&quot;&gt;JGit&lt;/a&gt;，之后就开始做项目了。遇到的第一个问题是如何用JGit生成patch文件。&lt;br&gt;
    
    </summary>
    
      <category term="development" scheme="http://qinghua.github.io/categories/development/"/>
    
    
      <category term="git" scheme="http://qinghua.github.io/tags/git/"/>
    
      <category term="JGit" scheme="http://qinghua.github.io/tags/JGit/"/>
    
  </entry>
  
  <entry>
    <title>用JGit通过Java来操作Git</title>
    <link href="http://qinghua.github.io/jgit/"/>
    <id>http://qinghua.github.io/jgit/</id>
    <published>2017-08-13T01:59:02.000Z</published>
    <updated>2017-08-14T00:22:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://eclipse.org/jgit/" target="_blank" rel="external">JGit</a>是一个由<a href="https://www.eclipse.org/org/" target="_blank" rel="external">Eclipse基金会</a>开发、用于操作git的纯Java库。它本身也是Eclispe的一部分，实际上Eclipse的插件<a href="http://www.eclipse.org/egit/" target="_blank" rel="external">EGit</a>便是基于JGit的。如果你像我这样有使用代码来操作git的需求，那就准备好拥抱JGit吧。目前来看别的竞品没它靠谱。<br><a id="more"></a></p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>从用户指南的<a href="http://wiki.eclipse.org/JGit/User_Guide#Concepts" target="_blank" rel="external">概念</a>一节中可以看到，JGit的基本概念如下：</p>
<ul>
<li>Git对象（Git Objects）：就是git的对象。它们在git中用SHA-1来表示。在JGit中用<code>AnyObjectId</code>和<code>ObjectId</code>表示。而它又包含了四种类型：<ol>
<li>二进制大对象（blob）：文件数据</li>
<li>树（tree）：指向其它的tree和blob</li>
<li>提交（commit）：指向某一棵tree</li>
<li>标签（tag）：把一个commit标记为一个标签</li>
</ol>
</li>
<li>引用（Ref）：对某一个git对象的引用。</li>
<li>仓库（Repository）：顾名思义，就是用于存储所有git对象和Ref的仓库。</li>
<li>RevWalk：该类用于从commit的关系图（graph）中遍历commit。晦涩难懂？看到范例就清楚了。</li>
<li>RevCommit：表示一个git的commit</li>
<li>RevTag：表示一个git的tag</li>
<li>RevTree：表示一个git的tree</li>
<li>TreeWalk：类似RevWalk，但是用于遍历一棵tree</li>
</ul>
<h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><p>让我们从一个最典型的用例开始吧。首先在<code>/tmp/jgit/repo</code>中创建一个git仓库：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mkdir -p /tmp/jgit/repo</div><div class="line">cd /tmp/jgit/repo</div><div class="line">git init --bare</div></pre></td></tr></table></figure></p>
<p>再创建一个clone该仓库的客户端：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd /tmp/jgit/</div><div class="line">git clone repo client</div><div class="line">cd client</div></pre></td></tr></table></figure></p>
<p>输入<code>git status</code>应该能够看到<strong>Initial commit</strong>，这样环境就没有问题了。然后提交一个文件，给仓库里来点库存：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">echo hello &gt; hello.txt</div><div class="line">git add hello.txt</div><div class="line">git commit -m "hello"</div><div class="line">git push</div></pre></td></tr></table></figure></p>
<h2 id="动手"><a href="#动手" class="headerlink" title="动手"></a>动手</h2><h3 id="获取仓库"><a href="#获取仓库" class="headerlink" title="获取仓库"></a>获取仓库</h3><p>动手时间。新建Maven工程，往pom.xml中增加dependency，最后的pom.xml看起来就像这样：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></div><div class="line">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.ggg.jgit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>helloJgit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jgit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>org.eclipse.jgit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.8.0.201706111038-r<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>让我们先尝试clone一下这个仓库。因为client分为已经存在以及重新clone的两种，所以我们在src/main/java中新增一个<code>RepositoryProvider</code>接口，用两种不同实现以示区分：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RepositoryProvider</span> </span>&#123;</div><div class="line">    <span class="function">Repository <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>并实现之：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RepositoryProviderCloneImpl</span> <span class="keyword">implements</span> <span class="title">RepositoryProvider</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String repoPath;</div><div class="line">    <span class="keyword">private</span> String clientPath;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RepositoryProviderCloneImpl</span><span class="params">(String repoPath, String clientPath)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.repoPath = repoPath;</div><div class="line">        <span class="keyword">this</span>.clientPath = clientPath;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Repository <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        File client = <span class="keyword">new</span> File(clientPath);</div><div class="line">        client.mkdir();</div><div class="line"></div><div class="line">        <span class="keyword">try</span> (Git result = Git.cloneRepository()</div><div class="line">                .setURI(repoPath)</div><div class="line">                .setDirectory(client)</div><div class="line">                .call()) &#123;</div><div class="line">            <span class="keyword">return</span> result.getRepository();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>新增一个<code>HelloJGit</code>主程序类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloJGit</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RepositoryProvider repoProvider = <span class="keyword">new</span> RepositoryProviderCloneImpl(<span class="string">"/tmp/jgit/repo"</span>, <span class="string">"/tmp/jgit/clientJava"</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">try</span> (Git git = <span class="keyword">new</span> Git(repoProvider.get())) &#123;</div><div class="line">            git.pull().call();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>直接运行<code>HelloJGit</code>的<code>main</code>函数，<code>ls /tmp/jgit/</code>应该就能看到新clone出来的<code>clientJava</code>文件夹了。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd /tmp/jgit/clientJava</div><div class="line">ls</div><div class="line">git status</div></pre></td></tr></table></figure></p>
<p>我们当然不希望总是在使用的时候才重新clone一个仓库，因为当仓库很大的时候可能会非常耗时。让我们在<code>client</code>中再提交一个commit：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">echo hello2 &gt; hello2.txt</div><div class="line">git add hello2.txt</div><div class="line">git commit -m "hello again"</div><div class="line">git push</div></pre></td></tr></table></figure></p>
<p>然后尝试直接从刚刚clone下来的clientJava中创建Repository：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RepositoryProviderExistingClientImpl</span> <span class="keyword">implements</span> <span class="title">RepositoryProvider</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String clientPath;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RepositoryProviderExistingClientImpl</span><span class="params">(String clientPath)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.clientPath = clientPath;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Repository <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">try</span> (Repository repo = <span class="keyword">new</span> FileRepository(clientPath)) &#123;</div><div class="line">            <span class="keyword">return</span> repo;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后把<code>HelloJGit</code>的<code>repoProvider</code>实例替换为<code>RepositoryProviderExistingClientImpl</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> RepositoryProvider repoProvider = <span class="keyword">new</span> RepositoryProviderExistingClientImpl(<span class="string">"/tmp/jgit/clientJava/.git"</span>);</div></pre></td></tr></table></figure></p>
<p>注意这次的路径中需要加上<code>.git</code>才行。再次运行<code>HelloJGit</code>的<code>main</code>函数，便可以通过<code>ls /tmp/jgit/clientJava</code>看到新提交的<code>hello2.txt</code>文件了。</p>
<h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><p>接下来尝试<code>git add</code>、<code>git commit</code>和<code>git push</code>这几个最常用的命令。让我们往<code>clientJava</code>中添加一个<code>hello3.txt</code>文件并提交。如下修改<code>HelloJGit</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="keyword">try</span> (Repository repo = repoProvider.get();</div><div class="line">         Git git = <span class="keyword">new</span> Git(repo)) &#123;</div><div class="line">        createFileFromGitRoot(repo, <span class="string">"hello3.txt"</span>, <span class="string">"hello3"</span>);</div><div class="line">        git.add()</div><div class="line">                .addFilepattern(<span class="string">"hello3.txt"</span>)</div><div class="line">                .call();</div><div class="line"></div><div class="line">        git.commit()</div><div class="line">                .setMessage(<span class="string">"hello3"</span>)</div><div class="line">                .call();</div><div class="line"></div><div class="line">        git.push()</div><div class="line">                .call();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createFileFromGitRoot</span><span class="params">(Repository repo, String filename, String content)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</div><div class="line">    File hello3 = <span class="keyword">new</span> File(repo.getDirectory().getParent(), filename);</div><div class="line">    <span class="keyword">try</span> (PrintWriter out = <span class="keyword">new</span> PrintWriter(hello3)) &#123;</div><div class="line">        out.println(content);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>虽然操作多了，但是有了<code>Repository</code>和<code>Git</code>对象之后，看起来它们的实现都非常直观。运行<code>main</code>函数之后，可以到<code>client</code>文件夹中校验一下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cd /tmp/jgit/client</div><div class="line">git pull</div><div class="line">cat hello3.txt</div><div class="line">git log</div></pre></td></tr></table></figure></p>
<p>在我的机器上运行<code>git log</code>，可以得到：<strong>commit 7841b8b80a77918f2ec45bcedb934e2723b16b5c (HEAD -&gt; master, origin/master)</strong>，以及另外两个commit。有兴趣的读者们可以自行尝试其它的git命令。</p>
<h3 id="其它对象"><a href="#其它对象" class="headerlink" title="其它对象"></a>其它对象</h3><p>虽然上面两小节的内容对于普通需求来说已经大致上够用了，但是在<a href="/jgit/#概念">概念一节</a>中介绍到的其它概念，如Git对象、引用等还没有出场呢。我们再新建一个<code>WalkJGit</code>的类，在<code>main</code>函数中编写如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> (Repository repo = repoProvider.get()) &#123;</div><div class="line">    Ref ref = repo.getAllRefs().get(Constants.HEAD);</div><div class="line">    ObjectId objectId = ref.getObjectId();</div><div class="line">    System.out.println(objectId);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这回，<code>Ref</code>和<code>ObjectId</code>都出现了。在我的机器上，运行以上程序打印出来了<strong>AnyObjectId[7841b8b80a77918f2ec45bcedb934e2723b16b5c]</strong>。我们可以看到，取得<code>HEAD</code>的<code>Ref</code>，其<code>ObjectId</code>其实就是在<code>client</code>文件夹中运行<code>git log</code>之后结果。除了<code>HEAD</code>以外，<code>repo.getAllRefs()</code>返回的<code>Map</code>实例中还有<code>refs/heads/master</code>和<code>refs/remotes/origin/master</code>，在目前的情况下，它们的<code>ObjectId</code>完全相同。那么如何获取其它的commit呢？那就是<code>RevWalk</code>出场的时候。把<code>main</code>函数中的内容替换为如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> (Repository repo = repoProvider.get()) &#123;</div><div class="line">    Ref ref = repo.getAllRefs().get(Constants.HEAD);</div><div class="line"></div><div class="line">    <span class="keyword">try</span> (RevWalk revWalk = <span class="keyword">new</span> RevWalk(repo)) &#123;</div><div class="line">        RevCommit lastCommit = revWalk.parseCommit(ref.getObjectId());</div><div class="line">        revWalk.markStart(lastCommit);</div><div class="line">        revWalk.forEach(System.out::println);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到<code>RevWalk</code>本身是实现了<code>Iterable</code>接口的。通过对该对象进行循环，就可以获取所有的commit的<code>RevCommit</code>对象。可以到<code>client</code>文件夹确认一下，这些SHA-1字符串应该跟刚才<code>git log</code>命令的结果相同。<code>RevCommit</code>对象本身含有这个commit的所有信息，所以可以如下打印出来：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">revWalk.forEach(c -&gt; &#123;</div><div class="line">    System.out.println(<span class="string">"commit "</span> + c.getName());</div><div class="line">    System.out.printf(<span class="string">"Author: %s &lt;%s&gt;\n"</span>, c.getAuthorIdent().getName(), c.getAuthorIdent().getEmailAddress());</div><div class="line">    System.out.println(<span class="string">"Date: "</span> + LocalDateTime.ofEpochSecond(c.getCommitTime(), <span class="number">0</span>, ZoneOffset.UTC));</div><div class="line">    System.out.println(<span class="string">"\t"</span> + c.getShortMessage() + <span class="string">"\n"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这样看起来是不是很有<code>git log</code>的感觉呢？需要注意的是，<code>RevWalk</code>线程不安全，并且像<code>Stream</code>那样，只能使用一次。<a href="https://github.com/eclipse/jgit/blob/master/org.eclipse.jgit/src/org/eclipse/jgit/revwalk/RevWalk.java#L77" target="_blank" rel="external">如果想要再来一次</a>，就需要重新创建<code>RevWalk</code>对象或是调用其<code>reset</code>方法（还得重新<code>markStart</code>！）。</p>
<p>要想看到每个commit中有什么内容，那就需要用到<code>TreeWalk</code>了，它的思路和<code>RevWalk</code>类似。尝试如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (RevCommit commit : revWalk) &#123;</div><div class="line">    System.out.println(<span class="string">"\ncommit: "</span> + commit.getName());</div><div class="line">    <span class="keyword">try</span> (TreeWalk treeWalk = <span class="keyword">new</span> TreeWalk(repo)) &#123;</div><div class="line">        treeWalk.addTree(commit.getTree());</div><div class="line">        treeWalk.setRecursive(<span class="keyword">true</span>);</div><div class="line">        <span class="keyword">while</span> (treeWalk.next()) &#123;</div><div class="line">            System.out.println(<span class="string">"filename: "</span> + treeWalk.getPathString());</div><div class="line">            ObjectId objectId = treeWalk.getObjectId(<span class="number">0</span>);</div><div class="line">            ObjectLoader loader = repo.open(objectId);</div><div class="line">            loader.copyTo(System.out);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样便可以显示仓库在每个commit时候的状态了。如果需要diff，那么还将需要用到<code>DiffEntry</code>等类，本文就不再赘述了，有兴趣的读者可以参考<a href="https://github.com/centic9/jgit-cookbook/blob/master/src/main/java/org/dstadler/jgit/porcelain/ShowChangedFilesBetweenCommits.java" target="_blank" rel="external">这个类</a>。</p>
<p>最后将环境还原：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rm -rf /tmp/jgit</div></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/centic9/jgit-cookbook" target="_blank" rel="external">这个代码库</a>里有很全面的、基本可以直接用于生产环境的范例。<br><a href="https://github.com/eclipse/jgit" target="_blank" rel="external">JGit的源码</a>和<a href="http://wiki.eclipse.org/JGit/User_Guide" target="_blank" rel="external">用户指南</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://eclipse.org/jgit/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JGit&lt;/a&gt;是一个由&lt;a href=&quot;https://www.eclipse.org/org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Eclipse基金会&lt;/a&gt;开发、用于操作git的纯Java库。它本身也是Eclispe的一部分，实际上Eclipse的插件&lt;a href=&quot;http://www.eclipse.org/egit/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;EGit&lt;/a&gt;便是基于JGit的。如果你像我这样有使用代码来操作git的需求，那就准备好拥抱JGit吧。目前来看别的竞品没它靠谱。&lt;br&gt;
    
    </summary>
    
      <category term="development" scheme="http://qinghua.github.io/categories/development/"/>
    
    
      <category term="git" scheme="http://qinghua.github.io/tags/git/"/>
    
      <category term="JGit" scheme="http://qinghua.github.io/tags/JGit/"/>
    
  </entry>
  
  <entry>
    <title>《智能时代》读后感</title>
    <link href="http://qinghua.github.io/intelligence-age-book-review/"/>
    <id>http://qinghua.github.io/intelligence-age-book-review/</id>
    <published>2017-07-02T08:51:23.000Z</published>
    <updated>2017-07-06T01:01:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>上个月刚刚读完吴军的<a href="https://book.douban.com/subject/26838557/" target="_blank" rel="external">《智能时代》</a>，本文总结并记录一些笔记及感想。<br><a id="more"></a></p>
<h2 id="数据、信息、知识和智能"><a href="#数据、信息、知识和智能" class="headerlink" title="数据、信息、知识和智能"></a>数据、信息、知识和智能</h2><p>在谈论数据时，人们经常将其与信息相混淆。其实信息来源于数据，但是并非所有的数据都承载着有用的信息。例如，对于<code>dd if=/dev/zero of=ggg.txt bs=1k count=10000</code>这样的一个10M文件来说，里面的每一个bit都为0，所以并不能提供什么有意义的信息。而且，无意义和伪造的数据都会干扰和影响我们。通过对信息的处理，可以获取知识，以推动人类文明的发展。例如：通过测量星球的位置和对应的时间，我们可以得到数据；通过处理这些数据得到星球运动的轨迹，就是信息；通过信息总结出开普勒三定律，则是知识。而人类的智能往往体现在：获取数据→分析数据→建立模型→预测未知上。</p>
<p>现在我们所说的人工智能有两个定义：狭义的人工智能指的是20世纪五六十年代的研究机器智能的特定方法，即传统人工智能方法，专注于让机器像人一样地去思考；广义的人工智能指的是任何可以让计算机通过图灵测试的方法，即让一台机器和一个人在幕后，一位裁判同时与他们交流，看看裁判是否能够分辨出自己交流的对象是机器还是人。以翻译为例：传统的方法就是针对某两种语言编写大量的规则，以反映人类的思考方式；而现代的方法则是通过数据驱动，用机器学习的方式训练出翻译模型的各种参数。在互联网出现以前，很难获取到大量的有效数据，因而实用性不高。但是在如今的大数据时代，获取大量数据已经成为了可能。越来越多的信息可以使模型越来越准确，进而使翻译的效果越来越好。这里有个大数据预测美国大选的例子：2012年有人把互联网上公开的新闻、Facebook、Twitter等选战数据按照州来整理，竟然成功地预测了全部50+1个州的选举结果。</p>
<p>数据的作用过去常常被人们所忽视。首先是由于过去的数据量不足（少了大数据的大，Vast）；其次是数据缺乏相关性（少了多维度，即多样性Variety）。而现在的数据量由于计算机本身的数据、传感器的数据以及旧信息的数字化，比过去增加了许多，使量变足以成为了质变。数据驱动方法过去的死穴在于，使用基于概率统计的模型会有很多小概率事件覆盖不到。只有提高数据的完备性才行。这在以前是很难做到的，比如搜集全国所有人的面孔。但是如今这样的事情也并非遥不可及。所以我们也许需要重新认识穷举法，在大数据时代它并不像想象中的那样笨。数据的相关性也非常重要。我上班的时候会经过一家广东肠粉的小吃店，招牌上“广”字的一点已经脱落，成了“厂东肠粉”。我们的智能当然能够判断出来这是广东而不是厂东，但是大数据呢？首先它并不能找到什么有意义的“厂东”，但是能找到广东，并且“厂”和“广”字形非常接近。但是这样也无法否定是不是有个小地方叫“厂东”，或是老板的名字叫“厂东”。所以需要交叉验证。接下来发现“广东”和“肠粉”两字经常出现，有相关性。这样数据的相关性便大大提升了可信度。要是有图片，还能根据“厂”的字形比另外三个字稍扁来做进一步的交叉验证，准确性就能够更上一层楼。实际上如果在baidu搜索“厂东肠粉”的时候，它已经会问你“您要找的是不是: 广东肠粉”。Google虽然并不提示你，但显示的搜索结果也都是广东肠粉。当大家都意识到数据的重要性后，市场上的竞争就从技术的竞争转变成了数据的竞争，智能问题已经演变成了数据问题。<br><img src="/img/intelligence-age-guang-dong.png" alt=""></p>
<h2 id="智能革命"><a href="#智能革命" class="headerlink" title="智能革命"></a>智能革命</h2><p>我们现在说起机械思维，总觉得它是个贬义词。但其实它正是以前推动工业革命的要素。机械思维认为世界变化的规律是确定的，因此规律可以被认识，并且可以用公式或语言描述清楚，放之四海而皆准。但成也萧何败萧何，它的局限性正是否认了不确定性和不可知性。世界的不确定性首先来自影响世界的变量实在太多，以至于无法套用公式算出结果。其次世界本身也是不确定的，人类对于世界的观察将会改变世界本身，如量子力学的不确定性原理。但是不确定并不意味着没有规律可循。香农在概率论的基础上，用信息论将世界的不确定性与信息联系了起来，给了人们一种看待世界和处理问题的全新思路。</p>
<p>新思路为我们带来了大数据思维。它的核心是：数据中所包含的信息可以帮助我们消除不确定性，而数据之间的相关性在某种程度上可以取代原来的因果关系，帮助我们得到想知道的答案。例如，根据大数据的统计结果，可以发现在视频网站上投放零食的广告效果很好，我们可以据此猜出人们在看视频时喜欢吃零食。所以这种新的思维方法允许我们在不知道原因的情况下直接从大量数据中寻找答案，即无监督学习。虽然机器推算出来相关的事情只有一定的概率，但是世界本身就充满了不确定性，100%的准确率固然是好，但是90%的结果也是非常有价值的。这就是思维的革命。</p>
<p>还有产业的革命。套用一个公式：<strong>现有产业 + 新技术 = 新产业</strong>。例如：</p>
<ul>
<li>第一次工业革命：现有产业 + 蒸汽机 = 新产业</li>
<li>第二次工业革命：现有产业 + 电 = 新产业</li>
<li>现今的信息革命：现有产业 + 摩尔定律 = 新产业</li>
<li>由大数据引发的智能革命：<ul>
<li>现有产业 + 大数据 = 新产业</li>
<li>现有产业 + 机器智能 = 新产业</li>
</ul>
</li>
</ul>
<p>在瓦特改良万能蒸汽机之后，很多上千年历史的古老行业都通过使用蒸汽机而变为新产业，如纺织业冲击了几千年来的家庭纺织业，而瓷器则由白色黄金变成了日用品等。并不需要每一个工厂都去制造蒸汽机，而大多数工厂都会受益于蒸汽机。到了19世纪末，电力的应用也催生了各种新产业，如建筑业通过使用电梯使人们可以把楼盖高，交通运输业通过电车、地铁等公共交通促进了城市的发展，形成了大都市。但是也不需要太多的供电公司，对于美国而言就是通用电气和西屋电气，而大多数公司都会受益于电。“二战”之后，许多产业在使用计算机之后产生了质的变化，如金融业、通信业等。计算机处理器是信息革命的代表产品，但是同样并不需要有很多生产它的公司，今天大部分的处理器都是来自Intel或AMD以及ARM公司所设计的产品，而大部分电脑和智能设备都离不开它们。正在到来的智能革命，也将催生和改造出许多的新产业，但同样，并不是所有公司都会掌握大数据或是培养出机器智能，而大多数公司都将受益于大数据和机器智能。</p>
<h2 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h2><p>新革命的到来当然不会是一帆风顺的，首先要解决的是技术上的挑战。大量的数据必然需要大量的存储，并使查找和使用数据的时间剧增。早期存储数据的磁带和软盘根本不可能承担起存储如此海量数据的任务。硬盘虽然容量上去了，但是其存取速度仍然受限于机械运动。直到SSD的崛起和平价化，才使得在存储技术上适应了大数据。数据的传输也是一个挑战，直到移动互联网和WIFI技术的兴起，才使得大量数据的传输成为可能。而对数据的处理，则受益于摩尔定律，处理器速度增加并越来越便宜，从而导致并行处理技术如Map Reduce等的发展。也有目前还没完全解决的问题，如数据的标准化等。Google设计了一种称为<a href="https://github.com/google/protobuf" target="_blank" rel="external">Protocal Buffer</a>的数据格式，并已开源供大家使用。</p>
<p>技术问题解决后，就是商业问题了。如何获得一个全集的大数据呢？例如，为了了解电视的收视率，显然不能再一个个地去发传单、打电话了。最好的方法是通过机顶盒记录用户的收视情况。但是掌握这些数据的生产厂商和有线电视运营商当然不会轻易地把这些数据分享出来。所以Google推出了自己的电视机顶盒Google TV，为获取数据进入电视广告市场做准备，但是销售结果很糟糕，据说后来每个季度退回来的机顶盒比卖出去的还多。以至于Google在2014年斥巨资收购了还在亏损状态的nest公司，以获取nest公司的产品（恒温器）在每一个家庭的数据。一些公司已经敏锐地发现了数据的价值，而另一些公司却捧着金饭碗要饭。</p>
<p>还有数据的安全。首先由于数据量大，数据一旦丢失或被盗，损失将是巨大的。一种行之有效的方式就是利用大数据本身的特点来保护大数据的信息安全。如果外来的入侵者侵入了计算机系统，由于对业务的不熟悉，他的操作很可能与众不同，因此可以通过与大数据的对比而被发现，从而被制止。还有就是对于隐私的保护。如果导航系统能够帮人们导航并避开拥堵路段，那也说明它知道每个人的行踪。一旦这些信息暴露出来，这是非常危险的。再比如说<a href="http://www.sohu.com/a/117859356_469880" target="_blank" rel="external">《大数据高手塔吉特：我知道你怀孕了！》</a>。现在的很多公司都或多或少具备了这样的能力，只是大家不知道或者不注意而已。甚至连淘宝的商家都有可能收集到你的信息，从而决定给你寄真货还是寄假货。</p>
<p>最后，随着生产力的进一步发展，机器将会抢掉许多人的饭碗：工人、医生、律师、翻译、编辑、中间商等等。特斯拉的汽车装配厂都是由机器人操作，很少雇佣汽车行业的人员，而所雇的都是IT人员。机器将会从大数据中学习到各种专家的知识，甚至表现得更好。那未来如此多失业的人将会怎么办？目前人类还没有很好的办法，只能靠“拖”字决。一两代之后，无法掌握新技能的人也已经到了退休年龄了。AI会有更好的办法么？也许AI会发现只需要让大家陷入深深的睡眠就可以了。《黑客帝国》又向现实迈进了一步。但是AI毕竟来自于大数据，而不是全数据。有朝一日醒来的人类，也许能够通过制造不常见的场景，引发AI的bug，就像李世石曾经战胜AlphaGo的那一盘围棋一样。而埃隆·马斯克用“<a href="https://www.huxiu.com/article/201384.html" target="_blank" rel="external">脑机接口</a>”的宏伟蓝图来应对AI。既然人类可能最终会被AI消灭，那不如就让人类与AI成为一体。</p>
<p>“2%的人将控制未来，成为他们或被淘汰”。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上个月刚刚读完吴军的&lt;a href=&quot;https://book.douban.com/subject/26838557/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《智能时代》&lt;/a&gt;，本文总结并记录一些笔记及感想。&lt;br&gt;
    
    </summary>
    
      <category term="AI" scheme="http://qinghua.github.io/categories/AI/"/>
    
    
      <category term="AI" scheme="http://qinghua.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin的语法糖们</title>
    <link href="http://qinghua.github.io/kotlin-syntax-suger/"/>
    <id>http://qinghua.github.io/kotlin-syntax-suger/</id>
    <published>2017-06-24T01:01:21.000Z</published>
    <updated>2017-06-24T02:10:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>当今的<a href="https://kotlinlang.org/" target="_blank" rel="external">Kotlin</a>真是炙手可热啊。自2011年JetBrains为了提高IDEA的销量而推出这个项目至今，它一直低调而稳定地发展着。到了上个月即2017年5月，<a href="https://blog.jetbrains.com/kotlin/2017/05/kotlin-on-android-now-official/" target="_blank" rel="external">Google宣布将Kotlin语言作为Android开发的一级编程语言</a>，算是到达了语言生的第一个巅峰。<a href="https://kotlinlang.org/docs/reference/faq.html#is-kotlin-hard" target="_blank" rel="external">Kotlin自身受到Java、C#、JavaScript、Scala、Groovy等语言的影响</a>，本文总结了它提供的部分常见语法糖并与其它语言进行比较。<br><a id="more"></a></p>
<h2 id="字符串模板（string-template）"><a href="#字符串模板（string-template）" class="headerlink" title="字符串模板（string template）"></a>字符串模板（<a href="https://kotlinlang.org/docs/reference/basic-types.html#string-templates" target="_blank" rel="external">string template</a>）</h2><p>Kotlin可以直接通过<code>println(&quot;Hello, {name}&quot;)</code>或<code>println(&quot;Hello, $name&quot;)</code>来使用字符串模板，而Java则需要先借助<code>String.format</code>来生成字符串。而kotlin还支持表达式，如<code>${person.name}</code>和<code>${2 * 3}</code>。这块古老的糖从shell开始就有了：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo "Hello, $&#123;name&#125;"</div></pre></td></tr></table></figure></p>
<p>如果你疑惑为什么无须导入包即可直接使用<code>println</code>，那是因为这个方法所在的<code>kotlin.io</code>包是默认导入（Default Imports）的，正如Java会默认导入<code>java.lang.*</code>一样。Kotlin的默认导入请参考<a href="https://kotlinlang.org/docs/reference/packages.html#default-imports" target="_blank" rel="external">这里</a>。</p>
<h2 id="分号推断（semicolon-inference）"><a href="#分号推断（semicolon-inference）" class="headerlink" title="分号推断（semicolon inference）"></a>分号推断（<a href="https://kotlinlang.org/docs/reference/grammar.html#semicolons" target="_blank" rel="external">semicolon inference</a>）</h2><p>我们知道Java中的每一条语句结束后，需要加上分号。Kotlin中的分号是可选的。这应该是来自JavaScript吧。不过写JavaScript还是推荐把分号都加上，否则可能<a href="http://cjihrig.com/blog/the-dangers-of-javascripts-automatic-semicolon-insertion/" target="_blank" rel="external">有危险</a>。Groovy、Scala也有同样的能力。</p>
<h2 id="定义函数（define-function）"><a href="#定义函数（define-function）" class="headerlink" title="定义函数（define function）"></a>定义函数（<a href="https://kotlinlang.org/docs/reference/functions.html" target="_blank" rel="external">define function</a>）</h2><p>JavaScript中，<code>function</code>；Go语言，<code>func</code>；Kotlin，<code>fun</code>。怎么看都像是SIM卡变成了micro-SIM，然后又变成了nano-SIM卡。Kotlin可以在类之外定义全局函数，也可以在函数中定义局部函数。这一点类似于JavaScript。</p>
<h2 id="var／val（local-variable）"><a href="#var／val（local-variable）" class="headerlink" title="var／val（local variable）"></a>var／val（<a href="https://kotlinlang.org/docs/reference/basic-syntax.html#defining-local-variables" target="_blank" rel="external">local variable</a>）</h2><p>变量是<code>var</code>，表示variable；常量是<code>val</code>，表示fixed value。这个很明显来自Scala。在Java中就只能用<code>final</code>关键字了。</p>
<h2 id="可空值（nullable-value）"><a href="#可空值（nullable-value）" class="headerlink" title="可空值（nullable value）"></a>可空值（<a href="https://kotlinlang.org/docs/reference/null-safety.html" target="_blank" rel="external">nullable value</a>）</h2><p>在变量类型后面加上一个问号，表明这个变量可以为null，否则默认不能为null。例如：<br>这一句编译错误：<code>var a: Int = null</code><br>这样才能成功：<code>var a: Int? = null</code><br>这块糖显然来自于C#，但是更加严格了。它是为了避免Java中的null所造成的<a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare" target="_blank" rel="external">十亿美元的错误</a>。</p>
<h2 id="集合字面量（collection-literals）"><a href="#集合字面量（collection-literals）" class="headerlink" title="集合字面量（collection literals）"></a>集合字面量（<a href="https://kotlinlang.org/docs/reference/collections.html#collections" target="_blank" rel="external">collection literals</a>）</h2><p>Java从来就不愿意用糖吸引小朋友……所以一般快速创建集合是这么写的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; colors = Arrays.asList(<span class="string">"red"</span>, <span class="string">"blue"</span>);</div></pre></td></tr></table></figure></p>
<p>有好事者（Guava）提供了这样的类库：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; colors = ImmutableList.of(<span class="string">"red"</span>, <span class="string">"blue"</span>);</div></pre></td></tr></table></figure></p>
<p>其实Java 8提供的Stream也许已经能够满足你的需求：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Stream&lt;String&gt; colors = Stream.of(<span class="string">"red"</span>, <span class="string">"blue"</span>);</div></pre></td></tr></table></figure></p>
<p>Java 9很可能会<a href="http://openjdk.java.net/jeps/269" target="_blank" rel="external">引入集合字面量</a>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; colors = List.of(<span class="string">"red"</span>, <span class="string">"blue"</span>);</div></pre></td></tr></table></figure></p>
<p>Kotlin出手了：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> colors = listOf(<span class="string">"red"</span>, <span class="string">"blue"</span>)</div></pre></td></tr></table></figure></p>
<p>不过实际上并非是语法层面的糖，<code>listOf</code>只是一个方法而已。我相信是从Scala中偷师的：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> colors = <span class="type">List</span>(<span class="string">"red"</span>, <span class="string">"blue"</span>)</div></pre></td></tr></table></figure></p>
<p>当然Scala还有自己的经典方式：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> colors = <span class="string">"red"</span> :: <span class="string">"blue"</span> :: <span class="type">Nil</span></div></pre></td></tr></table></figure></p>
<p>C#可以这样来初始化集合：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> ArrayList&#123;<span class="string">"red"</span>, <span class="string">"blue"</span>&#125;;</div></pre></td></tr></table></figure></p>
<p>JavaScript、Ruby、Go等直接扩展了数组，所以就更省心了。</p>
<h2 id="when表达式（when-expression）"><a href="#when表达式（when-expression）" class="headerlink" title="when表达式（when expression）"></a>when表达式（<a href="https://kotlinlang.org/docs/reference/control-flow.html#when-expression" target="_blank" rel="external">when expression</a>）</h2><p><code>when</code>表达式有点像是不需要<code>break</code>的<code>switch…case</code>：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">when</span> (x) &#123;</div><div class="line">    <span class="number">1</span> -&gt; print(<span class="string">"x == 1"</span>)</div><div class="line">    <span class="number">2</span> -&gt; print(<span class="string">"x == 2"</span>)</div><div class="line">    <span class="keyword">else</span> -&gt; &#123; <span class="comment">// 这里可以写多行哦</span></div><div class="line">        print(<span class="string">"x is neither 1 nor 2"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但它还可以做得更多：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">when</span> &#123;</div><div class="line">    <span class="string">"orange"</span> <span class="keyword">in</span> items -&gt; println(<span class="string">"juicy"</span>)</div><div class="line">    <span class="string">"apple"</span> <span class="keyword">in</span> items -&gt; println(<span class="string">"apple is fine too"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以把它作为扩展版<code>if…else</code>来用。它有点类似Groovy的<code>switch</code>。</p>
<h2 id="is运算符（is-operator）"><a href="#is运算符（is-operator）" class="headerlink" title="is运算符（is operator）"></a>is运算符（<a href="https://kotlinlang.org/docs/reference/basic-syntax.html#using-type-checks-and-automatic-casts" target="_blank" rel="external">is operator</a>）</h2><p>先看代码：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getStringLength</span><span class="params">(obj: <span class="type">Any</span>)</span></span>: <span class="built_in">Int</span>? &#123;</div><div class="line">    <span class="keyword">if</span> (obj <span class="keyword">is</span> String &amp;&amp; obj.length &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> obj.length</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">null</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里，<code>obj is String</code>之后就可以将其作为<code>String</code>来使用了，调用<code>String</code>的<code>length</code>属性。<code>is</code>不仅比<code>instanceof</code>更加短小精悍，而且还会自动将变量转换为<code>is</code>后面的类型。应该是出于C#而胜于C#。C#提供了<code>is</code>和<code>as</code>，但是<code>as</code>在Kotlin中显然就毫无用武之地了。</p>
<h2 id="范围运算符（range）"><a href="#范围运算符（range）" class="headerlink" title="范围运算符（range）"></a>范围运算符（<a href="https://kotlinlang.org/docs/reference/ranges.html" target="_blank" rel="external">range</a>）</h2><p>Java如果要循环打印1至9，一般就是这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Java 8以前</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</div><div class="line">    System.out.println(i);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Java 8 lambda</span></div><div class="line">IntStream.range(<span class="number">1</span>, <span class="number">9</span>).forEach(System.out::println);</div></pre></td></tr></table></figure></p>
<p>如果需要步长（step），lambda方案就需要引入filter、map或iterate。Kotlin自带接口<code>ClosedRange</code>，用了点糖：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.9</span>) print(i)</div><div class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.9</span> step <span class="number">2</span>) print(i)</div><div class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">9</span> downTo <span class="number">1</span>) print(i)</div></pre></td></tr></table></figure></p>
<p>bash早就支持大括号配合<code>..</code>（<a href="http://www.gnu.org/software/bash/manual/html_node/Brace-Expansion.html" target="_blank" rel="external">brace expansion</a>）的这种方式了：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">for i in &#123;1..9&#125;; do echo $i; done</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> bash 4支持步长</span></div><div class="line">for i in &#123;1..9..2&#125;; do echo $i; done</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> 否则用seq</span></div><div class="line">for i in `seq 1 2 9`; do echo $i; done</div></pre></td></tr></table></figure></p>
<p>不过我更喜欢ruby，支持lambda的写法更加优雅：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="number">1</span>..<span class="number">9</span>).each &#123;<span class="params">|x|</span> puts x&#125;</div><div class="line">(<span class="number">1</span>..<span class="number">9</span>).step(<span class="number">2</span>) &#123;<span class="params">|x|</span> puts x&#125;</div></pre></td></tr></table></figure></p>
<h2 id="运算符重载（operator-overloading）"><a href="#运算符重载（operator-overloading）" class="headerlink" title="运算符重载（operator overloading）"></a>运算符重载（<a href="https://kotlinlang.org/docs/reference/operator-overloading.html" target="_blank" rel="external">operator overloading</a>）</h2><p>这个是C#和Scala的把戏：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>, <span class="keyword">val</span> y: <span class="built_in">Int</span>)</div><div class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Point.<span class="title">plus</span><span class="params">(<span class="keyword">val</span> point: <span class="type">Point</span>)</span></span> = Point(x + point.x, y + point.y)</div><div class="line"></div><div class="line">Point(<span class="number">1</span>, <span class="number">2</span>) + Point(<span class="number">3</span>, <span class="number">4</span>) <span class="comment">// Point(x=4, y=6)</span></div></pre></td></tr></table></figure></p>
<p>怎么知道<code>+</code>号上映射的是<code>plus</code>方法呢？还是得参考<a href="https://kotlinlang.org/docs/reference/operator-overloading.html" target="_blank" rel="external">官方文档</a>。</p>
<h2 id="包别名（package-alias）"><a href="#包别名（package-alias）" class="headerlink" title="包别名（package alias）"></a>包别名（<a href="https://kotlinlang.org/docs/reference/packages.html#imports" target="_blank" rel="external">package alias</a>）</h2><p>Kotlin支持为包指定别名，对代码洁癖患者可能会起到一定的疗效：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.math.BigDecimal <span class="keyword">as</span> bd</div></pre></td></tr></table></figure></p>
<p>Python、Groovy也都是这样：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.List <span class="keyword">as</span> UtilList</div><div class="line"><span class="keyword">import</span> java.awt.List <span class="keyword">as</span> AwtList</div></pre></td></tr></table></figure></p>
<h2 id="类型别名（type-alias）"><a href="#类型别名（type-alias）" class="headerlink" title="类型别名（type alias）"></a>类型别名（<a href="https://kotlinlang.org/docs/reference/type-aliases.html" target="_blank" rel="external">type alias</a>）</h2><p>Kotlin还支持为类型指定别名：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typealias Row = List&lt;<span class="built_in">Int</span>&gt;</div></pre></td></tr></table></figure></p>
<p>这应该是来自Scala的Type：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">type</span> <span class="title">Row</span> </span>= <span class="type">List</span>[<span class="type">Int</span>]</div></pre></td></tr></table></figure></p>
<h2 id="扩展函数（extension-function）"><a href="#扩展函数（extension-function）" class="headerlink" title="扩展函数（extension function）"></a>扩展函数（<a href="https://kotlinlang.org/docs/reference/extensions.html" target="_blank" rel="external">extension function</a>）</h2><p>扩展函数允许为一个类增加公有静态方法，调用时就好像这个方法是原生的一样。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">greetingsWith</span><span class="params">(greeting: <span class="type">String</span>)</span></span> &#123;</div><div class="line">    println(<span class="string">"<span class="variable">$greeting</span>, <span class="variable">$this</span>"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="string">"ggg"</span>.greetingsWith(<span class="string">"Hello"</span>)</div></pre></td></tr></table></figure></p>
<p>虽然JavaScript也能轻易做到，但我还是强烈地认为它来自于C#，毕竟都是一脉相承。kotlin更近一步支持扩展属性：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> String.halfLength: <span class="built_in">Int</span></div><div class="line">    <span class="keyword">get</span>() = length / <span class="number">2</span></div><div class="line"></div><div class="line"><span class="string">"ggg"</span>.halfLength <span class="comment">// 1</span></div></pre></td></tr></table></figure></p>
<h2 id="函数扩展（function-expansion）"><a href="#函数扩展（function-expansion）" class="headerlink" title="函数扩展（function expansion）"></a>函数扩展（<a href="https://kotlinlang.org/docs/reference/lambdas.html#higher-order-functions" target="_blank" rel="external">function expansion</a>）</h2><p>如果函数的最后一个参数类型是个函数，可以通过大括号来传值：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">calculate</span><span class="params">(a: <span class="type">Int</span>, cal: (<span class="type">Int</span>)</span></span> -&gt; <span class="built_in">Int</span>): <span class="built_in">Int</span> &#123;</div><div class="line">    <span class="keyword">return</span> cal(a)</div><div class="line">&#125;</div><div class="line"></div><div class="line">calculate(<span class="number">3</span>) &#123; x -&gt; x * x &#125; <span class="comment">// 9</span></div></pre></td></tr></table></figure></p>
<p>这应该是来自ruby的block：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate</span><span class="params">(a, &amp;cal)</span></span></div><div class="line">    cal.call a</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">calculate(<span class="number">3</span>) &#123; <span class="params">|x|</span> x * x &#125; <span class="comment"># 9</span></div></pre></td></tr></table></figure></p>
<h2 id="默认参数（default-arguments）"><a href="#默认参数（default-arguments）" class="headerlink" title="默认参数（default arguments）"></a>默认参数（<a href="https://kotlinlang.org/docs/reference/functions.html#default-arguments" target="_blank" rel="external">default arguments</a>）</h2><p>Kotlin支持为参数指定一个默认值：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  show()</div><div class="line">  show(<span class="string">"Good morning"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">show</span> <span class="params">(msg: <span class="type">String</span> = <span class="string">"Hello World"</span>)</span></span> &#123;</div><div class="line">    println(<span class="string">"<span class="variable">$msg</span>"</span>) </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Java一般是靠重载来实现默认参数。许多其它的语言都支持默认参数。例如，JavaScript在ES6上也支持默认参数了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">a, b = <span class="number">1</span></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> a * b;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="单例对象（singleton）"><a href="#单例对象（singleton）" class="headerlink" title="单例对象（singleton）"></a>单例对象（<a href="https://kotlinlang.org/docs/reference/object-declarations.html#object-declarations" target="_blank" rel="external">singleton</a>）</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">object</span> Document &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这应该是来自于Scala，连关键字都一模一样。</p>
<h2 id="伴生对象（companion-object）"><a href="#伴生对象（companion-object）" class="headerlink" title="伴生对象（companion object）"></a>伴生对象（<a href="https://kotlinlang.org/docs/reference/object-declarations.html#companion-objects" target="_blank" rel="external">companion object</a>）</h2><p>伴生对象经常用于Factory。这一点相信也是来自于Scala。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</div><div class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> Factory &#123; <span class="comment">// Factory可省略，省略后可用Companion引用</span></div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">()</span></span>: MyClass = MyClass()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="getter和setter（getter-and-setter）"><a href="#getter和setter（getter-and-setter）" class="headerlink" title="getter和setter（getter and setter）"></a>getter和setter（<a href="https://kotlinlang.org/docs/reference/properties.html#getters-and-setters" target="_blank" rel="external">getter and setter</a>）</h2><p>Kotlin像C#一样支持属性（property）。我们来看两个例子：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> isEmpty: <span class="built_in">Boolean</span></div><div class="line">    <span class="keyword">get</span>() = <span class="keyword">this</span>.size == <span class="number">0</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> counter = <span class="number">0</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">set</span>(value) &#123;</div><div class="line">        <span class="keyword">if</span> (value &gt;= <span class="number">0</span>) field = value</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h2 id="数据类（data-class）"><a href="#数据类（data-class）" class="headerlink" title="数据类（data class）"></a>数据类（<a href="https://kotlinlang.org/docs/reference/data-classes.html" target="_blank" rel="external">data class</a>）</h2><p>告别繁琐的Java数据类的时代到来了：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</div></pre></td></tr></table></figure></p>
<p>看到最前面的<code>data</code>，我突然觉得这是源于<a href="/lombok">lombok</a>…</p>
<h2 id="没有原始类型（no-raw-types）"><a href="#没有原始类型（no-raw-types）" class="headerlink" title="没有原始类型（no raw types）"></a>没有原始类型（<a href="https://kotlinlang.org/docs/reference/java-interop.html#mapped-types" target="_blank" rel="external">no raw types</a>）</h2><p>Kotlin没有原始类型，一切皆对象：<code>1.inc()</code>。这一点与Ruby、Scala相同。</p>
<h2 id="没有受检查异常（no-checked-exception）"><a href="#没有受检查异常（no-checked-exception）" class="headerlink" title="没有受检查异常（no checked exception）"></a>没有受检查异常（<a href="https://kotlinlang.org/docs/reference/exceptions.html#checked-exceptions" target="_blank" rel="external">no checked exception</a>）</h2><p>Kotlin并没有受检查异常。因为在大型的项目中，它对代码质量的提升极其有限，但是却大大降低了效率。C#十多年前就是这样了，有兴趣的读者可以参考<a href="https://blogs.msdn.microsoft.com/csharpfaq/2004/03/12/why-doesnt-c-have-checked-exceptions/" target="_blank" rel="external">这篇文章</a>。</p>
<h2 id="没有static（no-static-member）"><a href="#没有static（no-static-member）" class="headerlink" title="没有static（no static member）"></a>没有static（<a href="https://kotlinlang.org/docs/reference/classes.html#companion-objects" target="_blank" rel="external">no static member</a>）</h2><p>Kotlin也没有static的成员。这一点与Scala相同。在Kotiln中可以使用包级别的函数，或者是伴生对象来实现static的效果。</p>
<h2 id="多返回值（multiple-return-values）"><a href="#多返回值（multiple-return-values）" class="headerlink" title="多返回值（multiple return values）"></a>多返回值（<a href="https://kotlinlang.org/docs/reference/multi-declarations.html" target="_blank" rel="external">multiple return values</a>）</h2><p>可以从<a href="https://kotlinlang.org/docs/reference/multi-declarations.html#example-returning-two-values-from-a-function" target="_blank" rel="external">这一个例子</a>中看到Kotlin是如何实现函数的多返回值的。我猜应该是受到了Go语言的启发。</p>
<h2 id="嵌套块注释（nested-block-comment）"><a href="#嵌套块注释（nested-block-comment）" class="headerlink" title="嵌套块注释（nested block comment）"></a>嵌套块注释（<a href="https://kotlinlang.org/docs/reference/basic-syntax.html#comments" target="_blank" rel="external">nested block comment</a>）</h2><p>Kotlin支持块注释<code>/* … */</code>的嵌套。这可能是来自Haskell或F#。</p>
<h2 id="在线版IDE"><a href="#在线版IDE" class="headerlink" title="在线版IDE"></a>在线版IDE</h2><p>如果不想安装那么多语言，可以试试这个<a href="https://codepad.remoteinterview.io" target="_blank" rel="external">在线版IDE</a>，它支持包括Kotlin在内的几十种语言。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当今的&lt;a href=&quot;https://kotlinlang.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Kotlin&lt;/a&gt;真是炙手可热啊。自2011年JetBrains为了提高IDEA的销量而推出这个项目至今，它一直低调而稳定地发展着。到了上个月即2017年5月，&lt;a href=&quot;https://blog.jetbrains.com/kotlin/2017/05/kotlin-on-android-now-official/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Google宣布将Kotlin语言作为Android开发的一级编程语言&lt;/a&gt;，算是到达了语言生的第一个巅峰。&lt;a href=&quot;https://kotlinlang.org/docs/reference/faq.html#is-kotlin-hard&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Kotlin自身受到Java、C#、JavaScript、Scala、Groovy等语言的影响&lt;/a&gt;，本文总结了它提供的部分常见语法糖并与其它语言进行比较。&lt;br&gt;
    
    </summary>
    
      <category term="development" scheme="http://qinghua.github.io/categories/development/"/>
    
    
      <category term="kotlin" scheme="http://qinghua.github.io/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>用Lombok优雅地写代码</title>
    <link href="http://qinghua.github.io/lombok/"/>
    <id>http://qinghua.github.io/lombok/</id>
    <published>2017-05-20T02:12:01.000Z</published>
    <updated>2017-05-20T07:56:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://projectlombok.org/index.html" target="_blank" rel="external">Lombok</a>是一个比较早、小众但是功能强大的Java库，源码在<a href="https://github.com/rzwitserloot/lombok" target="_blank" rel="external">github上</a>。如果你厌恶写Java代码时不得不手写或用IDE生成大量无趣的样板代码，如getter、setter等，那就准备好拥抱lombok吧。<br><a id="more"></a></p>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><h3 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h3><p>Lombok通过注解来减少样板代码的使用。对于数据类来说，自己看<a href="https://projectlombok.org/" target="_blank" rel="external">官网的视频</a>吧。三分钟太长不想看？那么也可以快速浏览一下<a href="https://projectlombok.org/features/Data.html" target="_blank" rel="external">这里的代码</a>。神奇的事情是怎么做到的呢？奥秘就是<a href="http://notatube.blogspot.com/2010/11/project-lombok-trick-explained.html" target="_blank" rel="external">在编译时插入代码</a>。你甚至还可以创建自己的注解！参考<a href="http://notatube.blogspot.com/2010/12/project-lombok-creating-custom.html" target="_blank" rel="external">这篇文章</a></p>
<h3 id="其它特性"><a href="#其它特性" class="headerlink" title="其它特性"></a>其它特性</h3><p>除了本职的数据类以外，lombok还提供了许多<a href="https://projectlombok.org/features/index.html" target="_blank" rel="external">其它的特性</a>，以帮助我们减少样板代码的使用。官网的说明非常详细，也都附带了代码，我就不做说明书的搬运工了。这里放一个例子：<a href="https://projectlombok.org/features/Synchronized.html" target="_blank" rel="external">@Synchronized</a>。</p>
<h2 id="与Intellij-IDEA集成"><a href="#与Intellij-IDEA集成" class="headerlink" title="与Intellij IDEA集成"></a>与Intellij IDEA集成</h2><p>动手时间。新建Maven工程，往pom.xml中增加dependency，最后的pom.xml看起来就像这样：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></div><div class="line">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.ggg.lombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>helloLombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>在src/main/java中新增一个Person类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Person类中右击，Go To，Test（或者Ctrl/Command+T）便可以在src/test/java中新增一个对应的测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.junit.Test;</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span> </span>&#123;</div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">should_get_name_from_person</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> Person(<span class="string">"ggg"</span>, <span class="number">18</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>出现了一条红线，编译失败。回到Person类中，在Person类的定义上面加上<code>@AllArgsConstructor</code>并<code>import lombok.AllArgsConstructor;</code>，还是编译不过。现在到了应该加载IDEA插件的时候了。参考<a href="https://github.com/mplushnikov/lombok-intellij-plugin" target="_blank" rel="external">这里</a>来安装lombok插件，别忘了重启Intellij IDEA。这回编译成功了。在测试的调用构造函数处Command/Ctrl+B便能跳转到Person类的<code>@AllArgsConstructor</code>上。接着写测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Person ggg = <span class="keyword">new</span> Person(<span class="string">"ggg"</span>, <span class="number">18</span>);</div><div class="line"></div><div class="line">assertEquals(<span class="string">"ggg"</span>, ggg.getName());</div></pre></td></tr></table></figure></p>
<p>getName又红了。切换回Person类，再加上<code>@Getter</code>，编译通过！运行测试，绿了！<br><img src="/img/lombok.jpg" alt=""></p>
<p>还可以通过Find Usages来找到字段的get方法在哪调用，可惜不能找到构造函数在哪调用。在享用便捷的同时，也需要付出些许的代价。有兴趣的看官可以自行尝试文档中的其它注解。例如<code>@ToString(of=&quot;name&quot;)</code>，<code>@Log</code>，<code>@Getter(lazy=true)</code>等等。值得一提的是，<a href="https://projectlombok.org/features/Cleanup.html" target="_blank" rel="external">@Cleanup</a>可以轻松地关闭流、连接等对象，Java 7也提供了<a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html" target="_blank" rel="external">try-with-resources</a>来做到这一点，只不过需要缩进罢了，但是可以很明显地看出作用域。还请自行选择喜欢的那个。当然，如果你的项目还在用老旧的Java 6，那确实也没有什么选择的余地。</p>
<h2 id="风险"><a href="#风险" class="headerlink" title="风险"></a>风险</h2><p>首先，Lombok扮演着一个注解处理器的角色，在编译时通过修改抽象语法树（Abstract Syntax Tree，AST）来修改代码。但是这是被注解处理器规范所明令禁止的，规范仅允许生成新文件或是新类。而聪明的lombok开发者通过javac未公开的API绕开了这个限制。所以有人视lombok为邪门歪道。不过嘛，不管黑猫白猫，能捉老鼠的就是好猫；不管黑糖白糖，能少写代码的就是好糖。先了解它，再决定要不要因为代价而放弃收益。如果未来的Java版本取消了后门，那么使用lombok的项目就存在升级JDK的风险。如果介意这一点，并且只有数据类的需求，可以去看看google的<a href="https://github.com/google/auto/blob/master/value/userguide/index.md" target="_blank" rel="external">AutoValue</a>。不过白魔法比黑魔法总是缺了点什么…</p>
<p>第二点是IDE的支持。虽然是支持，但是你也看到了并不能像原来虽然写了代码，但大都是自动生成的代码那样随心所欲地各种重构。另外IDE偶尔抽点风也可能会让你流半天汗。</p>
<p>最后一点是代码覆盖率的测试。如果贵公司对它有明确而严格的要求，那就需要好好研究lombok与所用的代码覆盖率工具的兼容程度了。目前看来lombok与<a href="http://cobertura.github.io/cobertura/" target="_blank" rel="external">Cobertura</a>的兼容性还是最好的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://projectlombok.org/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Lombok&lt;/a&gt;是一个比较早、小众但是功能强大的Java库，源码在&lt;a href=&quot;https://github.com/rzwitserloot/lombok&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github上&lt;/a&gt;。如果你厌恶写Java代码时不得不手写或用IDE生成大量无趣的样板代码，如getter、setter等，那就准备好拥抱lombok吧。&lt;br&gt;
    
    </summary>
    
      <category term="development" scheme="http://qinghua.github.io/categories/development/"/>
    
    
      <category term="lombok" scheme="http://qinghua.github.io/tags/lombok/"/>
    
  </entry>
  
  <entry>
    <title>区块链技术浅析</title>
    <link href="http://qinghua.github.io/blockchain/"/>
    <id>http://qinghua.github.io/blockchain/</id>
    <published>2017-04-03T05:33:33.000Z</published>
    <updated>2017-04-03T15:06:19.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zh.wikipedia.org/wiki/%E5%8C%BA%E5%9D%97%E9%93%BE" target="_blank" rel="external">区块链</a>是2016年起突然走红起来的一门技术，连国务院印发的<a href="http://news.sohu.com/20161227/n477114271.shtml" target="_blank" rel="external">《“十三五”国家信息化规划》</a>也将其纳入。上周公司举办黑客马拉松的活动，有幸浅尝了一下区块链的应用，本文旨在记录并分享区块链的一些心得。<br><a id="more"></a></p>
<h2 id="比特币（Bitcoin）"><a href="#比特币（Bitcoin）" class="headerlink" title="比特币（Bitcoin）"></a>比特币（Bitcoin）</h2><p>要说清楚区块链，首先需要了解<a href="https://zh.wikipedia.org/wiki/%E6%AF%94%E7%89%B9%E5%B8%81" target="_blank" rel="external">比特币</a>。2008年金融危机时，神秘的<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E6%9C%AC%E8%81%AA" target="_blank" rel="external">中本聪</a>发表了一篇论文，详细描述了比特币。一年之后，他将其实现。再一年之后，他便把比特币交予社区维护，自己不再露面了。比特币其实就是一个文件，里面记载了所有人的账户及交易信息。这个文件只能往里增加数据而不能修改数据。比特币网络中的每一个人都拥有这个文件的备份。</p>
<p>我也可以写一个文件来表示所有人的帐户信息，但是它一文不值。为什么比特币就有价值呢？它存在价值是因为人们相信它有价值，就像印出来的钞票一样。而人们自发的信任是需要时间的。最初比特币也没有什么价值。第一笔交易发生在2010年，一位程序员在佛罗里达花了一万个比特币购买了价值25美元的披萨。截止本文发布，一个比特币大约是7000元人民币左右，可以在<a href="https://www.okcoin.cn/market-btc.html" target="_blank" rel="external">OKCoin</a>上查看。随着比特币的流行，出现了不少类似的货币，如以太坊（Ethereum）、莱特币（Litecoin）等等。只要有人相信它，它就有价值。想当年刚听说比特币的时候，我心底还暗自嘲笑怎么会有人相信这种一点实体都没有的东西，事实证明我还是太naive了。</p>
<p>作为一种货币，需要能够向别人转账。假如邻居家老王要给你转10个比特币，他需要把这笔交易写入文件并告诉比特币网络的其他节点，让大家把交易添加进这个文件。所以每个人都能够得知这笔交易信息。现在问题来了，其它的节点怎么知道这笔转账是可信的，即老王提出的呢？要是每个人都发起从老王转账到自己的请求，那老王可就亏死了。其他人当然做不到。因为这笔交易需要用老王的私钥签名。公私钥的简介可以参考我写的<a href="http://qinghua.github.io/certificate/#u975E_u5BF9_u79F0_u52A0_u5BC6">《证书的那些事儿》的非对称加密一节</a>。其他人拿不到老王的私钥，当然就无从伪造请求了。在比特币中，公钥也用于表示对方的地址。消费时，你需要用数字签名证明你拥有对应的私钥。比特币没有中心节点，所以如果老王转错账了，抱歉，要不回来了。你只知道对方的公钥（或者说是比特币的帐号或地址），并不知道对方的身份。</p>
<p>为了安全，比特币上并不会记载每个账户的余额是多少。每当要转账时，它需要提供至少一笔未消费的历史交易信息作为input，转完账后，剩余的部分称为零钱，可以转入你自己的公钥，或是你小号的公钥。至此，未消费的交易就变成了已消费，不能被再次使用了。所以多次重复的请求只有第一笔才能成功。比特币的转账并非立即生效，只有在解开一道数学题之后才行。解题的过程就叫挖矿。题目的难度由程序控制，程序会根据历史记录把解题时间控制在大约十分钟左右。</p>
<p>还有一个问题，由于网络传输的不确定性，你并不能保证老王的转账被及时同步到了所有的节点上。所以如果在这笔交易完全传播出去之前，老王又在这笔交易之前将本来作为input的历史交易转帐给他的小号呢？其它的节点根本判断不了哪个在前，哪个在后。所以顺序在这里至关重要。比特币是这么解决这个问题的：把交易分配到区块里（多对一），然后将区块链接起来，称为区块链。每个区块都会引用上一个区块，这样便实现了有序。同一区块内的交易被认为是同时发生的。由于同一时间可能会产生多笔交易，所以可能会产生多个区块。那如何知道应该以哪一个区块为准呢？事实上，每一个区块都包含了一道特殊的数学题，只有解开这道题才能使之有效。当一个节点解开了这道题，它便会向比特币网络广播自己的结果，并把交易排在区块链的下一位。如果偶尔有多人同时解出了结果，那么区块链便会产生不同的分支。两个分支开始竞争，看谁能够更快生成下一个区块。哪个分支更长，哪个分支就有效。这样的话，由于多人同时算出答案的概率很低，所以分支会在一定时间之后消失。如果你的交易在一个消失的分支的区块里，便会重新放到未确认的交易区里，等待加入下一个区块。那如果有人能快速计算多个区块，岂不是可以随心所欲了？话虽如此，但是要以个人之力来对抗全网，实在是非常困难的事情。除非控制了整个比特币网络上50%以上的运算力，才开始有可能做到。这样的成本是非常高的，对于一般的交易来说，实在是有些不值得。你也无法提前运算，因为下一个区块需要引用当前的区块和随机数，只有在当前区块完成之后，才能开始计算。所以说参与的机器越多，比特币或者说区块链就越安全。还有一点值得注意的是，越前面的区块就越安全，因为攻击所需的资源会越大。小规模的转账，等一个区块便可以了；大规模的话，最好多等几个，以降低分支消失的概率。</p>
<p>有意思的是，由于比特币网络上的机器是那么的多，导致个人很难能够挖到矿。所以采矿池（mining pool）应运而生，集多人的算力，挖到矿后根据贡献来分配。但是采矿池太大了也会带来安全问题，因为有可能超过了50%的运算力。有一家BTC Guild曾经能够独立解出一个链中的6个区块，所以这个采矿组织主动限制了规模和会员的数量，以减少比特币网络成员的不安。</p>
<h2 id="区块链（blockchain）"><a href="#区块链（blockchain）" class="headerlink" title="区块链（blockchain）"></a>区块链（blockchain）</h2><p>上一节已经介绍了比特币的区块链了。其实区块链就是一个去中心化的存储。在这一点上，它与git是比较相似的。它们都是分布式、无中心的链式存储，但是在出现分支时的解决方式不一样。Git可以通过merge和rebase来解决冲突，而区块链则是通过链的长度来自动废弃分支，作废分支里的交易重新放到未确认的交易区里，以便下次再放入新区块里，这样的行为有些类似<code>git rebase</code>。</p>
<p>由于区块链不停地往里增加区块，势必导致文件越来越大。虽然可以控制区块的大小（最大1M）和增长速度（10分钟左右），但这么计算每年也有<code>365×24×6×1M=52G</code>左右的数据。长此以往，如何受得了？作为消费者来说，已经校验并消费过了的历史数据，可以仅保存其散列码，这样便能大大减少数据。比特币钱包用的是<a href="https://en.wikipedia.org/wiki/Merkle_tree" target="_blank" rel="external">Merkle Tree</a>来做验证。</p>
<p>区块链按照参与者的身份，可以分为公有链（Public blockchain）、联盟链（Consortium blockchain）和私有链（Private blockchain），公有链如比特币，是通过挖矿来达成共识（consensus），但是挖矿的计算需要消耗大量的电力资源。联盟链顾名思义，仅由联盟内部可写，外部经过授权可读。而私有链只有一个成员可写，类似传统的分布式数据库。联盟链和私有链由于成员并非匿名，可受部分信任，并且消耗运算力其实也是一种浪费，所以可以相对放松一些要求，不必非得挖矿，可以通过共识协议来达成共识。</p>
<p>使用区块链必须能够达成共识，否则就失去意义了。其实传统的分布式一致性算法也能解决达成共识的问题，只不过一般并不考虑恶意节点篡改数据的问题罢了，而且实际上使用的节点也不像区块链那么多。传统的常见算法有：ZooKeeper使用的Zab协议；etcd使用的Raft协议；当然还有大名鼎鼎的Paxos协议。限于篇幅，本文就不具体讨论它们的具体算法了。</p>
<p>区块链最主要的贡献，是解决了在不信任网络中的信任问题。与传统的解决方案相反，参与区块链的人越多则越安全。但是如果你的组织已经有足够的信誉，是否真的需要使用区块链来实现？当你想使用区块链技术来解决特定问题的时候，应该先问问自己，如果不用区块链，会有什么问题？如果回答不了这个问题，那可能你对区块链还不够了解，或者是区块链并不是你问题的最佳解决方案。相对于技术本身来说，更麻烦的问题是靠谱的想法和实施。别手里拿着个锤子看什么都是钉子哦。再考虑一下传统的方案吧。</p>
<p>除了金融领域以外，还有许多应用区块链的有趣想法：</p>
<ul>
<li><a href="http://business.sohu.com/20160414/n444147338.shtml" target="_blank" rel="external">当Airbnb遇到区块链：你弄碎房东花瓶的事全世界都会知道</a></li>
<li><a href="http://www.weiyangx.com/165124.html" target="_blank" rel="external">纳斯达克在爱沙尼亚推出区块链投票系统</a></li>
<li><a href="http://36kr.com/p/5068610.html" target="_blank" rel="external">沃尔玛推零售“黑科技”:区块链跟踪食品溯源</a></li>
<li><a href="http://news.163.com/16/0711/05/BRLVNTKN00014AED.html" target="_blank" rel="external">蚂蚁金服将使用区块链技术 追踪每一笔公益善款去向</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://v.youku.com/v_show/id_XNjQ0NzE0Mjky.html" target="_blank" rel="external">《详解比特币的原理和运行机制》</a><br><a href="http://blockchaindev.org/article/introduce_blockchain.html" target="_blank" rel="external">《区块链(Blockchain)深入介绍》</a><br><a href="http://blockchaindev.org/article/consensus_introduction.html" target="_blank" rel="external">《浅谈区块链共识机制与分布式一致性算法》</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%8C%BA%E5%9D%97%E9%93%BE&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;区块链&lt;/a&gt;是2016年起突然走红起来的一门技术，连国务院印发的&lt;a href=&quot;http://news.sohu.com/20161227/n477114271.shtml&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《“十三五”国家信息化规划》&lt;/a&gt;也将其纳入。上周公司举办黑客马拉松的活动，有幸浅尝了一下区块链的应用，本文旨在记录并分享区块链的一些心得。&lt;br&gt;
    
    </summary>
    
      <category term="architecture" scheme="http://qinghua.github.io/categories/architecture/"/>
    
    
      <category term="blockchain" scheme="http://qinghua.github.io/tags/blockchain/"/>
    
  </entry>
  
  <entry>
    <title>DevOpsDays北京站见闻</title>
    <link href="http://qinghua.github.io/devopsdays-beijing-2017/"/>
    <id>http://qinghua.github.io/devopsdays-beijing-2017/</id>
    <published>2017-03-19T12:00:00.000Z</published>
    <updated>2017-03-19T13:57:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>首度来到中国的DevOpsDays北京站昨天顺利举行了。有幸得到赠票，在大会上见到了DevOps之父Patrick Debois还有诸多业内专家。当天的盛况及ppt下载请移步<a href="http://mp.weixin.qq.com/s/A6QDB4Z-O5cm4KCnDOmKAw" target="_blank" rel="external">此处</a>。<br><a id="more"></a></p>
<p>传统的DevOps主要涵盖了CAMS（Culture文化、Automation自动化、Measure度量、Sharing分享）四大方面。而要落地DevOps，需要两条腿：一条是组织方面的转型，另一条是技术方面的自动化工具。组织转型是要涉及到利益的，不容易下手。所以大部分的分享还是以技术方面为主。只有Patrick的好基友<a href="http://www.krisbuytaert.be/blog/" target="_blank" rel="external">Kris Buytaert</a>的ppt讲的是reorg。乔梁讲的是他在百度和腾讯的经历，但可能是受时间所限并没有太多的实际内容。如果没有自上而下的变革，很难推动起组织转型。对于许多人来说，也许能够做到的，也就是自动化工具罢了。下午的Open Space深度交流专场里，不乏对组织转型方面的问题，但是嘉宾们其实也没有什么非常好的办法。有些技巧（比如说拿数据说话）可以让你把DevOps推销给老板，但终究一场战斗的胜利很难能够左右战略上的部署。没有自上而下的决心和后盾，在触及利益的时候肯定是各种痛啊。两条慢腿可能凑活着还能走走，一条腿快一条腿慢必然会驱使着变革的前进或倒退。DevOps讲究痛点驱动，相信以后的DevOpsDays会有更多组织转型方面的分享。</p>
<p>在技术上，专家们一直强调，没有DevOps团队，别叫他们DevOps工程师。DevOps需要融入到跨功能团队中的每一个人，不是某一类人，不是某一个团队。这里我感觉有一个词很重要：<strong>同理心</strong>。有了同理心，你会理解其它角色的痛点，反之亦然。由此，便可以催生出<strong>分享</strong>。有了分享，理解痛点，便能从“像部署一样痛苦的事要多做”出发，提取出最佳实践，催生<strong>自动化</strong>。要衡量效果如何？数据说话。于是催生<strong>度量</strong>。这几方面相辅相成，在整体的良性循环之下，团队<strong>文化</strong>的成型便是顺理成章。怎样让大家拥有同理心？除了依靠人的素质进步，百度的刘俊还提到了一个做法，据说甚是有效，那就是开发运维轮岗。想想也对，把你推到别人的位置上，自然就有同理心了。</p>
<p>我在《DevOps实践》的译者序上也说过，DevOps是要很高成本的。在应用它之前，先问自己这样的问题：为什么要上DevOps？它能解决我的什么问题？不要说我想提高工作效率，提高程序质量，要从更高层次的业务上说。换句话说，从战略层面上想清楚应用DevOps的目的，然后在战术层面上依照战略来有根据有优先级地安排资源打硬仗。跟性能调优一样，搞清楚哪里才是瓶颈，针对性地动手解决。而不是直接拍胸脯就上DevOps，把最宝贵的资源浪费在可能对这个组织最没用的地方上。</p>
<p>对于中小企业来说，不要开发自己的自动化工具，不要重复发明轮子，直接拿现成的开源工具来用吧。不是BAT这样的量级，玩不起自研版的工具，它们其实是很重量级的。针对开源工具有些功能不符合自己的需求这方面，ThoughtWorks的黄博文说道：可以从另一个角度来看待这个问题，为什么你要的功能没有？这是一个正常的功能吗？究竟是功能的缺失，还是说只是你走错了路？此言深得我心。据说业界运维做得最好的应该就是谷歌和Netfilx。它们都有不少开源的运维工具，值得业内人士仔细研究。</p>
<p>最后放一张乔梁对DevOps和持续交付的看法，四个角色分别是产品、开发、测试和运维。先剧透一下并不是所有人都同意这个观点，少年，你怎么看？<br><img src="/img/agile-devops-and-cicd.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首度来到中国的DevOpsDays北京站昨天顺利举行了。有幸得到赠票，在大会上见到了DevOps之父Patrick Debois还有诸多业内专家。当天的盛况及ppt下载请移步&lt;a href=&quot;http://mp.weixin.qq.com/s/A6QDB4Z-O5cm4KCnDOmKAw&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;此处&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="devops" scheme="http://qinghua.github.io/categories/devops/"/>
    
    
      <category term="activity" scheme="http://qinghua.github.io/tags/activity/"/>
    
  </entry>
  
  <entry>
    <title>如何测试随机数</title>
    <link href="http://qinghua.github.io/test-random/"/>
    <id>http://qinghua.github.io/test-random/</id>
    <published>2017-03-05T06:32:19.000Z</published>
    <updated>2017-03-05T07:18:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>怎样知道它是不是<a href="https://zh.wikipedia.org/wiki/%E9%9A%8F%E6%9C%BA%E6%95%B0" target="_blank" rel="external">随机数</a>？如何测试一个<a href="https://zh.wikipedia.org/wiki/%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8" target="_blank" rel="external">随机数生成器</a>？<br><a id="more"></a></p>
<p>有些程序很容易测试，但并非所有程序都是如此。自动化测试的目的是以现在的时间成本，来换取未来的时间成本。很多程序员们经常自己写一个小玩意，就不爱写测试了，这是因为他们觉得这个小玩意也就用那么几次，不值得为它单写一个测试。从这个角度上看，这是没错的。大型项目经常会有比较完备的测试，因为这个项目可能会交付很长时间，也可能会有很长的维护时间。这时候测试的成本就可以在未来得到回报。测试随机数生成器，首先要回答的问题是：值不值得做这个测试？如果说这个随机数生成器本来就是系统提供的接口，那是否我们有必要费精力去测试它呢？如果它是不可靠的，那可能暗示着你的技术选型出了问题。如果它可靠（<a href="https://zh.wikipedia.org/wiki/%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%80%A7" target="_blank" rel="external">伪随机数</a>也算是可靠），那是否可以使用系统的随机数生成器来生成你自己特定的随机数生成器呢？在这种情况下，自己写的随机数生成器还是可能需要测试的。那应该怎么测试它呢？</p>
<p>让我们来举个简单的例子。比如我们需要得到由两位数字组成的随机字符串（”00”~”99”），它要做的仅仅是调用系统接口生成0~99的数字并格式化为”00”~”99”的字符串。这时我们只需测试它调用系统接口的参数，以及格式化的逻辑即可。而它们都可以通过mock等技术手段很容易地测试。在系统提供的随机数生成器的支持下，应该是可以满足大部分的随机需求的。</p>
<p>如果你非要以打硬仗的方式来测试随机数的话，除去成本因素，要想从纯技术上回答这个问题，那就要先回答另一个问题：什么是随机数？这就回到了业务的本质：在不考虑测试时，在什么情况下你会认为它是一个随机数？简单起见，我们就以0~99的伪随机数为例。取决于业务，可能你的需求是：①连续两次执行结果基本不同（“基本”是由于真随机的不可预测性，它们是可能相同的），或者是②连续执行100遍每次数字都不同，或者是③计算一万遍，要求结果呈现怎样怎样的分布。对于①来说，两次计算结果相同的概率只有百分之一（1% <em> 1% </em> 100），三次结果相同的概率只有万分之一（1% <em> 1% </em> 1% * 100）。所以测试可以这样来设计：调用两次，如果结果相同，那就再调用一次，如果还相同，那就再调用，直至不同为止。最后看调用次数<code>count</code>：如果<code>count = 2</code>，很好。如果<code>count = 3</code>，那就说明现在正好是1%的那次。如果<code>count = 4</code>，说明是0.01%的那次。理想情况下，如果每天运行100次测试，可能会有1次<code>count = 3</code>，运行100天，有1次<code>count = 4</code>，运行10000天（大约27年），会有一次<code>count = 5</code>。根据业务的容忍程度判断<code>count</code>的大小，例如当它大于5就算测试失败。虽然偶尔也会出现<code>count = 6</code>的情况，但是非常罕有，平均2700年会有一次，而且就算测试失败，也很容易排查到这个问题。所以就可以认为是符合业务需求。对于②来说，那就执行100遍看结果好了，也是技术上可实现的。对于③来说，其实与①有相似之处，只要能够描述出来，就能够测试出来。只要自己控制好测试的阈值就可以了。</p>
<p>维基百科上提供了一些<a href="https://zh.wikipedia.org/wiki/%E9%9A%8F%E6%9C%BA%E6%80%A7#.E9.9A.8F.E6.9C.BA.E6.80.A7.E6.B5.8B.E8.AF.95.E6.96.B9.E6.B3.95" target="_blank" rel="external">随机性测试方法</a>。只要能描述，就可以测试。但是，值得吗？</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;怎样知道它是不是&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%9A%8F%E6%9C%BA%E6%95%B0&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;随机数&lt;/a&gt;？如何测试一个&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;随机数生成器&lt;/a&gt;？&lt;br&gt;
    
    </summary>
    
      <category term="development" scheme="http://qinghua.github.io/categories/development/"/>
    
    
      <category term="test" scheme="http://qinghua.github.io/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>如何尽量避免生产事故</title>
    <link href="http://qinghua.github.io/avoid-production-accident/"/>
    <id>http://qinghua.github.io/avoid-production-accident/</id>
    <published>2017-02-02T02:22:21.000Z</published>
    <updated>2017-02-05T13:43:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>运维不好当啊。上个月<a href="http://hs.blizzard.cn/articles/16/8565" target="_blank" rel="external">炉石传说数据库故障导致数据损坏</a>刚刚补偿完毕，这两天又出了个<a href="http://www.oschina.net/news/81473/gitlab-com-down" target="_blank" rel="external">GitLab误删生产数据库</a>。本文聊聊尽量避免生产事故的一些方法。<br><a id="more"></a></p>
<p>我看到<a href="http://mp.weixin.qq.com/s/kTA24o0opEk51Q-RNNWPKg" target="_blank" rel="external">圈内讨论</a>里有人说，重要系统维护的时候必须两个人一起干活，一个做另外一个在旁边看。这有点儿像是结对编程的思路。我觉得两个人一起固然会好一点，但从结对的实际经验来看，一来可能导致效率更低，二来两个人一起也不能保证不会出问题。大部分情况下这两个人的水平并不是一致的，水平高的人操作，容易导致另一个人只是干看着；而水平低的人操作，反而增加了误操作的几率，需要水平高的人紧盯着。</p>
<p>还有人说，改造一下<code>rm -rf</code>，让它只能删空目录，我觉得这是一个不错的点子。由于人总是可能会出错，所以由一个机制来保证（法制而非人治），效果应该更加理想。不过这种办法也有几个问题存在。一是所有的机器都需要替换并保持<code>rm</code>命令，二是操作的时候还是不免会稍微降低效率，三是误操作一般是在低意识的时候发生，<code>rm</code>的报错，固然有可能会警醒操作者，但也有可能在惯性思维的引导下使操作者直接调用重命名后的老<code>rm</code>。还有其它的办法吗？</p>
<p>我也来抛砖引玉一个：如果从数据库同步上着手呢？只要是关于删除数据库、数据表（数据记录单谈，视需求而定）的操作，都创建新库来备份旧数据而非直接删除。缺点一是需要修改同步工具的代码，工作难度比较大；二是需要定期清理同步数据库。</p>
<p>至于各种灾难恢复演练，确实很有必要，可惜目前的现实是大家每天手上都是一堆活儿，加上IT人员流动性又高，可操作性就欠缺了一点。无论如何，从性价比上来说，一个定期的备份绝对是避免进一步损失的救命稻草。当然，还有不断地学习……</p>
<p><img src="/img/mysql-drop-and-run.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;运维不好当啊。上个月&lt;a href=&quot;http://hs.blizzard.cn/articles/16/8565&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;炉石传说数据库故障导致数据损坏&lt;/a&gt;刚刚补偿完毕，这两天又出了个&lt;a href=&quot;http://www.oschina.net/news/81473/gitlab-com-down&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitLab误删生产数据库&lt;/a&gt;。本文聊聊尽量避免生产事故的一些方法。&lt;br&gt;
    
    </summary>
    
      <category term="idea" scheme="http://qinghua.github.io/categories/idea/"/>
    
    
      <category term="soft skill" scheme="http://qinghua.github.io/tags/soft-skill/"/>
    
  </entry>
  
  <entry>
    <title>创业公司里就职的那些事儿</title>
    <link href="http://qinghua.github.io/work-in-start-up/"/>
    <id>http://qinghua.github.io/work-in-start-up/</id>
    <published>2017-01-10T01:46:50.000Z</published>
    <updated>2017-01-10T08:41:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>创业公司和一般公司很不一样。第一次加入的小伙伴们如果了解得不够清楚，可能会像我当初那样一脸懵逼。本文主要说的是加入创业公司的一些值得注意的地方。<br><a id="more"></a></p>
<p>创业公司的特点就是快。哪怕代码写的烂，不好维护，也要比竞品更快地推出新功能。当然，这样的程序质量太差，过了一段时间就很难维护或是扩展了。所以在中期拉到投资之后，重心就转移到重构代码使之更稳定上面。当然也有只要修修补补能撑到上市那天就行的战略。至于后期，像阿里腾讯这样的，持续地为社区贡献出开源代码，那就已经是质量非常好的程序了。所以一句话总结就是：前期快速从无到有，中期从有到好，后期从好到精。</p>
<p>在大公司里，业务和体系都已经比较成熟了，你的位置可能就是一颗螺丝钉，但是可以研究得很深。而在创业公司里，对个人来说，会接触到方方面面的知识，得到更全面的发展，可能研究得广而不深。大公司的机会比较少，创业公司的机会比较多，倒闭的风险也很大。</p>
<h2 id="融资"><a href="#融资" class="headerlink" title="融资"></a>融资</h2><p>面试的时候，hr总会介绍：我们公司现在已经是A/B/C轮融资了，估值多少多少万美元。可是在当时的我看来，只不过是一个字母和一个数字罢了，没有太深的感触。它究竟有什么意义呢？这要从创业公司的成长过程说起了。来自36氪的下图说得非常清楚：<br><img src="/img/idea-to-ipo.jpg" alt=""></p>
<ul>
<li>种子轮和天使轮还没有产品，变数太大，就不细说了。</li>
<li>A轮意味着已经有了一小部分的用户规模，产品得到初步验证，但是对收入没有什么要求。</li>
<li>B轮意味着更大规模的用户，也开始要求有初步的商业模式了，对于共享单车这样的领域，很明显用户要使用就必须付费，所以自带商业模式光环，只要市场占有率高就行。</li>
<li>C轮意味着需要开始变现、盈利，不断地用钱去砸市场。如果市场还没有抢下来，很可能还需要继续融资往里烧钱。</li>
<li>到了DEF轮，就没有什么本质上的区别了。</li>
</ul>
<p>创业公司在C轮之前挂掉很正常，例如找不到盈利模式，或是占不住市场。到了D轮，挂掉的风险就非常小了，公司一般都是奔着上市去了，再不行还可以被收购。</p>
<h2 id="期权"><a href="#期权" class="headerlink" title="期权"></a>期权</h2><p>期权（option）是员工持股计划（ESOP，Employee Stock Ownership Plans）的一种方式，用于激励员工。期权本身并不是股票，但是赋予了员工以较低价格购买公司普通股（ordinary shares）的权利。一开始100%的股池里，可能会抽出10%~20%作为员工的持股。不过随着每一轮的新投资进来，包括前期投资人在内的所有人的股份都会被稀释。例如：某创业公司天使轮估值1000万，这时候天使投资人投了200万占20%，员工占10%，创始人占70%；到了A轮估值2000万，A轮投资人投了400万占20%，所以原来100%的总池子就只能占80%了，员工就被稀释成了8%，天使投资人变成了16%，创始人变成了56%。不过员工部分虽然原来从10%变成8%，看起来比例降了，但是价值由100万升值为160万，反而倒是更值钱了。不过出于公司持续发展，新人不断进入，需要激励员工的原因，新的投资人一般会要求保持员工的10%不变，那么多出来的2%就需要从创始人和各投资人之间博弈中产生了。</p>
<p>对于员工来说，进入创业公司，一般来说薪水会比正常公司低一些，但是公司会通过给予期权来提供一夜暴富的可能。一般都是预计给你多少多少股（例如一万股），每年给四分之一，头四分之一需要工作满一年之后才有，也有分季度给的，也有两年之后给一半的，也有根据公司业绩和个人表现，在入职一定时间之后再谈的，比较灵活。一般一年内离职，是拿不到期权的。如果公司已经上市，并且员工已经拿到了期权，就可以在解禁期后行权将其变为股票。公司与员工约定的价格成为行权价（exercise price），加入公司越早，行权价越低，甚至可能是0元。每一轮投资之后，由于估值上升，行权价也会上升。但是行权价对特定员工来说是固定的，也就是说，如果当初说的就是0.01刀一股，那么第四年行权价对此员工来说还是0.01刀一股。而第四年新加入的员工可能已经变成10刀一股的行权价了。越早进入收益越大，当然也伴随这更大的风险。同一时期加入的新员工，行权价是一样的，但是期权数量上可能会不一样。员工能赚取的收益，就是（当前每股价格－行权价）×股数-税收。如果运气不好碰到股票价格下降，也可以选择不行权。如果能等到上市，虽然很难，但是回报最高。有时候下一轮投资者进来，员工也会有机会套现一部分，但是套现的比例和对象都是由公司来决定的。虽然说上市最好，但是万一命不好碰上了普通股对美股18比1的稀释，也只有自吞苦水了。还有，期权是有有效期的，必须在规定的时间内行权，否则就作废了。</p>
<p>如果公司还未上市，那就麻烦了。要是员工获取了一些期权后，中途离职呢？一般看公司（创始人）的厚道程度，有这么几种做法：</p>
<ul>
<li>公司折价（例如70%或80%）回购，当然对员工来说非常有利了</li>
<li>保留期权，可以等到最终上市再行权，这样对员工来说也不错，但是对于公司来说，可能就会导致期权都发完了，后入职的员工就拿不到期权了</li>
<li>离职三个月或半年内确定是否行权，若行权则需要员工掏钱。风险较大，若最终未上市，可能股份就变得一文不值了</li>
<li>直接作废……</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://workspace.fx114.net/qa-203-156906.aspx" target="_blank" rel="external">《期权有哪些坑,你知道吗?》</a><br><a href="https://www.zhihu.com/question/23357108/answer/76897476" target="_blank" rel="external">《你该怎么选Offer》</a><br><a href="https://www.zhihu.com/question/19678660/answer/17228691" target="_blank" rel="external">《在创业公司工作，期权怎么发放？》</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;创业公司和一般公司很不一样。第一次加入的小伙伴们如果了解得不够清楚，可能会像我当初那样一脸懵逼。本文主要说的是加入创业公司的一些值得注意的地方。&lt;br&gt;
    
    </summary>
    
      <category term="idea" scheme="http://qinghua.github.io/categories/idea/"/>
    
    
      <category term="soft skill" scheme="http://qinghua.github.io/tags/soft-skill/"/>
    
      <category term="start up" scheme="http://qinghua.github.io/tags/start-up/"/>
    
  </entry>
  
  <entry>
    <title>如何打造一个好氛围的技术团队</title>
    <link href="http://qinghua.github.io/build-tech-team/"/>
    <id>http://qinghua.github.io/build-tech-team/</id>
    <published>2017-01-09T00:41:23.000Z</published>
    <updated>2017-01-10T01:56:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>在创业团队里，由于自身名气不响，聘用到合适的员工是非常困难的。我就曾经遇上过无数约好面试不来的，几个发完offer后不报道也不主动回复的，甚至还有面试过程中接到BAT电话提供offer于是立马拔脚走人的。本文尝试记录一下某创业公司里，从零开始打造一个好氛围的技术团队的一些心得。<br><a id="more"></a></p>
<h2 id="组建团队"><a href="#组建团队" class="headerlink" title="组建团队"></a>组建团队</h2><p>招聘难，并不意味着就要降低标准。与其为了眼前利益而将就着聘用一个不太合适的人，并可能在未来使你自己还要耗费精力紧盯他的工作，让大家都痛苦，倒不如一开始就不要入这个坑。实际上招聘员工还是有一些技巧的。最靠谱的，就是自己认识，或者是同事内部推荐的人。这样的人有自己或者同事的背书，相比简历pk加海选，一般还是靠谱得多的。设置一个还不错的推荐费，更能增加一些推荐的动力。猎头们手上也会有一些不错的资源，就是会比较贵一些。选对合适的招聘时机也很重要。过年之后有不少领了年终奖后由于各种原因要跳槽的人，对于公司来说，可以选择的余地多了不少。当然弊端是这时候的竞争对手也会有很多。不过如果你的公司有足够吸引力的话（要不然你为什么会在那里？），关系也不大。提供差异化的岗位也是一个办法。有时候招聘时会觉得这人挺不错的，但就是不太适合这个职位，这时如果有条件的话，可以把眼光放长远些，留得好萝卜，不怕没有坑。有些工作还可以考虑以外包、合作甚至兼职的方式完成，不一定非得通过招聘来解决。</p>
<p>团队的规模不要太大，不然管理起来又麻烦又累，效率也不高。也不要求每个人都非常资深，工作经验能够均匀地哈希开就可以了。团队成员的性格和技能上最好能够互补。性格上，可以参考<a href="/effective-communication">《人际风格与有效沟通实战》</a>这篇文章，配备各种性格的队员。技能上，最好每个队员都各有所长，这样才能相互学习，促进团队整体的健康发展。</p>
<h2 id="维护团队"><a href="#维护团队" class="headerlink" title="维护团队"></a>维护团队</h2><h3 id="根"><a href="#根" class="headerlink" title="根"></a>根</h3><p>有了团队之后，就需要让队员在团队里有家一般安心的感觉，这样才能集中精力，发挥出团队的战斗力。新招聘的人，由于对这个团队所知不多，根据各自的性格，可能会不敢表达，或者是急于表现。这就首先需要有一个能让新人感觉可靠的人物。虽然不至于时时嘘寒问暖，但是也要针对不同性格适时鼓励或是交代更多的背景知识。每当我去到一个新团队的时候，我就会把认识的人视为“根”，工作或是政策上有问题都会优先找他，就算他解决不了，也会告诉我应该找谁。有的公司会有类似的政策，称之为buddy或者是sponsor，以帮助新人迅速融入环境。所以为每位新人找到一个合适的“根”，让其从“根”上发芽并迅速成长为参天大树，就是团队领袖的任务之一。</p>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>团队成员如果只是通过工作维系在一起，这样的连接就不是那么的可靠。所以我们需要团队建设（team building）来增加工作之外的连接。我记得新团队的第一次团队建设，是参加一个密室逃脱。在游戏中，不仅能看到每个人的特点和配合能力，还能给未来增加不少谈资，从而加强团队成员间的连接。相比起来，如果只是吃顿饭……效果就比较有限了，但总是比没有强。所以许多公司会有针对新人的拓展训练。如果公司层面能够组织旅游那就更理想了，除了提振团队士气，甚至找到自己的另一半也不无可能。团队发展好了，就会自发产生各种活动，甚至邀请团队成员去自己家里玩，从而将同事变成了朋友，在这样的团队里工作相信一定是令人愉悦的享受，而不仅仅是为了养家糊口而工作。</p>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p><a href="http://wiki.mbalib.com/wiki/%E5%9B%A2%E9%98%9F" target="_blank" rel="external">团队是指一种为了实现某一目标而由相互协作的个体所组成的正式群体</a>，所以明确团队的目标是非常重要的，可以说没有目标就没有团队存在的必要。这个目标需要让所有的团队成员都心中有数。曾经有一段时间完成一期的开发工作之后，第二天团队突然发现没有活儿了，于是有人开始焦虑，有人开始懒散，还有人浑浑噩噩，不知道整天都做了些什么。直到PM组织大家开了一个小会，说明了接下来的目标之后，团队才找到了存在的价值，重新振奋士气走下去。实现团队目标的同时，也可以兼顾团队成员个体的目标，尽量使之也能协同实现。</p>
<h3 id="会议"><a href="#会议" class="headerlink" title="会议"></a>会议</h3><p>工作上，新人可能对别人都干了些什么不那么了解，会有一种“不那么透明”的感觉。每天早上团队<a href="https://zh.wikipedia.org/wiki/%E7%AB%99%E4%BC%9A" target="_blank" rel="external">站会（stand-up meeting）</a>是解决这个问题的良方之一。大家轮着说昨天都做了什么，今天要做些什么，遇到了哪些问题，有心的人自然能从中获取到有用的信息。<a href="https://zh.wikipedia.org/wiki/%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B" target="_blank" rel="external">结对编程（pair programming）</a>也有助于在团队成员之间共享信息，但是它的成本比较高，可以在创业公司中将其作为非常规手段，只在必要的时候结对即可。一个迭代或项目完成之后的<a href="https://zh.wikipedia.org/wiki/Scrum#Scrum.E4.BC.9A.E8.AE.AE" target="_blank" rel="external">回顾会议（retrospective）</a>也对改进团队效率、增加团队透明度很有帮助。大致做法如下：</p>
<ol>
<li>如果团队成员之间不很熟悉，或者氛围非常不好，需要做安全度检查，大家匿名打分，如果分数偏低，需要请在场人士中级别最高的人员离场，之后重复打分直至分数较高为止。如果一直都是很低，那团队肯定有问题。这个会也没有必要开了，领导需要在线下解决。这个是担心开会的时候，大家真话说得少，光说套话等。不说真话的会，不如不开，省的浪费大家时间。</li>
<li>主持人组织大家写一些便利贴，一般包含好的（well）、不好的（less well）和不确定的（puzzle）三类，然后将其贴在白板上并进行归类。一个well的例子可能是我们有XXX新人加入，一个less well的例子可能是好久没有团建了，一个puzzle的例子可能是我们好久没有code review了。主持人应该尽量客观，通常尽量少发表自己的看法。他还要负责时间上的控制，不要太发散了，导致问题都聊不完，或者聊太high了。建议主持人轮岗。</li>
<li>让大家都明白白板上的便利贴说的到底都是什么事。</li>
<li>让大家投票选出最想聊的几件事，然后讨论并记下可以做的行动（action）以及负责人。</li>
<li>主持人记录回顾内容并发给大家（wiki或邮件），这样可以在下次回顾会议的时候看看上次的行动进展如何了。</li>
</ol>
<h3 id="分权"><a href="#分权" class="headerlink" title="分权"></a>分权</h3><p>如果管理得太过精细，管理者难免会心力交瘁（有些人除外）。适当地放手，让团队成员自己负责某一块领域，不仅有助于管理者集中精力处理自己的任务，也更能促进团队成员的成长。即使管理者有事不在的时候，也能迅速找到后备者顶上，解决一些迫在眉睫的问题。每个团队成员都不一样，有些人不喜欢总是做一样的事情，这种时候就可以考虑轮岗，增加其技术广度。而有些人可能由于家庭或别的原因，希望稳定一段时间，这种时候就可以让其深入成为某一领域上的专家。所以一对一地聊一聊，确认对方的喜好，以及公司层面可以提供的支持，可以作为领导者的事前功课。</p>
<h3 id="提高效率"><a href="#提高效率" class="headerlink" title="提高效率"></a>提高效率</h3><p>团队的开发效率非常重要，可以说是关系到团队的存亡。这方面可以采用痛点驱动的办法来提高团队效率。例如，如果程序员写的代码，要部署上某个环境非常费劲，那就会迫使程序员尽量少去部署。这时候团队就需要有人站出来，解决部署慢的问题。有许多时候这其实就是个对某原则的妥协，或是对某个工具不太熟悉罢了。例如，当时团队开发app的h5端的时候，部署测试环境需要五分钟，导致调试效率低下。后来通过分析为什么慢，并打出一系列组合拳来解决那些原因，我们将部署时间缩短到了10秒，大家的工作热情很容易就起来了。还有一次由于包引用的关系，导致部署并调试本地环境需要耗时三分钟。分析原因之后，我们放弃了DRY原则，将比较类似的代码分散到了不同的代码库里，极大地提高了本地的调试效率。而被放弃的DRY原则在这种场景下其实并不是那么的适用。</p>
<p>许多程序员倾向于复制/粘贴代码来作为自己的模板。所以如果技术领导者想要大家写出什么样的代码，首先需要让自己的代码成为理想代码的模板。例如，如果我希望大家编写单元测试，那我的代码就需要有单元测试，这样当其他人复制的时候，就需要考虑单元测试怎么写的问题。但如果只是口头说说，很快就会流于形式。而模板当然不可能一口气就写得那么完美，所以当代码审查的时候，需要识别并不断改进烂代码，还要把思想传达给其他人，最终成为团队共同的财富。</p>
<h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><p>仅有工作的热情还不够，程序员其实并不是吃青春饭的职业，而是终身不断学习提高的职业。团队应该能够提供集体学习的环境，例如大家每周三晚上共同学习某一个课程（例如某个特定技术或是在线课程），共同成长。一个人学，学得快；一群人学，学得深。集体学习因为可以相互分享和讨论，学习效果要比个体学习更加突出。</p>
<h3 id="分享"><a href="#分享" class="headerlink" title="分享"></a>分享</h3><p>要想打造一个技术氛围浓厚的团队，适时地举办技术分享会是一个很不错的办法。一开始可能由于各种原因没人响应，这就需要团队领袖走出第一步并持续鼓励大家分享。如果团队成员不太自信，一开始的分享内容可以是非技术的，也可以是较短时间的。只要走出了第一步，后面总会越来越好的。分享除了让团队成员获取知识，更直接的其实是让分享者自身成长，还有助于将自己塑造成此领域的技术专家形象。分享可能会带来一些工作时间上的消耗（准备分享以及大家聚集在一起的时间），但是从长远来看是非常有益于团队成长和技术氛围构筑的。我所在的上一个团队就成功地推出了两档分享品牌，一个是每周五下午一个小时左右的技术主题分享，以及不定期的午间半小时非技术或是小技术分享。除了session形式的分享以外，还可以有workshop类型的分享，大家一起动手完成某个任务，效果更佳。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在创业团队里，由于自身名气不响，聘用到合适的员工是非常困难的。我就曾经遇上过无数约好面试不来的，几个发完offer后不报道也不主动回复的，甚至还有面试过程中接到BAT电话提供offer于是立马拔脚走人的。本文尝试记录一下某创业公司里，从零开始打造一个好氛围的技术团队的一些心得。&lt;br&gt;
    
    </summary>
    
      <category term="idea" scheme="http://qinghua.github.io/categories/idea/"/>
    
    
      <category term="soft skill" scheme="http://qinghua.github.io/tags/soft-skill/"/>
    
      <category term="start up" scheme="http://qinghua.github.io/tags/start-up/"/>
    
      <category term="management" scheme="http://qinghua.github.io/tags/management/"/>
    
  </entry>
  
</feed>
