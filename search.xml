<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[用AWS创建工作流]]></title>
      <url>/aws-step-functions/</url>
      <content type="html"><![CDATA[<p>AWS提供了一系列易于使用的服务，其中的Step Functions可以用于创建工作流。本文主要介绍了Step Functions的使用并顺带介绍了其它几个相应的AWS服务。此外，亚马逊提供了为期一年的免费账户，可以访问<a href="https://aws.amazon.com/cn/free/" target="_blank" rel="external">AWS</a>来试用。<br><a id="more"></a></p>
<h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><p>首先假定一个场景：我需要定期抓取亚马逊某商品的价格，并通知自己。传统的实现方式就是写一个爬虫，然后在服务器上cron一下就好了。虽然能使，但是一旦考虑到灵活性（商品应该可定制，通知手段应该灵活）、高可用（服务器挂了也不应该影响到业务）、可视化（提供易于使用的界面，以看当前和历史的执行情况）、可监控（看当前的执行情况、出错了需要通知开发者）等，那就费时费力了。好在AWS给我们提供了一系列的服务，允许我们像Linux的管道那样把服务简单、灵活地拼接起来，从而实现需求。</p>
<h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h2><h3 id="服务介绍"><a href="#服务介绍" class="headerlink" title="服务介绍"></a>服务介绍</h3><p>首先简单介绍一下在这个工作流中我们会涉及到的AWS服务：<br><strong>Step Functions</strong>：用于可视化管理工作流。是本文的核心。<br><strong>SNS</strong>：通知服务，只要给主题（Topic）发消息，主题的订阅者（Subscription）就会通过订阅的渠道（如邮件、短信等）收到消息。<br><strong>Lambda</strong>：无需服务器即可运行代码的计算服务，免去了管理服务器的烦恼。只有在程序运行的时候才收费。<br><strong>CloudWatch</strong>：监控或触发AWS资源的服务。在本文中我们姑且把它当做一个cron服务。</p>
<h3 id="Step-Functions"><a href="#Step-Functions" class="headerlink" title="Step Functions"></a>Step Functions</h3><p>对于本文的需求来说，最简单明了的工作流即是下图：<br><img src="/img/aws-sf-CrawAmazonPrice-v1.png" alt=""></p>
<p>非常直观，一眼就能看出来它会先抓取亚马逊的价格，然后通知自己。对于Step Functions来说，这张流程图的代码很简洁：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"StartAt"</span>: <span class="string">"CrawAmazonPrice"</span>,</div><div class="line">  <span class="attr">"States"</span>: &#123;</div><div class="line">    <span class="attr">"CrawAmazonPrice"</span>: &#123;</div><div class="line">      <span class="attr">"Type"</span>: <span class="string">"Task"</span>,</div><div class="line">      <span class="attr">"Resource"</span>: <span class="string">"arn:aws:lambda:us-east-1:XXX_ACCOUNT_ID_XXX:function:CrawAmazonPrice"</span>,</div><div class="line">      <span class="attr">"Next"</span>: <span class="string">"NotifyMe"</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">"NotifyMe"</span>: &#123;</div><div class="line">      <span class="attr">"Type"</span>: <span class="string">"Task"</span>,</div><div class="line">      <span class="attr">"Resource"</span>: <span class="string">"arn:aws:states:::sns:publish"</span>,</div><div class="line">      <span class="attr">"Parameters"</span>: &#123;</div><div class="line">        <span class="attr">"Message.$"</span>: <span class="string">"$.body"</span>,</div><div class="line">        <span class="attr">"TopicArn"</span>: <span class="string">"arn:aws:sns:us-east-1:XXX_ACCOUNT_ID_XXX:PriceDown"</span></div><div class="line">      &#125;,</div><div class="line">      <span class="attr">"End"</span>: <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h3><p>上面的<code>CrawAmazonPrice</code>指定了<code>Resource</code>是一个名为<code>CrawAmazonPrice</code>的AWS Lambda函数，而<code>NotifyMe</code>则指定了一个名为<code>PriceDown</code>的SNS主题。对这个主题感兴趣的用户（比如说，我）可以用期待的方式（邮件、短信等）订阅它。所以这个流程就是：开始-&gt;CrawAmazonPrice（Lambda）-&gt;NotifyMe（SNS）-&gt;结束。</p>
<p>为了简便起见，我们可以直接通过AWS界面实现<code>CrawAmazonPrice</code>的Lambda函数。直接新建一个Python 3.7的脚本即可：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> json</div><div class="line"><span class="keyword">import</span> re</div><div class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">lambda_handler</span><span class="params">(event, context)</span>:</span></div><div class="line">    req = request.Request(<span class="string">'http://www.amazon.cn/dp/B07FNP8DX4'</span>)</div><div class="line">    req.add_header(<span class="string">'User-Agent'</span>, <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102'</span>)</div><div class="line">    response = request.urlopen(req)</div><div class="line">    html = response.read().decode(<span class="string">'utf-8'</span>)</div><div class="line">    price = re.search(<span class="string">'data-asin-price=\"(.+?)\"'</span>, html).group(<span class="number">1</span>)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="string">'statusCode'</span>: <span class="number">200</span>,</div><div class="line">        <span class="string">'body'</span>: json.dumps(price)</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p><img src="/img/aws-lambda-CrawAmazonPrice.png" alt=""></p>
<h3 id="SNS"><a href="#SNS" class="headerlink" title="SNS"></a>SNS</h3><p>SNS就更简单了，创建一个名为<code>PriceDown</code>的新主题，然后为它创建一个协议为<code>Email</code>的订阅，填入自己的邮箱地址，便会收到AWS给这个邮箱发送的确认订阅邮件。点击邮件中的链接，即可完成订阅。要是日后有其他人对这个主题也感兴趣，增加一个订阅即可。<br><img src="/img/aws-sns-PriceDown.png" alt=""></p>
<h3 id="CloudWatch"><a href="#CloudWatch" class="headerlink" title="CloudWatch"></a>CloudWatch</h3><p>剩下的事情就是创建一个CloudWatch，来定期触发这个Step Functions。直接通过AWS界面创建一个规则（Rule），固定频率为每天，将目标设置为上面的Step Function工作流，取个名字如<code>DailyLookUpPrice</code>就可以啦！<br><img src="/img/aws-cw-DailyLookUpPrice.png" alt=""></p>
<h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><p>每次当CloudWatch被触发时，都会在Step Functions中留下自己的足迹。<br><img src="/img/aws-sf-CrawAmazonPrice-execution.png" alt=""></p>
<p>由上图可以看到，每个状态的进入和退出都清晰可见，非常方便。</p>
<h2 id="需求变更"><a href="#需求变更" class="headerlink" title="需求变更"></a>需求变更</h2><p>假如我们只想在价格低的时候通知自己，除了修改Lambda中定义的代码以外，还可以增加一个Task，以便增强灵活性。例如，公司内部有一个最低价格的服务，但是无法被公司外部（如AWS）调用到。即便如此，Step Functions也可以支持这种应用场景。在任何可以调用公司服务的地方写一段代码，这段代码作为一个活动（Activity）来轮询Step Functions，当执行到该Task时，该代码就被运行，调用公司内部的服务。AWS的实现也很简单，首先新增一个名为<code>EnsureLowestPrice</code>的活动，然后在Step Function的JSON中增加一个Task，并修改<code>CrawAmazonPrice</code>，使其<code>Next</code>指向<code>EnsureLowestPrice</code>：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">"EnsureLowestPrice": &#123;</div><div class="line">  "Type": "Task",</div><div class="line">  "Resource": "arn:aws:states:us-east-1:XXX_ACCOUNT_ID_XXX:activity:EnsureLowestPrice",</div><div class="line">  "Next": "NotifyMe"</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这回的Task就不是Lambda啦，而是自己运行在随意机器上的代码。以Java为例，可以参考<a href="https://docs.aws.amazon.com/zh_cn/step-functions/latest/dg/tutorial-creating-activity-state-machine.html" target="_blank" rel="external">AWS官方文档</a>来实现。</p>
<p>“价格低于最低价”的服务，在这里只是一个表示内部服务的示例罢了。当然，如果真要实现一个类似的服务，用AWS的DynamoDB甚至S3可以很方便地实现。</p>
<p>假如需要并行查询多种商品价格，Step Functions也能轻易支持：<br><img src="/img/aws-sf-CrawAmazonPrice-v2.png" alt=""></p>
<p>并行的代码如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">"CrawAmazonPrice": &#123;</div><div class="line">  "Type": "Parallel",</div><div class="line">  "Next": "EnsureLowestPrice",</div><div class="line">  "Branches": [</div><div class="line">    &#123;</div><div class="line">      "StartAt": "CrawPrice1",</div><div class="line">      "States": &#123;</div><div class="line">        "CrawPrice1": &#123;</div><div class="line">          "Type": "Task",</div><div class="line">          "Resource": "arn:aws:lambda:us-east-1:XXX_ACCOUNT_ID_XXX:function:CrawAmazonPrice",</div><div class="line">          "End": true</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">      "StartAt": "CrawPrice2",</div><div class="line">      "States": &#123;</div><div class="line">        "CrawPrice2": &#123;</div><div class="line">          "Type": "Task",</div><div class="line">          "Resource": "arn:aws:lambda:us-east-1:XXX_ACCOUNT_ID_XXX:function:CrawAmazonPrice",</div><div class="line">          "End": true</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于<code>Branches</code>及<code>States</code>的灵活性，再复杂的工作流也不在话下。</p>
<h2 id="进阶功能"><a href="#进阶功能" class="headerlink" title="进阶功能"></a>进阶功能</h2><h3 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h3><p>如果代码出现死循环之类的问题，可能会导致工作流无法继续流动下去。这时可以通过给该状态设置超时<code>TimeoutSeconds</code>以使之到时退出。合理地设置这个值需要考虑某个状态可能需要运行的时间、是否有人工步骤等。默认的<code>TimeoutSeconds</code>为99999999。</p>
<h3 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h3><p>如果程序可能运行数个小时，也许你难以知道现在的状态是运行中，还是程序挂掉了。这时可以通过设置心跳<code>HeartbeatSeconds</code>来使Step Functions知道当前的运行状况，以便及时把挂掉了（没有心跳了）的任务分发给其它节点。当然为了这个功能，程序中需要增加相对应的逻辑（定期发送心跳）。</p>
<h3 id="重试"><a href="#重试" class="headerlink" title="重试"></a>重试</h3><p>有时候程序出错，可能只需要重试一下就好了。这时我们可以使用Step Functions提供的重试<code>Retry</code>机制。如以下程序所示：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">"Retry" : [</div><div class="line">  &#123;</div><div class="line">    "ErrorEquals": [ "States.TaskFailed", "States.Timeout" ],</div><div class="line">    "IntervalSeconds": 600,</div><div class="line">    "MaxAttempts": 3</div><div class="line">  &#125;</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p><code>Retry</code>是一个集合，所以可以为不同的错误定义不同的重试机制。</p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>如果重试还是不行，那还有一个招式就是异常处理机制<code>Catch</code>。它与重试类似，可以为不同的错误定义不同的状态流向:<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">"Catch": [</div><div class="line">  &#123;</div><div class="line">    "ErrorEquals": [ "States.ALL" ],</div><div class="line">    "Next": "NotifyError"</div><div class="line">  &#125;</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>在上面的代码里，只要出错了（并且重试也没有成功），就跳转到<code>NotifyError</code>的状态，可以通过SNS通知订阅者了。</p>
<h3 id="错误状态"><a href="#错误状态" class="headerlink" title="错误状态"></a>错误状态</h3><p>在异常处理中由于跳转到了<code>NotifyError</code>，并且通知成功，反而倒让这个工作流从异常变成正常了。想让工作流失败，只需在<code>NotifyError</code>的后面接一步简单的<code>FailExecution</code>状态就可以了。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">"FailExecution": &#123;</div><div class="line">  "Type": "Fail"</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="最终工作流"><a href="#最终工作流" class="headerlink" title="最终工作流"></a>最终工作流</h3><p><img src="/img/aws-sf-CrawAmazonPrice-v3.png" alt=""></p>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>最求完美，永无止境。例如，这些服务我们现在都是在AWS界面上点来点去的，其实这些人工操作可以通过<code>CloudFormation</code>来变成自动化的脚本。如此，便可以实现我们的基础设施即代码，做到一键部署了。另外，随着需求的演化，如果要更新Step Functions的工作流，还可能需要考虑到对其进行版本管理。还有，当处理活动的节点数较多时，如果能够把某次执行的机器名输出到工作流中，也有助于错误排查。</p>
]]></content>
      
        <categories>
            
            <category> development </category>
            
        </categories>
        
        
        <tags>
            
            <tag> aws </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[未来的软件开发什么样]]></title>
      <url>/future-software-development/</url>
      <content type="html"><![CDATA[<p>前一阵子经常看到各种文章说以后人工智能如何如何强大，人类各种失业，要么凄惨，要么极乐，软件开发也无法幸免。那么开挂后未来的软件开发究竟会如何演进？其实我们可以借助传统制造业来推演一下。<br><a id="more"></a></p>
<h2 id="过去"><a href="#过去" class="headerlink" title="过去"></a>过去</h2><p>软件开发和制造业在一定程度上是有相似性的。只不过制造业的历史更悠久、经历更丰富，它的革命总是更早地发生，这就足够让我们有所参照了。</p>
<p>传统制造业的原始阶段呢，最初都是以个体或家庭为单位，把整个产品都制造出来，比如毛皮，斧子等，没有统一标准，但是凑活都能用。哪一天不保暖或者不锋利了，那就再缝一缝或者磨一磨。软件开发的原始阶段呢，一开始都是单枪匹马，搞出来一个程序，凑活就能用。哪天出了个新情况，那就在原来的基础上改巴改巴，争取无需大改就能对付过去。</p>
<p>过了这个原始阶段，随着需求的演进，我们需要的产品更加地精细了。传统的制造方式难以为继，分工合作成为主流。每个人并不都会制造一个大整体，那也不现实；但是可以制造一个个符合标准的零件，最终将它们拼接成一个复杂的整体。而软件开发呢，也发展到了另一个阶段：一个人或一个小团队已经难以对复杂的单体系统进行开发维护的工作了，那就需要引入模块化或者是微服务化，降低各个组件的复杂度，以便可以更容易地让人掌握。市场上也有许多符合标准的开源及收费的包或服务，可在软件开发过程中使用。从这个角度上说，其实程序员们也都是流水线上的工人，只不过制造的是软件罢了。但是注意，传统的开发方式并没有消亡，因为还是会源源不断地冒出需求，人家就要一个斧子，干嘛组件化那么麻烦？能用就行了。就像现在还有许多的个体软件开发者，各自拥有一些框架，要建站？单枪匹马几百元就能搞定！</p>
<h2 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h2><p>到了现在这个阶段，制造业迎来的就是机器人时代。2011年，富士康就提出了十年内的“百万机器人计划”，计划投入百万台机器人到生产线上，以取代部分工人，解决用工荒的问题。而现在的软件业呢，也喜迎人工智能时代，各种AI加入软件，不跟它沾点儿边还真不好意思跟别的程序员打招呼。机器人能把高效地把最容易重复的部分完成，也能在高危环境中大展身手。人工智能呢，现阶段也是把容易重复或是根据经验估计的部分逐步取代。有时候软件开发人员也会问问自己，未来我会不会被AI所取代？</p>
<h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>不可否认，未来机器人会取代相当一部分人类。但与此同时，机器人也解放了人类，可以让他们创造新的工作类型。无法胜任的人类，会被残酷地淘汰掉，也许会演变为暴乱、战争……本文就不讨论这些了。而AI也将解放出许多软件工程师，这事是注定的，虽然那一天的到来还比较遥远。而那些专业知识不精、无法持续学习的程序员们，也将被AI的洪流无情碾轧。那未来的程序员们如何与AI共处呢？</p>
<h3 id="合作"><a href="#合作" class="headerlink" title="合作"></a>合作</h3><p>现在的机器人时代，一些生产线的机器人并非是“替代”人类生产，而是“协助”。在软件开发中，写个小工具或利用现有的工具来辅助自己开发是最正常不过的事情了，跟AI还扯不上关系。但与此同时，AI辅助程序员编程，也已经开始萌芽——<a href="https://kite.com/" target="_blank" rel="external">Kite</a>了解一下？</p>
<p>现在的教育平台，就如雨后春笋般地冒出来。孩子就读的小学，各科的老师们已经推荐了不下五款的app用来辅助学习。这些教育平台会降低老师的重要性吗？并不。事实上老师们正在用这些app提高教学效率。这正是一个典型的双赢合作啊。未来的软件工程师也可以轻松地在更加智能的AI的配合下，完成可视化的设计、模板代码、用户手册等。</p>
<h3 id="创新"><a href="#创新" class="headerlink" title="创新"></a>创新</h3><p>在制造业中，工厂里的机器人取代了劳动力，但是也产生了相当多的数据，需要许多人来分析和监控这些数据，还需要许多人来维护这些机器人。这是由于机器人存在而被人们创造出来的新岗位啊，尽管新岗位的数量远远小于原先的岗位数量。未来的AI可以使用多种方法来迅速实现各种需求，而软件工程师们可能更多负责评审、验证、监控这些程序的运行，当然还要编写、改进那些真正干活儿的AI，就像维护机器人一样。虽然说当人工智能强大到可以自我进化的时候，也许就不需要人类了，可是离那一天还早着呢。</p>
<h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>“合并”在这里的语境看起来有点儿吓人。现在的制造业中，已经出现了一些外骨骼机器人，在军事上也有一些可佩戴单兵装备还在研发中。而未来更可能会出现半机器人时代，也就是说，你身体的任何一个部位，都可以被机器替换，从而获得更快的奔跑速度、更大的力量、增强的感官等等。当你的大脑中的某个部分被AI替换时，也许你会拥有永不遗忘的记忆，极快的计算速度，各种知识信手拈来……这时候的软件工程师，也许舒舒服服地躺在海边，随便想一想，便能迅速获得一堆代码及所需的环境，甚至AI已经帮你自动测试完毕了。我们所剩下的，也许就只有思考了。</p>
<h3 id="斗争"><a href="#斗争" class="headerlink" title="斗争"></a>斗争</h3><p>想想《黑客帝国》……我是一个乐观派，这么黑暗的话题还是不要展开了。未来也许是：与AI斗，其乐无穷？</p>
]]></content>
      
        <categories>
            
            <category> idea </category>
            
        </categories>
        
        
        <tags>
            
            <tag> idea </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java 11时代，这些编程习惯可以改一改了]]></title>
      <url>/java-11/</url>
      <content type="html"><![CDATA[<p>还在用着Java 8吗？09月26日Oracle的长期支持版Java 11已经出炉，将一直支持到2026年9月。对广大的程序员们来说，从Java 9~11，日常的编码都有什么变化呢？一起来看看吧。<br><a id="more"></a></p>
<h2 id="var关键字"><a href="#var关键字" class="headerlink" title="var关键字"></a>var关键字</h2><p>Java 10引进了<code>var</code>关键字来指代任意类型，让它朝C#又迈进了一步。以下是两个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var abc = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line"><span class="keyword">for</span> (var character : abc) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>var</code>并不仅仅能类型推断，它还能完成以前做不到的事——引用匿名类的变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var o = <span class="keyword">new</span> Object() &#123;</div><div class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</div><div class="line">&#125;;</div><div class="line">System.out.println(o.a);</div></pre></td></tr></table></figure></p>
<p>在所有可能的地方都用上<code>var</code>也许并不是一个好实践。一种做法是：如果后面的表达式一眼就能看出来是啥类型，我们就用<code>var</code>；否则，就还是老老实实地写声明，一眼扫过就能明白的代码更具可读性。</p>
<p>更详细的用法请参考<a href="https://developer.oracle.com/java/jdk-10-local-variable-type-inference" target="_blank" rel="external">Oracle官方文档</a>。Java 11更是<a href="https://bugs.java.com/view_bug.do?bug_id=JDK-8193259" target="_blank" rel="external">允许对lambda的参数使用<code>var</code></a>。</p>
<h2 id="集合字面量"><a href="#集合字面量" class="headerlink" title="集合字面量"></a>集合字面量</h2><p>一直以来我们都是老老实实地用以下这些方法来初始化一个已知的不可变集合：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这样挺方便，就是语义上稍欠优雅</span></div><div class="line">List&lt;String&gt; abc1 = Arrays.asList(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>);</div><div class="line"></div><div class="line"><span class="comment">// 这样构建的是Collection，可以传入可变集合</span></div><div class="line">Collection&lt;String&gt; abc2 = Collections.unmodifiableCollection(abc1);</div><div class="line"></div><div class="line"><span class="comment">// 更优雅的Guava方案</span></div><div class="line">List&lt;String&gt; abc3 = ImmutableList.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>);</div></pre></td></tr></table></figure></p>
<p>可变集合：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 最基本的方法，就是有点长，令人不爽</span></div><div class="line">List&lt;String&gt; abc4 = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">abc4.add(<span class="string">"A"</span>);</div><div class="line">abc4.add(<span class="string">"B"</span>);</div><div class="line">abc4.add(<span class="string">"C"</span>);</div><div class="line"></div><div class="line"><span class="comment">// 构造函数</span></div><div class="line">List&lt;String&gt; abc5 = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>));</div><div class="line"></div><div class="line"><span class="comment">// 匿名内部类</span></div><div class="line">List&lt;String&gt; abc6 = <span class="keyword">new</span> ArrayList&lt;&gt;()&#123;&#123; add(<span class="string">"A"</span>);add(<span class="string">"B"</span>);add(<span class="string">"C"</span>); &#125;&#125;</div><div class="line"></div><div class="line"><span class="comment">// 利用Java 8的Stream</span></div><div class="line">List&lt;String&gt; abc7 = Stream.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>).collect(Collectors.toList());</div><div class="line"></div><div class="line"><span class="comment">// 更优雅的Guava方案</span></div><div class="line">List&lt;String&gt; abc8 = Lists.newArrayList(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>);</div></pre></td></tr></table></figure></p>
<p>对于不可变集合，Java 9引入了集合的工厂方法<code>of</code>，这回终于可以用上原装的了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; abc1 = List.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>);</div><div class="line">Set&lt;String&gt; abc2 = Set.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>);</div><div class="line">Map&lt;String, Integer&gt; abc3 = Map.of(<span class="string">"A"</span>, <span class="number">1</span>, <span class="string">"B"</span>, <span class="number">2</span>, <span class="string">"C"</span>, <span class="number">3</span>);</div><div class="line">Map&lt;String, Integer&gt; abc4 = Map.ofEntries(Map.entry(<span class="string">"A"</span>, <span class="number">1</span>),</div><div class="line">                                          Map.entry(<span class="string">"B"</span>, <span class="number">2</span>),</div><div class="line">                                          Map.entry(<span class="string">"C"</span>, <span class="number">3</span>));</div></pre></td></tr></table></figure></p>
<p>值得注意的是，<code>List</code>不允许通过<code>of</code>传入<code>null</code>，<code>Map</code>不允许传入相同的键。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">List.of(<span class="string">"A"</span>, <span class="keyword">null</span>); <span class="comment">// NullPointerException</span></div><div class="line">Map.of(<span class="string">"A"</span>, <span class="number">1</span>, <span class="string">"A"</span>, <span class="number">2</span>); <span class="comment">// IllegalArgumentException: duplicate key: A</span></div></pre></td></tr></table></figure></p>
<p>Java 10引入了<code>copyOf</code>方法，也能方便地从可变集合中创建出不可变集合：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var abcMutable = <span class="keyword">new</span> ArrayList&lt;&gt;(List.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>))</div><div class="line">var abcImmutable = List.copyOf(abcMutable);</div></pre></td></tr></table></figure></p>
<p>Java 10还在<code>Collectors</code>类中增加了<code>toUnmodifiableList</code>/<code>toUnmodifiableMap</code>/<code>toUnmodifiableSet</code>方法，可以直接从<code>Stream</code>创建一个不可变集合：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; abc = Stream.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>).collect(Collectors.toUnmodifiableList());</div></pre></td></tr></table></figure></p>
<h2 id="Deprecated"><a href="#Deprecated" class="headerlink" title="Deprecated"></a>Deprecated</h2><p>这个相对简单，就是给<code>@Deprecated</code>注解增加了两个字段：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Deprecated</span>(since=<span class="string">"1.1"</span>, forRemoval = <span class="keyword">true</span>)</div></pre></td></tr></table></figure></p>
<p>前者表示从哪个版本起不建议使用，后者表示未来是否会将其删除。</p>
<h2 id="接口的private方法"><a href="#接口的private方法" class="headerlink" title="接口的private方法"></a>接口的private方法</h2><p>从Java 8起，允许给接口增加<code>default</code>方法。从Java 9起，接口又增加了一项能力：可以定义<code>private</code>方法了。示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Dog</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"bowwow"</span>);</div><div class="line">        wagTail();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"walk"</span>);</div><div class="line">        wagTail();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">wagTail</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"wag"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>既然如此，它跟抽象类还有什么区别吗？接口的优势就是允许子类实现多个接口，而抽象类因为可以拥有可变字段（接口的字段是<code>final</code>的）而更为强大。我们在接口定义方法时，也应当让其尽可能简洁。</p>
<h2 id="Optional的新方法"><a href="#Optional的新方法" class="headerlink" title="Optional的新方法"></a>Optional的新方法</h2><p>从Java 9起，<code>Optional</code>终于可以通过<code>stream()</code>方法返回一个<code>Stream</code>了，这样它就可以用上<code>Stream</code>提供的许多API了。原来只能这么做：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Optional&lt;String&gt; optional = Optional.of(<span class="string">"ggg"</span>);</div><div class="line"></div><div class="line"><span class="comment">// java 8</span></div><div class="line">Stream&lt;String&gt; texts = optional.map(Stream::of).orElseGet(Stream::empty);</div><div class="line"></div><div class="line"><span class="comment">// java 9</span></div><div class="line">Stream&lt;String&gt; texts = optional.stream();</div></pre></td></tr></table></figure></p>
<p>另一个可以耍耍的方法是<code>ifPresentOrElse</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// java 8</span></div><div class="line"><span class="keyword">if</span> (optional.isPresent()) &#123;</div><div class="line">    System.out.print(optional.get());</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    System.out.println();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// java 9</span></div><div class="line">optional.ifPresentOrElse(System.out::print, System.out::println);</div></pre></td></tr></table></figure></p>
<p>Java 9还新增了一个方法<code>or</code>，与原来的<code>orElse</code>类似，但是返回的是一个<code>Optional</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// java 8</span></div><div class="line">String name = optional.orElse(<span class="string">"n/a"</span>);</div><div class="line"></div><div class="line"><span class="comment">// java 9</span></div><div class="line">Optional&lt;String&gt; name = optional.or(() -&gt; Optional.of(<span class="string">"n/a"</span>));</div></pre></td></tr></table></figure></p>
<h2 id="HttpClient"><a href="#HttpClient" class="headerlink" title="HttpClient"></a>HttpClient</h2><p>Java 11引进了HttpClient，http请求变得简单了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">HttpClient client = HttpClient.newHttpClient();</div><div class="line">HttpRequest request = HttpRequest.newBuilder().uri(URI.create(uri)).build();</div><div class="line">HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());</div><div class="line"></div><div class="line">System.out.println(response.body());</div></pre></td></tr></table></figure></p>
<p>异步也很简单，返回一个<code>CompletableFuture</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">HttpClient client = HttpClient.newHttpClient();</div><div class="line">HttpRequest request = HttpRequest.newBuilder().uri(URI.create(uri)).build();</div><div class="line">CompletableFuture&lt;Void&gt; futureResponse = client.sendAsync(request, HttpResponse.BodyHandlers.ofString())</div><div class="line">        .thenApply(HttpResponse::body)</div><div class="line">        .thenAccept(System.out::println);</div><div class="line"></div><div class="line">futureResponse.get();</div></pre></td></tr></table></figure></p>
<p>原生的<code>HttpURLConnection</code>可以抛弃了。Apache的<code>HttpClient</code>也许也可以雪藏了。</p>
<h2 id="可过期的CompletableFuture"><a href="#可过期的CompletableFuture" class="headerlink" title="可过期的CompletableFuture"></a>可过期的CompletableFuture</h2><p>上一小节中，我们可以得到一个<code>CompletableFuture</code>。从Java 9起，它可以设置过期时间了。可以把上面的<code>futureResponse.get()</code>替换如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CompletableFuture&lt;Void&gt; timeoutFuture = futureResponse.orTimeout(<span class="number">1</span>, TimeUnit.SECONDS);</div><div class="line">timeoutFuture.get();</div></pre></td></tr></table></figure></p>
<p>如果没有在设置的时间内获得结果，便会抛出<code>java.util.concurrent.ExecutionException: java.util.concurrent.TimeoutException</code>。如果想在过期时不抛异常而是设一个默认值，可以这样做：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CompletableFuture&lt;String&gt; futureResponse = client.sendAsync(request, HttpResponse.BodyHandlers.ofString())</div><div class="line">        .thenApply(HttpResponse::body)</div><div class="line">CompletableFuture&lt;String&gt; timeoutFuture = futureResponse.completeOnTimeout(<span class="string">"default value"</span>, <span class="number">1</span>, TimeUnit.MILLISECONDS);</div><div class="line">timeoutFuture.get();</div></pre></td></tr></table></figure></p>
<h2 id="Process-API"><a href="#Process-API" class="headerlink" title="Process API"></a>Process API</h2><p>Process API是元老级的API了，但是功能一直不够完整，无法获取进程的PID、用户、命令等。Java 9引入了<code>ProcessHandle</code>，可以查询进程，甚至允许在进程退出时执行方法。它提供了获取当前进程的<code>current</code>方法，以及获取全部进程的<code>allProcesses</code>方法。用法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Optional&lt;String&gt; currentUser = ProcessHandle.current().info().user();</div><div class="line">ProcessHandle.allProcesses()</div><div class="line">        .filter(p -&gt; p.info().user().equals(currentUser))</div><div class="line">        .forEach(p -&gt; System.out.println(String.valueOf(p.pid()) + <span class="string">" "</span> + p.info().command()));</div></pre></td></tr></table></figure></p>
<p>如果在Mac中打开了一个<code>TextEdit</code>，便可以看到类似这样的输出结果：<strong>1234 Optional[/Applications/TextEdit.app/Contents/MacOS/TextEdit]</strong>。Windows的话可以打开<code>notepad.exe</code>，也能看到：<strong>1234 Optional[C:\Windows\System32\notepad.exe]</strong>。可以用以下方法在该进程退出时打印一些信息：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Optional&lt;ProcessHandle&gt; optionalProcessHandle = ProcessHandle.of(<span class="number">1234</span>);</div><div class="line">CompletableFuture&lt;Void&gt; future = optionalProcessHandle.get()</div><div class="line">        .onExit().thenAccept(x -&gt; System.out.println(x.pid()));</div><div class="line">future.get();</div></pre></td></tr></table></figure></p>
<p>甚至还能用<code>optionalProcessHandle.get().destroy()</code>来摧毁进程。如此这般，Java外部打开的<code>TextEdit</code>或<code>notepad.exe</code>都会被退出。由于其它用户的进程无法使用<code>ProcessHandle.of</code>来获取，所以只能杀掉自己的进程。对安全方面感兴趣的话可以参考一下<a href="https://docs.oracle.com/en/java/javase/11/core/process-api1.html#GUID-FB7E1852-6C0F-4681-8B35-E2F1ABF483D5" target="_blank" rel="external">官方文档</a>。</p>
]]></content>
      
        <categories>
            
            <category> development </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[手稿秒变html的Sketch 2 Code]]></title>
      <url>/sketch2code/</url>
      <content type="html"><![CDATA[<p>可以把手稿变成html的<a href="https://sketch2code.azurewebsites.net/" target="_blank" rel="external">Sketch 2 Code</a>出世了，这是微软在<a href="https://github.com/Microsoft/ailab" target="_blank" rel="external">GitHub上的C#开源代码</a>。听说它能够把前端都凉掉？我很兴奋地尝了尝鲜，写下了这篇小文。咱们来看看它有没有传说中的那么高大上。<br><a id="more"></a></p>
<p>官网上放出来的示例当然是最佳了：<br><img src="/img/sketch-2-code-official.png" alt=""></p>
<p>能有这样的效果那是相当的不错呀，布局、文字、图像都识别得很不错，但也并非完美：</p>
<ol>
<li>布局：PRODUCT CATALOG变成了竖排，搜索按钮也没有对齐</li>
<li>文字：三幅画下面的第一个PRODUCT识别成了RODUCT，最后一个3变成了S。$19.5左边多了一个8</li>
<li>图像：原图上明明有三个段落嘛，html变成了两个</li>
</ol>
<p>那我自己画一幅，用网站提供的TAKE A PICTURE功能上传试试：<br><img src="/img/sketch-2-code-1st-try.png" alt=""></p>
<p>这是什么鬼？敢情什么都没识别出来？是我的画风太清奇了吗？不死心，同一幅图再拍一次：<br><img src="/img/sketch-2-code-2nd-try.png" alt=""></p>
<p>这次有限地成功了，看来位置、方向、大小、光影上的一点点细微差别，也会很大地影响最终的结果。后来又试了几次，最完美的识别也就是上面这幅图了，要我是草图设计师，用这玩意儿还是挺跟它较劲的。倒是处理速度还挺快，几秒之内就能搞定。</p>
<p>接下来试一试中文：<br><img src="/img/sketch-2-code-chinese-try.png" alt=""></p>
<p>果然是不支持中文呀。从下图中我们能看到，尽管中文都能够识别成Lable，但确实对中文的OCR无能为力。<br><img src="/img/sketch-2-code-chinese-analysis.png" alt=""></p>
<p>再试试横线本，看来背景的横线是可以被过滤掉的：<br><img src="/img/sketch-2-code-lines-try.png" alt=""></p>
<p>最后试着参考GitHub的注册首页画一幅手稿：<br><img src="/img/sketch-2-code-github-try.png" alt=""></p>
<p>上面的html是试过几遍之后最好的解析了。生成的html代码中引用了bootstrap的css，所以网页看上去还比较顺眼。但是格式有点乱，有一些连续空行、缩进等问题。不过这些问题相信都很容易解决。最大的问题是目前的实用程度还不太高。想要让前端变凉，数据量应该还不太够（大家多多上传草图吧），而且还应该有不少工作能做。希望它能早日实用化，让前端们投入到更有意义的工作中去。</p>
<p>最终结论：未来很美好，但是现在的实用性还有待提高。</p>
]]></content>
      
        <categories>
            
            <category> tool </category>
            
        </categories>
        
        
        <tags>
            
            <tag> AI </tag>
            
            <tag> OCR </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[组合型软件架构]]></title>
      <url>/composable-software-architecture/</url>
      <content type="html"><![CDATA[<p>以前玩游戏的时候，总是希望在高手后面看他怎么操作，以提高自己的水平。当时悟出了一个道理：菜鸟看老鸟，只觉得每一步都顺理成章。但是菜鸟自己上时，老鸟却是看得频频摇头。今天这个标题讲的就是这么个理所当然的架构，源于我的同事对当前系统的思考。<br><a id="more"></a></p>
<h2 id="单体系统→微服务→平台"><a href="#单体系统→微服务→平台" class="headerlink" title="单体系统→微服务→平台"></a>单体系统→微服务→平台</h2><p>随着IT的不断发展，软件能解决的问题越来越多也越来越大。在大型软件开发中，人们发现要与一大坨代码共舞变得越来越困难，于是微服务架构兴起并持续火热，许多单体系统也纷纷挤上风口随之演进，不管是新服务单提出去还是老服务逐步拆分，总之他们都渐渐走到分布式系统的大道上了。服务的数量上去了，便带来了一个问题：你的服务跟别人的服务应该如何集成呢？最简单粗暴直截了当的做法就是直接调用。但是这样缺少定制化支持。对方有什么，你可能就只能凑合着用什么。要不，就得等对方把你的需求排上档期。</p>
<p>总这样不行呀，缺胳膊少腿的服务和只能傻傻等待着跟不上节奏的服务没法儿工作呀。为了满足不同客户的多方面需求，服务的平台化就成了一个自然而然的选择。作为平台方，不止提供服务，而且提供客户在平台上的定制化功能，客户成为了平台的租户。一般来说，租户需要在平台那边写点儿为自己的需求而定制的代码或是DSL，以便支持自己的业务场景。</p>
<p>如果你是一个平台的所有者，如何才能让别人在你的平台上顺利安营扎寨，而你无需提供太多的支持工作呢？</p>
<h2 id="构建组合型平台"><a href="#构建组合型平台" class="headerlink" title="构建组合型平台"></a>构建组合型平台</h2><p>首先要问自己一下，你的平台，也就是你拥有的服务，面向的客户是什么人呢？从技术维度上来说，无非是这几类：</p>
<ul>
<li>非技术人员：你的服务只对非技术人员开放，对方想要的是一个大而全的系统，而不希望在不同的服务间来回奔波。以操作系统为例的话，那就是需要一个Windows。</li>
<li>技术人员：你的服务只对技术人员开放，对方想要的是更加灵活，别人的烂代码不要影响到自己的代码。Unix/Linux就是一个典型的例子。</li>
<li>混合型人员：你的服务对技术人员及非技术人员开放，大家各取所需，当然对你的要求也比较高了。举个例子就是OSX。</li>
</ul>
<p>出于简单起见，我们先考虑前两种类型。实际情况是，第一类其实就是许多第二类的聚合。你可能有许多微服务，但是作为网关的微服务其实数量不多。这样，我们便把要解决的大部分平台问题归类于对技术人员开放的服务了。第三类的混合型也很类似。其实对于微服务来说，我根本不在乎对方的实现方式、架构方式，能提供稳定的服务就可以了。但是，一旦它是个平台，并且我需要在其上定制代码，那我也就不得不关心一下了。还是先分两个类：</p>
<ul>
<li>非组合型软件架构：平台代码和租户代码的耦合比较紧，类比的话，就是EJB。平台升级很可能需要租户代码一起改。于是，能不升级就不升级，因为租户很多，升级可能会很繁琐。</li>
<li>组合型软件架构：可能由多种服务组成，对于每种服务而言，SRP是最重要的事，把一件简单的事情做好。其实“简单”是相对而言的，不管内部有多复杂，但是开放出去的接口，或者是允许租户在其中实现的能力，都应该只专注于一件事情。举个例子，亚马逊AWS的S3。作为使用者而言，还是非常简单的。虽然程序员们都知道要维护这样一个服务其实是相当复杂的。这些服务之间是松耦合的，像Linux的管道一样，灵活组合，对外提供平台的能力。</li>
</ul>
<p>如果一个租户的代码挂掉了，从而影响到其他的租户甚至是你的平台，那这个平台就是很有问题的。这句话看起来理所当然，但确实有不少所谓的平台并不是这样设计的。在这种情况下，租户要往这个平台提交代码，就需要接受平台的代码审查，以免待提交的代码影响到其他人。而平台方就不得不耗费人力审查代码、部署代码，当租户的数量多起来时，平台根本就无法提供足够的可伸缩性，势必需要排优先级。于是各种抱怨就纷至沓来，自己的技术人员也苦不堪言。所以，我们希望租户拥有对自己代码的审查和部署的所有权，不希望当租户代码变化时需要平台人员人力审核。</p>
<p>如果你需要开发一个平台，如何能够做到让租户之间不相互影响呢？最佳的租户隔离方式是向租户提供服务级别的隔离。一个租户服务的倒掉不至于影响到其他租户的服务，只是影响已损坏服务的分支业务自己而已（自己的代码挂掉，当然自己承担喽）。如果由于某些原因无法为所有租户都提供服务级别的隔离，那么也可以尝试进程级别的隔离，例如Docker。一个损坏的进程在许多情况下都不太至于影响到平台为其他租户进程提供的服务。如果很不幸的是不得不与租户在同一个进程里，那么起码还可以用DSL来限制租户的能力，让租户的代码不能有太大的破坏性。要是租户也能用平台的语言，还在同一个进程中，那么搞砸平台的服务只是时间问题罢了。</p>
<p>在DevOps的光茫照耀下，我们当然要提倡自动化，这是平台和租户双方的责任。平台提供的是从代码提交到部署测试环境乃至生产环境的自动化能力，而租户需要实现的是自动化测试。一个典型的应用场景就是：平台上的租户代码提交，触发了该租户的持续交付流水线，于是在测试环境上自动部署平台的租户代码，接下来运行租户自己实现的自动化测试，一旦通过，租户便可以决定是否要在平台的生产环境上自动部署这次提交的代码。</p>
<p>最后，作为平台，提供的是能力。不要强迫租户使用你的能力，而要提供稳定的服务，让租户心甘情愿地使用你的能力。向Unix那样，把一个个稳定的服务组合起来，以提供整体的服务；同时，允许租户自由替换其中的某些服务以实现灵活性。能做到这一点的平台就相当成熟了。</p>
]]></content>
      
        <categories>
            
            <category> idea </category>
            
        </categories>
        
        
        <tags>
            
            <tag> idea </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用JaVers比较对象]]></title>
      <url>/javers/</url>
      <content type="html"><![CDATA[<p><a href="https://javers.org/" target="_blank" rel="external">JaVers</a>是一个轻量级的对象比较/审计框架，非常易于使用。当前的JaVers版本3是用Java 8编写的，只能运行在JRE 8或以上版本。2.9.2是最后一个和Java 7兼容的版本。源代码<a href="https://github.com/javers/javers" target="_blank" rel="external">在此</a>。<br><a id="more"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>如果你需要实时比较生产环境的处理结果和备份环境的处理结果，或是在新系统中重放生产环境的请求，或者像代码一样对对象进行版本管理，那么JaVers就可以成为你的好朋友。它不仅可以比较对象，也可以将比较结果存储在数据库中以便审计。审计是这样的一种需求：</p>
<blockquote>
<p>作为用户，我希望知道谁改变了状态，<br>是什么时候改变的，以及原先的状态是什么。</p>
</blockquote>
<p>本文仅关注于比较部分，对审计部分就不具体展开了。</p>
<h2 id="快速一览"><a href="#快速一览" class="headerlink" title="快速一览"></a>快速一览</h2><p>新建Maven工程，往pom.xml中增加dependency，最后的pom.xml看起来就像这样：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></div><div class="line">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.ggg.javers<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>helloJaVers<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>helloJaVers<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.javers<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javers-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>25.0-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>假设我们有一个名为<code>Staff</code>的POJO如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ToString</span></div><div class="line"><span class="meta">@Builder</span></div><div class="line"><span class="meta">@Data</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Staff</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">    <span class="keyword">private</span> Double height;</div><div class="line">    <span class="keyword">private</span> BigDecimal salary;</div><div class="line">    <span class="keyword">private</span> Staff manager;</div><div class="line">    <span class="keyword">private</span> List&lt;String&gt; hobbies;</div><div class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; phones;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在<code>main</code>函数中如下编写：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Staff tommy = Staff.builder()</div><div class="line">                   .name(<span class="string">"Tommy"</span>)</div><div class="line">                   .age(<span class="number">18</span>)</div><div class="line">                   .height(<span class="number">180</span>d)</div><div class="line">                   .salary(<span class="keyword">new</span> BigDecimal(<span class="string">"10000"</span>))</div><div class="line">                   .hobbies(Lists.newArrayList(<span class="string">"film"</span>, <span class="string">"game"</span>))</div><div class="line">                   .phones(ImmutableMap.of(<span class="string">"home"</span>, <span class="string">"1234"</span>, <span class="string">"office"</span>, <span class="string">"4321"</span>))</div><div class="line">                   .manager(Staff.builder().name(<span class="string">"ok"</span>).build())</div><div class="line">                   .build();</div><div class="line">Staff ggg = Staff.builder()</div><div class="line">                 .name(<span class="string">"ggg"</span>)</div><div class="line">                 .age(<span class="number">17</span>)</div><div class="line">                 .height(<span class="number">180.000000001</span>d)</div><div class="line">                 .hobbies(Lists.newArrayList(<span class="string">"game"</span>, <span class="string">"music"</span>, <span class="string">"travel"</span>))</div><div class="line">                 .phones(ImmutableMap.of(<span class="string">"mobile"</span>, <span class="string">"4321"</span>, <span class="string">"home"</span>, <span class="string">"1235"</span>))</div><div class="line">                 .manager(Staff.builder().name(<span class="string">"ok"</span>).build())</div><div class="line">                 .build();</div><div class="line"></div><div class="line">Javers javers = JaversBuilder.javers().build();</div><div class="line">Diff diff = javers.compare(tommy, ggg);</div><div class="line">System.out.println(diff);</div></pre></td></tr></table></figure></p>
<p>即可得到以下输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Diff:</div><div class="line">* changes on org.ggg.javers.Staff/ :</div><div class="line">  - &apos;age&apos; changed from &apos;18&apos; to &apos;17&apos;</div><div class="line">  - &apos;height&apos; changed from &apos;180.0&apos; to &apos;180.000000001&apos;</div><div class="line">  - &apos;hobbies&apos; collection changes :</div><div class="line">    0. &apos;film&apos; changed to &apos;game&apos;</div><div class="line">    1. &apos;game&apos; changed to &apos;music&apos;</div><div class="line">    2. &apos;travel&apos; added</div><div class="line">  - &apos;name&apos; changed from &apos;Tommy&apos; to &apos;ggg&apos;</div><div class="line">  - &apos;phones&apos; map changes :</div><div class="line">    &apos;home&apos; -&gt; &apos;1234&apos; changed to &apos;1235&apos;</div><div class="line">    &apos;mobile&apos; -&gt; &apos;4321&apos; added</div><div class="line">    &apos;office&apos; -&gt; &apos;4321&apos; removed</div><div class="line">  - &apos;salary&apos; changed from &apos;10000&apos; to &apos;&apos;</div></pre></td></tr></table></figure></p>
<p>大部分的代码都是我们创建对象所用的，可见JaVers非常易于使用。</p>
<h2 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h2><p>根据DDD，JaVers把要比较的对象分为三种类型：实体（Entity）、值对象（Value Object）和值（Value）。每种类型都有不同的比较方法。值最简单，就是看它们是否是<code>Object.equals()</code>的。实体和值对象都是按属性依次比较。它们俩的区别是实体拥有标识（Entity Id），而值对象并没有。标识不同的实体就会被认为是不同的对象，从而不再继续比较其余的字段。从DDD的角度上严格来说值对象不能单独存在，需要依附于实体。好在JaVers并不教条，值对象也可以用来单独比较。上面的代码其实就是把Staff对象当作值对象来比较。如果我们在<code>Staff</code>类中，给<code>name</code>添加一个<code>@Id</code>的注解（所有的注解都在<code>org.javers.core.metamodel.annotation</code>包里），那么比较结果就会不同：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Diff:</div><div class="line">* new object: org.ggg.javers.Staff/ggg</div><div class="line">* object removed: org.ggg.javers.Staff/Tommy</div></pre></td></tr></table></figure></p>
<p>只有当<code>name</code>属性相同的时候，这两个对象才会被当成同一实体，从而依次比较其余属性。如果没有权限修改实体以增加<code>@Id</code>注解，也可以用这样的方法来注册，效果相同：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Javers javers = JaversBuilder.javers()</div><div class="line">                             .registerEntity(<span class="keyword">new</span> EntityDefinition(Staff.class, <span class="string">"name"</span>))</div><div class="line">                             .build();</div></pre></td></tr></table></figure></p>
<p>如果<code>registerEntity</code>的属性和<code>@Id</code>注解都存在，那么以<code>registerEntity</code>所注册的属性为准。</p>
<p>JaVers完全兼容<a href="http://www.groovy-lang.org/" target="_blank" rel="external">Groovy</a>，可以参考其<a href="https://javers.org/documentation/diff-examples/#groovy-diff-example" target="_blank" rel="external">文档</a>来了解用例。</p>
<h2 id="自定义比较方式"><a href="#自定义比较方式" class="headerlink" title="自定义比较方式"></a>自定义比较方式</h2><h3 id="忽略属性"><a href="#忽略属性" class="headerlink" title="忽略属性"></a>忽略属性</h3><p>从业务上说，有些属性新、旧系统本来就不一样，或者是不关心，这时候我们可以在比较中“忽略”这些属性。如果有权限修改要比较的对象类，可以简单地在属性上面增加一个<code>@DiffIgnores</code>，比较的时候就会将其忽略。<code>@DiffIgnores</code>相当于黑名单，<code>@DiffInclude</code>起到了白名单的效果。如果没有修改类的权限，那么也可以用这样的方法来注册，效果相同：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Javers javers = JaversBuilder.javers()</div><div class="line">                             .registerValueObject(<span class="keyword">new</span> ValueObjectDefinition(Staff.class, Lists.newArrayList(<span class="string">"hobbies"</span>, <span class="string">"phones"</span>)))</div><div class="line">                             .build();</div></pre></td></tr></table></figure></p>
<p>这里我们注册的是个值对象ValueObject，与上一个例子的实体Entity的区别就是有没有标识属性。</p>
<h3 id="比较算法"><a href="#比较算法" class="headerlink" title="比较算法"></a>比较算法</h3><p>一开始细心的读者们就可能注意到了，<code>Lists.newArrayList(&quot;film&quot;, &quot;game&quot;)</code>和<code>Lists.newArrayList(&quot;game&quot;, &quot;music&quot;, &quot;travel&quot;)</code>的比较结果居然是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- &apos;hobbies&apos; collection changes :</div><div class="line">  0. &apos;film&apos; changed to &apos;game&apos;</div><div class="line">  1. &apos;game&apos; changed to &apos;music&apos;</div><div class="line">  2. &apos;travel&apos; added</div></pre></td></tr></table></figure></p>
<p>这当然也是可以配置的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Javers javers = JaversBuilder.javers()</div><div class="line">                             .withListCompareAlgorithm(ListCompareAlgorithm.LEVENSHTEIN_DISTANCE)</div><div class="line">                             .build();</div></pre></td></tr></table></figure></p>
<p>这样的话，结果就变成了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- &apos;hobbies&apos; collection changes :</div><div class="line">  2. &apos;travel&apos; added</div><div class="line">  1. &apos;music&apos; added</div><div class="line">  0. &apos;film&apos; removed</div></pre></td></tr></table></figure></p>
<p>值得注意的是，这种算法在列表元素过多的时候可能会影响性能。</p>
<h3 id="定制比较"><a href="#定制比较" class="headerlink" title="定制比较"></a>定制比较</h3><p>我们可以注册自定义的比较器，例如，如果在业务上认为两个<code>Double</code>类型的<code>1.000000001</code>和<code>1</code>相等，这时候我们可以注册一个如下的类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomDoubleIgnorePrecisionComparator</span> <span class="keyword">implements</span> <span class="title">CustomPropertyComparator</span>&lt;<span class="title">Double</span>, <span class="title">ValueChange</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> DELTA = <span class="number">0.00001</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> ValueChange <span class="title">compare</span><span class="params">(<span class="keyword">final</span> Double left, <span class="keyword">final</span> Double right, <span class="keyword">final</span> GlobalId affectedId, <span class="keyword">final</span> Property property)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">double</span> diff = Math.abs(left - right);</div><div class="line">        <span class="keyword">if</span> (diff &lt;= DELTA) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ValueChange(affectedId, property.getName(), left, right);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>GlobalId</code>是当前比较对象的标识，如值对象的<code>org.ggg.javers.Staff/</code>或是以name为标识的实体的<code>org.ggg.javers.Staff/ggg</code>。<code>Property</code>是当前比较的属性。可以通过这两个值来设置比较属性的黑名单或是白名单。然后注册进JaVers就好了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Javers javers = JaversBuilder.javers()</div><div class="line">                             .registerCustomComparator(<span class="keyword">new</span> CustomDoubleIgnorePrecisionComparator(), Double.class)</div><div class="line">                             .build();</div></pre></td></tr></table></figure></p>
<p>需要注意的是，<code>Double</code>与<code>double</code>是不同的，如果<code>Staff</code>中的<code>height</code>是<code>double</code>类型，那么需要在调用<code>registerCustomComparator</code>时传入<code>double.class</code>。自定义的比较在许多场合都比较有用，比如String类型的不同格式的日期等。</p>
<h3 id="关联字段比较"><a href="#关联字段比较" class="headerlink" title="关联字段比较"></a>关联字段比较</h3><p>关联字段就是说，如果几个字段之间有关联，我们就认为它们一样。比如说我们虚构一个需求：对于一个拥有<code>int x</code>和<code>int y</code>的<code>Rectangle</code>类来说，如果<code>x * y</code>也就是面积相等，我们就认为它们相等。在这种情况下，JaVers似乎并没有原生提供关联字段比较的办法。有一种办法是新建一个包装类，比如说<code>RectangleWrapper</code>，里面有一个<code>Rectangle rectangle</code>和一个<code>int area</code>字段，分别赋值为要比较的对象和其<code>x * y</code>。注册<code>Javers</code>的时候，把<code>Rectangle</code>类的<code>x</code>和<code>y</code>忽略即可。如果有更复杂的需求，例如当面积不同时需要报<code>x</code>和<code>y</code>不同而不是<code>area</code>不同，那也可以通过生成多个<code>Javers</code>对象，并多次调用来解决。<code>Javers#compare</code>方法返回的是一个<code>Diff</code>对象，从中可以很方便地查看某些字段是否存在变化。就是要多写点代码咯。</p>
]]></content>
      
        <categories>
            
            <category> development </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JaVers </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[逆向工作法]]></title>
      <url>/working-backwards/</url>
      <content type="html"><![CDATA[<p>我们经常听到以客户为中心，可是说来容易做来难。“地球上最以客户为中心的公司”亚马逊是怎么做的呢？这可不是喊喊口号就完事了，逆向工作法（Working Backwards）了解一下？<br><a id="more"></a></p>
<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>Working backwards原本的意思是，从最终要解决的事情开始，每次回退一步，直到最初。</p>
<blockquote>
<p><a href="https://mathgeekmama.com/problem-solving-by-working-backwards/" target="_blank" rel="external">Working backwards is to start with the final solution and work back one step at a time to get to the beginning.</a></p>
</blockquote>
<p>在亚马逊，这个概念变得更加具体，成为了如何实现“以客户为中心”的一系列过程。它的产出是三份材料：</p>
<ol>
<li>新闻稿（Press Release，PR）：通过用户的语言描述一个想法，如产品、服务或功能</li>
<li>常见问题解答（Frequently Asked Questions，FAQs）：用户和参与方可能会问的问题</li>
<li>视觉资料（Visuals）：形式多样，有助于大家沟通想法</li>
</ol>
<p>这三份材料在产品的生命周期中，随着一次次的迭代而不断地演进。在<a href="/working-backwards/#准备文档">准备文档</a>一节中，我们会更详细地介绍它们。</p>
<h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><p>为什么要使用逆向工作法？简单来说，因为要“以客户为中心”。逆向工作法是一种行之有效的方法，能够把重点放在客户真正关心的问题上，进而交付用户体验极佳的产品。它是亚马逊成功的关键。</p>
<p>逆向工作法的最终目标就是取悦用户。没错，取悦用户能够带来巨大的价值。对亚马逊来说，它力争成为地球上最以客户为中心的公司，与逆向工作法天然契合。如果你的愿景并非如此，那也不妨看看人家是怎么做的。不过你也需要知道，逆向工作法需要很大的工作量，但是它号称可以节省更多的未来工作量。</p>
<h2 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h2><h3 id="了解用户"><a href="#了解用户" class="headerlink" title="了解用户"></a>了解用户</h3><p>一开始其实跟<a href="https://zh.wikipedia.org/wiki/%E8%85%A6%E5%8A%9B%E6%BF%80%E7%9B%AA%E6%B3%95" target="_blank" rel="external">头脑风暴法（Brainstorming）</a>很像，在打破时间、预算、资源（含技术）等限制的情况下，尽可能发散地提出各种想法。比如Kindle的首要设计理念，就是让用户感觉不到它的存在，从而能够专心读书。它连音乐播放器都没有！之后，亚马逊花了三年时间打造无线和电子屏技术，才推出了这一革命性产品。</p>
<p>你知道你的用户究竟是什么人吗？有一个很典型的答案：所有人都是我的潜在用户。这话倒是没错，但是这个答案对深入了解用户并没有太大的帮助。考虑一些特定用户的情况，如上班族、网络不好的用户、残疾人等等。思考其面对的问题，他们想要的是什么？问问自己，时间、地点和用户的现状会怎样影响其需求？让最终用户受益，是让参与方各个团队通力合作的基础。以后的团队合作开发中，如果大家有分歧，这正是一个大家达成一致的关键。</p>
<p>如果不知道用户要的究竟是什么，那你很可能就是在浪费时间。用户想要的可能是需求，也可能是方案，一定要搞清楚。这两者之间的区别可能非常小。如果你不知道这到底是需求还是方案，那就问问自己：为什么用户需要它？这个问题的答案有可能就是需求。汽车大王福特有一句名言：“如果我当年去问顾客他们想要什么，他们肯定会告诉我：一匹更快的马。这就是典型的方案，而不是需求。如果不考虑用户的需求而直接转向方案，那很可能就会痛失一个改善用户体验的机会。</p>
<blockquote>
<p>“If I had asked people what they wanted, they would have said faster horses.” ― Henry Ford</p>
</blockquote>
<p>需求有时会表现为痛点。例如，用户说他总是不知道中午应该上哪儿吃饭去。那么用户的需求是什么？一个帮他做决定的人？点评网站？外卖app？还是一个骰子？这些都是方案，用户的需求其实只是希望让决定中午上哪儿吃饭这件事变得非常简单自然。</p>
<p>如果你能回答关于用户的这五个问题，那这一步就差不多了：</p>
<ol>
<li>谁是你的用户？</li>
<li>他遇到了什么问题？</li>
<li>他的核心诉求是什么？可能有许多的诉求，但我们只挑一个最核心的需求。</li>
<li>你怎么知道他想要的是什么？搜集数据，让数据说话。</li>
<li>用户体验应该是怎么样的？这个主要是通过视觉资料来展示，我们将在下面的<a href="/working-backwards/#视觉资料">视觉资料</a>一节中再详细探讨。</li>
</ol>
<h3 id="准备文档"><a href="#准备文档" class="headerlink" title="准备文档"></a>准备文档</h3><h4 id="新闻稿"><a href="#新闻稿" class="headerlink" title="新闻稿"></a>新闻稿</h4><p>虽然这里说的新闻稿是内部人员写的内部文档，但是看起来应该跟即将公开发布的新闻稿差不多。市场人员几乎无需修改便可以直接使用。想象用户正在看这篇新闻稿的心理活动，避免使用行业术语，因为用户很可能并不了解这些术语。</p>
<p>写好新闻稿需要花时间，也需要重复地练习。多向别人要反馈吧！今天的一点点改进可能会节省未来花在上面的大量时间。一份好的新闻稿描述了你的想法是什么，以及为什么要这样做。一般一页纸就够了，不要长篇大论。避免模棱两可的词（weasel words），如一些，许多，经常，可能，显然，一般，等等等等。用数据来代替它们吧。</p>
<p>这里有一些关键内容：</p>
<ul>
<li>用户心声（Customer Testimonial）：先写这个部分。虽然它是虚构的，但是要设身处地地为用户着想，以增加可信度。</li>
<li>问题/机会（Problem/Opportunity）：描述一个问题或机会，别夸大。可以这样开头：“用户们以前只能…”</li>
<li>方案（Solution）：描述能够使用户受益的观点。可以这样开头：“现在，用户们可以…”</li>
<li>标题（Headline）：最后写的部分，要求简短有力。</li>
</ul>
<p>请注意，所有的文档都不是固定不变的，它们是一直演进的。把最重要的内容放在第一段。保证其他人哪怕只看了第一段也能对你的想法有所了解。想一想<a href="https://en.wikipedia.org/wiki/Elevator_pitch" target="_blank" rel="external">电梯游说（Elevator pitch）</a>，怎样在很短的时间内表达出你的想法？写文档像写代码一样，要尽量简单。</p>
<h4 id="常见问题解答"><a href="#常见问题解答" class="headerlink" title="常见问题解答"></a>常见问题解答</h4><p>新闻稿描写了愿景，而FAQ提供更详细的说明。FAQ包含了两个部分：客户会问的问题以及内部参与方会问的问题。关于前者，你需要站在客户的角度上，思考其究竟会问出什么样的问题。例如，我怎么参与进去呢？有了问题我应该找谁呢？我要花钱吗？要像回答真正的客户一样来回答这些问题。关于后者，那就是你的老大、兄弟团队或是投资人应该会问的问题。例如，为什么能够提高用户体验呢？如何验证项目是否成功呢？为什么现在是推行的最佳时期？执行计划是什么？越是常见的问题，放在越上面。</p>
<p>别害怕尖锐的问题，都写上吧。比如说什么问题你最不希望被人问到？有没有你还没找到答案的问题？为什么要这样做，而不是那样做？别藏着掖着，都亮出来吧。这样别人才能更容易地看到这个想法的亮点和痛点。对于暂时还是无解的问题，那就诚实地写下：“我不知道。我还在通过XXX来寻找答案”。在寻求反馈的时候，其他人说不定就能够解决这个问题。但是如果不写，我们不但失去了解决它的机会，而且增加了未来的风险。</p>
<h4 id="视觉资料"><a href="#视觉资料" class="headerlink" title="视觉资料"></a>视觉资料</h4><p>视觉资料包括但不限于：白板、<a href="https://en.wikipedia.org/wiki/Storyboard" target="_blank" rel="external">分镜（Storyboard）</a>、<a href="https://zhuanlan.zhihu.com/p/24536517" target="_blank" rel="external">用户体验历程图（Customer Journey Map）</a>、<a href="https://en.wikipedia.org/wiki/Website_wireframe" target="_blank" rel="external">线框图（Wireframe）</a>、<a href="https://www.zhihu.com/question/31609683" target="_blank" rel="external">高保真UI（High-Fidelity UI）</a>、技术架构图（Technical Architecture Diagram）等等。分镜是一系列草图的组合，能够呈现端到端的用户体验。到了后期，还可以引入技术架构图等来描述一个复杂的系统。不用拘泥于形式，任何有助于表达的东西都是我们的工具。</p>
<p>视觉资料可以让我们对用户体验有一个直观的认识。可以的话，让设计师尽早参与吧。一开始手绘即可，不需要那么高保真。不然大家的讨论容易集中在页面风格上，而不是客户体验上。高保真图是随着迭代的更替和讨论的深入而慢慢成型的。选择保真度有一个小窍门：保真度应该跟你的想法成熟度相匹配。越不成型的想法应该采用的视觉资料就应该越低保真。草图是最简单有效的开始。别怕画得难看，它能帮你加深对自己想法的认识。记住，画得好看与否并不是关键，清晰地表达你的想法才是。</p>
<h3 id="提供反馈"><a href="#提供反馈" class="headerlink" title="提供反馈"></a>提供反馈</h3><p>许多会议一开始都是先花个两三盏茶左右的时间来阅读新闻稿和FAQ。与更多取决于演讲者个人魅力的PPT不同，阅读可以让所有人都处在同一起跑线上。提供反馈时，最好直来直往，别拐弯抹角。如果你有些地方看不明白，尽管说出来。别因为自己跟对方的关系而束手束脚，我们对事不对人。另外在这个时候，我们更多地关注在想法本身，而较少对语法错误、错别字挑刺，这一点与代码审查略有不同。代码审查啥都挑，但要是低级错误太多是要打回去重写的。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>我们先前说过，做好这些事情需要时间练习。如果你一时想不出什么点子，上文提过的中午上哪儿吃饭的问题应该怎么解决？亲爱的读者，你有什么想法吗？</p>
]]></content>
      
        <categories>
            
            <category> idea </category>
            
        </categories>
        
        
        <tags>
            
            <tag> idea </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[挖掘IntelliJ IDEA的调试功能]]></title>
      <url>/intellij-idea-debug/</url>
      <content type="html"><![CDATA[<p>本文介绍了<a href="https://www.jetbrains.com/idea/" target="_blank" rel="external">IntelliJ IDEA</a>的一些相对不那么广为人知，但是又很实用的调试功能。希望能让你的IDE发挥出最大的功效！本文使用的IDEA版本是<code>2018.1</code>社区版，快捷键是<code>Mac OS X</code>。本文的兄弟篇是<a href="/intellij-idea-utilities">挖掘IntelliJ IDEA的实用功能</a>。<br><a id="more"></a></p>
<h2 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h2><h3 id="断点类型"><a href="#断点类型" class="headerlink" title="断点类型"></a>断点类型</h3><p>一般来说调试时，我们都是在代码行上鼠标一点，然后运行测试，遇断点所在的行即停，这就是所谓的行断点。IDEA支持以下几种断点类型：</p>
<ol>
<li>行断点（Line Breakpoints）：就是我们最经常用的方式。</li>
<li>方法断点（Method Breakpoints）：如果你看到代码调用了一个接口，但不知道具体会跑在哪个实现上，便可以在接口上设置断点，这样不管哪个子类运行到这个方法都会停下来。</li>
<li>异常断点（Exception Breakpoints）：可以在<strong>Run</strong> -&gt; <strong>View Breakpoints</strong>中的<strong>Java Exception Breakpoints</strong>里添加异常的具体类型。这样的话，程序中一旦发生了这种异常马上就会停下来。</li>
<li>字段断点（Field Watchpoints）：可以设置在字段上，这样读写字段都可以触发。需要注意的是，默认只有写才会停下，想要让读取时也停下，需要右击断点，在<strong>Watch</strong>的<strong>Field access</strong>上打勾才行。</li>
</ol>
<h3 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h3><p>断点是可以设置条件的，这样便可以只在关心的时候停下来。比如说循环里处理一堆字符串，但是只关心特定的字符串，那条件断点便可以派上用场。按住Shift键设置断点，或是右击断点之后选择<strong>More</strong>来打开以下界面：<br><img src="/img/idea-debug-conditional-breakpoint.jpg" alt=""></p>
<p>上图就是设置条件断点的界面，直接在<strong>Condition</strong>里输入条件即可，如<code>&quot;ggg&quot;.equals(name)</code>。需要注意的是，<strong>Suspend</strong>默认是没有打勾的，必须勾选上才能让程序暂停。另外，辛辛苦苦设置的特定断点，是可以拖拽到别的地方去的，这样就省的到处敲来敲去的了。还有一个小技巧是按住Alt的同时设置断点，可以让断点仅停一次便自动消失。在设置临时断点时有点用。</p>
<h3 id="无断点暂停"><a href="#无断点暂停" class="headerlink" title="无断点暂停"></a>无断点暂停</h3><p>如果在很长的循环时不知道程序运行到哪里了，可以在调试时点击调试窗口上的<strong>Pause Program</strong>，这样程序便能在当前执行的地方暂停。另外，运行到光标（Run to cursor）也可以在没有设置断点的时候让程序运行到光标所在行时暂停。</p>
<h2 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h2><p>下面介绍一些调试的小技巧。</p>
<h3 id="智能进入（Smart-step-into）"><a href="#智能进入（Smart-step-into）" class="headerlink" title="智能进入（Smart step into）"></a>智能进入（Smart step into）</h3><p>当调试程序运行到类似这样的句子时，如果你想看的是<code>actor.action</code>方法，那么进入这个方法就相对麻烦一些。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">actor.action(actionProvider.provide(action.getName()));</div></pre></td></tr></table></figure></p>
<p>这时可以使用调试窗口上的智能进入，程序会弹出一个对话框，我们选择需要的调用处即可。算是一个提升调试效率的小技巧。</p>
<p>官方文档传送门：<a href="https://www.jetbrains.com/help/idea/debugging-code.html#d181035e286" target="_blank" rel="external">https://www.jetbrains.com/help/idea/debugging-code.html#d181035e286</a></p>
<h3 id="表达式评估（Evaluate-expression）"><a href="#表达式评估（Evaluate-expression）" class="headerlink" title="表达式评估（Evaluate expression）"></a>表达式评估（Evaluate expression）</h3><p>这应该是大部分人都知道的技巧了，可以通过表达式评估来重新赋值当前的变量，以便让程序运行到其它的分支去。当然也可以在<strong>Variables</strong>窗口中，右击想要改变的变量，选择<strong>Set Value</strong>。不过表达式评估里可以轻松增加新变量、动态import新类库等，功能更加强大。</p>
<p>官方文档传送门：<a href="https://www.jetbrains.com/help/idea/evaluating-expressions.html" target="_blank" rel="external">https://www.jetbrains.com/help/idea/evaluating-expressions.html</a></p>
<h3 id="远程调试（Remote-debug）"><a href="#远程调试（Remote-debug）" class="headerlink" title="远程调试（Remote debug）"></a>远程调试（Remote debug）</h3><p>如果运行的实例在其它机器（或者虚拟机、docker）上，只要实例设置了以下参数，就可以通过远程调试连接到<code>8000</code>端口进行调试。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-Xdebug -Xrunjdwp:transport=dt_socket,address=8000,server=y,<span class="built_in">suspend</span>=y</div></pre></td></tr></table></figure></p>
<p>官方文档传送门：<a href="https://www.jetbrains.com/help/idea/debugging-code.html#d181035e408" target="_blank" rel="external">https://www.jetbrains.com/help/idea/debugging-code.html#d181035e408</a></p>
<p>对于IDEA来说，只需要在<strong>Run</strong> -&gt; <strong>Edit Configuration</strong>里，增加一个<strong>Remote</strong>，设置主机<strong>Host</strong>和端口<strong>Port</strong>，然后调试它即可。</p>
<h3 id="弃栈帧（Drop-frame）"><a href="#弃栈帧（Drop-frame）" class="headerlink" title="弃栈帧（Drop frame）"></a>弃栈帧（Drop frame）</h3><p>Visual Studio好的一点是调试时可以拖拽当前执行的位置，方便反复查看。虽然IDEA没有这样的功能，但是它可以使用弃栈帧来把当前调用栈的第一栈帧丢弃掉，相当于重新开始当前调试的方法。使用方法也算简单，在要丢弃的栈帧上右击，选择<strong>Drop Frame</strong>即可。或者直接单击调试窗口的<strong>Drop Frame</strong>按钮。不过需要注意的是，如果对象在子方法运行时发生了变化，是不会再变回去的。</p>
<p>官方文档传送门：<a href="https://www.jetbrains.com/help/idea/debugging-code.html#d181035e308" target="_blank" rel="external">https://www.jetbrains.com/help/idea/debugging-code.html#d181035e308</a></p>
<h3 id="强制抛异常（Throw-an-exception）："><a href="#强制抛异常（Throw-an-exception）：" class="headerlink" title="强制抛异常（Throw an exception）："></a>强制抛异常（Throw an exception）：</h3><p>这是IDEA 2018年加入的新功能，可以直接在调试中抛出指定的异常。使用方法跟上面的弃栈帧类似，右击栈帧并选择<strong>Throw Exception</strong>，然后输入如下代码即可：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException()</div></pre></td></tr></table></figure></p>
<p>官方文档传送门：<a href="https://www.jetbrains.com/help/idea/altering-the-program-s-execution-flow.html#throw_exception" target="_blank" rel="external">https://www.jetbrains.com/help/idea/altering-the-program-s-execution-flow.html#throw_exception</a></p>
<h3 id="强制返回（Force-return）："><a href="#强制返回（Force-return）：" class="headerlink" title="强制返回（Force return）："></a>强制返回（Force return）：</h3><p>这是IDEA2015版时增加的功能，类似上面的手动抛异常，只不过是返回一个指定值罢了。使用方法跟上面也都类似，右击栈帧并选择<strong>Force Return</strong>，然后输入要返回的值即可。如果是<code>void</code>的方法那就更简单了，连返回值都不用输。</p>
<p>官方文档传送门：<a href="https://www.jetbrains.com/help/idea/altering-the-program-s-execution-flow.html" target="_blank" rel="external">https://www.jetbrains.com/help/idea/altering-the-program-s-execution-flow.html</a></p>
<h3 id="自动载入变化代码（Reload-changes）"><a href="#自动载入变化代码（Reload-changes）" class="headerlink" title="自动载入变化代码（Reload changes）"></a>自动载入变化代码（Reload changes）</h3><p>利用Java虚拟机提供的HotSwap功能，我们可以做到一边调试一边改代码。只要在修改完代码之后，点击<strong>Run</strong> -&gt; <strong>Reload Changed Classes</strong>即可。不过HotSwap有一些限制，例如不支持static的字段和方法等。</p>
<p>官方文档传送门：<a href="https://www.jetbrains.com/help/idea/altering-the-program-s-execution-flow.html#reload_classes" target="_blank" rel="external">https://www.jetbrains.com/help/idea/altering-the-program-s-execution-flow.html#reload_classes</a></p>
<h3 id="显示方法返回值（Show-method-return-values）"><a href="#显示方法返回值（Show-method-return-values）" class="headerlink" title="显示方法返回值（Show method return values）"></a>显示方法返回值（Show method return values）</h3><p>调试窗口里的<strong>Settings</strong> -&gt; <strong>Show Method Return Values</strong>开关可以显示方法的返回值。例如以下方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">random</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Math.random();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>只要在<code>return</code>上设断点然后<strong>Step Over</strong>，或者在方法内部的任何地方设断点然后<strong>Step Out</strong>一下，便可以在调用处的变量窗口看到一个类似于这样的值：<code>Test.random() = 0.28735657504865864</code>。在这个方法调用没有赋值给变量时（如<code>if (random() &lt; 10)</code>）还挺有用的。</p>
<h3 id="调试流（Trace-Current-Stream-Chain）"><a href="#调试流（Trace-Current-Stream-Chain）" class="headerlink" title="调试流（Trace Current Stream Chain）"></a>调试流（Trace Current Stream Chain）</h3><p>前面说了Visual Studio的好，但是它调试时不能看lambda的值也真是挺恶心的，据说2015版以后开始支持有限的lambda了。IDEA在这方面就做的非常到位。Java 8带来的Stream里面到底是什么，有时候很难知道。通过IDEA提供的这个功能，我们可以很轻松地看到流在各个步骤之间的变化。如下图：<br><img src="/img/idea-debug-lambda.jpg" alt=""></p>
<p>展平模式（Flat Mode）更是提供了全局的视角：<br><img src="/img/idea-debug-lambda-flat-mode.jpg" alt=""></p>
<p>使用这个功能也非常简单，当程序在lambda表达式的任意处停下时，单击调试窗口的<strong>Trace Current Stream Chain</strong>按钮即可。</p>
<p>官方文档传送门：<a href="https://www.jetbrains.com/help/idea/analyze-java-stream-operations.html" target="_blank" rel="external">https://www.jetbrains.com/help/idea/analyze-java-stream-operations.html</a></p>
<h3 id="调试内存泄漏（Memory-View）"><a href="#调试内存泄漏（Memory-View）" class="headerlink" title="调试内存泄漏（Memory View）"></a>调试内存泄漏（Memory View）</h3><p>内存泄漏是一个比较头疼的问题，好在IDEA提供了内存分析工具，只要单击调试窗口右上角的<strong>Restore ‘Memory’ View</strong>就能看到内存窗口，然后点击其中的<strong>Click to load the classes list</strong>就能看到当前内存的对象分布情况。然后可以据此分析到底是哪个类的对象数量看起来有问题。</p>
<p>官方文档传送门：<a href="https://www.jetbrains.com/help/idea/analyze-objects-in-the-jvm-heap.html" target="_blank" rel="external">https://www.jetbrains.com/help/idea/analyze-objects-in-the-jvm-heap.html</a></p>
<h3 id="调试lombok"><a href="#调试lombok" class="headerlink" title="调试lombok"></a>调试lombok</h3><p>如果只是想暂停一下set或get方法，可以使用字段断点，只不过可能会在调试中报错：<strong>Source code does not match the bytecode</strong>，但它能够工作。</p>
<p>如果想设断点的是<code>toString</code>、<code>hashCode</code>等方法，可以在注解上设置断点，也可以在调试时使用：<strong>Refactor</strong> -&gt; <strong>Delombok</strong>并选择相对应的注解，然后再使用上文介绍的HotSwap功能，就可以生成代码并按需调试了。最后别忘记把代码恢复回来。</p>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>调试异步、线程、死锁、活锁等高级功能，官网上面有详细的教程，可以在用到时参考。</p>
<p>官方文档传送门：<a href="https://www.jetbrains.com/help/idea/tutorial-java-debugging-deep-dive.html" target="_blank" rel="external">https://www.jetbrains.com/help/idea/tutorial-java-debugging-deep-dive.html</a></p>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>功能熟悉了以后，熟练使用快捷键能够大幅提高效率。以下是笔者调试时经常使用的快捷键：</p>
<ul>
<li>F7：进入调用的方法</li>
<li>F8：单步运行</li>
<li>F9：继续运行</li>
<li>Shift+F7：智能进入调用的方法</li>
<li>Shift+F8：跳出当前方法</li>
<li>Alt+F8：表达式评估</li>
<li>Alt+F9：运行到光标</li>
<li>Ctrl+Shift+F9：调试当前光标所在方法或类</li>
<li>Ctrl+Shift+F10：运行当前光标所在方法或类</li>
<li>Shift+F9：调试上次运行的测试</li>
<li>Shift+F10：运行上次运行的测试</li>
<li>Command+Shift+T：切换测试和实现</li>
</ul>
]]></content>
      
        <categories>
            
            <category> tool </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IntelliJ IDEA </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[软件开发有没有高下]]></title>
      <url>/it-depends/</url>
      <content type="html"><![CDATA[<p>俗话说“文无第一，武无第二”，软件开发归类于“文”，还是“武”？这个问题本身就有争议。想痛快地吵上一吵吗？进来看看吧。<br><a id="more"></a></p>
<h2 id="大家都来吵"><a href="#大家都来吵" class="headerlink" title="大家都来吵"></a>大家都来吵</h2><p>软件涉及到的领域太广，以至于程序员之间、程序之间很多时候难分伯仲。你可能也经常会听见一些牛逼的程序员们互相吵来吵去，很多时候并不是自己拥有一个完美的解决方案，而是觉得对方的解决方案在特定情况下不好。当然没有十全十美的方案。举个简单的例子，我们奉行的DRY（Don’t Repeat Yourself）原则，要求我们不要WET（Write Everything Twice或者We Enjoy Typing）。可即便是这么通用的原则，也可以被质疑：这样就失去了两边各自变化的能力了。听起来似乎有些道理，但是回头想想，两边各自变化的可能性有多大？这样的可能性在每个人的眼中是不一样的。因为大家的背景不一样，也许某人知道更多的未来需求，也许某人预见业务增长将会很快，也许某人曾经在这上面吃过亏……不一而足。</p>
<p>像DRY这样，但是更加令人难以决断的例子还有很多，列了一些常见的如下：</p>
<ul>
<li><strong>缩进用空格还是TAB？</strong><br><a href="https://stackoverflow.blog/2017/06/15/developers-use-spaces-make-money-use-tabs/" target="_blank" rel="external">据说用空格的程序员收入比用TAB的多</a>，你还打算继续用TAB吗？</li>
<li><strong>Java的变量名要不要默认加final？</strong><br>加上去是有它的好处，但是很烦不是吗？它的价值是否能抵过你的烦恼？这有一个<a href="http://www.javapractices.com/topic/TopicAction.do?Id=23" target="_blank" rel="external">最佳实践</a>，但是否应该采用？</li>
<li><strong>应该测试先行地去TDD，还是补上单元测试就好了？</strong><br>测试驱动开发当然是<a href="http://www.extremeprogramming.org/rules/testfirst.html" target="_blank" rel="external">测试先行</a>，但现实中往往有许多不容易写第一个测试的情况。怎么破？</li>
<li><strong>要不要写注释？</strong><br><a href="https://refactoring.guru/smells/comments" target="_blank" rel="external">重构</a>告诉我们注释很可能是坏味道，应该先尝试重构以让注释变得多余。但就有极端人士认为<a href="https://softwareengineering.stackexchange.com/questions/1/comments-are-a-code-smell" target="_blank" rel="external">所有代码中的注释都是多余</a>的。我们的观点呢？</li>
<li><strong>用不用设计模式？</strong><br>你有没有这样的经历，学完设计模式以后，编程时总想着套到什么地方去？到底应该何时用、怎么用、用多少？</li>
<li><strong>要不要尽量内联（inline）？</strong><br>有一种编程风格是尽量inline所有的变量，除非很不好懂，需要用变量名来解释。例如：<pre><code class="java">String name = someService.getName();
String result = otherService.getResult(name);
<span class="keyword">return</span> result;
</code></pre>
需要重构为：<pre><code class="java"><span class="keyword">return</span> otherService.getResult(someService.getName());
</code></pre>
因为比较简洁嘛。我原来也倾向于使用这种风格。但是新团队的风格是尽量抽变量，理由是方便调试。比如一行中要是出错了呢？调试时要是想知道返回值呢？当然可以查看<code>otherService.getResult(someService.getName())</code>，但是这个操作要是不幂等呢？似乎也有几分道理。</li>
<li><strong>要不要用Java 8的Lambda？</strong><br>曾经有人对我说，最好别用Lambda，因为会的员工不多，不好维护。站在他当时的立场上看，这个理由确实成立。但如果总是这样，新技术岂不是永远都上不了台了？</li>
<li><strong>用异常还是返回值来处理验证逻辑？</strong><br>这也是个比较经典的问题，原来认为<a href="https://stackoverflow.com/questions/299068/how-slow-are-java-exceptions" target="_blank" rel="external">异常影响性能</a>，但随着时代的演进，我们更倾向于<a href="https://stackoverflow.com/questions/4670987/why-is-it-better-to-throw-an-exception-rather-than-return-an-error-code" target="_blank" rel="external">使用异常</a>了。当然<a href="https://softwareengineering.stackexchange.com/questions/184654/ive-been-told-that-exceptions-should-only-be-used-in-exceptional-cases-how-do" target="_blank" rel="external">争论还在继续</a>。</li>
<li><strong>代码覆盖率要不要100%？</strong><br>追求100％的代码覆盖率究竟有没有意义？上80％可能比较轻松，但是最后的20％可能需要付出额外80％的劳动，值得不值得？那么，<a href="https://stackoverflow.com/questions/90002/what-is-a-reasonable-code-coverage-for-unit-tests-and-why" target="_blank" rel="external">代码覆盖率设置为多少比较合理</a>?</li>
<li><strong>要不要结对编程？</strong><br>一人工作一人看，结对编程效率低。但是结对的关键不是效率，而是质量。这又涉及到下面这个问题：</li>
<li><strong>如何衡量软件质量？</strong><br>代码行数、代码覆盖率、缺陷率、圈复杂度……但是它们足够吗？应该如何看待这些值？换个问题，如何衡量软件复杂性？这个问题又涉及到下面的问题：</li>
<li><strong>如何衡量程序员的KPI？</strong><br><a href="https://softwareengineering.stackexchange.com/questions/26596/metric-by-which-to-hold-developers-accountable" target="_blank" rel="external">这很难</a>。只能参考而无绝对。</li>
<li><strong>软件该如何收费？</strong><br>虽然现在看起来有点而离谱，但是很早以前曾经任职的公司确实是按行数收费的，行数＝编写的代码行数＋自动生成的代码×系数（如20％）。更加透明一点的是按工时收费。</li>
<li><strong>可以不用QA吗？</strong><br>曾任职的公司开展过一场“去QA化”运动，现在也不提了。这里的<a href="https://www.zhihu.com/question/19666055/answer/13399364" target="_blank" rel="external">回答</a>很有意思。</li>
<li><strong>是否把修复CI当做第一优先级的事情？</strong><br>这是测试别人是不是了解CI的三个问题之一。当然修复CI的优先级很高。但是有多高呢？我们在实践中是根据具体情况有所取舍的。线上生产环境的问题，才是第一优先级的事情。甚至就连上面这句话有时也不成立。</li>
<li><strong>要不要代码审查？如何审查？</strong><br>大部分人还是认同代码审查的，但是审查方式可以有很多种。最直接的是团队成员都围着电脑看代码，让一个没参与的人来讲解。但是可能费时很多，而且不是所有人都能进入状态，有的人喜欢一起看，有的人喜欢单独看。有一种方式是工具的支持，可以进行一对一的审查，这个可以挖个坑单写一片文章了。</li>
<li><strong>要不要鼓励项目中使用多种技术，比如多种测试框架，版本管理工具等？</strong><br>这里存在着工作效率与提升技能之间的小冲突。使用已经用过的技术当然开发起来更快，但是也是去了尝新的机会，或者说是乐趣。而过量的技术运用到一个项目中，也会带来沉重的负担。</li>
<li><strong>PHP是不是世界上最好的语言？</strong><br>我还是不评论了吧，免得挨揍。</li>
</ul>
<h2 id="底线还得有"><a href="#底线还得有" class="headerlink" title="底线还得有"></a>底线还得有</h2><p>对于永远稳定不会变化的需求（尽管很少，但这样的需求确实存在）而言，软件开发也许就能够分出高下来。举个例子：一个确定不会被重用的小工具。在这种情况下，可以适用的原则是：<strong>越快越好</strong>。我们甚至可以适当允许一些bug的存在，因为修复它们所需的时间可能大于手动修复运行结果所需的时间。另外，永远稳定不会变化的需求真的就永远不会变化吗？未必。但是在开发的某个时间点上，它确实是被认为是永远不会再变化的了。唯一不变的是变化本身。</p>
<p>曾经有同事去印度当了几个月的程序员讲师，回来后告诉我，在回答学员们的问题时，讲师们说得最多的就是这句话：“It depends.”。这基本上是一个放之四海而皆准的原则：<strong>具体情况具体分析</strong>。那是不是所有的问题都直接无脑地“具体情况具体分析”就完了？当然可以，但这是一种思想上的懒，不是我这“懒程序员”的“懒”。因为这句话对解决问题并不能有太多实质上的帮助嘛。关键是，我们还得就着“具体情况”来“分析”。所以，我们可以在其上再构建一些原则，来覆盖特定的情况。</p>
<p>比如说设计模式，它是对特定问题的特定解决方案。不要一股脑儿就往上套，好的经验是在发现坏味道以后，重构到设计模式，甚至是重构了一半，就已经消除掉坏味道了。原则：<strong>越简单越好</strong>。<br>比如说final，它并不能带来明显可观的价值，所以应该以大多数人的习惯为先。原则：<strong>贴近大多数人的习惯</strong>。<br>比如说lambda，明显它是更加先进的生产力，所以上面的原则就不适用了，应该以先进的生产力为先。原则：<strong>采用先进的生产力</strong>。<br>比如说代码覆盖率，高覆盖率自然是好，但是值得吗？比如Java可能就很难做到100％，但JS就能轻松一些。原则：<strong>采用性价比高的方案</strong>。<br>从“代码审查”中我们也可以看到，每个人都是不一样的，我在<a href="/effective-communication">人际风格与有效沟通实战</a>中也曾提到不同风格的人。原则：<strong>因人而异</strong>。<br>从“尽量内联”、“异常或返回值”中我们也可以看到，应该保持开放的心态来调整各原则。原则：<strong>原则需要与时俱进</strong>。<br>比如说要不要写注释，大多数情况下，组织得当的方法名、变量名已经能够说明问题了，这时的注释就显得多余。但偶尔还是需要介绍一块代码的来龙去脉，这时的注释就是必要的。原则：<strong>具体情况具体分析</strong>。</p>
<p>我们现在已经有了好几条原则了：</p>
<ul>
<li><strong>越快越好</strong></li>
<li><strong>越简单越好</strong></li>
<li><strong>贴近大多数人的习惯</strong></li>
<li><strong>采用先进的生产力</strong></li>
<li><strong>采用性价比高的方案</strong></li>
<li><strong>因人而异</strong></li>
<li><strong>原则需要与时俱进</strong></li>
<li><strong>具体情况具体分析</strong></li>
</ul>
<p>有些原则可能在特定的情况下是冲突的，需要自己思考究竟哪条原则更加符合现实情况。在适当的时候使用适当的原则（就像设计模式一样），而不是拿着锤子看见啥都像钉子（也像设计模式一样）。另外，需求是变化的，我们的原则也不必一成不变。有句话说“规则是用来打破的”。我想说的是，在充分理解规则之后，再来决定是不是打破它，并承担相应的后果。或者，考虑是不是用更高级的规则（如“具体情况具体分析”）来约束它，或是用更低级的规则来覆盖它吧。</p>
]]></content>
      
        <categories>
            
            <category> idea </category>
            
        </categories>
        
        
        <tags>
            
            <tag> idea </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[挖掘IntelliJ IDEA的实用功能]]></title>
      <url>/intellij-idea-utilities/</url>
      <content type="html"><![CDATA[<p>本文介绍了<a href="https://www.jetbrains.com/idea/" target="_blank" rel="external">IntelliJ IDEA</a>的一些相对不那么广为人知的实用功能。希望能让你的IDE发挥出最大的功效！本文使用的IDEA版本是<code>2017.2.6</code>社区版，快捷键是<code>Mac OS X</code>。本文的兄弟篇是<a href="/intellij-idea-debug">挖掘IntelliJ IDEA的调试功能</a>。<br><a id="more"></a></p>
<h2 id="多重选择"><a href="#多重选择" class="headerlink" title="多重选择"></a>多重选择</h2><p>Sublime Text有一个非常好用的功能，就是可以选择多个光标，允许一起编辑。IDEA也向其学习，提供了类似的功能。只要按住<strong>Alt+Shift</strong>时，用鼠标点击其它位置即可。还可以通过<strong>Ctrl+G</strong>选择下一个相同的字符串，或是<strong>Ctrl+Command+G</strong>选择所有相同的字符串。如下图：<br><img src="/img/idea-multiple-selections.png" alt=""></p>
<p>还有一个功能是纵向选择，可以通过<strong>Command+Shift+8</strong>来开关。之后的效果如下：<br><img src="/img/idea-column-selection.png" alt=""></p>
<p>有一个注意事项就是，多重选择的时候不要用IDE自带的重构功能。</p>
<p>官方文档传送门：<a href="https://www.jetbrains.com/help/idea/editor-basics.html#editor_lines_code_blocks" target="_blank" rel="external">https://www.jetbrains.com/help/idea/editor-basics.html#editor_lines_code_blocks</a></p>
<h2 id="文件比较器"><a href="#文件比较器" class="headerlink" title="文件比较器"></a>文件比较器</h2><p>比较两个项目中的文件很简单，选中这两个文件，然后<strong>Command+D</strong>就可以了。JAR文件、文件夹也能够进行比较：<br><img src="/img/idea-compare-folders.png" alt=""></p>
<p>如果只有一个文件在项目中，那就选中它，然后<strong>Command+D</strong>，再从对话框中打开项目外的文件即可。如果另一个文件在剪贴板，那就打开项目中的文件，然后右击编辑器选择<strong>Compare with Clipboard</strong>即可。</p>
<p>如果两个文件都不在项目中……那好歹复制一个进去呗。</p>
<p>官方文档传送门：<a href="https://www.jetbrains.com/help/idea/comparing-files.html" target="_blank" rel="external">https://www.jetbrains.com/help/idea/comparing-files.html</a></p>
<h2 id="正则校验器"><a href="#正则校验器" class="headerlink" title="正则校验器"></a>正则校验器</h2><p>如果你写了个（或搜了个）炫酷的正则表达式，除了单元测试，IDEA也提供了简便的测试方式。比如对于如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Pattern EMAIL_PATTERN = Pattern.compile(<span class="string">"^([a-zA-Z0-9_\\-\\.]+)@([a-zA-Z0-9_\\-\\.]+)\\.([a-zA-Z]&#123;2,5&#125;)$"</span>);</div></pre></td></tr></table></figure></p>
<p>在正则的字符串中按下<strong>Alt+Enter</strong>，选择<strong>Check RegExp</strong>，然后填入想校验的字符串即可：<br><img src="/img/idea-check-regexp.png" alt=""></p>
<p>官方文档传送门：<a href="https://www.jetbrains.com/help/idea/regular-expression-syntax-reference.html#tips-tricks" target="_blank" rel="external">https://www.jetbrains.com/help/idea/regular-expression-syntax-reference.html#tips-tricks</a></p>
<h2 id="Emmet"><a href="#Emmet" class="headerlink" title="Emmet"></a>Emmet</h2><p>还在写这样的html吗？早就out了……<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">id</span>=<span class="string">"users"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">tr</span> <span class="attr">class</span>=<span class="string">"user"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>只要输入<code>table#users&gt;tr.user&gt;td*3</code>然后按下<strong>TAB</strong>就行了。能自动生成的，我们就不自己写。不过这个功能只在后缀名为<code>html</code>或<code>xml</code>的文件编辑器中生效，所以创建一个html文件然后再试试吧。</p>
<p>这里有一张Emmet的语法表：<a href="https://docs.emmet.io/cheat-sheet/" target="_blank" rel="external">https://docs.emmet.io/cheat-sheet/</a></p>
<p>官方文档传送门：<a href="https://www.jetbrains.com/help/idea/emmet.html" target="_blank" rel="external">https://www.jetbrains.com/help/idea/emmet.html</a></p>
<h2 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h2><p>如果你看到这样的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> name + <span class="string">" is "</span> + age + <span class="string">" years old."</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>就会忍不住想把它变成这样的话：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> StringBuilder().append(name)</div><div class="line">                          .append(<span class="string">" is "</span>)</div><div class="line">                          .append(age)</div><div class="line">                          .append(<span class="string">" years old."</span>)</div><div class="line">                          .toString();</div></pre></td></tr></table></figure></p>
<p>只要在等号后面的语句中按下<strong>Alt+Enter</strong>，选择<strong>Replace ‘+’ with ‘StringBuilder.append()’</strong>即可。也可以选择<strong>Replace ‘+’ with ‘String.format()’</strong>，来把它变成这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> String.format(<span class="string">"%s is %d years old."</span>, name, age);</div></pre></td></tr></table></figure></p>
<p>所以当你准备拼接字符串了，考虑这个功能吧，比自己慢慢写要顺手多了。其实<strong>Alt+Enter</strong>这个万能快捷键在不同的代码下支持许多不同的功能，没事在代码上随便敲一敲，你会发现惊喜的。</p>
<h2 id="本地历史"><a href="#本地历史" class="headerlink" title="本地历史"></a>本地历史</h2><p>通过<strong>VCS</strong>菜单中，<strong>Local History</strong>的<strong>Show History</strong>，可以打开当前文件的本地修改历史。如果某个版本你并没有提交过，只是在本地曾经改过，但是又改掉了，就可以利用这个功能将其找回。甚至还可以针对字段、方法、文件夹、乃至整个项目来查看。所以保存量是比较大的，IDEA默认就保留五个工作日的本地历史，有一周一般来说也就够了吧。这个值也能通过传给JVM的参数<code>localHistory.daysToKeep</code>来修改。如果因为磁盘不够等原因不想要，也可以把它设置为0。<br><img src="/img/idea-local-history.png" alt=""></p>
<p>官方文档传送门：<a href="https://www.jetbrains.com/help/idea/local-history.html" target="_blank" rel="external">https://www.jetbrains.com/help/idea/local-history.html</a></p>
<h2 id="测试覆盖率"><a href="#测试覆盖率" class="headerlink" title="测试覆盖率"></a>测试覆盖率</h2><p>通过<strong>Run</strong>菜单里的<strong>Run ‘xxxTest’ with Coverage</strong>，可以在运行测试时顺便跑出测试覆盖率。通过<strong>Analyze</strong>菜单里的<strong>Show Coverage Data</strong>，可以查看覆盖率的大致情况。而通过<strong>Generate Coverage Report</strong>，可以生成测试报告，在报告里可以看到具体的每一行是否运行过。这是覆盖率数据：<br><img src="/img/idea-coverage-data.png" alt=""></p>
<p>这是测试报告：<br><img src="/img/idea-coverage-report.png" alt=""></p>
<p>官方文档传送门：<a href="https://www.jetbrains.com/help/idea/viewing-code-coverage-results.html" target="_blank" rel="external">https://www.jetbrains.com/help/idea/viewing-code-coverage-results.html</a></p>
<h2 id="生产力指南"><a href="#生产力指南" class="headerlink" title="生产力指南"></a>生产力指南</h2><p>点击<strong>Help</strong>菜单里的<strong>Productivity Guide</strong>，就能看到一张大表，记录着各功能的使用情况。注意一下使用频率低的，了解一下从未使用过的，很快就能成为Intellij IDEA的砖家了。<br><img src="/img/idea-productivity-guide.png" alt=""></p>
<p>官方文档传送门：<a href="https://www.jetbrains.com/help/idea/productivity-guide.html" target="_blank" rel="external">https://www.jetbrains.com/help/idea/productivity-guide.html</a></p>
]]></content>
      
        <categories>
            
            <category> tool </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IntelliJ IDEA </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[敲最少的键，编最多的码]]></title>
      <url>/type-less-code-more/</url>
      <content type="html"><![CDATA[<p>我们知道在软件开发中，效率是很重要的环节。结对编程时，有些手快的人想到哪里就能编到哪里，恨不得分分钟从手慢的人那儿把键盘抢过来。今天的这篇文章主要是如何用好<a href="https://www.jetbrains.com/idea/" target="_blank" rel="external">IntelliJ IDEA</a>这个著名的IDE，以实现：“敲最少的键，编最多的码”。虽说本文的示例是Java，其它语言区别也不大，尤其是当现在的<a href="https://www.jetbrains.com/products.html" target="_blank" rel="external">JET BRAINS全家桶</a>已经是如此齐备时。<br><a id="more"></a></p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>废话不多说，在环境准备好的情况下，假设我们来测试驱动开发一个计算一天有多少个小时的API。参见以下的两分半小视频：</p>
<iframe frameborder="0" width="640" height="498" src="https://v.qq.com/iframe/player.html?vid=s0545lt9r2e&tiny=0&auto=0" allowfullscreen></iframe>

<p>要是视频不清晰或看不到，就直接到<a href="https://v.qq.com/x/page/s0545lt9r2e.html" target="_blank" rel="external">腾讯视频</a>中看720P吧。</p>
<p>如何才能做到”敲最少的键，编最多的码“呢？除了掌握技巧之外，就是多练习实践了。以下就是技巧的内容。</p>
<h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><p>首先把环境准备一下。只要有<code>src</code>和<code>test</code>即可。我自己是一个默认的Maven新项目，在<code>pom</code>中引用了<code>junit</code>。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"> &lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></div><div class="line">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.ggg<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ggg<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>专业版的IDEA支持项目模板，如果你对默认的模板不满意，项目模板能够节省你的一部分操作。</p>
<h2 id="步骤分解"><a href="#步骤分解" class="headerlink" title="步骤分解"></a>步骤分解</h2><ol>
<li>快捷键：在<code>test/java</code>中用快捷键<strong>Ctrl+N</strong>生成文件。</li>
<li>文件模版：选择的<code>JUnit</code>正是我事先创建好的文件模板，内容见下文的“功能简介”。这里的一个小诀窍是先按下<strong>u</strong>，可以过滤掉不需要的模板。</li>
<li>输入：输入<code>HoursCalculatorTest</code>并回车，测试文件就此生成。</li>
<li>代码自动生成：移动光标到合适位置，用快捷键<strong>Ctrl+N</strong>自动生成<strong>Test Method</strong>。</li>
<li>输入：将测试方法命名为<code>should_get_24_hours_for_1_day</code>。</li>
<li>输入：这里需要新建一个测试目标，即<code>new HoursCalculator()</code>。</li>
<li>快捷键：因为<code>HoursCalculator</code>类还不存在，所以会报错，用快捷键<strong>F2</strong>移动到下一个错误处，再用快捷键<strong>Alt+Enter</strong>自动修复错误，选择<strong>Create class ‘HoursCalculator’</strong>。</li>
<li>代码自动生成：输入<code>org.ggg</code>自动生成<code>HoursCalculator</code>类。</li>
<li>快捷键：<strong>Ctrl+Tab</strong>回到上一个文件即我们的测试类。<strong>Command+Alt+V</strong>将<code>new HoursCalculator()</code>抽取为一个变量<code>hoursCalculator</code>，<strong>Command+Shift+Enter</strong>结束本行，将光标跳至下一行开头。</li>
<li>输入：输入<code>int hoursByDay = hoursCalculator.getHoursByDay(1)</code>来获取计算结果。小诀窍是只要输入<code>hc</code>，IDEA就会提示<code>hoursCalculator</code>。</li>
<li>代码自动生成：还是<strong>Alt+Enter</strong>自动修复错误，选择<strong>Create method ‘getHoursByDay’</strong>，便能在<code>HoursCalculator</code>类中自动生成<code>getHoursByDay</code>方法。</li>
<li>输入：一路回车，可以把参数名改为<code>days</code>。</li>
<li>快捷键：还是<strong>Ctrl+Tab</strong>回到测试类，然后<strong>Command+Shift+Enter</strong>结束本行（分号会自动补齐）。</li>
<li>输入：输入<code>assertEquals(24,hoursByDay)</code>，还是<strong>Command+Shift+Enter</strong>结束本行（还会调整格式）。</li>
<li>快捷键：<strong>Ctrl+Shift+F10</strong>运行测试，红了。用<strong>Ctrl+Tab</strong>回到<code>HoursCalculator</code>类准备修改实现。</li>
<li>输入：把返回值从<code>0</code>改为<code>24</code>。</li>
<li>快捷键：<strong>Shift+F10</strong>运行上个测试，这回绿了。用<strong>Ctrl+Tab</strong>回到我们的测试类，准备编写下一个测试。</li>
<li>活动模板：将光标移动到合适的位置，输入<strong>test</strong>和<strong>TAB</strong>键。可以看到生成了另一个测试方法。当然我们在此也可以用上面的“代码自动生成”，这里不过是用了另一种方法而已。<code>test</code>是我事先创建好的活动模板，内容见下文的“功能简介”。</li>
<li>输入：将方法命名为<code>should_get_48_hours_for_2_days</code>。之后按照类似上文的方式，实现并执行测试，红了。令方法返回<code>24 * day</code>并再次执行测试，绿了。移动光标到测试方法之外，执行全部测试，都绿了，保证后一个实现不会破坏前一个实现。</li>
<li>快捷键：现在是tdd的重构阶段。<code>24</code>是一个magic number，所以我们要用<strong>Command+Alt+C</strong>将其变成一个常量，如<code>hoursInDay</code>。不过常量应该还是大写的蛇式比较符合惯例，于是可以<strong>Shift+F6</strong>改名。</li>
<li>插件：我事先安装了<strong>string-manipulation</strong>插件，所以可以直接使用快捷键<strong>Alt+M</strong>并选择<strong>4. To SCREAMING_SNAKE_CASE</strong>将变量改名为<code>HOURS_IN_DAY</code>。其实现在版本的IDEA已经会在快捷键改名时提示<code>HOURS_IN_DAY</code>了，但是插件支持的功能更加丰富一些，并且也能在编辑非java文件时使用。</li>
<li>快捷键：用<strong>Shift+F10</strong>运行上次运行的全部测试，依然是绿的。</li>
<li>快捷键：测试文件还不在包中，用<strong>F6</strong>将其移入<code>org.ggg</code>中。还可以用<strong>Command+Alt+O</strong>来优化import部分。</li>
<li>快捷键：再次用<strong>Shift+F10</strong>运行测试，依然是绿的，重构完成。</li>
</ol>
<h2 id="用到的IDE功能简介"><a href="#用到的IDE功能简介" class="headerlink" title="用到的IDE功能简介"></a>用到的IDE功能简介</h2><h3 id="快捷键（Shortcuts）"><a href="#快捷键（Shortcuts）" class="headerlink" title="快捷键（Shortcuts）"></a>快捷键（<a href="https://resources.jetbrains.com/storage/products/intellij-idea/docs/IntelliJIDEA_ReferenceCard.pdf" target="_blank" rel="external">Shortcuts</a>）</h3><p>我用的是<strong>Mac OS X</strong>的Keymap。常用的快捷键要牢记，很多时候它决定了程序员的效率如何。JET BRAINS的各种语言的IDE快捷键都比较类似，花点精力记住它决不会吃亏。</p>
<h3 id="文件模板（File-Templates）"><a href="#文件模板（File-Templates）" class="headerlink" title="文件模板（File Templates）"></a>文件模板（<a href="https://www.jetbrains.com/help/idea/file-and-code-templates.html" target="_blank" rel="external">File Templates</a>）</h3><p>顾名思义，文件模板即是新建文件时使用到的模板。我们在上面的步骤中使用的<code>JUnit</code>活动模板如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#if ($&#123;PACKAGE_NAME&#125; &amp;&amp; $&#123;PACKAGE_NAME&#125; != "")package $&#123;PACKAGE_NAME&#125;;#end</div><div class="line"></div><div class="line">import org.junit.Test;</div><div class="line"></div><div class="line">import static org.junit.Assert.*;</div><div class="line">#parse("File Header.java")</div><div class="line">public class $&#123;NAME&#125; &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它的语法基于<a href="http://velocity.apache.org/engine/devel/user-guide.html#Velocity_Template_Language_VTL:_An_Introduction" target="_blank" rel="external">Apache Velocity</a>，支持变量，如<code>${PACKAGE_NAME}</code>表示包名，<code>${NAME}</code>表示用户输入的名称，等等。</p>
<p>可以通过在<strong>Preferences</strong>中搜索<strong>File and Code Templates</strong>，来创建或修改文件模板。也可以在一开始<strong>Ctrl+N</strong>时选择<strong>Edit File Templates…</strong>。</p>
<h3 id="活动模板（Live-Templates）"><a href="#活动模板（Live-Templates）" class="headerlink" title="活动模板（Live Templates）"></a>活动模板（<a href="https://www.jetbrains.com/help/idea/live-templates.html" target="_blank" rel="external">Live Templates</a>）</h3><p>活动模板与文件模板类似，但它不需要新建文件，可以在文件的任何地方激活，只需要输入名字后加一个<strong>TAB</strong>即可。我们在上面的步骤中使用的<code>test</code>活动模板如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> $NAME$() &#123;</div><div class="line">    $END$</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中的<code>$END$</code>表示最后光标会出现在哪里。在此，表示光标最后会出现在方法体内，以便于继续编写实现。</p>
<p>可以通过在<strong>Preferences</strong>中搜索<strong>Live Templates</strong>，来创建或修改活动模板。</p>
<h3 id="代码自动生成（Generating-Code）"><a href="#代码自动生成（Generating-Code）" class="headerlink" title="代码自动生成（Generating Code）"></a>代码自动生成（<a href="https://www.jetbrains.com/help/idea/generating-code.html" target="_blank" rel="external">Generating Code</a>）</h3><p>有许多常用的代码，例如getter、setter、constructor、equals&amp;hashCode等等，IDEA都能够通过这个功能帮助自动生成。</p>
<p>我们在上面的步骤中使用了<strong>Ctrl+N</strong>生成了junit的测试方法，用<strong>Alt+Enter</strong>通过修复错误的方式来生成类和方法。</p>
<h3 id="插件（Plugins）"><a href="#插件（Plugins）" class="headerlink" title="插件（Plugins）"></a>插件（<a href="https://www.jetbrains.com/help/idea/managing-plugins.html" target="_blank" rel="external">Plugins</a>）</h3><p>IDEA支持<a href="https://plugins.jetbrains.com/idea_ce" target="_blank" rel="external">许多插件</a>。插件的功能强大，能够做到从修改字符串到语言级别的支持。比如我们用的版本控制系统VCS就是用插件的方式开发的。</p>
<p>我们在上面的步骤中使用了<a href="https://plugins.jetbrains.com/plugin/2162-string-manipulation" target="_blank" rel="external"><strong>string-manipulation</strong>插件</a>。安装完插件，别忘了重启IntelliJ IDEA。你也可以<a href="https://www.jetbrains.com/help/idea/creating-a-project-for-plugin-development.html" target="_blank" rel="external">编写自己的插件</a>。</p>
]]></content>
      
        <categories>
            
            <category> tool </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IntelliJ IDEA </tag>
            
            <tag> TDD </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[个人的技术债]]></title>
      <url>/personal-tech-debt/</url>
      <content type="html"><![CDATA[<p><a href="https://zh.wikipedia.org/wiki/%E6%8A%80%E6%9C%AF%E8%B4%9F%E5%80%BA" target="_blank" rel="external">技术债</a>是一个借用了财务债的绝妙隐喻（<a href="http://www.extremeprogramming.org/rules/metaphor.html" target="_blank" rel="external">极限编程XP的实践</a>之一），表示当我们为了短期利益（如按时完成开发），而在技术上对软件的长期质量进行的妥协。它一般用于项目管理，但其实也广泛地存在于各个地方，比如每个人的身上。<br><a id="more"></a></p>
<h2 id="项目的技术债"><a href="#项目的技术债" class="headerlink" title="项目的技术债"></a>项目的技术债</h2><p>技术债的起源和后果、解决方式等，网上一搜一大把，我这里就不再赘述了。这里总结一点常见的误区：</p>
<ul>
<li>技术债是邪恶的：这里借用维基百科的一小段话：“第一次发布代码，就好比借了一笔钱。只要通过不断重写来偿还债务，小额负债可以加速开发。但久未偿还债务会引发危险。复用马马虎虎的代码，类似于负债的利息”。健康的债务是好事，谁买房子不贷款（土豪请随意）？</li>
<li>技术债必须偿还：有时候你写一段小程序，只希望尽快跑起来看看，然后将之抛弃。程序由于没有重构，而充斥着各种反模式（它们都是技术债！）。我自己就写了不少，用毕即弃。这里面的债……反正我自己是没有兴趣也没有时间偿还。有些项目的代码，你知道永远也不会有人会动（当然这个很主观，并且取决于你的经验），或者是很快就要完蛋的，我也倾向于先不还这个债，真的到了出现万一的时候，那就再还吧。还债是有成本的，如果感觉还债成本将要上升，也许就应该还这个债了。有没有一种lazy的感觉？</li>
<li>开发新功能优先于偿还技术债：这是一个it depends的问题，谁高谁低取决于对债和利息的判断及不同角色间的博弈。如果利息趋近于零，当然可以先不考虑还债；如果新功能的投资预期带来大把的收益，当然可以先开发新功能。</li>
<li>技术债可以避免：如果这样的话，只要没有新功能，就永远不必发新版本了。没有完美的人，没有完美的程序。别想躲开它，想想怎么处理它。</li>
</ul>
<h2 id="个人的技术债"><a href="#个人的技术债" class="headerlink" title="个人的技术债"></a>个人的技术债</h2><p>Martin Fowler把<a href="https://martinfowler.com/bliki/TechnicalDebt.html" target="_blank" rel="external">技术债</a>分为<a href="https://martinfowler.com/bliki/TechnicalDebtQuadrant.html" target="_blank" rel="external">四个象限</a>，如下图所示：<br><img src="/img/tech-debt-quadrant.png" alt=""></p>
<p>项目在不断前进，做项目的人也是不断前进的。项目需要还债来让自己运转良好，人不也一样需要还债让自己进步吗？参考上图，我也画了张个人的技术债四象限，如下图所示：<br><img src="/img/personal-tech-debt-quadrant.png" alt=""></p>
<p>这四个象限不都是技术债的源头吗？下面我们来具体分析一下每一个象限：</p>
<p><strong>有意的－慎重的：清理</strong>。例如，我知道项目上需要用到drools，它对未来的项目可能会很有用，可惜当时没条件深入学习。又或者项目上用到了JJTree，它有些过时了，以后也基本用不上，不需要浪费时间在这上面。这是两个不同的例子，因为你是有意地做出了选择，所以凭你的经验来决定吧，是否应该把它放到你的个人技术债上。<br><strong>有意的－草率的：思考</strong>。例如，当时工作太忙，虽然知道docker能够解决这个问题，但没时间去学，至于项目嘛，凑合能用就好了。现在回头想想，还能凑合吗？因为草率，所以需要思考；因为有意，所以还要选择。是否放入你的个人技术债，你自己决定吧。<br><strong>无心的－慎重的：复盘</strong>。例如，当时不知道其实AWS可以满足项目的需求，但是现在知道了，很可能用AWS可以节省一大部分的开发和运维成本，但也可能有坑。在这种情况下，我们可以做一次复盘，如果项目再来一遍应该怎样？把收获到的经验用到下一个项目中吧。<br><strong>无心的－草率的：求知</strong>。例如，我并不知道前端技术大爆炸有那么多的框架可选，现在我也不太了解，反正有活儿我就上JQuery。用一句绕口的话总结就是：不知道自己不知道什么。如果是这样，那么就应该先高层次地了解一下背景知识，起码让自己不至于抓瞎吧。之后再慢慢将自己的知识体系建立起来。</p>
<p>接下来就该给你的债排优先级，用<a href="http://wiki.mbalib.com/wiki/%E6%97%B6%E9%97%B4%E2%80%9C%E5%9B%9B%E8%B1%A1%E9%99%90%E2%80%9D%E6%B3%95" target="_blank" rel="external">时间“四象限”法</a>，XY轴分别是重要性和紧急性。重要又紧急的债先还；重要不紧急的债可以制定计划；紧急但不重要的，不值得投入大把的时间，够用就好；不重要不紧急的就尽量放弃吧，除非这个债是你的兴趣爱好之所在。</p>
<p>2017年已经远离，是不是在收获了许多成果的同时，也留下了一些遗憾？2018年的余额也已充值完毕，去年（说不定去了好几年呢）欠下的债，该考虑怎么还一还了吧？</p>
]]></content>
      
        <categories>
            
            <category> idea </category>
            
        </categories>
        
        
        <tags>
            
            <tag> idea </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《Java函数式编程》出版啦]]></title>
      <url>/functional-programming-in-java/</url>
      <content type="html"><![CDATA[<p>从2017年年初到年底，我的新译作<a href="https://book.douban.com/subject/27594722/" target="_blank" rel="external">《Java函数式编程》</a>终于出版啦。这里简要地介绍一下本书，并放篇我为此书所作的译者序，安利一下。<br><a id="more"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>《Java函数式编程》并不是一本关于Java的书，而是一本关于函数式编程的书。作者由浅入深地介绍了函数式编程的思维方式，并引导读者通过易于掌握的例子、练习和图表来学习和巩固函数式编程的基本原则和最佳实践。读者甚至可以在阅读的同时编写出自己的函数式类库！</p>
<p>与<a href="https://book.douban.com/subject/26346017/" target="_blank" rel="external">《Java 8函数式编程》</a>相比（这是一本Java 8的函数式用法的入门佳作），本书侧重的是函数式的思维与实践，而非是Java 8的语法。如果你是一位看完基础语法书后喜欢接着看“Effective”系列的程序员，那么本书就有几分类似于“Effective”版，只不过它讲的是函数式而非是Java 8的“Effective”。语言容易过时或被淘汰，但是思想永存。</p>
<p><img src="/img/functional_programming_in_java_en.jpg" alt=""><br><img src="/img/functional_programming_in_java_cn.jpg" alt=""></p>
<h2 id="译者序"><a href="#译者序" class="headerlink" title="译者序"></a>译者序</h2><p>有幸受邀翻译本书。初见书名，心中不免有几分疑虑，难道又是一本教你怎么使用Java 8 lambda来函数式编程的书吗？翻了几页，方觉自己大误。本书其实意在如何从零开始，逐步理清函数式编程的思维方式并编写基础类库，不仅授之以鱼，而且授之以渔。只不过由于Java的受众实在太广，所以才使用这门语言罢了。</p>
<p>函数式编程有一个至关重要的前提，那就是函数的输出只能取决于函数的参数（我们会在书中看到生成随机数的例子）。初看上去似乎与Java这门面向对象的语言不搭。但语言只是工具而已，正如你也可以在Haskell中编写命令式风格的代码。在一个不太复杂、甚至非并发的常规Java系统中，由于程序内部状态的改变，多次调用同一个方法的返回值很可能是不一样的，更不用说所带来的副作用了。函数式编程中，确定的输入决定了确定的输出，就意味着只要参数对了，结果一定在预期中。也就是说，函数式编程没有无法重现的bug。在这样的前提下，单元测试相对容易实现，而且能极大地增强你的信心。（想想你对目前所在项目的单元测试有多大的信心？）许多个这样的函数复合起来，在不改变信心的同时能够提供更多更强大的功能，进而带来更大的收益，如无状态的线程安全、必要时才计算的惰性求值、加快多次执行速度的记忆化等等。</p>
<p>传统的命令式编程是计算机硬件的抽象，源自图灵机，其实就是外部输入、内部状态、对外部的输出以及对内部状态的改变。函数式编程源自λ演算，即将变量和函数替换为或值表达式并根据运算符计算。函数式编程相比命令式编程代码更简洁、可读性更强，这是因为它的思维方式更倾向于描述要什么，而不是怎么做。所以学习过程反而更加自然，并且不需要多么高深的数学基础。可是我们也知道，软件开发没有银弹。新的方法论也会带来新的问题，需要运用新知识来解决。幸运的是，新知识的坑已经有人帮你踩过了，高阶函数、偏应用函数、复合函数、柯里化、闭包……软件开发从来不缺术语。幸好它们并非高不可攀，作者将会在第二章中扫清你的疑虑，并在后续章节中挑战惰性求值、记忆化、状态处理、应用作用还有actor等更高级的技术。你说Monad？作者才不告诉你它究竟是什么，但是看完本书你自然就领悟了。</p>
<p>函数式编程不是万能药。它有自己擅长的领域，也有自己的弱项。函数式编程是级别更高的抽象。高级别抽象带来的收益就是易读、好写，可是有些低级别的事情（如果你真的需要的话）可能就不容易完成。函数式编程没有副作用，导致无法完成输入/输出操作。尽管如此，你也会在本书中看到一些解决办法。函数式编程没有变量，因此无法改变循环的终止条件，故而没有循环，严重依赖于用递归来抽象循环。在某些情况下可能会影响性能，所以你还会在本书中看到一些性能与情怀之间的权衡。绝大部分的编程最佳实践都是针对某个特定的场景而言的。因此脱离业务场景直接讨论技术并不可取。拥有函数式编程的思维，你就拥有了解决问题的另一种选择，但是条条大路通罗马，千万别钻牛角尖。程序是对现实世界的建模，“不要让世界适应你的模型。让你的模型适应世界。”</p>
<h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>感谢作者Pierre-Yves Saumont，不仅写了这样一本令程序员们受益匪浅的书，而且耗费精力维护本书的后续重构，还耐心地回答我对书中的疑问，使我有机会提高中文版的翻译质量。<br>感谢永恒的侠少和刘舫，让我可以集中精力专注于翻译之上，并让本书得以出版。<br>感谢瑞民，虽然世事变幻莫测，但是你始终扮演了非常重要的角色。<br>感谢家人和朋友们，我永远离不开你们的鼓励和支持。</p>
]]></content>
      
        <categories>
            
            <category> development </category>
            
        </categories>
        
        
        <tags>
            
            <tag> book </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[懒程序员笔记]]></title>
      <url>/lazy-programmer/</url>
      <content type="html"><![CDATA[<p>坚持更新“懒程序员改变世界”的博客已经两年了，近期准备和老友办一个“懒程序员笔记”的订阅号，既然都是“懒程序员”的主题，那就围绕着它写点儿什么吧。<br><img src="/img/lazy-programmer-notes-qrcode.png" alt=""><br><a id="more"></a></p>
<p>有一篇文章叫<a href="http://www.jiemian.com/article/427711.html" target="_blank" rel="external">《世界是由懒人创造的》</a>（真的是马云分享的吗？），大致意思就是懒人推动了世界的发展。因为懒，才能创造出一堆的发明，来让我们的生活更方便。当然了，文章弥漫着浓浓的调侃氛围。赞赏、批判这篇文章的人都有不少，至于我的观点嘛，想必从本文的标题中也能看出一二。但是请别忘记，原文最后也写了：“要懒出风格，懒出境界”。</p>
<p>在程序员的世界中，偷懒尤其重要。懒得造轮子？网上大把大把的开源库等着你试用。不想稍微改点代码就从头到位测一遍？那就用自动化测试吧。不想每次部署的时候手忙脚乱？那就上持续交付。不想每次总跟客户扯皮？那就搞敏捷，把客户变成团队的一员。不想让开发和运维互斗？那就拥抱DevOps，大家都在一条船上。可以说，“偷懒”是技术进步的原动力。有些人喜欢说“痛点驱动”，其实它们是一回事，因为没法儿偷懒，所以很“痛”啊。程序员们也非常厌恶重复性的劳动，例如填写工时、定期发送邮件、给别人权限、教新人如何配置环境等等等等。</p>
<p>可是光靠偷懒能够解决问题吗？要是你不想做那么无聊的事情，但是又没有解决的办法，如何才能推动世界进步呢？有道是“创新靠懒，实现靠勤”。唯有学习和思考不能偷懒。你有一个工具箱，你懒，那就用工具箱里的工具来让你懒得其所。可如果你的工具箱是空的，你怎么偷懒啊？有些人看上去非常的勤奋，整天忙个不停，似乎非常充实。但是，偶尔夜深失眠的时候，可能内心也会感觉到一阵恐慌吧。因为忙碌占据了他全部的时间，而真正需要的沉淀、思考、总结的时间基本没有。这样的人只是用勤奋来自欺欺人，掩盖自己懒得思考的本质。有个词叫“低品质勤奋者”很好地涵盖了这一类人。我也曾是其中一员，现在还不时会偷懒，但我已经知道了，不要“用身体的勤奋掩盖思想的懒惰”。</p>
<p>偷懒节省出来的时间都上哪儿去了？学习、思考、与家人相伴。偶尔的放纵没什么关系，但是主旋律还是要保持清醒的大脑，经常使其运转，如果大脑平时不怎么动，可能在关键时刻也就转不动了。如何开始恢复大脑的正常运转？从每天给自己留点独处的时间，深度思考一下今天做了什么有意义的事情，怎样还能做得更好开始吧。一定要坚持，无论刮风下雨，生病加班，因为以我自己的经验来看，一旦破例，很容易便会再次破例，从而使曾经的坚持迅速土崩瓦解。但是可以根据当天的状况灵活控制时间。写文章也是一种有效的思考总结的方法，在此也推荐给大家。试试看，只要走出第一步，总能找到一条适合自己的路。</p>
<p>最后让我们来膜拜一下著名的懒程序员们吧。</p>
<ul>
<li>Nihad Abbasov在<a href="https://github.com/NARKOZ/hacker-scripts" target="_blank" rel="external">github</a>上分享了一个项目，里面包含了一堆的脚本，包括加班时给太太发短信、宿醉时给自己请假、根据自己从工位走到咖啡机的用时来煮咖啡……</li>
<li>Etherable在<a href="https://workplace.stackexchange.com/questions/93696/is-it-unethical-for-me-to-not-tell-my-employer-i-ve-automated-my-job" target="_blank" rel="external">StackExchange</a>上表示，他偷偷写了一段程序，使它十分钟就能完成过去一个人月才能完成的工作。而自己每周改改规范、发发邮件什么的只需一两个小时就够了。于是在程序员中掀起了一场道德辩论，究竟应不应该告诉老板？</li>
<li><a href="http://money.163.com/13/0117/08/8LDJ5PPO00252V0H.html" target="_blank" rel="external">美最懒程序员不干活 支付1/5薪水工作全外包中国</a>。这样的懒程序员，虽然不是本文提倡的类型，但也懒出了风格，堪称跨界人才。</li>
<li>阿里的4位程序员，懒得跟大家抢购月饼，写了段js脚本，<a href="https://www.zhihu.com/question/50600301" target="_blank" rel="external">结果</a>大家都知道了……</li>
</ul>
]]></content>
      
        <categories>
            
            <category> idea </category>
            
        </categories>
        
        
        <tags>
            
            <tag> idea </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SSH妙用]]></title>
      <url>/ssh-tricks/</url>
      <content type="html"><![CDATA[<p>最近方才了解到，原来可以通过SSH以配置SOCKS代理的方式，不用开VPN便能够科学上网，于是便搜集了一些SSH的用法，以供未来参考。<br><a id="more"></a></p>
<h2 id="无密码登录"><a href="#无密码登录" class="headerlink" title="无密码登录"></a>无密码登录</h2><p>只要把自己的公钥保存在远程主机上就可以了，如果本机尚未生成公私钥对（可以通过<code>ls ~/.ssh</code>查看是否存在以<code>pub</code>为扩展名的文件），可以通过<code>ssh-keygen</code>生成一个。之后把这个<code>pub</code>文件的内容全部复制到远程主机上的<code>~/.ssh/authorized_keys</code>中就能够实现无密码登录了。复制的过程也可以用以下命令实现：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-copy-id user@remote.host.name</div></pre></td></tr></table></figure></p>
<p>Mac上默认没有<code>ssh-copy-id</code>，可以通过以下命令安装：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install ssh-copy-id</div></pre></td></tr></table></figure></p>
<h2 id="远程执行命令"><a href="#远程执行命令" class="headerlink" title="远程执行命令"></a>远程执行命令</h2><p>配置完无密码登录后，在远程主机上执行命令很简单，只要在最后面加一个字符串即可：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh remote.host.name <span class="string">"hostname"</span></div></pre></td></tr></table></figure></p>
<p>如果命令很长，是个脚本，那就这么搞：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> -e <span class="string">"ls\necho ggg"</span> &gt; cmd.txt</div><div class="line"></div><div class="line">ssh remote.host.name <span class="string">"`cat cmd.txt`"</span></div><div class="line">ssh remote.host.name &lt; cmd.txt</div><div class="line">cat cmd.txt | ssh remote.host.name</div></pre></td></tr></table></figure></p>
<p>下面分享一段调试时查看远程日志的实用代码。如果你不知道自己的请求会被负载均衡到哪台服务器上去，可以试试下面这个ssh到所有服务器上执行<code>tail -F</code>的小脚本（当然也能用<code>cat</code>了）：<br><figure class="highlight sh"><figcaption><span>tail_log</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="built_in">set</span> -e</div><div class="line"></div><div class="line"><span class="keyword">if</span> [ -z <span class="variable">$1</span> ]; <span class="keyword">then</span></div><div class="line">  <span class="built_in">echo</span> <span class="string">"usage: <span class="variable">$(basename $0)</span> [log path] [optional grep message]"</span></div><div class="line">  <span class="built_in">echo</span> <span class="string">"sample: <span class="variable">$(basename $0)</span> /abc/def/application.log* Execption"</span></div><div class="line">  <span class="built_in">exit</span> 1</div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line">log_path=<span class="variable">$1</span></div><div class="line">grep_message=<span class="variable">$&#123;2-"''"&#125;</span></div><div class="line"></div><div class="line">hosts=(</div><div class="line">  <span class="string">"remote1.host.name"</span></div><div class="line">  <span class="string">"remote2.host.name"</span></div><div class="line">  <span class="string">"remote3.host.name"</span></div><div class="line">)</div><div class="line"></div><div class="line">remote_command=<span class="string">"tail -F <span class="variable">$&#123;log_path&#125;</span> | grep --line-buffered <span class="variable">$&#123;grep_message&#125;</span>"</span></div><div class="line"><span class="keyword">for</span> host <span class="keyword">in</span> <span class="string">"<span class="variable">$&#123;hosts[@]&#125;</span>"</span></div><div class="line"><span class="keyword">do</span></div><div class="line">  <span class="built_in">exec</span> <span class="string">"ssh -fo StrictHostKeyChecking=no <span class="variable">$&#123;host&#125;</span> \"<span class="variable">$&#123;remote_command&#125;</span>\" &amp;"</span></div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure></p>
<p>当然看完日志以后，别忘了把ssh的进程杀掉：<br><figure class="highlight sh"><figcaption><span>kill_log</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="built_in">kill</span> -9 $(ps -ef | grep <span class="string">"[s]sh -fo StrictHostKeyChecking=no"</span> | awk <span class="string">'&#123;print $2&#125;'</span>)</div></pre></td></tr></table></figure></p>
<p>稍微解释一下以上的两个参数：</p>
<ul>
<li><code>ssh -f</code>: 让SSH在后台执行，之所以在后面再加一个<code>&amp;</code>，是因为想让所有机器并行来tail日志。</li>
<li><code>ssh -o StrictHostKeyChecking=no</code>: 这样就看不到由于第一次连接或是机器指纹变更而出现的<strong>Are you sure you want to continue connecting (yes/no)?</strong></li>
</ul>
<h2 id="SSH隧道"><a href="#SSH隧道" class="headerlink" title="SSH隧道"></a>SSH隧道</h2><h3 id="配置SOCKS代理"><a href="#配置SOCKS代理" class="headerlink" title="配置SOCKS代理"></a>配置SOCKS代理</h3><p>超级简单：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -D 9999 remote.host.name</div></pre></td></tr></table></figure></p>
<p>这样便可以通过如下系统设置通过远程主机上网了（以mac为例）：<br><img src="/img/mac_proxy.jpg" alt=""></p>
<p>浏览器代理也是一样（以chrome插件SwitchyOmega为例）：<br><img src="/img/switchy_omega.jpg" alt=""></p>
<h3 id="本地端口转发"><a href="#本地端口转发" class="headerlink" title="本地端口转发"></a>本地端口转发</h3><p>如果你想让本地经由remote1访问remote2，可以这么做：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -L 9999:remote2.host.name:80 remote1.host.name</div></pre></td></tr></table></figure></p>
<p><code>-L</code>后面的参数，表示<strong>本地端口:目标主机：目标主机端口</strong>，也就是说，往本地9999端口发出去的请求，会经由remote1传给remote2的80端口。为什么我们会需要这样的东东呢？原因可能有几种：</p>
<ul>
<li>本地访问不了remote2（或remote2的指定端口），但是本地可以访问remote1，并且remote1可以访问remote2。如果公司的网络分为几块，互相之间操作有限制，可能就需要一些remote1作为跳板／堡垒机（bastion）来做这样的脏活儿。</li>
<li>被邪恶的防火墙挡住了去路的时候。</li>
<li>希望能够比较安全的时候。</li>
<li>有时候目标机器由于安全原因或其它原因，某个端口只能开放给自己。这时候就可以将remote1和remote2合而为一。例如，当Java调试所用的5050端口不对外开放时，就可以用以下命令让IDE在localhost的5050端口进行调试：<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -L 5050:localhost:5050 remote.host.name</div></pre></td></tr></table></figure>
</li>
</ul>
<p>中间的localhost是相对remote.host.name而言的，也就是它自己。</p>
<h3 id="远程端口转发"><a href="#远程端口转发" class="headerlink" title="远程端口转发"></a>远程端口转发</h3><p>在你的本地可以连通远程主机remote1和另一台远程主机remote2，而它们俩不能相互访问的情况下，如果你想让remote1能够访问remote2，就可以这么做：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -R 9999:remote2.host.name:80 remote1.host.name</div></pre></td></tr></table></figure></p>
<p>这样的话，remote1的本地用户便可以便可以通过你的9999端口，访问remote2的80端口了。相当于你把自己变成了一台堡垒机！如果你有权限在其它机器上运行远程端口转发的命令，那你也可以把它变成堡垒机，把你自己的客户机变成remote1了。</p>
<h2 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h2><p>SSH当然是可以用来复制文件的：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat file | ssh -e none remote-host <span class="string">"cat &gt; file"</span></div></pre></td></tr></table></figure></p>
<p>其中的参数<code>-e none</code>，表示不转义任何字符。SSH默认会通过<code>~</code>来转义一些控制语句。</p>
<p>但是既然我们有<code>scp</code>，还用<code>ssh</code>图个什么，用专业工具吧。</p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>可以用<a href="https://github.com/libfuse/sshfs" target="_blank" rel="external">sshfs</a>来将远程的文件系统通过SFTP加载到本地。对于mac而言，可以用<a href="https://osxfuse.github.io/" target="_blank" rel="external">FUSE for macOS</a>来实现。我还没有那样的需求，没试过，据说比较简单。有兴趣的读者可以自行尝试。</p>
<h2 id="其它环境"><a href="#其它环境" class="headerlink" title="其它环境"></a>其它环境</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>Windows的话，你可以就得试试<a href="http://www.putty.org/" target="_blank" rel="external">Putty</a>了。</p>
<h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><p>用手机和平板来运维？你值得拥有！<br><a href="https://juicessh.com/" target="_blank" rel="external">JuiceSSH</a>的基本功能时免费的，但是要想端口转发什么的就得收费了。用户体验很不错。<br><a href="https://play.google.com/store/apps/details?id=org.connectbot" target="_blank" rel="external">ConnectBot</a>是完全免费的。</p>
<h3 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h3><p><a href="https://itunes.apple.com/us/app/prompt-2/id917437289?mt=8" target="_blank" rel="external">Prompt</a>都说好，收费。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://matt.might.net/articles/ssh-hacks/" target="_blank" rel="external">SSH: More than secure shell</a><br><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html" target="_blank" rel="external">SSH原理与运用（二）：远程操作与端口转发</a><br><a href="https://blog.urfix.com/25-ssh-commands-tricks/" target="_blank" rel="external">25 Best SSH Commands / Tricks</a></p>
]]></content>
      
        <categories>
            
            <category> tool </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ssh </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用Tampermonkey实现自动化网页操作]]></title>
      <url>/tampermonkey/</url>
      <content type="html"><![CDATA[<p><a href="http://tampermonkey.net/" target="_blank" rel="external">Tampermonkey</a>是一个<a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo?hl=en" target="_blank" rel="external">浏览器插件</a>，可以在网页上嵌入自己编写的js脚本，支持除IE以外的大部分浏览器。还有一个更早的<a href="https://en.wikipedia.org/wiki/Greasemonkey" target="_blank" rel="external">Greasemonkey</a>（油猴）功能类似，可惜它只适用于<a href="https://addons.mozilla.org/en-US/firefox/addon/greasemonkey/" target="_blank" rel="external">Firefox</a>。Tampermonkey的源代码在<a href="https://github.com/Tampermonkey/tampermonkey" target="_blank" rel="external">Github</a>上。<br><a id="more"></a></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>原理其实很简单，就是在宿主页面载入完毕后，运行自己的js脚本罢了，从而实现对浏览器渲染后的html进行改变。除了让你浏览的网页更加个性化以外，还能为你提供一键解决实际问题的需求，例如隐藏广告、自动签到薅羊毛、抢票、每天/每周在网页上填写考勤表等。</p>
<p>Tampermonkey不仅允许使用这些脚本，并且可以编写、管理及同步。安装步骤与一般的插件无异。安装好后，下面拿一个例子练手。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>我们试试在<a href="https://www.baidu.com/" target="_blank" rel="external">百度</a>上增加“Google一下”的按钮。首先单击插件图标，点击“添加新脚本”，于是便进入了Tampermonkey的编辑器。上面的几行注释就是Tampermonkey自己的语法，保存了一些元数据，包括脚本的名字、版本、在满足什么规则的网页上生效等。我们把<code>@match</code>的内容修改为<code>https://www.baidu.com/*</code>，这样便能在百度域名下的所有网页中生效啦。</p>
<p>打开百度，可以看到“百度一下”的按钮：<code>id=&quot;su&quot;</code>，我们将“Google一下”插入到其后即可。在<code>// Your code here...</code>后面编写如下js代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'#su'</span>).after(<span class="string">'&lt;input type="button" id="google" value="Google一下" class="btn self-btn bg s_btn" style="background-color:grey;" onclick="googleIt" /&gt;'</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">googleIt</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="string">'google'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>保存并刷新百度，顺利地看到了灰色的“Google一下”。这说明我们的脚本起作用了。在插件图标的位置上页显示了一个红色的<code>1</code>，说明当前网页上的生效脚本数量为1。但是点击“Google一下”什么也没有弹出。在控制台上可以看到出错了：<strong>Uncaught ReferenceError: googleIt is not defined</strong>。这是因为所有代码都是<a href="https://stackoverflow.com/questions/16704209/onclick-added-with-tampermonkey-is-not-calling-the-function" target="_blank" rel="external">作为一个字符串被<code>eval</code></a>的，所以应该使用动态的方式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'#su'</span>).after(<span class="string">'&lt;input type="button" id="google" value="Google一下" class="btn self-btn bg s_btn" style="background-color:grey;" /&gt;'</span>);</div><div class="line">$(<span class="string">"#google"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    googleIt();</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这回点击按钮就能够正常工作了！我们现在要做的，就是把<code>alert</code>替换为打开Google页面即可：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">googleIt</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> searchText = <span class="built_in">document</span>.querySelector(<span class="string">'#kw'</span>).value;</div><div class="line">    location.href = getGoogleUrl(searchText);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGoogleUrl</span>(<span class="params">searchText</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'https://www.google.com/search?q='</span> + searchText;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>短短几行代码，就搞定了。Tampermonkey内置了一些对象与函数，可以让我们很方便地实现一些功能，如打开新窗口可以使用<code>GM_openInTab</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">googleIt</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> searchText = <span class="built_in">document</span>.querySelector(<span class="string">'#kw'</span>).value;</div><div class="line">    GM_openInTab(getGoogleUrl(searchText), <span class="literal">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第二个参数可以决定当前的焦点是老窗口还是新窗口。在使用内置函数之前，需要先<code>@grant</code>一下，如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// @grant        GM_openInTab</span></div></pre></td></tr></table></figure></p>
<p>否则无法生效。更多的内置函数可以在<a href="http://tampermonkey.net/documentation.php" target="_blank" rel="external">官方文档</a>中查看。</p>
<p>我们新写的代码并不会直接出现在控制台中，如果需要调试，可以在代码中增加<code>debugger;</code>，这样运行时就能自动停在这一行了。百度主页有引用jQuery，所以我们可以直接在代码中使用<code>$</code>。如果需要的页面上没有jQuery，那么可以通过这行命令引入：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//      @include https://code.jquery.com/jquery-3.2.1.min.js</span></div></pre></td></tr></table></figure></p>
<p>完整的代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ==UserScript==</span></div><div class="line"><span class="comment">// @name         Google on baidu</span></div><div class="line"><span class="comment">// @namespace    http://tampermonkey.net/</span></div><div class="line"><span class="comment">// @version      0.1</span></div><div class="line"><span class="comment">// @description  Google it!</span></div><div class="line"><span class="comment">// @author       ggg</span></div><div class="line"><span class="comment">// @match        https://www.baidu.com/*</span></div><div class="line"><span class="comment">// @grant        GM_openInTab</span></div><div class="line"><span class="comment">// ==/UserScript==</span></div><div class="line"></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="meta">    'use strict'</span>;</div><div class="line"></div><div class="line">    $(<span class="string">'#su'</span>).after(<span class="string">'&lt;input type="button" id="google" value="Google一下" class="btn self-btn bg s_btn" style="background-color:grey;" /&gt;'</span>);</div><div class="line">    $(<span class="string">"#google"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        googleIt();</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">googleIt</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> searchText = $(<span class="string">'#kw'</span>).val();</div><div class="line">        GM_openInTab(getGoogleUrl(searchText), <span class="literal">false</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getGoogleUrl</span>(<span class="params">searchText</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'https://www.google.com/search?q='</span> + searchText;</div><div class="line">    &#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p>不过这种做法存在两个问题：</p>
<ol>
<li>如果宿主网页变化，脚本需要随之变化。这也没办法，谁叫我们依赖它呢。好在宿主网页没事也不会经常变化。</li>
<li>“Google一下”的按钮会比原生的“百度一下”延迟一些才出来，体验上稍微差一些。毕竟相对而言我们的脚本只是二等公民。</li>
</ol>
<p>但是获益的巨大几乎可以让我们完全无视这些缺陷。</p>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>脚本也是代码，也有自己的版本，也能被多人所共享使用。只要它在因特网上的url以<code>.user.js</code>结尾，即可轻易分享给其他人。上面的这个例子我就放到了<a href="https://github.com/qinghua/tamperMonkeyScript/raw/master/googleit.user.js" target="_blank" rel="external">Github</a>中。分享出去的时候，如果对方安装了tampermonkey，就可以看到脚本的安装界面了。更多的共享脚本可以单击插件图标，点击“获取新脚本”，或是参考<a href="https://tampermonkey.net/scripts.php" target="_blank" rel="external">这里</a>来获得。</p>
]]></content>
      
        <categories>
            
            <category> development </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tampermonkey </tag>
            
            <tag> js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[代码还是数据]]></title>
      <url>/code-or-data/</url>
      <content type="html"><![CDATA[<p>这段逻辑是代码还是数据，对我来说从来都不曾是个问题，直到遇上了这么一个项目。<br><a id="more"></a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>一般来说，我们写程序，都是连同测试代码一起提交，至少也是一起代码审查。有一个关于收费的项目，偏偏反其道而行之。这个项目的一些背景如下：</p>
<ol>
<li>收费的逻辑通过DSL配置在代码库中。</li>
<li>对于这些逻辑，没有单元测试，但是有集成测试。</li>
<li>集成测试里面包含了request与response，在测试的时候回放request并比较response是否匹配。</li>
<li>集成测试是json文件，放在S3上。</li>
</ol>
<p>如果有一个对费率的修改，那么程序员除了往代码库中提交修改后的DSL，还会往S3更新json测试文件。这就带来了几个问题：</p>
<ul>
<li>代码审查者只能看到代码库的变动，除非再去S3上看测试数据，不然并不知道这段DSL的测试情况。而在S3上看测试数据相对比较繁琐，这样的机制可以说是鼓励代码审查者不去看测试数据。</li>
<li>没有版本管理（或者说由于S3与代码库的版本管理机制差别较大），导致这些测试不容易追踪，也不容易查看历史记录。</li>
<li>持续集成通过与否依赖于S3的数据。所以集成测试失败时，不一定能在解决时复原到失败时的状态。</li>
<li>DEV提交代码和更新测试数据这两步变成了一个原子操作，需要一起完成，至少在代码提交后、CI上运行集成测试之前更新S3。而在提交代码前更新S3又有破坏别人正在运行测试的风险。</li>
</ul>
<p>那么，为什么这个项目会选用这样的方案呢？原来，在设计的时候是这么考虑的：费率修改的需求来自于产品经理，希望测试数据能够由PM们提供。所以将会开发一个面向PM们的小系统，后台就是这个S3数据，这样的话到时候修改费率，就增加了一层来自需求方的保障。如果测试数据来自于代码库，那就很难通过页面来修改并提交代码库了。初衷还是不错的，但是仔细推敲下来，DEV自己的测试哪儿去了？这样运转起来后，是不是只会养成DEV把测试推给PM的习惯？</p>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>我觉得这里面有一个误区，就是把DEV自己的测试和PM的测试混为一谈了。实际上应该将它们分开来。为什么呢？DEV自己的测试其实本来就应该是代码的一部分，应该保存在代码库中。而PM的测试其实是对程序员测试的补充，也应该算是代码的一部分，如果能够放在代码库中固然是好，但是我们也不能对所有的PM们都抱有提交代码这样不切实际的期望，所以在这种情况下，S3算是一个权衡的方案。而CI上应该有两步，其一是DEV的测试，其二是PM的测试（在PM修改测试数据的小系统还没上线之前，可以暂不配置这个测试）。它们之间是顺序执行还是并发执行倒是无关紧要。但这样也有不尽如人意的地方：</p>
<ul>
<li>修改代码需要DEV和PM同时协作，最好一起修改，否则CI会红。但这正是DevOps运动所提倡的，不是么？</li>
<li>背景一节介绍的一些缺点在PM的测试中仍然存在。PM修改测试数据的小系统需要更加完善的版本管理和审计。这部分的开销可能还不小。</li>
</ul>
<p>顺便提一句，传统的PM测试数据是由DEV提供一个CSV格式，让PM填完之后由DEV添加到代码库中。在忽略DEV和PM的用户体验的情况下，这也是一个可行的方案。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到底什么样的逻辑应该进代码库，什么样的逻辑应该持久化呢？其实我们应该把逻辑区分为程序、配置和数据。</p>
<p>程序：<br>在代码库中，提供服务的主要功能。对其的修改通常都是改bug或是引入新功能。</p>
<p>配置：<br>在配置服务器中，但是配置的默认值很可能是在代码库中。经常需要修改，修改其值可以让程序表现出不同的处理逻辑。需要易于修改。</p>
<p>数据：<br>在持久化存储（一般是数据库）中，因用户而异，数量可能会比较大。随用户的操作而变化。需要有备份机制。</p>
<p>反推到上文所说：“收费的逻辑通过DSL配置在代码库中”。这段逻辑，也许应该是配置而非程序，因为它会经常需要修改。收费记录毋庸置疑，一定是数据了。从逻辑分类的角度上出发，你是否会发现其实自己现在的代码库中包含了太多的配置？</p>
<p>另外，虽然代码库似乎也可以用于配置或数据，但是最好还是别这么干，这里有一篇<a href="https://stackoverflow.com/questions/20151158/using-git-repository-as-a-database-backend" target="_blank" rel="external">stack overflow的问答</a>，解释得挺清楚的。</p>
]]></content>
      
        <categories>
            
            <category> idea </category>
            
        </categories>
        
        
        <tags>
            
            <tag> soft skill </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用JGit生成patch文件]]></title>
      <url>/git-patch/</url>
      <content type="html"><![CDATA[<p>上篇博文介绍了<a href="/jgit">JGit</a>，之后就开始做项目了。遇到的第一个问题是如何用JGit生成patch文件。<br><a id="more"></a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我希望在项目中能够实现这样的功能：用户发送一个request，服务器就帮用户生成代码并生成一个commit到用户本地的git中，但是这不太可能，因为用户的环境并不是服务器的环境。进一步的方案是直接在服务器端clone git仓库（或是维持一份最新代码），服务器本地生成commit并push，这样做会有一些安全方面需要考虑的因素。我采用的是退一步的方案，即让服务器生成一个patch文件并上传到<a href="https://aws.amazon.com/s3/" target="_blank" rel="external">S3</a>，以便用户稍后下载并apply到本地。</p>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><h3 id="api-command"><a href="#api-command" class="headerlink" title="api command"></a>api command</h3><p>打开JGit的<a href="https://github.com/eclipse/jgit/tree/master/org.eclipse.jgit/src/org/eclipse/jgit/api" target="_blank" rel="external">api包</a>一看，各种git命令应有尽有，如apply、cherry-pick等。但惟独没有format-patch命令。网上一搜，甚少有人有这样的需求或问题，只有<a href="http://www.codeaffine.com/2016/06/16/jgit-diff/" target="_blank" rel="external">这篇文章</a>比较靠谱，但是它介绍的侧重于diff而非生成patch。</p>
<h3 id="Patch"><a href="#Patch" class="headerlink" title="Patch"></a>Patch</h3><p>还是得找找patch相关的代码。源代码搜遍也就这个<a href="https://github.com/eclipse/jgit/blob/master/org.eclipse.jgit/src/org/eclipse/jgit/patch/Patch.java" target="_blank" rel="external">Patch.java</a>应该是patch文件的JGit模型，但是读完后发现，它只能把patch文件映射成这个模型，并不能反向从模型序列化为patch文件。</p>
<h3 id="DiffFormatter-DiffEntry"><a href="#DiffFormatter-DiffEntry" class="headerlink" title="DiffFormatter / DiffEntry"></a>DiffFormatter / DiffEntry</h3><p>DiffCommand其实上还是调用的DiffFormatter和DiffEntry，所以看看这俩是否能够支持什么样的参数，来生成patch文件呢？可惜还是无果。DiffFormatter的API也不太直观，不容易理解。但是它能够做一些diff commit这样的事情。</p>
<h3 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h3><p>走投无路之际，在<a href="https://git-scm.com/docs/git-format-patch" target="_blank" rel="external">git-format-patch</a>上看到，这个命令其实是用来生成<strong>用邮件发送</strong>的patch文件。难怪patch文件的前几行看起来有From，有Subject什么的，也许它们不是必须的？那就可以试试把diff的结果当作patch直接写入文件。</p>
<h2 id="动手时间"><a href="#动手时间" class="headerlink" title="动手时间"></a>动手时间</h2><p>首先创建一个git环境，a、b、c三个文件用来测试改删增：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">mkdir -p /tmp/ggg</div><div class="line"><span class="built_in">cd</span> /tmp/ggg</div><div class="line">git init</div><div class="line"><span class="built_in">echo</span> line a1 &gt; a.txt</div><div class="line"><span class="built_in">echo</span> line a2 &gt;&gt; a.txt</div><div class="line"><span class="built_in">echo</span> line b1 &gt; b.txt</div><div class="line">git add .</div><div class="line">git commit -m <span class="string">"first commit wiht a.txt and b.txt"</span></div><div class="line"><span class="built_in">echo</span> line a3 &gt;&gt; a.txt</div><div class="line"><span class="built_in">echo</span> line c1 &gt; c.txt</div><div class="line">rm b.txt</div><div class="line">git diff</div></pre></td></tr></table></figure></p>
<p>运行完成后就能看到diff文件的内容了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">diff --git a/a.txt b/a.txt</div><div class="line">index 7a3d45f..c723fac 100644</div><div class="line">--- a/a.txt</div><div class="line">+++ b/a.txt</div><div class="line">@@ -1,2 +1,3 @@</div><div class="line"> line a1</div><div class="line"> line a2</div><div class="line">+line a3</div><div class="line">diff --git a/b.txt b/b.txt</div><div class="line">deleted file mode 100644</div><div class="line">index b45d9fa..0000000</div><div class="line">--- a/b.txt</div><div class="line">+++ /dev/null</div><div class="line">@@ -1 +0,0 @@</div><div class="line">-line b1</div></pre></td></tr></table></figure></p>
<p>在程序中，如此这般运行git diff命令：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Git git = Git.init().setDirectory(<span class="keyword">new</span> File(<span class="string">"/tmp/ggg"</span>)).call();</div><div class="line">git.diff().setOutputStream(System.out).call();</div></pre></td></tr></table></figure></p>
<p>发现JGit的diff和Git的diff还是不太一样的。JGit的diff包含了新增文件的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">diff --git a/a.txt b/a.txt</div><div class="line">index 7a3d45f..c723fac 100644</div><div class="line">--- a/a.txt</div><div class="line">+++ b/a.txt</div><div class="line">@@ -1,2 +1,3 @@</div><div class="line"> line a1</div><div class="line"> line a2</div><div class="line">+line a3</div><div class="line">diff --git a/b.txt b/b.txt</div><div class="line">deleted file mode 100644</div><div class="line">index b45d9fa..0000000</div><div class="line">--- a/b.txt</div><div class="line">+++ /dev/null</div><div class="line">@@ -1 +0,0 @@</div><div class="line">-line b1</div><div class="line">diff --git a/c.txt b/c.txt</div><div class="line">new file mode 100644</div><div class="line">index 0000000..8e37e08</div><div class="line">--- /dev/null</div><div class="line">+++ b/c.txt</div><div class="line">@@ -0,0 +1 @@</div><div class="line">+line c1</div></pre></td></tr></table></figure></p>
<p>这就非常合适了。只要证明它能够被作为patch导入到git中即可。首先修改代码输出到文件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">File patch = <span class="keyword">new</span> File(<span class="string">"/tmp/jgit.patch"</span>);</div><div class="line">Git git = Git.init().setDirectory(<span class="keyword">new</span> File(<span class="string">"/tmp/ggg"</span>)).call();</div><div class="line"><span class="keyword">try</span> (OutputStream outputStream = <span class="keyword">new</span> FileOutputStream(patch)) &#123;</div><div class="line">    git.diff().setOutputStream(outputStream).call();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后清空修改过的文件：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /tmp/ggg</div><div class="line">git checkout .</div><div class="line">git clean -df</div><div class="line">git status</div></pre></td></tr></table></figure></p>
<p>现在尝试apply patch：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git apply /tmp/jgit.patch</div><div class="line">git status</div></pre></td></tr></table></figure></p>
<p>果然成功了。在不考虑冲突的情况下，看起来这一招还是管用的。但是由于缺失了commit的信息，所以运行<code>git am /tmp/jgit.patch</code>就会报错：<em>Patch format detection failed.</em>有没有办法解决这个问题呢？当然了。我们现在知道了patch只不过是多了一些邮件信息罢了，那我们自己就可以生成。在<code>try</code>内增加如下代码，模拟<code>git format-patch</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">    outputStream.write(<span class="string">"From: GGG &lt;ggg@somewhere.com&gt;\n"</span>.getBytes());</div><div class="line">    outputStream.write(<span class="string">"Date: Tue, 12 Sep 2017 20:16:10 +0800\n"</span>.getBytes());</div><div class="line">    outputStream.write(<span class="string">"Subject: [PATCH] ggg is not here. Turn left and ask JGit\n"</span>.getBytes());</div><div class="line">    outputStream.write(<span class="string">"\n---\n\n"</span>.getBytes());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行一下，然后尝试使用<code>git am</code>：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git am /tmp/jgit.patch</div><div class="line">git <span class="built_in">log</span></div><div class="line">git show HEAD</div></pre></td></tr></table></figure></p>
<p>果然可以直接生成commit。Mission Complete!</p>
<h2 id="patch-amp-diff"><a href="#patch-amp-diff" class="headerlink" title="patch &amp; diff"></a>patch &amp; diff</h2><p>其实Linux已经提供了一个<code>patch</code>命令，无需git即可直接应用patch文件：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git reset HEAD^ --hard</div><div class="line">ls</div><div class="line">patch &lt; /tmp/jgit.patch</div></pre></td></tr></table></figure></p>
<p>而且还支持回滚（git apply也支持）：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">patch -R &lt; /tmp/jgit.patch</div><div class="line">ls</div></pre></td></tr></table></figure></p>
<p>实际上patch文件一般是使用<code>diff</code>命令来生成的：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">diff -u a.txt c.txt &gt; diff.patch</div><div class="line">cat diff.patch</div></pre></td></tr></table></figure></p>
<p>这两个命令网上的教程不少，有兴趣的话可以自行搜索阅读。最后还是把环境恢复：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rm -rf /tmp/ggg /tmp/jgit.patch</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> development </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JGit </tag>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用JGit通过Java来操作Git]]></title>
      <url>/jgit/</url>
      <content type="html"><![CDATA[<p><a href="https://eclipse.org/jgit/" target="_blank" rel="external">JGit</a>是一个由<a href="https://www.eclipse.org/org/" target="_blank" rel="external">Eclipse基金会</a>开发、用于操作git的纯Java库。它本身也是Eclispe的一部分，实际上Eclipse的插件<a href="http://www.eclipse.org/egit/" target="_blank" rel="external">EGit</a>便是基于JGit的。如果你像我这样有使用代码来操作git的需求，那就准备好拥抱JGit吧。目前来看别的竞品没它靠谱。<br><a id="more"></a></p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>从用户指南的<a href="http://wiki.eclipse.org/JGit/User_Guide#Concepts" target="_blank" rel="external">概念</a>一节中可以看到，JGit的基本概念如下：</p>
<ul>
<li>Git对象（Git Objects）：就是git的对象。它们在git中用SHA-1来表示。在JGit中用<code>AnyObjectId</code>和<code>ObjectId</code>表示。而它又包含了四种类型：<ol>
<li>二进制大对象（blob）：文件数据</li>
<li>树（tree）：指向其它的tree和blob</li>
<li>提交（commit）：指向某一棵tree</li>
<li>标签（tag）：把一个commit标记为一个标签</li>
</ol>
</li>
<li>引用（Ref）：对某一个git对象的引用。</li>
<li>仓库（Repository）：顾名思义，就是用于存储所有git对象和Ref的仓库。</li>
<li>RevWalk：该类用于从commit的关系图（graph）中遍历commit。晦涩难懂？看到范例就清楚了。</li>
<li>RevCommit：表示一个git的commit</li>
<li>RevTag：表示一个git的tag</li>
<li>RevTree：表示一个git的tree</li>
<li>TreeWalk：类似RevWalk，但是用于遍历一棵tree</li>
</ul>
<h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><p>让我们从一个最典型的用例开始吧。首先在<code>/tmp/jgit/repo</code>中创建一个git仓库：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mkdir -p /tmp/jgit/repo</div><div class="line">cd /tmp/jgit/repo</div><div class="line">git init --bare</div></pre></td></tr></table></figure></p>
<p>再创建一个clone该仓库的客户端：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd /tmp/jgit/</div><div class="line">git clone repo client</div><div class="line">cd client</div></pre></td></tr></table></figure></p>
<p>输入<code>git status</code>应该能够看到<strong>Initial commit</strong>，这样环境就没有问题了。然后提交一个文件，给仓库里来点库存：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">echo hello &gt; hello.txt</div><div class="line">git add hello.txt</div><div class="line">git commit -m "hello"</div><div class="line">git push</div></pre></td></tr></table></figure></p>
<h2 id="动手"><a href="#动手" class="headerlink" title="动手"></a>动手</h2><h3 id="获取仓库"><a href="#获取仓库" class="headerlink" title="获取仓库"></a>获取仓库</h3><p>动手时间。新建Maven工程，往pom.xml中增加dependency，最后的pom.xml看起来就像这样：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></div><div class="line">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.ggg.jgit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>helloJgit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jgit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>org.eclipse.jgit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.8.0.201706111038-r<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>让我们先尝试clone一下这个仓库。因为client分为已经存在以及重新clone的两种，所以我们在src/main/java中新增一个<code>RepositoryProvider</code>接口，用两种不同实现以示区分：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RepositoryProvider</span> </span>&#123;</div><div class="line">    <span class="function">Repository <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>并实现之：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RepositoryProviderCloneImpl</span> <span class="keyword">implements</span> <span class="title">RepositoryProvider</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String repoPath;</div><div class="line">    <span class="keyword">private</span> String clientPath;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RepositoryProviderCloneImpl</span><span class="params">(String repoPath, String clientPath)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.repoPath = repoPath;</div><div class="line">        <span class="keyword">this</span>.clientPath = clientPath;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Repository <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        File client = <span class="keyword">new</span> File(clientPath);</div><div class="line">        client.mkdir();</div><div class="line"></div><div class="line">        <span class="keyword">try</span> (Git result = Git.cloneRepository()</div><div class="line">                .setURI(repoPath)</div><div class="line">                .setDirectory(client)</div><div class="line">                .call()) &#123;</div><div class="line">            <span class="keyword">return</span> result.getRepository();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>新增一个<code>HelloJGit</code>主程序类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloJGit</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RepositoryProvider repoProvider = <span class="keyword">new</span> RepositoryProviderCloneImpl(<span class="string">"/tmp/jgit/repo"</span>, <span class="string">"/tmp/jgit/clientJava"</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">try</span> (Git git = <span class="keyword">new</span> Git(repoProvider.get())) &#123;</div><div class="line">            git.pull().call();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>直接运行<code>HelloJGit</code>的<code>main</code>函数，<code>ls /tmp/jgit/</code>应该就能看到新clone出来的<code>clientJava</code>文件夹了。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd /tmp/jgit/clientJava</div><div class="line">ls</div><div class="line">git status</div></pre></td></tr></table></figure></p>
<p>我们当然不希望总是在使用的时候才重新clone一个仓库，因为当仓库很大的时候可能会非常耗时。让我们在<code>client</code>中再提交一个commit：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">echo hello2 &gt; hello2.txt</div><div class="line">git add hello2.txt</div><div class="line">git commit -m "hello again"</div><div class="line">git push</div></pre></td></tr></table></figure></p>
<p>然后尝试直接从刚刚clone下来的clientJava中创建Repository：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RepositoryProviderExistingClientImpl</span> <span class="keyword">implements</span> <span class="title">RepositoryProvider</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String clientPath;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RepositoryProviderExistingClientImpl</span><span class="params">(String clientPath)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.clientPath = clientPath;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Repository <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">try</span> (Repository repo = <span class="keyword">new</span> FileRepository(clientPath)) &#123;</div><div class="line">            <span class="keyword">return</span> repo;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后把<code>HelloJGit</code>的<code>repoProvider</code>实例替换为<code>RepositoryProviderExistingClientImpl</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> RepositoryProvider repoProvider = <span class="keyword">new</span> RepositoryProviderExistingClientImpl(<span class="string">"/tmp/jgit/clientJava/.git"</span>);</div></pre></td></tr></table></figure></p>
<p>注意这次的路径中需要加上<code>.git</code>才行。再次运行<code>HelloJGit</code>的<code>main</code>函数，便可以通过<code>ls /tmp/jgit/clientJava</code>看到新提交的<code>hello2.txt</code>文件了。</p>
<h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><p>接下来尝试<code>git add</code>、<code>git commit</code>和<code>git push</code>这几个最常用的命令。让我们往<code>clientJava</code>中添加一个<code>hello3.txt</code>文件并提交。如下修改<code>HelloJGit</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="keyword">try</span> (Repository repo = repoProvider.get();</div><div class="line">         Git git = <span class="keyword">new</span> Git(repo)) &#123;</div><div class="line">        createFileFromGitRoot(repo, <span class="string">"hello3.txt"</span>, <span class="string">"hello3"</span>);</div><div class="line">        git.add()</div><div class="line">                .addFilepattern(<span class="string">"hello3.txt"</span>)</div><div class="line">                .call();</div><div class="line"></div><div class="line">        git.commit()</div><div class="line">                .setMessage(<span class="string">"hello3"</span>)</div><div class="line">                .call();</div><div class="line"></div><div class="line">        git.push()</div><div class="line">                .call();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createFileFromGitRoot</span><span class="params">(Repository repo, String filename, String content)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</div><div class="line">    File hello3 = <span class="keyword">new</span> File(repo.getDirectory().getParent(), filename);</div><div class="line">    <span class="keyword">try</span> (PrintWriter out = <span class="keyword">new</span> PrintWriter(hello3)) &#123;</div><div class="line">        out.println(content);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>虽然操作多了，但是有了<code>Repository</code>和<code>Git</code>对象之后，看起来它们的实现都非常直观。运行<code>main</code>函数之后，可以到<code>client</code>文件夹中校验一下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cd /tmp/jgit/client</div><div class="line">git pull</div><div class="line">cat hello3.txt</div><div class="line">git log</div></pre></td></tr></table></figure></p>
<p>在我的机器上运行<code>git log</code>，可以得到：<strong>commit 7841b8b80a77918f2ec45bcedb934e2723b16b5c (HEAD -&gt; master, origin/master)</strong>，以及另外两个commit。有兴趣的读者们可以自行尝试其它的git命令。</p>
<h3 id="其它对象"><a href="#其它对象" class="headerlink" title="其它对象"></a>其它对象</h3><p>虽然上面两小节的内容对于普通需求来说已经大致上够用了，但是在<a href="/jgit/#概念">概念一节</a>中介绍到的其它概念，如Git对象、引用等还没有出场呢。我们再新建一个<code>WalkJGit</code>的类，在<code>main</code>函数中编写如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> (Repository repo = repoProvider.get()) &#123;</div><div class="line">    Ref ref = repo.getAllRefs().get(Constants.HEAD);</div><div class="line">    ObjectId objectId = ref.getObjectId();</div><div class="line">    System.out.println(objectId);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这回，<code>Ref</code>和<code>ObjectId</code>都出现了。在我的机器上，运行以上程序打印出来了<strong>AnyObjectId[7841b8b80a77918f2ec45bcedb934e2723b16b5c]</strong>。我们可以看到，取得<code>HEAD</code>的<code>Ref</code>，其<code>ObjectId</code>其实就是在<code>client</code>文件夹中运行<code>git log</code>之后结果。除了<code>HEAD</code>以外，<code>repo.getAllRefs()</code>返回的<code>Map</code>实例中还有<code>refs/heads/master</code>和<code>refs/remotes/origin/master</code>，在目前的情况下，它们的<code>ObjectId</code>完全相同。那么如何获取其它的commit呢？那就是<code>RevWalk</code>出场的时候。把<code>main</code>函数中的内容替换为如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> (Repository repo = repoProvider.get()) &#123;</div><div class="line">    Ref ref = repo.getAllRefs().get(Constants.HEAD);</div><div class="line"></div><div class="line">    <span class="keyword">try</span> (RevWalk revWalk = <span class="keyword">new</span> RevWalk(repo)) &#123;</div><div class="line">        RevCommit lastCommit = revWalk.parseCommit(ref.getObjectId());</div><div class="line">        revWalk.markStart(lastCommit);</div><div class="line">        revWalk.forEach(System.out::println);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到<code>RevWalk</code>本身是实现了<code>Iterable</code>接口的。通过对该对象进行循环，就可以获取所有的commit的<code>RevCommit</code>对象。可以到<code>client</code>文件夹确认一下，这些SHA-1字符串应该跟刚才<code>git log</code>命令的结果相同。<code>RevCommit</code>对象本身含有这个commit的所有信息，所以可以如下打印出来：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">revWalk.forEach(c -&gt; &#123;</div><div class="line">    System.out.println(<span class="string">"commit "</span> + c.getName());</div><div class="line">    System.out.printf(<span class="string">"Author: %s &lt;%s&gt;\n"</span>, c.getAuthorIdent().getName(), c.getAuthorIdent().getEmailAddress());</div><div class="line">    System.out.println(<span class="string">"Date: "</span> + LocalDateTime.ofEpochSecond(c.getCommitTime(), <span class="number">0</span>, ZoneOffset.UTC));</div><div class="line">    System.out.println(<span class="string">"\t"</span> + c.getShortMessage() + <span class="string">"\n"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这样看起来是不是很有<code>git log</code>的感觉呢？需要注意的是，<code>RevWalk</code>线程不安全，并且像<code>Stream</code>那样，只能使用一次。<a href="https://github.com/eclipse/jgit/blob/master/org.eclipse.jgit/src/org/eclipse/jgit/revwalk/RevWalk.java#L77" target="_blank" rel="external">如果想要再来一次</a>，就需要重新创建<code>RevWalk</code>对象或是调用其<code>reset</code>方法（还得重新<code>markStart</code>！）。</p>
<p>要想看到每个commit中有什么内容，那就需要用到<code>TreeWalk</code>了，它的思路和<code>RevWalk</code>类似。尝试如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (RevCommit commit : revWalk) &#123;</div><div class="line">    System.out.println(<span class="string">"\ncommit: "</span> + commit.getName());</div><div class="line">    <span class="keyword">try</span> (TreeWalk treeWalk = <span class="keyword">new</span> TreeWalk(repo)) &#123;</div><div class="line">        treeWalk.addTree(commit.getTree());</div><div class="line">        treeWalk.setRecursive(<span class="keyword">true</span>);</div><div class="line">        <span class="keyword">while</span> (treeWalk.next()) &#123;</div><div class="line">            System.out.println(<span class="string">"filename: "</span> + treeWalk.getPathString());</div><div class="line">            ObjectId objectId = treeWalk.getObjectId(<span class="number">0</span>);</div><div class="line">            ObjectLoader loader = repo.open(objectId);</div><div class="line">            loader.copyTo(System.out);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样便可以显示仓库在每个commit时候的状态了。如果需要diff，那么还将需要用到<code>DiffEntry</code>等类，本文就不再赘述了，有兴趣的读者可以参考<a href="https://github.com/centic9/jgit-cookbook/blob/master/src/main/java/org/dstadler/jgit/porcelain/ShowChangedFilesBetweenCommits.java" target="_blank" rel="external">这个类</a>。</p>
<p>最后将环境还原：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rm -rf /tmp/jgit</div></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/centic9/jgit-cookbook" target="_blank" rel="external">这个代码库</a>里有很全面的、基本可以直接用于生产环境的范例。<br><a href="https://github.com/eclipse/jgit" target="_blank" rel="external">JGit的源码</a>和<a href="http://wiki.eclipse.org/JGit/User_Guide" target="_blank" rel="external">用户指南</a>。</p>
]]></content>
      
        <categories>
            
            <category> development </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JGit </tag>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《智能时代》读后感]]></title>
      <url>/intelligence-age-book-review/</url>
      <content type="html"><![CDATA[<p>上个月刚刚读完吴军的<a href="https://book.douban.com/subject/26838557/" target="_blank" rel="external">《智能时代》</a>，本文总结并记录一些笔记及感想。<br><a id="more"></a></p>
<h2 id="数据、信息、知识和智能"><a href="#数据、信息、知识和智能" class="headerlink" title="数据、信息、知识和智能"></a>数据、信息、知识和智能</h2><p>在谈论数据时，人们经常将其与信息相混淆。其实信息来源于数据，但是并非所有的数据都承载着有用的信息。例如，对于<code>dd if=/dev/zero of=ggg.txt bs=1k count=10000</code>这样的一个10M文件来说，里面的每一个bit都为0，所以并不能提供什么有意义的信息。而且，无意义和伪造的数据都会干扰和影响我们。通过对信息的处理，可以获取知识，以推动人类文明的发展。例如：通过测量星球的位置和对应的时间，我们可以得到数据；通过处理这些数据得到星球运动的轨迹，就是信息；通过信息总结出开普勒三定律，则是知识。而人类的智能往往体现在：获取数据→分析数据→建立模型→预测未知上。</p>
<p>现在我们所说的人工智能有两个定义：狭义的人工智能指的是20世纪五六十年代的研究机器智能的特定方法，即传统人工智能方法，专注于让机器像人一样地去思考；广义的人工智能指的是任何可以让计算机通过图灵测试的方法，即让一台机器和一个人在幕后，一位裁判同时与他们交流，看看裁判是否能够分辨出自己交流的对象是机器还是人。以翻译为例：传统的方法就是针对某两种语言编写大量的规则，以反映人类的思考方式；而现代的方法则是通过数据驱动，用机器学习的方式训练出翻译模型的各种参数。在互联网出现以前，很难获取到大量的有效数据，因而实用性不高。但是在如今的大数据时代，获取大量数据已经成为了可能。越来越多的信息可以使模型越来越准确，进而使翻译的效果越来越好。这里有个大数据预测美国大选的例子：2012年有人把互联网上公开的新闻、Facebook、Twitter等选战数据按照州来整理，竟然成功地预测了全部50+1个州的选举结果。</p>
<p>数据的作用过去常常被人们所忽视。首先是由于过去的数据量不足（少了大数据的大，Vast）；其次是数据缺乏相关性（少了多维度，即多样性Variety）。而现在的数据量由于计算机本身的数据、传感器的数据以及旧信息的数字化，比过去增加了许多，使量变足以成为了质变。数据驱动方法过去的死穴在于，使用基于概率统计的模型会有很多小概率事件覆盖不到。只有提高数据的完备性才行。这在以前是很难做到的，比如搜集全国所有人的面孔。但是如今这样的事情也并非遥不可及。所以我们也许需要重新认识穷举法，在大数据时代它并不像想象中的那样笨。数据的相关性也非常重要。我上班的时候会经过一家广东肠粉的小吃店，招牌上“广”字的一点已经脱落，成了“厂东肠粉”。我们的智能当然能够判断出来这是广东而不是厂东，但是大数据呢？首先它并不能找到什么有意义的“厂东”，但是能找到广东，并且“厂”和“广”字形非常接近。但是这样也无法否定是不是有个小地方叫“厂东”，或是老板的名字叫“厂东”。所以需要交叉验证。接下来发现“广东”和“肠粉”两字经常出现，有相关性。这样数据的相关性便大大提升了可信度。要是有图片，还能根据“厂”的字形比另外三个字稍扁来做进一步的交叉验证，准确性就能够更上一层楼。实际上如果在baidu搜索“厂东肠粉”的时候，它已经会问你“您要找的是不是: 广东肠粉”。Google虽然并不提示你，但显示的搜索结果也都是广东肠粉。当大家都意识到数据的重要性后，市场上的竞争就从技术的竞争转变成了数据的竞争，智能问题已经演变成了数据问题。<br><img src="/img/intelligence-age-guang-dong.png" alt=""></p>
<h2 id="智能革命"><a href="#智能革命" class="headerlink" title="智能革命"></a>智能革命</h2><p>我们现在说起机械思维，总觉得它是个贬义词。但其实它正是以前推动工业革命的要素。机械思维认为世界变化的规律是确定的，因此规律可以被认识，并且可以用公式或语言描述清楚，放之四海而皆准。但成也萧何败萧何，它的局限性正是否认了不确定性和不可知性。世界的不确定性首先来自影响世界的变量实在太多，以至于无法套用公式算出结果。其次世界本身也是不确定的，人类对于世界的观察将会改变世界本身，如量子力学的不确定性原理。但是不确定并不意味着没有规律可循。香农在概率论的基础上，用信息论将世界的不确定性与信息联系了起来，给了人们一种看待世界和处理问题的全新思路。</p>
<p>新思路为我们带来了大数据思维。它的核心是：数据中所包含的信息可以帮助我们消除不确定性，而数据之间的相关性在某种程度上可以取代原来的因果关系，帮助我们得到想知道的答案。例如，根据大数据的统计结果，可以发现在视频网站上投放零食的广告效果很好，我们可以据此猜出人们在看视频时喜欢吃零食。所以这种新的思维方法允许我们在不知道原因的情况下直接从大量数据中寻找答案，即无监督学习。虽然机器推算出来相关的事情只有一定的概率，但是世界本身就充满了不确定性，100%的准确率固然是好，但是90%的结果也是非常有价值的。这就是思维的革命。</p>
<p>还有产业的革命。套用一个公式：<strong>现有产业 + 新技术 = 新产业</strong>。例如：</p>
<ul>
<li>第一次工业革命：现有产业 + 蒸汽机 = 新产业</li>
<li>第二次工业革命：现有产业 + 电 = 新产业</li>
<li>现今的信息革命：现有产业 + 摩尔定律 = 新产业</li>
<li>由大数据引发的智能革命：<ul>
<li>现有产业 + 大数据 = 新产业</li>
<li>现有产业 + 机器智能 = 新产业</li>
</ul>
</li>
</ul>
<p>在瓦特改良万能蒸汽机之后，很多上千年历史的古老行业都通过使用蒸汽机而变为新产业，如纺织业冲击了几千年来的家庭纺织业，而瓷器则由白色黄金变成了日用品等。并不需要每一个工厂都去制造蒸汽机，而大多数工厂都会受益于蒸汽机。到了19世纪末，电力的应用也催生了各种新产业，如建筑业通过使用电梯使人们可以把楼盖高，交通运输业通过电车、地铁等公共交通促进了城市的发展，形成了大都市。但是也不需要太多的供电公司，对于美国而言就是通用电气和西屋电气，而大多数公司都会受益于电。“二战”之后，许多产业在使用计算机之后产生了质的变化，如金融业、通信业等。计算机处理器是信息革命的代表产品，但是同样并不需要有很多生产它的公司，今天大部分的处理器都是来自Intel或AMD以及ARM公司所设计的产品，而大部分电脑和智能设备都离不开它们。正在到来的智能革命，也将催生和改造出许多的新产业，但同样，并不是所有公司都会掌握大数据或是培养出机器智能，而大多数公司都将受益于大数据和机器智能。</p>
<h2 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h2><p>新革命的到来当然不会是一帆风顺的，首先要解决的是技术上的挑战。大量的数据必然需要大量的存储，并使查找和使用数据的时间剧增。早期存储数据的磁带和软盘根本不可能承担起存储如此海量数据的任务。硬盘虽然容量上去了，但是其存取速度仍然受限于机械运动。直到SSD的崛起和平价化，才使得在存储技术上适应了大数据。数据的传输也是一个挑战，直到移动互联网和WIFI技术的兴起，才使得大量数据的传输成为可能。而对数据的处理，则受益于摩尔定律，处理器速度增加并越来越便宜，从而导致并行处理技术如Map Reduce等的发展。也有目前还没完全解决的问题，如数据的标准化等。Google设计了一种称为<a href="https://github.com/google/protobuf" target="_blank" rel="external">Protocal Buffer</a>的数据格式，并已开源供大家使用。</p>
<p>技术问题解决后，就是商业问题了。如何获得一个全集的大数据呢？例如，为了了解电视的收视率，显然不能再一个个地去发传单、打电话了。最好的方法是通过机顶盒记录用户的收视情况。但是掌握这些数据的生产厂商和有线电视运营商当然不会轻易地把这些数据分享出来。所以Google推出了自己的电视机顶盒Google TV，为获取数据进入电视广告市场做准备，但是销售结果很糟糕，据说后来每个季度退回来的机顶盒比卖出去的还多。以至于Google在2014年斥巨资收购了还在亏损状态的nest公司，以获取nest公司的产品（恒温器）在每一个家庭的数据。一些公司已经敏锐地发现了数据的价值，而另一些公司却捧着金饭碗要饭。</p>
<p>还有数据的安全。首先由于数据量大，数据一旦丢失或被盗，损失将是巨大的。一种行之有效的方式就是利用大数据本身的特点来保护大数据的信息安全。如果外来的入侵者侵入了计算机系统，由于对业务的不熟悉，他的操作很可能与众不同，因此可以通过与大数据的对比而被发现，从而被制止。还有就是对于隐私的保护。如果导航系统能够帮人们导航并避开拥堵路段，那也说明它知道每个人的行踪。一旦这些信息暴露出来，这是非常危险的。再比如说<a href="http://www.sohu.com/a/117859356_469880" target="_blank" rel="external">《大数据高手塔吉特：我知道你怀孕了！》</a>。现在的很多公司都或多或少具备了这样的能力，只是大家不知道或者不注意而已。甚至连淘宝的商家都有可能收集到你的信息，从而决定给你寄真货还是寄假货。</p>
<p>最后，随着生产力的进一步发展，机器将会抢掉许多人的饭碗：工人、医生、律师、翻译、编辑、中间商等等。特斯拉的汽车装配厂都是由机器人操作，很少雇佣汽车行业的人员，而所雇的都是IT人员。机器将会从大数据中学习到各种专家的知识，甚至表现得更好。那未来如此多失业的人将会怎么办？目前人类还没有很好的办法，只能靠“拖”字决。一两代之后，无法掌握新技能的人也已经到了退休年龄了。AI会有更好的办法么？也许AI会发现只需要让大家陷入深深的睡眠就可以了。《黑客帝国》又向现实迈进了一步。但是AI毕竟来自于大数据，而不是全数据。有朝一日醒来的人类，也许能够通过制造不常见的场景，引发AI的bug，就像李世石曾经战胜AlphaGo的那一盘围棋一样。而埃隆·马斯克用“<a href="https://www.huxiu.com/article/201384.html" target="_blank" rel="external">脑机接口</a>”的宏伟蓝图来应对AI。既然人类可能最终会被AI消灭，那不如就让人类与AI成为一体。</p>
<p>“2%的人将控制未来，成为他们或被淘汰”。</p>
]]></content>
      
        <categories>
            
            <category> AI </category>
            
        </categories>
        
        
        <tags>
            
            <tag> AI </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Kotlin的语法糖们]]></title>
      <url>/kotlin-syntax-suger/</url>
      <content type="html"><![CDATA[<p>当今的<a href="https://kotlinlang.org/" target="_blank" rel="external">Kotlin</a>真是炙手可热啊。自2011年JetBrains为了提高IDEA的销量而推出这个项目至今，它一直低调而稳定地发展着。到了上个月即2017年5月，<a href="https://blog.jetbrains.com/kotlin/2017/05/kotlin-on-android-now-official/" target="_blank" rel="external">Google宣布将Kotlin语言作为Android开发的一级编程语言</a>，算是到达了语言生的第一个巅峰。<a href="https://kotlinlang.org/docs/reference/faq.html#is-kotlin-hard" target="_blank" rel="external">Kotlin自身受到Java、C#、JavaScript、Scala、Groovy等语言的影响</a>，本文总结了它提供的部分常见语法糖并与其它语言进行比较。<br><a id="more"></a></p>
<h2 id="字符串模板（string-template）"><a href="#字符串模板（string-template）" class="headerlink" title="字符串模板（string template）"></a>字符串模板（<a href="https://kotlinlang.org/docs/reference/basic-types.html#string-templates" target="_blank" rel="external">string template</a>）</h2><p>Kotlin可以直接通过<code>println(&quot;Hello, {name}&quot;)</code>或<code>println(&quot;Hello, $name&quot;)</code>来使用字符串模板，而Java则需要先借助<code>String.format</code>来生成字符串。而kotlin还支持表达式，如<code>${person.name}</code>和<code>${2 * 3}</code>。这块古老的糖从shell开始就有了：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo "Hello, $&#123;name&#125;"</div></pre></td></tr></table></figure></p>
<p>如果你疑惑为什么无须导入包即可直接使用<code>println</code>，那是因为这个方法所在的<code>kotlin.io</code>包是默认导入（Default Imports）的，正如Java会默认导入<code>java.lang.*</code>一样。Kotlin的默认导入请参考<a href="https://kotlinlang.org/docs/reference/packages.html#default-imports" target="_blank" rel="external">这里</a>。</p>
<h2 id="分号推断（semicolon-inference）"><a href="#分号推断（semicolon-inference）" class="headerlink" title="分号推断（semicolon inference）"></a>分号推断（<a href="https://kotlinlang.org/docs/reference/grammar.html#semicolons" target="_blank" rel="external">semicolon inference</a>）</h2><p>我们知道Java中的每一条语句结束后，需要加上分号。Kotlin中的分号是可选的。这应该是来自JavaScript吧。不过写JavaScript还是推荐把分号都加上，否则可能<a href="http://cjihrig.com/blog/the-dangers-of-javascripts-automatic-semicolon-insertion/" target="_blank" rel="external">有危险</a>。Groovy、Scala也有同样的能力。</p>
<h2 id="定义函数（define-function）"><a href="#定义函数（define-function）" class="headerlink" title="定义函数（define function）"></a>定义函数（<a href="https://kotlinlang.org/docs/reference/functions.html" target="_blank" rel="external">define function</a>）</h2><p>JavaScript中，<code>function</code>；Go语言，<code>func</code>；Kotlin，<code>fun</code>。怎么看都像是SIM卡变成了micro-SIM，然后又变成了nano-SIM卡。Kotlin可以在类之外定义全局函数，也可以在函数中定义局部函数。这一点类似于JavaScript。</p>
<h2 id="var／val（local-variable）"><a href="#var／val（local-variable）" class="headerlink" title="var／val（local variable）"></a>var／val（<a href="https://kotlinlang.org/docs/reference/basic-syntax.html#defining-local-variables" target="_blank" rel="external">local variable</a>）</h2><p>变量是<code>var</code>，表示variable；常量是<code>val</code>，表示fixed value。这个很明显来自Scala。在Java中就只能用<code>final</code>关键字了。</p>
<h2 id="可空值（nullable-value）"><a href="#可空值（nullable-value）" class="headerlink" title="可空值（nullable value）"></a>可空值（<a href="https://kotlinlang.org/docs/reference/null-safety.html" target="_blank" rel="external">nullable value</a>）</h2><p>在变量类型后面加上一个问号，表明这个变量可以为null，否则默认不能为null。例如：<br>这一句编译错误：<code>var a: Int = null</code><br>这样才能成功：<code>var a: Int? = null</code><br>这块糖显然来自于C#，但是更加严格了。它是为了避免Java中的null所造成的<a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare" target="_blank" rel="external">十亿美元的错误</a>。</p>
<h2 id="集合字面量（collection-literals）"><a href="#集合字面量（collection-literals）" class="headerlink" title="集合字面量（collection literals）"></a>集合字面量（<a href="https://kotlinlang.org/docs/reference/collections.html#collections" target="_blank" rel="external">collection literals</a>）</h2><p>Java从来就不愿意用糖吸引小朋友……所以一般快速创建集合是这么写的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; colors = Arrays.asList(<span class="string">"red"</span>, <span class="string">"blue"</span>);</div></pre></td></tr></table></figure></p>
<p>有好事者（Guava）提供了这样的类库：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; colors = ImmutableList.of(<span class="string">"red"</span>, <span class="string">"blue"</span>);</div></pre></td></tr></table></figure></p>
<p>其实Java 8提供的Stream也许已经能够满足你的需求：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Stream&lt;String&gt; colors = Stream.of(<span class="string">"red"</span>, <span class="string">"blue"</span>);</div></pre></td></tr></table></figure></p>
<p>Java 9很可能会<a href="http://openjdk.java.net/jeps/269" target="_blank" rel="external">引入集合字面量</a>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; colors = List.of(<span class="string">"red"</span>, <span class="string">"blue"</span>);</div></pre></td></tr></table></figure></p>
<p>Kotlin出手了：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> colors = listOf(<span class="string">"red"</span>, <span class="string">"blue"</span>)</div></pre></td></tr></table></figure></p>
<p>不过实际上并非是语法层面的糖，<code>listOf</code>只是一个方法而已。我相信是从Scala中偷师的：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> colors = <span class="type">List</span>(<span class="string">"red"</span>, <span class="string">"blue"</span>)</div></pre></td></tr></table></figure></p>
<p>当然Scala还有自己的经典方式：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> colors = <span class="string">"red"</span> :: <span class="string">"blue"</span> :: <span class="type">Nil</span></div></pre></td></tr></table></figure></p>
<p>C#可以这样来初始化集合：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> ArrayList&#123;<span class="string">"red"</span>, <span class="string">"blue"</span>&#125;;</div></pre></td></tr></table></figure></p>
<p>JavaScript、Ruby、Go等直接扩展了数组，所以就更省心了。</p>
<h2 id="when表达式（when-expression）"><a href="#when表达式（when-expression）" class="headerlink" title="when表达式（when expression）"></a>when表达式（<a href="https://kotlinlang.org/docs/reference/control-flow.html#when-expression" target="_blank" rel="external">when expression</a>）</h2><p><code>when</code>表达式有点像是不需要<code>break</code>的<code>switch…case</code>：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">when</span> (x) &#123;</div><div class="line">    <span class="number">1</span> -&gt; print(<span class="string">"x == 1"</span>)</div><div class="line">    <span class="number">2</span> -&gt; print(<span class="string">"x == 2"</span>)</div><div class="line">    <span class="keyword">else</span> -&gt; &#123; <span class="comment">// 这里可以写多行哦</span></div><div class="line">        print(<span class="string">"x is neither 1 nor 2"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但它还可以做得更多：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">when</span> &#123;</div><div class="line">    <span class="string">"orange"</span> <span class="keyword">in</span> items -&gt; println(<span class="string">"juicy"</span>)</div><div class="line">    <span class="string">"apple"</span> <span class="keyword">in</span> items -&gt; println(<span class="string">"apple is fine too"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以把它作为扩展版<code>if…else</code>来用。它有点类似Groovy的<code>switch</code>。</p>
<h2 id="is运算符（is-operator）"><a href="#is运算符（is-operator）" class="headerlink" title="is运算符（is operator）"></a>is运算符（<a href="https://kotlinlang.org/docs/reference/basic-syntax.html#using-type-checks-and-automatic-casts" target="_blank" rel="external">is operator</a>）</h2><p>先看代码：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getStringLength</span><span class="params">(obj: <span class="type">Any</span>)</span></span>: <span class="built_in">Int</span>? &#123;</div><div class="line">    <span class="keyword">if</span> (obj <span class="keyword">is</span> String &amp;&amp; obj.length &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> obj.length</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">null</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里，<code>obj is String</code>之后就可以将其作为<code>String</code>来使用了，调用<code>String</code>的<code>length</code>属性。<code>is</code>不仅比<code>instanceof</code>更加短小精悍，而且还会自动将变量转换为<code>is</code>后面的类型。应该是出于C#而胜于C#。C#提供了<code>is</code>和<code>as</code>，但是<code>as</code>在Kotlin中显然就毫无用武之地了。</p>
<h2 id="范围运算符（range）"><a href="#范围运算符（range）" class="headerlink" title="范围运算符（range）"></a>范围运算符（<a href="https://kotlinlang.org/docs/reference/ranges.html" target="_blank" rel="external">range</a>）</h2><p>Java如果要循环打印1至9，一般就是这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Java 8以前</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</div><div class="line">    System.out.println(i);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Java 8 lambda</span></div><div class="line">IntStream.range(<span class="number">1</span>, <span class="number">9</span>).forEach(System.out::println);</div></pre></td></tr></table></figure></p>
<p>如果需要步长（step），lambda方案就需要引入filter、map或iterate。Kotlin自带接口<code>ClosedRange</code>，用了点糖：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.9</span>) print(i)</div><div class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.9</span> step <span class="number">2</span>) print(i)</div><div class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">9</span> downTo <span class="number">1</span>) print(i)</div></pre></td></tr></table></figure></p>
<p>bash早就支持大括号配合<code>..</code>（<a href="http://www.gnu.org/software/bash/manual/html_node/Brace-Expansion.html" target="_blank" rel="external">brace expansion</a>）的这种方式了：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">for i in &#123;1..9&#125;; do echo $i; done</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> bash 4支持步长</span></div><div class="line">for i in &#123;1..9..2&#125;; do echo $i; done</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> 否则用seq</span></div><div class="line">for i in `seq 1 2 9`; do echo $i; done</div></pre></td></tr></table></figure></p>
<p>不过我更喜欢ruby，支持lambda的写法更加优雅：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="number">1</span>..<span class="number">9</span>).each &#123;<span class="params">|x|</span> puts x&#125;</div><div class="line">(<span class="number">1</span>..<span class="number">9</span>).step(<span class="number">2</span>) &#123;<span class="params">|x|</span> puts x&#125;</div></pre></td></tr></table></figure></p>
<h2 id="运算符重载（operator-overloading）"><a href="#运算符重载（operator-overloading）" class="headerlink" title="运算符重载（operator overloading）"></a>运算符重载（<a href="https://kotlinlang.org/docs/reference/operator-overloading.html" target="_blank" rel="external">operator overloading</a>）</h2><p>这个是C#和Scala的把戏：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>, <span class="keyword">val</span> y: <span class="built_in">Int</span>)</div><div class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Point.<span class="title">plus</span><span class="params">(<span class="keyword">val</span> point: <span class="type">Point</span>)</span></span> = Point(x + point.x, y + point.y)</div><div class="line"></div><div class="line">Point(<span class="number">1</span>, <span class="number">2</span>) + Point(<span class="number">3</span>, <span class="number">4</span>) <span class="comment">// Point(x=4, y=6)</span></div></pre></td></tr></table></figure></p>
<p>怎么知道<code>+</code>号上映射的是<code>plus</code>方法呢？还是得参考<a href="https://kotlinlang.org/docs/reference/operator-overloading.html" target="_blank" rel="external">官方文档</a>。</p>
<h2 id="包别名（package-alias）"><a href="#包别名（package-alias）" class="headerlink" title="包别名（package alias）"></a>包别名（<a href="https://kotlinlang.org/docs/reference/packages.html#imports" target="_blank" rel="external">package alias</a>）</h2><p>Kotlin支持为包指定别名，对代码洁癖患者可能会起到一定的疗效：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.math.BigDecimal <span class="keyword">as</span> bd</div></pre></td></tr></table></figure></p>
<p>Python、Groovy也都是这样：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.List <span class="keyword">as</span> UtilList</div><div class="line"><span class="keyword">import</span> java.awt.List <span class="keyword">as</span> AwtList</div></pre></td></tr></table></figure></p>
<h2 id="类型别名（type-alias）"><a href="#类型别名（type-alias）" class="headerlink" title="类型别名（type alias）"></a>类型别名（<a href="https://kotlinlang.org/docs/reference/type-aliases.html" target="_blank" rel="external">type alias</a>）</h2><p>Kotlin还支持为类型指定别名：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typealias Row = List&lt;<span class="built_in">Int</span>&gt;</div></pre></td></tr></table></figure></p>
<p>这应该是来自Scala的Type：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">type</span> <span class="title">Row</span> </span>= <span class="type">List</span>[<span class="type">Int</span>]</div></pre></td></tr></table></figure></p>
<h2 id="扩展函数（extension-function）"><a href="#扩展函数（extension-function）" class="headerlink" title="扩展函数（extension function）"></a>扩展函数（<a href="https://kotlinlang.org/docs/reference/extensions.html" target="_blank" rel="external">extension function</a>）</h2><p>扩展函数允许为一个类增加公有静态方法，调用时就好像这个方法是原生的一样。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">greetingsWith</span><span class="params">(greeting: <span class="type">String</span>)</span></span> &#123;</div><div class="line">    println(<span class="string">"<span class="variable">$greeting</span>, <span class="variable">$this</span>"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="string">"ggg"</span>.greetingsWith(<span class="string">"Hello"</span>)</div></pre></td></tr></table></figure></p>
<p>虽然JavaScript也能轻易做到，但我还是强烈地认为它来自于C#，毕竟都是一脉相承。kotlin更近一步支持扩展属性：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> String.halfLength: <span class="built_in">Int</span></div><div class="line">    <span class="keyword">get</span>() = length / <span class="number">2</span></div><div class="line"></div><div class="line"><span class="string">"ggg"</span>.halfLength <span class="comment">// 1</span></div></pre></td></tr></table></figure></p>
<h2 id="函数扩展（function-expansion）"><a href="#函数扩展（function-expansion）" class="headerlink" title="函数扩展（function expansion）"></a>函数扩展（<a href="https://kotlinlang.org/docs/reference/lambdas.html#higher-order-functions" target="_blank" rel="external">function expansion</a>）</h2><p>如果函数的最后一个参数类型是个函数，可以通过大括号来传值：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">calculate</span><span class="params">(a: <span class="type">Int</span>, cal: (<span class="type">Int</span>)</span></span> -&gt; <span class="built_in">Int</span>): <span class="built_in">Int</span> &#123;</div><div class="line">    <span class="keyword">return</span> cal(a)</div><div class="line">&#125;</div><div class="line"></div><div class="line">calculate(<span class="number">3</span>) &#123; x -&gt; x * x &#125; <span class="comment">// 9</span></div></pre></td></tr></table></figure></p>
<p>这应该是来自ruby的block：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate</span><span class="params">(a, &amp;cal)</span></span></div><div class="line">    cal.call a</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">calculate(<span class="number">3</span>) &#123; <span class="params">|x|</span> x * x &#125; <span class="comment"># 9</span></div></pre></td></tr></table></figure></p>
<h2 id="默认参数（default-arguments）"><a href="#默认参数（default-arguments）" class="headerlink" title="默认参数（default arguments）"></a>默认参数（<a href="https://kotlinlang.org/docs/reference/functions.html#default-arguments" target="_blank" rel="external">default arguments</a>）</h2><p>Kotlin支持为参数指定一个默认值：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  show()</div><div class="line">  show(<span class="string">"Good morning"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">show</span> <span class="params">(msg: <span class="type">String</span> = <span class="string">"Hello World"</span>)</span></span> &#123;</div><div class="line">    println(<span class="string">"<span class="variable">$msg</span>"</span>) </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Java一般是靠重载来实现默认参数。许多其它的语言都支持默认参数。例如，JavaScript在ES6上也支持默认参数了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">a, b = <span class="number">1</span></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> a * b;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="单例对象（singleton）"><a href="#单例对象（singleton）" class="headerlink" title="单例对象（singleton）"></a>单例对象（<a href="https://kotlinlang.org/docs/reference/object-declarations.html#object-declarations" target="_blank" rel="external">singleton</a>）</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">object</span> Document &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这应该是来自于Scala，连关键字都一模一样。</p>
<h2 id="伴生对象（companion-object）"><a href="#伴生对象（companion-object）" class="headerlink" title="伴生对象（companion object）"></a>伴生对象（<a href="https://kotlinlang.org/docs/reference/object-declarations.html#companion-objects" target="_blank" rel="external">companion object</a>）</h2><p>伴生对象经常用于Factory。这一点相信也是来自于Scala。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</div><div class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> Factory &#123; <span class="comment">// Factory可省略，省略后可用Companion引用</span></div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">()</span></span>: MyClass = MyClass()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="getter和setter（getter-and-setter）"><a href="#getter和setter（getter-and-setter）" class="headerlink" title="getter和setter（getter and setter）"></a>getter和setter（<a href="https://kotlinlang.org/docs/reference/properties.html#getters-and-setters" target="_blank" rel="external">getter and setter</a>）</h2><p>Kotlin像C#一样支持属性（property）。我们来看两个例子：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> isEmpty: <span class="built_in">Boolean</span></div><div class="line">    <span class="keyword">get</span>() = <span class="keyword">this</span>.size == <span class="number">0</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> counter = <span class="number">0</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">set</span>(value) &#123;</div><div class="line">        <span class="keyword">if</span> (value &gt;= <span class="number">0</span>) field = value</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h2 id="数据类（data-class）"><a href="#数据类（data-class）" class="headerlink" title="数据类（data class）"></a>数据类（<a href="https://kotlinlang.org/docs/reference/data-classes.html" target="_blank" rel="external">data class</a>）</h2><p>告别繁琐的Java数据类的时代到来了：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</div></pre></td></tr></table></figure></p>
<p>看到最前面的<code>data</code>，我突然觉得这是源于<a href="/lombok">lombok</a>…</p>
<h2 id="没有原始类型（no-raw-types）"><a href="#没有原始类型（no-raw-types）" class="headerlink" title="没有原始类型（no raw types）"></a>没有原始类型（<a href="https://kotlinlang.org/docs/reference/java-interop.html#mapped-types" target="_blank" rel="external">no raw types</a>）</h2><p>Kotlin没有原始类型，一切皆对象：<code>1.inc()</code>。这一点与Ruby、Scala相同。</p>
<h2 id="没有受检查异常（no-checked-exception）"><a href="#没有受检查异常（no-checked-exception）" class="headerlink" title="没有受检查异常（no checked exception）"></a>没有受检查异常（<a href="https://kotlinlang.org/docs/reference/exceptions.html#checked-exceptions" target="_blank" rel="external">no checked exception</a>）</h2><p>Kotlin并没有受检查异常。因为在大型的项目中，它对代码质量的提升极其有限，但是却大大降低了效率。C#十多年前就是这样了，有兴趣的读者可以参考<a href="https://blogs.msdn.microsoft.com/csharpfaq/2004/03/12/why-doesnt-c-have-checked-exceptions/" target="_blank" rel="external">这篇文章</a>。</p>
<h2 id="没有static（no-static-member）"><a href="#没有static（no-static-member）" class="headerlink" title="没有static（no static member）"></a>没有static（<a href="https://kotlinlang.org/docs/reference/classes.html#companion-objects" target="_blank" rel="external">no static member</a>）</h2><p>Kotlin也没有static的成员。这一点与Scala相同。在Kotiln中可以使用包级别的函数，或者是伴生对象来实现static的效果。</p>
<h2 id="多返回值（multiple-return-values）"><a href="#多返回值（multiple-return-values）" class="headerlink" title="多返回值（multiple return values）"></a>多返回值（<a href="https://kotlinlang.org/docs/reference/multi-declarations.html" target="_blank" rel="external">multiple return values</a>）</h2><p>可以从<a href="https://kotlinlang.org/docs/reference/multi-declarations.html#example-returning-two-values-from-a-function" target="_blank" rel="external">这一个例子</a>中看到Kotlin是如何实现函数的多返回值的。我猜应该是受到了Go语言的启发。</p>
<h2 id="嵌套块注释（nested-block-comment）"><a href="#嵌套块注释（nested-block-comment）" class="headerlink" title="嵌套块注释（nested block comment）"></a>嵌套块注释（<a href="https://kotlinlang.org/docs/reference/basic-syntax.html#comments" target="_blank" rel="external">nested block comment</a>）</h2><p>Kotlin支持块注释<code>/* … */</code>的嵌套。这可能是来自Haskell或F#。</p>
<h2 id="在线版IDE"><a href="#在线版IDE" class="headerlink" title="在线版IDE"></a>在线版IDE</h2><p>如果不想安装那么多语言，可以试试这个<a href="https://codepad.remoteinterview.io" target="_blank" rel="external">在线版IDE</a>，它支持包括Kotlin在内的几十种语言。</p>
]]></content>
      
        <categories>
            
            <category> development </category>
            
        </categories>
        
        
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用Lombok优雅地写代码]]></title>
      <url>/lombok/</url>
      <content type="html"><![CDATA[<p><a href="https://projectlombok.org/index.html" target="_blank" rel="external">Lombok</a>是一个比较早、小众但是功能强大的Java库，源码在<a href="https://github.com/rzwitserloot/lombok" target="_blank" rel="external">github上</a>。如果你厌恶写Java代码时不得不手写或用IDE生成大量无趣的样板代码，如getter、setter等，那就准备好拥抱lombok吧。<br><a id="more"></a></p>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><h3 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h3><p>Lombok通过注解来减少样板代码的使用。对于数据类来说，自己看<a href="https://projectlombok.org/" target="_blank" rel="external">官网的视频</a>吧。三分钟太长不想看？那么也可以快速浏览一下<a href="https://projectlombok.org/features/Data.html" target="_blank" rel="external">这里的代码</a>。神奇的事情是怎么做到的呢？奥秘就是<a href="http://notatube.blogspot.com/2010/11/project-lombok-trick-explained.html" target="_blank" rel="external">在编译时插入代码</a>。你甚至还可以创建自己的注解！参考<a href="http://notatube.blogspot.com/2010/12/project-lombok-creating-custom.html" target="_blank" rel="external">这篇文章</a></p>
<h3 id="其它特性"><a href="#其它特性" class="headerlink" title="其它特性"></a>其它特性</h3><p>除了本职的数据类以外，lombok还提供了许多<a href="https://projectlombok.org/features/index.html" target="_blank" rel="external">其它的特性</a>，以帮助我们减少样板代码的使用。官网的说明非常详细，也都附带了代码，我就不做说明书的搬运工了。这里放一个例子：<a href="https://projectlombok.org/features/Synchronized.html" target="_blank" rel="external">@Synchronized</a>。</p>
<h2 id="与Intellij-IDEA集成"><a href="#与Intellij-IDEA集成" class="headerlink" title="与Intellij IDEA集成"></a>与Intellij IDEA集成</h2><p>动手时间。新建Maven工程，往pom.xml中增加dependency，最后的pom.xml看起来就像这样：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></div><div class="line">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.ggg.lombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>helloLombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>在src/main/java中新增一个Person类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Person类中右击，Go To，Test（或者Ctrl/Command+T）便可以在src/test/java中新增一个对应的测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.junit.Test;</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span> </span>&#123;</div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">should_get_name_from_person</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> Person(<span class="string">"ggg"</span>, <span class="number">18</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>出现了一条红线，编译失败。回到Person类中，在Person类的定义上面加上<code>@AllArgsConstructor</code>并<code>import lombok.AllArgsConstructor;</code>，还是编译不过。现在到了应该加载IDEA插件的时候了。参考<a href="https://github.com/mplushnikov/lombok-intellij-plugin" target="_blank" rel="external">这里</a>来安装lombok插件，别忘了重启Intellij IDEA。这回编译成功了。在测试的调用构造函数处Command/Ctrl+B便能跳转到Person类的<code>@AllArgsConstructor</code>上。接着写测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Person ggg = <span class="keyword">new</span> Person(<span class="string">"ggg"</span>, <span class="number">18</span>);</div><div class="line"></div><div class="line">assertEquals(<span class="string">"ggg"</span>, ggg.getName());</div></pre></td></tr></table></figure></p>
<p>getName又红了。切换回Person类，再加上<code>@Getter</code>，编译通过！运行测试，绿了！<br><img src="/img/lombok.jpg" alt=""></p>
<p>还可以通过Find Usages来找到字段的get方法在哪调用，可惜不能找到构造函数在哪调用。在享用便捷的同时，也需要付出些许的代价。有兴趣的看官可以自行尝试文档中的其它注解。例如<code>@ToString(of=&quot;name&quot;)</code>，<code>@Log</code>，<code>@Getter(lazy=true)</code>等等。值得一提的是，<a href="https://projectlombok.org/features/Cleanup.html" target="_blank" rel="external">@Cleanup</a>可以轻松地关闭流、连接等对象，Java 7也提供了<a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html" target="_blank" rel="external">try-with-resources</a>来做到这一点，只不过需要缩进罢了，但是可以很明显地看出作用域。还请自行选择喜欢的那个。当然，如果你的项目还在用老旧的Java 6，那确实也没有什么选择的余地。</p>
<h2 id="风险"><a href="#风险" class="headerlink" title="风险"></a>风险</h2><p>首先，Lombok扮演着一个注解处理器的角色，在编译时通过修改抽象语法树（Abstract Syntax Tree，AST）来修改代码。但是这是被注解处理器规范所明令禁止的，规范仅允许生成新文件或是新类。而聪明的lombok开发者通过javac未公开的API绕开了这个限制。所以有人视lombok为邪门歪道。不过嘛，不管黑猫白猫，能捉老鼠的就是好猫；不管黑糖白糖，能少写代码的就是好糖。先了解它，再决定要不要因为代价而放弃收益。如果未来的Java版本取消了后门，那么使用lombok的项目就存在升级JDK的风险。如果介意这一点，并且只有数据类的需求，可以去看看google的<a href="https://github.com/google/auto/blob/master/value/userguide/index.md" target="_blank" rel="external">AutoValue</a>。不过白魔法比黑魔法总是缺了点什么…</p>
<p>第二点是IDE的支持。虽然是支持，但是你也看到了并不能像原来虽然写了代码，但大都是自动生成的代码那样随心所欲地各种重构。另外IDE偶尔抽点风也可能会让你流半天汗。</p>
<p>第三点是代码覆盖率的测试。如果贵公司对它有明确而严格的要求，那就需要好好研究lombok与所用的代码覆盖率工具的兼容程度了。目前看来lombok与<a href="http://cobertura.github.io/cobertura/" target="_blank" rel="external">Cobertura</a>的兼容性还是最好的。</p>
<p>最后一点是代码行为可能会与你的预期不一样，比如enum的<code>@ToString</code>。<a href="https://medium.com/@vgonzalo/dont-use-lombok-672418daa819" target="_blank" rel="external">这篇文章</a>中详细地介绍了非预期的代码行为、去lombok的痛苦以及替代方案，值得看官们参考。</p>
]]></content>
      
        <categories>
            
            <category> development </category>
            
        </categories>
        
        
        <tags>
            
            <tag> lombok </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[区块链技术浅析]]></title>
      <url>/blockchain/</url>
      <content type="html"><![CDATA[<p><a href="https://zh.wikipedia.org/wiki/%E5%8C%BA%E5%9D%97%E9%93%BE" target="_blank" rel="external">区块链</a>是2016年起突然走红起来的一门技术，连国务院印发的<a href="http://news.sohu.com/20161227/n477114271.shtml" target="_blank" rel="external">《“十三五”国家信息化规划》</a>也将其纳入。上周公司举办黑客马拉松的活动，有幸浅尝了一下区块链的应用，本文旨在记录并分享区块链的一些心得。<br><a id="more"></a></p>
<h2 id="比特币（Bitcoin）"><a href="#比特币（Bitcoin）" class="headerlink" title="比特币（Bitcoin）"></a>比特币（Bitcoin）</h2><p>要说清楚区块链，首先需要了解<a href="https://zh.wikipedia.org/wiki/%E6%AF%94%E7%89%B9%E5%B8%81" target="_blank" rel="external">比特币</a>。2008年金融危机时，神秘的<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E6%9C%AC%E8%81%AA" target="_blank" rel="external">中本聪</a>发表了一篇论文，详细描述了比特币。一年之后，他将其实现。再一年之后，他便把比特币交予社区维护，自己不再露面了。比特币其实就是一个文件，里面记载了所有人的账户及交易信息。这个文件只能往里增加数据而不能修改数据。比特币网络中的每一个人都拥有这个文件的备份。</p>
<p>我也可以写一个文件来表示所有人的帐户信息，但是它一文不值。为什么比特币就有价值呢？它存在价值是因为人们相信它有价值，就像印出来的钞票一样。而人们自发的信任是需要时间的。最初比特币也没有什么价值。第一笔交易发生在2010年，一位程序员在佛罗里达花了一万个比特币购买了价值25美元的披萨。截止本文发布，一个比特币大约是7000元人民币左右，可以在<a href="https://www.okcoin.cn/market-btc.html" target="_blank" rel="external">OKCoin</a>上查看。随着比特币的流行，出现了不少类似的货币，如以太坊（Ethereum）、莱特币（Litecoin）等等。只要有人相信它，它就有价值。想当年刚听说比特币的时候，我心底还暗自嘲笑怎么会有人相信这种一点实体都没有的东西，事实证明我还是太naive了。</p>
<p>作为一种货币，需要能够向别人转账。假如邻居家老王要给你转10个比特币，他需要把这笔交易写入文件并告诉比特币网络的其他节点，让大家把交易添加进这个文件。所以每个人都能够得知这笔交易信息。现在问题来了，其它的节点怎么知道这笔转账是可信的，即老王提出的呢？要是每个人都发起从老王转账到自己的请求，那老王可就亏死了。其他人当然做不到。因为这笔交易需要用老王的私钥签名。公私钥的简介可以参考我写的<a href="http://qinghua.github.io/certificate/#u975E_u5BF9_u79F0_u52A0_u5BC6">《证书的那些事儿》的非对称加密一节</a>。其他人拿不到老王的私钥，当然就无从伪造请求了。在比特币中，公钥也用于表示对方的地址。消费时，你需要用数字签名证明你拥有对应的私钥。比特币没有中心节点，所以如果老王转错账了，抱歉，要不回来了。你只知道对方的公钥（或者说是比特币的帐号或地址），并不知道对方的身份。</p>
<p>为了安全，比特币上并不会记载每个账户的余额是多少。每当要转账时，它需要提供至少一笔未消费的历史交易信息作为input，转完账后，剩余的部分称为零钱，可以转入你自己的公钥，或是你小号的公钥。至此，未消费的交易就变成了已消费，不能被再次使用了。所以多次重复的请求只有第一笔才能成功。比特币的转账并非立即生效，只有在解开一道数学题之后才行。解题的过程就叫挖矿。题目的难度由程序控制，程序会根据历史记录把解题时间控制在大约十分钟左右。</p>
<p>还有一个问题，由于网络传输的不确定性，你并不能保证老王的转账被及时同步到了所有的节点上。所以如果在这笔交易完全传播出去之前，老王又在这笔交易之前将本来作为input的历史交易转帐给他的小号呢？其它的节点根本判断不了哪个在前，哪个在后。所以顺序在这里至关重要。比特币是这么解决这个问题的：把交易分配到区块里（多对一），然后将区块链接起来，称为区块链。每个区块都会引用上一个区块，这样便实现了有序。同一区块内的交易被认为是同时发生的。由于同一时间可能会产生多笔交易，所以可能会产生多个区块。那如何知道应该以哪一个区块为准呢？事实上，每一个区块都包含了一道特殊的数学题，只有解开这道题才能使之有效。当一个节点解开了这道题，它便会向比特币网络广播自己的结果，并把交易排在区块链的下一位。如果偶尔有多人同时解出了结果，那么区块链便会产生不同的分支。两个分支开始竞争，看谁能够更快生成下一个区块。哪个分支更长，哪个分支就有效。这样的话，由于多人同时算出答案的概率很低，所以分支会在一定时间之后消失。如果你的交易在一个消失的分支的区块里，便会重新放到未确认的交易区里，等待加入下一个区块。那如果有人能快速计算多个区块，岂不是可以随心所欲了？话虽如此，但是要以个人之力来对抗全网，实在是非常困难的事情。除非控制了整个比特币网络上50%以上的运算力，才开始有可能做到。这样的成本是非常高的，对于一般的交易来说，实在是有些不值得。你也无法提前运算，因为下一个区块需要引用当前的区块和随机数，只有在当前区块完成之后，才能开始计算。所以说参与的机器越多，比特币或者说区块链就越安全。还有一点值得注意的是，越前面的区块就越安全，因为攻击所需的资源会越大。小规模的转账，等一个区块便可以了；大规模的话，最好多等几个，以降低分支消失的概率。</p>
<p>有意思的是，由于比特币网络上的机器是那么的多，导致个人很难能够挖到矿。所以采矿池（mining pool）应运而生，集多人的算力，挖到矿后根据贡献来分配。但是采矿池太大了也会带来安全问题，因为有可能超过了50%的运算力。有一家BTC Guild曾经能够独立解出一个链中的6个区块，所以这个采矿组织主动限制了规模和会员的数量，以减少比特币网络成员的不安。</p>
<h2 id="区块链（blockchain）"><a href="#区块链（blockchain）" class="headerlink" title="区块链（blockchain）"></a>区块链（blockchain）</h2><p>上一节已经介绍了比特币的区块链了。其实区块链就是一个去中心化的存储。在这一点上，它与git是比较相似的。它们都是分布式、无中心的链式存储，但是在出现分支时的解决方式不一样。Git可以通过merge和rebase来解决冲突，而区块链则是通过链的长度来自动废弃分支，作废分支里的交易重新放到未确认的交易区里，以便下次再放入新区块里，这样的行为有些类似<code>git rebase</code>。</p>
<p>由于区块链不停地往里增加区块，势必导致文件越来越大。虽然可以控制区块的大小（最大1M）和增长速度（10分钟左右），但这么计算每年也有<code>365×24×6×1M=52G</code>左右的数据。长此以往，如何受得了？作为消费者来说，已经校验并消费过了的历史数据，可以仅保存其散列码，这样便能大大减少数据。比特币钱包用的是<a href="https://en.wikipedia.org/wiki/Merkle_tree" target="_blank" rel="external">Merkle Tree</a>来做验证。</p>
<p>区块链按照参与者的身份，可以分为公有链（Public blockchain）、联盟链（Consortium blockchain）和私有链（Private blockchain），公有链如比特币，是通过挖矿来达成共识（consensus），但是挖矿的计算需要消耗大量的电力资源。联盟链顾名思义，仅由联盟内部可写，外部经过授权可读。而私有链只有一个成员可写，类似传统的分布式数据库。联盟链和私有链由于成员并非匿名，可受部分信任，并且消耗运算力其实也是一种浪费，所以可以相对放松一些要求，不必非得挖矿，可以通过共识协议来达成共识。</p>
<p>使用区块链必须能够达成共识，否则就失去意义了。其实传统的分布式一致性算法也能解决达成共识的问题，只不过一般并不考虑恶意节点篡改数据的问题罢了，而且实际上使用的节点也不像区块链那么多。传统的常见算法有：ZooKeeper使用的Zab协议；etcd使用的Raft协议；当然还有大名鼎鼎的Paxos协议。限于篇幅，本文就不具体讨论它们的具体算法了。</p>
<p>区块链最主要的贡献，是解决了在不信任网络中的信任问题。与传统的解决方案相反，参与区块链的人越多则越安全。但是如果你的组织已经有足够的信誉，是否真的需要使用区块链来实现？当你想使用区块链技术来解决特定问题的时候，应该先问问自己，如果不用区块链，会有什么问题？如果回答不了这个问题，那可能你对区块链还不够了解，或者是区块链并不是你问题的最佳解决方案。相对于技术本身来说，更麻烦的问题是靠谱的想法和实施。别手里拿着个锤子看什么都是钉子哦。再考虑一下传统的方案吧。</p>
<p>除了金融领域以外，还有许多应用区块链的有趣想法：</p>
<ul>
<li><a href="http://business.sohu.com/20160414/n444147338.shtml" target="_blank" rel="external">当Airbnb遇到区块链：你弄碎房东花瓶的事全世界都会知道</a></li>
<li><a href="http://www.weiyangx.com/165124.html" target="_blank" rel="external">纳斯达克在爱沙尼亚推出区块链投票系统</a></li>
<li><a href="http://36kr.com/p/5068610.html" target="_blank" rel="external">沃尔玛推零售“黑科技”:区块链跟踪食品溯源</a></li>
<li><a href="http://news.163.com/16/0711/05/BRLVNTKN00014AED.html" target="_blank" rel="external">蚂蚁金服将使用区块链技术 追踪每一笔公益善款去向</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://v.youku.com/v_show/id_XNjQ0NzE0Mjky.html" target="_blank" rel="external">《详解比特币的原理和运行机制》</a><br><a href="http://blockchaindev.org/article/introduce_blockchain.html" target="_blank" rel="external">《区块链(Blockchain)深入介绍》</a><br><a href="http://blockchaindev.org/article/consensus_introduction.html" target="_blank" rel="external">《浅谈区块链共识机制与分布式一致性算法》</a></p>
]]></content>
      
        <categories>
            
            <category> architecture </category>
            
        </categories>
        
        
        <tags>
            
            <tag> blockchain </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[DevOpsDays北京站见闻]]></title>
      <url>/devopsdays-beijing-2017/</url>
      <content type="html"><![CDATA[<p>首度来到中国的DevOpsDays北京站昨天顺利举行了。有幸得到赠票，在大会上见到了DevOps之父Patrick Debois还有诸多业内专家。当天的盛况及ppt下载请移步<a href="http://mp.weixin.qq.com/s/A6QDB4Z-O5cm4KCnDOmKAw" target="_blank" rel="external">此处</a>。<br><a id="more"></a></p>
<p>传统的DevOps主要涵盖了CAMS（Culture文化、Automation自动化、Measure度量、Sharing分享）四大方面。而要落地DevOps，需要两条腿：一条是组织方面的转型，另一条是技术方面的自动化工具。组织转型是要涉及到利益的，不容易下手。所以大部分的分享还是以技术方面为主。只有Patrick的好基友<a href="http://www.krisbuytaert.be/blog/" target="_blank" rel="external">Kris Buytaert</a>的ppt讲的是reorg。乔梁讲的是他在百度和腾讯的经历，但可能是受时间所限并没有太多的实际内容。如果没有自上而下的变革，很难推动起组织转型。对于许多人来说，也许能够做到的，也就是自动化工具罢了。下午的Open Space深度交流专场里，不乏对组织转型方面的问题，但是嘉宾们其实也没有什么非常好的办法。有些技巧（比如说拿数据说话）可以让你把DevOps推销给老板，但终究一场战斗的胜利很难能够左右战略上的部署。没有自上而下的决心和后盾，在触及利益的时候肯定是各种痛啊。两条慢腿可能凑活着还能走走，一条腿快一条腿慢必然会驱使着变革的前进或倒退。DevOps讲究痛点驱动，相信以后的DevOpsDays会有更多组织转型方面的分享。</p>
<p>在技术上，专家们一直强调，没有DevOps团队，别叫他们DevOps工程师。DevOps需要融入到跨功能团队中的每一个人，不是某一类人，不是某一个团队。这里我感觉有一个词很重要：<strong>同理心</strong>。有了同理心，你会理解其它角色的痛点，反之亦然。由此，便可以催生出<strong>分享</strong>。有了分享，理解痛点，便能从“像部署一样痛苦的事要多做”出发，提取出最佳实践，催生<strong>自动化</strong>。要衡量效果如何？数据说话。于是催生<strong>度量</strong>。这几方面相辅相成，在整体的良性循环之下，团队<strong>文化</strong>的成型便是顺理成章。怎样让大家拥有同理心？除了依靠人的素质进步，百度的刘俊还提到了一个做法，据说甚是有效，那就是开发运维轮岗。想想也对，把你推到别人的位置上，自然就有同理心了。</p>
<p>我在《DevOps实践》的译者序上也说过，DevOps是要很高成本的。在应用它之前，先问自己这样的问题：为什么要上DevOps？它能解决我的什么问题？不要说我想提高工作效率，提高程序质量，要从更高层次的业务上说。换句话说，从战略层面上想清楚应用DevOps的目的，然后在战术层面上依照战略来有根据有优先级地安排资源打硬仗。跟性能调优一样，搞清楚哪里才是瓶颈，针对性地动手解决。而不是直接拍胸脯就上DevOps，把最宝贵的资源浪费在可能对这个组织最没用的地方上。</p>
<p>对于中小企业来说，不要开发自己的自动化工具，不要重复发明轮子，直接拿现成的开源工具来用吧。不是BAT这样的量级，玩不起自研版的工具，它们其实是很重量级的。针对开源工具有些功能不符合自己的需求这方面，ThoughtWorks的黄博文说道：可以从另一个角度来看待这个问题，为什么你要的功能没有？这是一个正常的功能吗？究竟是功能的缺失，还是说只是你走错了路？此言深得我心。据说业界运维做得最好的应该就是谷歌和Netfilx。它们都有不少开源的运维工具，值得业内人士仔细研究。</p>
<p>最后放一张乔梁对DevOps和持续交付的看法，四个角色分别是产品、开发、测试和运维。先剧透一下并不是所有人都同意这个观点，少年，你怎么看？<br><img src="/img/agile-devops-and-cicd.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> devops </category>
            
        </categories>
        
        
        <tags>
            
            <tag> activity </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何测试随机数]]></title>
      <url>/test-random/</url>
      <content type="html"><![CDATA[<p>怎样知道它是不是<a href="https://zh.wikipedia.org/wiki/%E9%9A%8F%E6%9C%BA%E6%95%B0" target="_blank" rel="external">随机数</a>？如何测试一个<a href="https://zh.wikipedia.org/wiki/%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8" target="_blank" rel="external">随机数生成器</a>？<br><a id="more"></a></p>
<p>有些程序很容易测试，但并非所有程序都是如此。自动化测试的目的是以现在的时间成本，来换取未来的时间成本。很多程序员们经常自己写一个小玩意，就不爱写测试了，这是因为他们觉得这个小玩意也就用那么几次，不值得为它单写一个测试。从这个角度上看，这是没错的。大型项目经常会有比较完备的测试，因为这个项目可能会交付很长时间，也可能会有很长的维护时间。这时候测试的成本就可以在未来得到回报。测试随机数生成器，首先要回答的问题是：值不值得做这个测试？如果说这个随机数生成器本来就是系统提供的接口，那是否我们有必要费精力去测试它呢？如果它是不可靠的，那可能暗示着你的技术选型出了问题。如果它可靠（<a href="https://zh.wikipedia.org/wiki/%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%80%A7" target="_blank" rel="external">伪随机数</a>也算是可靠），那是否可以使用系统的随机数生成器来生成你自己特定的随机数生成器呢？在这种情况下，自己写的随机数生成器还是可能需要测试的。那应该怎么测试它呢？</p>
<p>让我们来举个简单的例子。比如我们需要得到由两位数字组成的随机字符串（”00”~”99”），它要做的仅仅是调用系统接口生成0~99的数字并格式化为”00”~”99”的字符串。这时我们只需测试它调用系统接口的参数，以及格式化的逻辑即可。而它们都可以通过mock等技术手段很容易地测试。在系统提供的随机数生成器的支持下，应该是可以满足大部分的随机需求的。</p>
<p>如果你非要以打硬仗的方式来测试随机数的话，除去成本因素，要想从纯技术上回答这个问题，那就要先回答另一个问题：什么是随机数？这就回到了业务的本质：在不考虑测试时，在什么情况下你会认为它是一个随机数？简单起见，我们就以0~99的伪随机数为例。取决于业务，可能你的需求是：①连续两次执行结果基本不同（“基本”是由于真随机的不可预测性，它们是可能相同的），或者是②连续执行100遍每次数字都不同，或者是③计算一万遍，要求结果呈现怎样怎样的分布。对于①来说，两次计算结果相同的概率只有百分之一（1% <em> 1% </em> 100），三次结果相同的概率只有万分之一（1% <em> 1% </em> 1% * 100）。所以测试可以这样来设计：调用两次，如果结果相同，那就再调用一次，如果还相同，那就再调用，直至不同为止。最后看调用次数<code>count</code>：如果<code>count = 2</code>，很好。如果<code>count = 3</code>，那就说明现在正好是1%的那次。如果<code>count = 4</code>，说明是0.01%的那次。理想情况下，如果每天运行100次测试，可能会有1次<code>count = 3</code>，运行100天，有1次<code>count = 4</code>，运行10000天（大约27年），会有一次<code>count = 5</code>。根据业务的容忍程度判断<code>count</code>的大小，例如当它大于5就算测试失败。虽然偶尔也会出现<code>count = 6</code>的情况，但是非常罕有，平均2700年会有一次，而且就算测试失败，也很容易排查到这个问题。所以就可以认为是符合业务需求。对于②来说，那就执行100遍看结果好了，也是技术上可实现的。对于③来说，其实与①有相似之处，只要能够描述出来，就能够测试出来。只要自己控制好测试的阈值就可以了。</p>
<p>维基百科上提供了一些<a href="https://zh.wikipedia.org/wiki/%E9%9A%8F%E6%9C%BA%E6%80%A7#.E9.9A.8F.E6.9C.BA.E6.80.A7.E6.B5.8B.E8.AF.95.E6.96.B9.E6.B3.95" target="_blank" rel="external">随机性测试方法</a>。只要能描述，就可以测试。但是，值得吗？</p>
]]></content>
      
        <categories>
            
            <category> development </category>
            
        </categories>
        
        
        <tags>
            
            <tag> test </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何尽量避免生产事故]]></title>
      <url>/avoid-production-accident/</url>
      <content type="html"><![CDATA[<p>运维不好当啊。上个月<a href="http://hs.blizzard.cn/articles/16/8565" target="_blank" rel="external">炉石传说数据库故障导致数据损坏</a>刚刚补偿完毕，这两天又出了个<a href="http://www.oschina.net/news/81473/gitlab-com-down" target="_blank" rel="external">GitLab误删生产数据库</a>。本文聊聊尽量避免生产事故的一些方法。<br><a id="more"></a></p>
<p>我看到<a href="http://mp.weixin.qq.com/s/kTA24o0opEk51Q-RNNWPKg" target="_blank" rel="external">圈内讨论</a>里有人说，重要系统维护的时候必须两个人一起干活，一个做另外一个在旁边看。这有点儿像是结对编程的思路。我觉得两个人一起固然会好一点，但从结对的实际经验来看，一来可能导致效率更低，二来两个人一起也不能保证不会出问题。大部分情况下这两个人的水平并不是一致的，水平高的人操作，容易导致另一个人只是干看着；而水平低的人操作，反而增加了误操作的几率，需要水平高的人紧盯着。</p>
<p>还有人说，改造一下<code>rm -rf</code>，让它只能删空目录，我觉得这是一个不错的点子。由于人总是可能会出错，所以由一个机制来保证（法制而非人治），效果应该更加理想。不过这种办法也有几个问题存在。一是所有的机器都需要替换并保持<code>rm</code>命令，二是操作的时候还是不免会稍微降低效率，三是误操作一般是在低意识的时候发生，<code>rm</code>的报错，固然有可能会警醒操作者，但也有可能在惯性思维的引导下使操作者直接调用重命名后的老<code>rm</code>。还有其它的办法吗？</p>
<p>我也来抛砖引玉一个：如果从数据库同步上着手呢？只要是关于删除数据库、数据表（数据记录单谈，视需求而定）的操作，都创建新库来备份旧数据而非直接删除。缺点一是需要修改同步工具的代码，工作难度比较大；二是需要定期清理同步数据库。</p>
<p>至于各种灾难恢复演练，确实很有必要，可惜目前的现实是大家每天手上都是一堆活儿，加上IT人员流动性又高，可操作性就欠缺了一点。无论如何，从性价比上来说，一个定期的备份绝对是避免进一步损失的救命稻草。当然，还有不断地学习……</p>
<p><img src="/img/mysql-drop-and-run.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> idea </category>
            
        </categories>
        
        
        <tags>
            
            <tag> soft skill </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[创业公司里就职的那些事儿]]></title>
      <url>/work-in-start-up/</url>
      <content type="html"><![CDATA[<p>创业公司和一般公司很不一样。第一次加入的小伙伴们如果了解得不够清楚，可能会像我当初那样一脸懵逼。本文主要说的是加入创业公司的一些值得注意的地方。<br><a id="more"></a></p>
<p>创业公司的特点就是快。哪怕代码写的烂，不好维护，也要比竞品更快地推出新功能。当然，这样的程序质量太差，过了一段时间就很难维护或是扩展了。所以在中期拉到投资之后，重心就转移到重构代码使之更稳定上面。当然也有只要修修补补能撑到上市那天就行的战略。至于后期，像阿里腾讯这样的，持续地为社区贡献出开源代码，那就已经是质量非常好的程序了。所以一句话总结就是：前期快速从无到有，中期从有到好，后期从好到精。</p>
<p>在大公司里，业务和体系都已经比较成熟了，你的位置可能就是一颗螺丝钉，但是可以研究得很深。而在创业公司里，对个人来说，会接触到方方面面的知识，得到更全面的发展，可能研究得广而不深。大公司的机会比较少，创业公司的机会比较多，倒闭的风险也很大。</p>
<h2 id="融资"><a href="#融资" class="headerlink" title="融资"></a>融资</h2><p>面试的时候，hr总会介绍：我们公司现在已经是A/B/C轮融资了，估值多少多少万美元。可是在当时的我看来，只不过是一个字母和一个数字罢了，没有太深的感触。它究竟有什么意义呢？这要从创业公司的成长过程说起了。来自36氪的下图说得非常清楚：<br><img src="/img/idea-to-ipo.jpg" alt=""></p>
<ul>
<li>种子轮和天使轮还没有产品，变数太大，就不细说了。</li>
<li>A轮意味着已经有了一小部分的用户规模，产品得到初步验证，但是对收入没有什么要求。</li>
<li>B轮意味着更大规模的用户，也开始要求有初步的商业模式了，对于共享单车这样的领域，很明显用户要使用就必须付费，所以自带商业模式光环，只要市场占有率高就行。</li>
<li>C轮意味着需要开始变现、盈利，不断地用钱去砸市场。如果市场还没有抢下来，很可能还需要继续融资往里烧钱。</li>
<li>到了DEF轮，就没有什么本质上的区别了。</li>
</ul>
<p>创业公司在C轮之前挂掉很正常，例如找不到盈利模式，或是占不住市场。到了D轮，挂掉的风险就非常小了，公司一般都是奔着上市去了，再不行还可以被收购。</p>
<h2 id="期权"><a href="#期权" class="headerlink" title="期权"></a>期权</h2><p>期权（option）是员工持股计划（ESOP，Employee Stock Ownership Plans）的一种方式，用于激励员工。期权本身并不是股票，但是赋予了员工以较低价格购买公司普通股（ordinary shares）的权利。一开始100%的股池里，可能会抽出10%~20%作为员工的持股。不过随着每一轮的新投资进来，包括前期投资人在内的所有人的股份都会被稀释。例如：某创业公司天使轮估值1000万，这时候天使投资人投了200万占20%，员工占10%，创始人占70%；到了A轮估值2000万，A轮投资人投了400万占20%，所以原来100%的总池子就只能占80%了，员工就被稀释成了8%，天使投资人变成了16%，创始人变成了56%。不过员工部分虽然原来从10%变成8%，看起来比例降了，但是价值由100万升值为160万，反而倒是更值钱了。不过出于公司持续发展，新人不断进入，需要激励员工的原因，新的投资人一般会要求保持员工的10%不变，那么多出来的2%就需要从创始人和各投资人之间博弈中产生了。</p>
<p>对于员工来说，进入创业公司，一般来说薪水会比正常公司低一些，但是公司会通过给予期权来提供一夜暴富的可能。一般都是预计给你多少多少股（例如一万股），每年给四分之一，头四分之一需要工作满一年之后才有，也有分季度给的，也有两年之后给一半的，也有根据公司业绩和个人表现，在入职一定时间之后再谈的，比较灵活。一般一年内离职，是拿不到期权的。如果公司已经上市，并且员工已经拿到了期权，就可以在解禁期后行权将其变为股票。公司与员工约定的价格成为行权价（exercise price），加入公司越早，行权价越低，甚至可能是0元。每一轮投资之后，由于估值上升，行权价也会上升。但是行权价对特定员工来说是固定的，也就是说，如果当初说的就是0.01刀一股，那么第四年行权价对此员工来说还是0.01刀一股。而第四年新加入的员工可能已经变成10刀一股的行权价了。越早进入收益越大，当然也伴随这更大的风险。同一时期加入的新员工，行权价是一样的，但是期权数量上可能会不一样。员工能赚取的收益，就是（当前每股价格－行权价）×股数-税收。如果运气不好碰到股票价格下降，也可以选择不行权。如果能等到上市，虽然很难，但是回报最高。有时候下一轮投资者进来，员工也会有机会套现一部分，但是套现的比例和对象都是由公司来决定的。虽然说上市最好，但是万一命不好碰上了普通股对美股18比1的稀释，也只有自吞苦水了。还有，期权是有有效期的，必须在规定的时间内行权，否则就作废了。</p>
<p>如果公司还未上市，那就麻烦了。要是员工获取了一些期权后，中途离职呢？一般看公司（创始人）的厚道程度，有这么几种做法：</p>
<ul>
<li>公司折价（例如70%或80%）回购，当然对员工来说非常有利了</li>
<li>保留期权，可以等到最终上市再行权，这样对员工来说也不错，但是对于公司来说，可能就会导致期权都发完了，后入职的员工就拿不到期权了</li>
<li>离职三个月或半年内确定是否行权，若行权则需要员工掏钱。风险较大，若最终未上市，可能股份就变得一文不值了</li>
<li>直接作废……</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://workspace.fx114.net/qa-203-156906.aspx" target="_blank" rel="external">《期权有哪些坑,你知道吗?》</a><br><a href="https://www.zhihu.com/question/23357108/answer/76897476" target="_blank" rel="external">《你该怎么选Offer》</a><br><a href="https://www.zhihu.com/question/19678660/answer/17228691" target="_blank" rel="external">《在创业公司工作，期权怎么发放？》</a></p>
]]></content>
      
        <categories>
            
            <category> idea </category>
            
        </categories>
        
        
        <tags>
            
            <tag> soft skill </tag>
            
            <tag> start up </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何打造一个好氛围的技术团队]]></title>
      <url>/build-tech-team/</url>
      <content type="html"><![CDATA[<p>在创业团队里，由于自身名气不响，聘用到合适的员工是非常困难的。我就曾经遇上过无数约好面试不来的，几个发完offer后不报道也不主动回复的，甚至还有面试过程中接到BAT电话提供offer于是立马拔脚走人的。本文尝试记录一下某创业公司里，从零开始打造一个好氛围的技术团队的一些心得。<br><a id="more"></a></p>
<h2 id="组建团队"><a href="#组建团队" class="headerlink" title="组建团队"></a>组建团队</h2><p>招聘难，并不意味着就要降低标准。与其为了眼前利益而将就着聘用一个不太合适的人，并可能在未来使你自己还要耗费精力紧盯他的工作，让大家都痛苦，倒不如一开始就不要入这个坑。实际上招聘员工还是有一些技巧的。最靠谱的，就是自己认识，或者是同事内部推荐的人。这样的人有自己或者同事的背书，相比简历pk加海选，一般还是靠谱得多的。设置一个还不错的推荐费，更能增加一些推荐的动力。猎头们手上也会有一些不错的资源，就是会比较贵一些。选对合适的招聘时机也很重要。过年之后有不少领了年终奖后由于各种原因要跳槽的人，对于公司来说，可以选择的余地多了不少。当然弊端是这时候的竞争对手也会有很多。不过如果你的公司有足够吸引力的话（要不然你为什么会在那里？），关系也不大。提供差异化的岗位也是一个办法。有时候招聘时会觉得这人挺不错的，但就是不太适合这个职位，这时如果有条件的话，可以把眼光放长远些，留得好萝卜，不怕没有坑。有些工作还可以考虑以外包、合作甚至兼职的方式完成，不一定非得通过招聘来解决。</p>
<p>团队的规模不要太大，不然管理起来又麻烦又累，效率也不高。也不要求每个人都非常资深，工作经验能够均匀地哈希开就可以了。团队成员的性格和技能上最好能够互补。性格上，可以参考<a href="/effective-communication">《人际风格与有效沟通实战》</a>这篇文章，配备各种性格的队员。技能上，最好每个队员都各有所长，这样才能相互学习，促进团队整体的健康发展。</p>
<h2 id="维护团队"><a href="#维护团队" class="headerlink" title="维护团队"></a>维护团队</h2><h3 id="根"><a href="#根" class="headerlink" title="根"></a>根</h3><p>有了团队之后，就需要让队员在团队里有家一般安心的感觉，这样才能集中精力，发挥出团队的战斗力。新招聘的人，由于对这个团队所知不多，根据各自的性格，可能会不敢表达，或者是急于表现。这就首先需要有一个能让新人感觉可靠的人物。虽然不至于时时嘘寒问暖，但是也要针对不同性格适时鼓励或是交代更多的背景知识。每当我去到一个新团队的时候，我就会把认识的人视为“根”，工作或是政策上有问题都会优先找他，就算他解决不了，也会告诉我应该找谁。有的公司会有类似的政策，称之为buddy或者是sponsor，以帮助新人迅速融入环境。所以为每位新人找到一个合适的“根”，让其从“根”上发芽并迅速成长为参天大树，就是团队领袖的任务之一。</p>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>团队成员如果只是通过工作维系在一起，这样的连接就不是那么的可靠。所以我们需要团队建设（team building）来增加工作之外的连接。我记得新团队的第一次团队建设，是参加一个密室逃脱。在游戏中，不仅能看到每个人的特点和配合能力，还能给未来增加不少谈资，从而加强团队成员间的连接。相比起来，如果只是吃顿饭……效果就比较有限了，但总是比没有强。所以许多公司会有针对新人的拓展训练。如果公司层面能够组织旅游那就更理想了，除了提振团队士气，甚至找到自己的另一半也不无可能。团队发展好了，就会自发产生各种活动，甚至邀请团队成员去自己家里玩，从而将同事变成了朋友，在这样的团队里工作相信一定是令人愉悦的享受，而不仅仅是为了养家糊口而工作。</p>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p><a href="http://wiki.mbalib.com/wiki/%E5%9B%A2%E9%98%9F" target="_blank" rel="external">团队是指一种为了实现某一目标而由相互协作的个体所组成的正式群体</a>，所以明确团队的目标是非常重要的，可以说没有目标就没有团队存在的必要。这个目标需要让所有的团队成员都心中有数。曾经有一段时间完成一期的开发工作之后，第二天团队突然发现没有活儿了，于是有人开始焦虑，有人开始懒散，还有人浑浑噩噩，不知道整天都做了些什么。直到PM组织大家开了一个小会，说明了接下来的目标之后，团队才找到了存在的价值，重新振奋士气走下去。实现团队目标的同时，也可以兼顾团队成员个体的目标，尽量使之也能协同实现。</p>
<h3 id="会议"><a href="#会议" class="headerlink" title="会议"></a>会议</h3><p>工作上，新人可能对别人都干了些什么不那么了解，会有一种“不那么透明”的感觉。每天早上团队<a href="https://zh.wikipedia.org/wiki/%E7%AB%99%E4%BC%9A" target="_blank" rel="external">站会（stand-up meeting）</a>是解决这个问题的良方之一。大家轮着说昨天都做了什么，今天要做些什么，遇到了哪些问题，有心的人自然能从中获取到有用的信息。<a href="https://zh.wikipedia.org/wiki/%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B" target="_blank" rel="external">结对编程（pair programming）</a>也有助于在团队成员之间共享信息，但是它的成本比较高，可以在创业公司中将其作为非常规手段，只在必要的时候结对即可。一个迭代或项目完成之后的<a href="https://zh.wikipedia.org/wiki/Scrum#Scrum.E4.BC.9A.E8.AE.AE" target="_blank" rel="external">回顾会议（retrospective）</a>也对改进团队效率、增加团队透明度很有帮助。大致做法如下：</p>
<ol>
<li>如果团队成员之间不很熟悉，或者氛围非常不好，需要做安全度检查，大家匿名打分，如果分数偏低，需要请在场人士中级别最高的人员离场，之后重复打分直至分数较高为止。如果一直都是很低，那团队肯定有问题。这个会也没有必要开了，领导需要在线下解决。这个是担心开会的时候，大家真话说得少，光说套话等。不说真话的会，不如不开，省的浪费大家时间。</li>
<li>主持人组织大家写一些便利贴，一般包含好的（well）、不好的（less well）和不确定的（puzzle）三类，然后将其贴在白板上并进行归类。一个well的例子可能是我们有XXX新人加入，一个less well的例子可能是好久没有团建了，一个puzzle的例子可能是我们好久没有code review了。主持人应该尽量客观，通常尽量少发表自己的看法。他还要负责时间上的控制，不要太发散了，导致问题都聊不完，或者聊太high了。建议主持人轮岗。</li>
<li>让大家都明白白板上的便利贴说的到底都是什么事。</li>
<li>让大家投票选出最想聊的几件事，然后讨论并记下可以做的行动（action）以及负责人。</li>
<li>主持人记录回顾内容并发给大家（wiki或邮件），这样可以在下次回顾会议的时候看看上次的行动进展如何了。</li>
</ol>
<h3 id="分权"><a href="#分权" class="headerlink" title="分权"></a>分权</h3><p>如果管理得太过精细，管理者难免会心力交瘁（有些人除外）。适当地放手，让团队成员自己负责某一块领域，不仅有助于管理者集中精力处理自己的任务，也更能促进团队成员的成长。即使管理者有事不在的时候，也能迅速找到后备者顶上，解决一些迫在眉睫的问题。每个团队成员都不一样，有些人不喜欢总是做一样的事情，这种时候就可以考虑轮岗，增加其技术广度。而有些人可能由于家庭或别的原因，希望稳定一段时间，这种时候就可以让其深入成为某一领域上的专家。所以一对一地聊一聊，确认对方的喜好，以及公司层面可以提供的支持，可以作为领导者的事前功课。</p>
<h3 id="提高效率"><a href="#提高效率" class="headerlink" title="提高效率"></a>提高效率</h3><p>团队的开发效率非常重要，可以说是关系到团队的存亡。这方面可以采用痛点驱动的办法来提高团队效率。例如，如果程序员写的代码，要部署上某个环境非常费劲，那就会迫使程序员尽量少去部署。这时候团队就需要有人站出来，解决部署慢的问题。有许多时候这其实就是个对某原则的妥协，或是对某个工具不太熟悉罢了。例如，当时团队开发app的h5端的时候，部署测试环境需要五分钟，导致调试效率低下。后来通过分析为什么慢，并打出一系列组合拳来解决那些原因，我们将部署时间缩短到了10秒，大家的工作热情很容易就起来了。还有一次由于包引用的关系，导致部署并调试本地环境需要耗时三分钟。分析原因之后，我们放弃了DRY原则，将比较类似的代码分散到了不同的代码库里，极大地提高了本地的调试效率。而被放弃的DRY原则在这种场景下其实并不是那么的适用。</p>
<p>许多程序员倾向于复制/粘贴代码来作为自己的模板。所以如果技术领导者想要大家写出什么样的代码，首先需要让自己的代码成为理想代码的模板。例如，如果我希望大家编写单元测试，那我的代码就需要有单元测试，这样当其他人复制的时候，就需要考虑单元测试怎么写的问题。但如果只是口头说说，很快就会流于形式。而模板当然不可能一口气就写得那么完美，所以当代码审查的时候，需要识别并不断改进烂代码，还要把思想传达给其他人，最终成为团队共同的财富。</p>
<h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><p>仅有工作的热情还不够，程序员其实并不是吃青春饭的职业，而是终身不断学习提高的职业。团队应该能够提供集体学习的环境，例如大家每周三晚上共同学习某一个课程（例如某个特定技术或是在线课程），共同成长。一个人学，学得快；一群人学，学得深。集体学习因为可以相互分享和讨论，学习效果要比个体学习更加突出。</p>
<h3 id="分享"><a href="#分享" class="headerlink" title="分享"></a>分享</h3><p>要想打造一个技术氛围浓厚的团队，适时地举办技术分享会是一个很不错的办法。一开始可能由于各种原因没人响应，这就需要团队领袖走出第一步并持续鼓励大家分享。如果团队成员不太自信，一开始的分享内容可以是非技术的，也可以是较短时间的。只要走出了第一步，后面总会越来越好的。分享除了让团队成员获取知识，更直接的其实是让分享者自身成长，还有助于将自己塑造成此领域的技术专家形象。分享可能会带来一些工作时间上的消耗（准备分享以及大家聚集在一起的时间），但是从长远来看是非常有益于团队成长和技术氛围构筑的。我所在的上一个团队就成功地推出了两档分享品牌，一个是每周五下午一个小时左右的技术主题分享，以及不定期的午间半小时非技术或是小技术分享。除了session形式的分享以外，还可以有workshop类型的分享，大家一起动手完成某个任务，效果更佳。</p>
]]></content>
      
        <categories>
            
            <category> idea </category>
            
        </categories>
        
        
        <tags>
            
            <tag> soft skill </tag>
            
            <tag> start up </tag>
            
            <tag> management </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[性能调优的一些技巧总结]]></title>
      <url>/performance-tuning/</url>
      <content type="html"><![CDATA[<p>程序猿和攻城狮们天天写代码，难免碰到别人反映程序慢。我自己就碰到了许多次这样的问题。现在将一些心得记录总结一下，以便大家和未来的自己参考。总体原则是：不能无的放矢。<br><a id="more"></a></p>
<p>曾经面试过一个人，问对方说如果有一天客服反馈说你编写的页面加载很慢，那你应该怎么办？对方想了想：加缓存呗。可是此时连慢的原因都还不知道呢，加缓存能管用么？不管如何，首先得知道哪里慢，然后针对慢的地方对症下药，才是解决之道。没有数据的性能调优就是耍流氓！就像这几天霾绕帝都，让人想起炒菜油烟的梗。难道所有人不炒菜雾霾就能消失？首先还是要收集数据，到底慢（mái）的主要原（chéng）因（fèn）是什么？</p>
<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>十年前，那会儿还没有chrome呢。当时web页面调得没有什么问题了，然后在客户那边渲染就是很慢。看了一下数据量确实很大，于是用最原始的办法：加上alert()来人肉估计一下运行时间，然后就发现下面这段代码很慢：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123; ... &#125;</div></pre></td></tr></table></figure></p>
<p>可是循环体的内容很简单，怎么看都不太会影响处理速度的样子，那问题出在哪里呢？抱着试试看的想法，把代码变成这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int length = arr.length;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123; ... &#125;</div></pre></td></tr></table></figure>
<p>居然问题就解决了！从此后写js的习惯就变了……当然现代的浏览器都对类似的代码进行了优化，所以这么奇怪的事情已经不太常见了。我们有了强大的chrome，可以用Profiles来测试网页的性能：<br><img src="/img/chrome-profiler.jpg" alt=""></p>
<p>开Profile后，在百度上搜索“性能调优”就能得到上图的结果，从中可以看出到底哪个地方耗时最多，然后采取针对性的措施。有一年除夕夜，大家都早早离开了，可是我还要处理一个页面的性能问题，否则春节期间在客户现场支持的同事就要遭殃了。当时就是用Profile找到速度极慢的函数，发现它还被调用了2+n遍，最后改成了只调用1遍，便把性能提上来了。当然，这两个例子都是在我确切地知道问题发生在前端的时候才用的方式。而网页慢的原因不一定只是前端，所以需要结合Network一起看：<br><img src="/img/chrome-network.jpg" alt=""></p>
<p>如果request持续时间占的比重很大，那就需要跑到后端看看了。如果一个web页面明显慢，但是时间又在前后端分布均匀，那么恭喜你，前后端的调优都得一起做了，否则性能提升恐怕不会那么的明显。这样的机会可不是每个程序员都能得到的。前端的算法也是一个可能会出事故的点。有一次的需求就是页面的一棵树，每个枝叶都有一个checkbox，在选择枝的时候要把叶都选上。如果数据量有可能比较大的话，算法的优劣一般就直接决定了用户的体验。算法因需求而异，这里就不展开细说了，刷刷<a href="https://leetcode.com/" target="_blank" rel="external">LeetCode</a>吧。</p>
<p>有时候，速度慢在资源加载上。例如，一个angular的库就100多k，再加上其它七七八八的类库，还有自己的js代码，一开始需要下载1M的js文件。CDN、minify这些手段之外，还有一种办法就是，让下载大文件在用户的操作期间来做。例如，企业级web应用的统一入口一般都是login页面，这时候用户需要填写自己的凭证信息，而这是需要一段时间的。如果在这段时间内把大文件下载并缓存到浏览器里，虽然还是比较慢，但是并不太会影响用户体验。还可以拆分相对来说不太会变化的代码和变化可能会较频繁的代码，这样在部署新版本之后，不太会变化的代码的缓存就可以重复利用起来了。</p>
<p>上面的办法其实就是异步的思路。有时候代码是这样工作的：一个ajax完成之后，再发另一个ajax以请求其它信息。这时候就可以看看是否这两个ajax请求有依赖，如果没有依赖，完全可以并行运行，如果有依赖，也可以考虑是否能合并为一个更特定一些的请求。</p>
<h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><p>后端可以发挥的空间相对来说更大一些。缓存用好了是一剂良药，用不好就是一剂毒药。毕竟<a href="http://martinfowler.com/bliki/TwoHardThings.html" target="_blank" rel="external">命名和缓存失效是计算机科学里面最难应对的两件事</a>。前一阵子某电商的模块里，从后端获取商品极慢，然后就发现了gateway在获取商品的API里，竟然向商品服务发了几百个请求，不慢才怪呢。统计了一下，这里面至少有90%都是参数相同的重复请求，使用30秒的短缓存，便可以立即减少重复请求，提高90%的性能，这样用户的感知就非常明显了。但实际上，还是需要分析代码，为什么会有这么多的重复请求？多半还是代码写的有问题。缓存是治标之道，立竿见影，但要治本，还是需要从代码上着手，优化代码本身。还有一些可以做的，是提供合并查询的API，例如除了提供getSkuById()以外，再提供一个getSkusByIds()的方法，当然还要小心不要出现<a href="http://stackoverflow.com/questions/97197/what-is-the-n1-selects-issue" target="_blank" rel="external">n+1</a>的问题。还有一个C#里经常会碰到的性能问题，那就是过早地计算linq的实际值。Java 8的流里也有类似的可能。</p>
<p>有时候，性能问题与需求有关系。曾经碰到过的一个需求是：用户注册的时候，要求昵称不能重复。如果重复了，推荐3个以递增数字结尾的新昵称给用户。例如，ggg被注册了，推荐ggg1、ggg2、ggg3给用户。当然还需要判断ggg1、ggg2、ggg3是否也被注册了，否则还得往后加。而验证昵称的代码因为需要访问数据库导致比较慢。有一段时间，用户很喜欢使用这个昵称：༺༻，都排到100号了。每当新用户想使用这个昵称的时候，后台都需要判断100次以上，因为༺༻1到༺༻100都被占用了。这时候就可以跟产品经理讨论讨论，是否需要推荐昵称？是否可以改变推荐昵称的方式？例如增加日期到推荐昵称里以避免重复。必要时，还可以挑战一下：有多少用户使用了我们系统推荐的昵称？如果需求实在是硬邦邦完全不能变，那只能考虑一些技术手段了，例如给数据库里用户表的昵称字段增加索引、缓存常见昵称的当前最大值、甚至动大刀子弄个昵称服务，或是备份数据库等，看看是否付出能够值回票价了。还有一次是推荐好友的功能，要求随机同城异性等级高，说不定还需要考虑年龄星座喜好呢，这些大多是不常用的字段，也滤不掉太多数据，查找起来自然很慢，这样也需要看看业务价值究竟有多大。</p>
<p>后端不像前端那样打开浏览器就能看到性能信息，也很难通过调试的方式来看生产环境为什么慢。这个时候如果框架里有处理时间日志，就会对排除性能问题非常有帮助。如果配置了ELK或者Splunk，就可以轻松找到可疑的接口。用户模块新上线的时候，就曾经直接定位到推荐好友的API速度慢，从而找到那条缓慢的SQL。哪怕是模块正常工作期间，也能通过日志看到一些有用信息。有天晚上从日志里发现用户注册API特别慢，后来知道原来是电信/联通的问题，当天如果通过微信/微博注册的用户，由于网络不通畅，导致整个用户注册响应都有问题。如果部署在阿里云上，云抽风了也并不罕见。另外所有与外部请求有关的模块，都有潜在的性能风险。使用外部请求的模块一般都有微信/微博授权、微信/支付宝付款、SMS网关、埋点、物流/天气接口、各种云服务/CDN等等。</p>
]]></content>
      
        <categories>
            
            <category> development </category>
            
        </categories>
        
        
        <tags>
            
            <tag> performance tuning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[终端录制工具推荐]]></title>
      <url>/terminal-recorder/</url>
      <content type="html"><![CDATA[<p>Mac自带的QuickTime Player就有录屏的功能，所以平时如果录一段操作什么的很方便。但是视频嘛，终究是比较大的。如果仅仅是录制命令行的话，可以考虑本文里介绍的工具。<br><a id="more"></a></p>
<h2 id="showterm"><a href="#showterm" class="headerlink" title="showterm"></a>showterm</h2><p><a href="http://showterm.io/" target="_blank" rel="external">showterm</a>是一个用ruby编写的开源命令行录屏工具，用起来超级简单。使用<code>gem</code>来安装：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo gem install showterm</div></pre></td></tr></table></figure></p>
<p>录制更简单：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">showterm</div></pre></td></tr></table></figure></p>
<p>然后就可以自行敲入各种命令来录制了，使用<code>exit</code>或者Ctrl+D快捷键结束录制。showterm会把录制结果直接上传并给出一个网址，如：<a href="http://showterm.io/6ccdbde054d30d825934e" target="_blank" rel="external">http://showterm.io/6ccdbde054d30d825934e</a>，这样就能很方便地分享给朋友们啦。要想嵌入到自己的网页上也没有问题：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://showterm.io/6ccdbde054d30d825934e"</span> <span class="attr">width</span>=<span class="string">"640"</span> <span class="attr">height</span>=<span class="string">"480"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>效果如下：</p>
<iframe src="http://showterm.io/6ccdbde054d30d825934e" width="640" height="480"></iframe>

<h2 id="TermRecord"><a href="#TermRecord" class="headerlink" title="TermRecord"></a>TermRecord</h2><p><a href="https://github.com/theonewolf/TermRecord" target="_blank" rel="external">TermRecord</a>是一个用python编写的开源命令行录屏工具。使用<code>pip</code>来安装：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">brew install ttyrec</div><div class="line">sudo easy_install pip</div><div class="line">sudo pip install TermRecord</div></pre></td></tr></table></figure></p>
<p>有别于showterm，它不会自动上传到网上，而是生成一个html文件，想要分享的话，你可以将其发送给好友。录制同样简单：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">TermRecord -o ggg.html</div></pre></td></tr></table></figure></p>
<p>同样使用<code>exit</code>或者Ctrl+D快捷键结束录制。要想查看录制结果，直接浏览器打开<code>ggg.html</code>就可以了。</p>
<h2 id="asciinema"><a href="#asciinema" class="headerlink" title="asciinema"></a>asciinema</h2><p><a href="https://asciinema.org/docs/getting-started" target="_blank" rel="external">asciinema</a>是一个用ClojureScript编写的开源命令行录屏工具。相比上面的工具，asciinema综合了它们各自的优点，最为强大。使用<code>brew</code>来安装：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew update &amp;&amp; brew install asciinema</div></pre></td></tr></table></figure></p>
<p>用<code>pip3</code>来安装也可以：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo pip3 install asciinema</div></pre></td></tr></table></figure></p>
<p>录制还是简单：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">asciinema rec</div></pre></td></tr></table></figure></p>
<p>还是使用<code>exit</code>或者Ctrl+D快捷键结束录制。与showterm不同的是，它会在结束录制的时候提示，如果要上传的话，敲回车，这样就不至于把废品也上传了。上传之后，asciinema会给出一个网址，如：<a href="https://asciinema.org/a/44nu2i2ieywlmqq9wx5sk5k1e" target="_blank" rel="external">https://asciinema.org/a/44nu2i2ieywlmqq9wx5sk5k1e</a>。要想嵌入到自己的网页上也没有问题：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"https://asciinema.org/a/44nu2i2ieywlmqq9wx5sk5k1e.js"</span> <span class="attr">id</span>=<span class="string">"asciicast-44nu2i2ieywlmqq9wx5sk5k1e"</span> <span class="attr">async</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>效果如下：</p>
<script type="text/javascript" src="https://asciinema.org/a/44nu2i2ieywlmqq9wx5sk5k1e.js" id="asciicast-44nu2i2ieywlmqq9wx5sk5k1e" async></script>

<p>如果不想上传，可以用这条命令将其保存为一个json文件：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">asciinema rec ggg.json</div></pre></td></tr></table></figure></p>
<p>使用以下命令可以查看录制结果：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">asciinema play ggg.json</div></pre></td></tr></table></figure></p>
<p>甚至可以再次上传：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">asciinema upload ggg.json</div></pre></td></tr></table></figure></p>
<p>还能通过<code>asciinema auth</code>命令并在<a href="https://asciinema.org/login/new" target="_blank" rel="external">asciinema</a>上注册账号来管理自己上传的文件，功能上确实是这几个工具中最强大的。</p>
]]></content>
      
        <categories>
            
            <category> tool </category>
            
        </categories>
        
        
        <tags>
            
            <tag> showterm </tag>
            
            <tag> TermRecord </tag>
            
            <tag> asciinema </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[领域驱动设计DDD]]></title>
      <url>/ddd/</url>
      <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Domain-driven_design" target="_blank" rel="external">Domain Driven Design</a>（DDD）是Eric Evans于2004在其同名著作里提出的概念，它指明了让软件设计满足理想需求模型的方向。但是建模、设计这种事本来就很抽象，读懂这样的大作也是需要消耗不少脑细胞。本文希望能尽量以简单加实例的方式介绍DDD里的一些常见概念。<br><a id="more"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="什么是领域"><a href="#什么是领域" class="headerlink" title="什么是领域"></a>什么是领域</h3><p>《领域驱动设计》书里写的是：用户会把软件程序应用于某个主体区域，这个区域就是软件的领域。简单来说，就认为是公司的某块业务好了。如果领域比较大，可以将其拆分为多个子域（Subdomain），子域包含核心域（Core Domain）和支撑子域（Supporting Subdomain），核心域顾名思义，是最重要的子域，我们应该把关注点集中在它上面；其余的子域都是支撑子域。支撑子域里有一类特殊的用于解决通用问题的子域，称为通用子域（Generic Subdomain），例如用户和权限等。不过这些都是相对而言的，对于消费方来说，他的支撑子域有可能就是你的核心域。个别子域可能会有交集，称为共享内核（Shared Kernel），目的是减少重复，但是仍保持两个独立的上下文。由于不同子域的开发团队可能会同时修改共享内核，所以需要小心并注意沟通。</p>
<h3 id="要DDD做什么"><a href="#要DDD做什么" class="headerlink" title="要DDD做什么"></a>要DDD做什么</h3><p>DDD试图解决的是软件的复杂性问题，如果软件比较复杂，或者是预期会很复杂，或者是你不知道，那么都可以开始考虑DDD。否则，由于维系领域模型需要实现大量的封装和隔离，DDD会带来较大的成本。但是，DDD并不是一个笨重的开发过程，它能够和敏捷开发很好地结合起来，另外，DDD也倾向于“测试先行，逐步改进”。</p>
<h2 id="战略建模（Strategic-Modeling）"><a href="#战略建模（Strategic-Modeling）" class="headerlink" title="战略建模（Strategic Modeling）"></a>战略建模（Strategic Modeling）</h2><h3 id="通用语言（Ubiquitous-Language）"><a href="#通用语言（Ubiquitous-Language）" class="headerlink" title="通用语言（Ubiquitous Language）"></a>通用语言（Ubiquitous Language）</h3><p>其实写软件就像是翻译，把领域上的业务需求翻译成软件的各个功能。业务需求来自领域专家（Domain Expert），程序员们需要把领域专家的语言翻译成程序。如果程序员们翻译的时候使用的是自己的语言，而领域专家使用自己的行话，导致术语不一致，就会使得沟通不顺畅，难于消化知识。所以团队需要一种通用语言来进行沟通。这样的通用语言尽量以业务语言为主，而非技术语言。一开始的通用语言可能不尽完美，但它就像是代码一样，经常需要重构。例如：“创建一个订单”就比“插入一条订单数据”更容易让领域专家明白谈话的背景。</p>
<h3 id="限界上下文（Bounded-Context）"><a href="#限界上下文（Bounded-Context）" class="headerlink" title="限界上下文（Bounded Context）"></a>限界上下文（Bounded Context）</h3><p>通用语言里，同一个名词在不同的场景里不一定有相同的意思。比如用户，在推荐好友（可能关注年龄、性别、地域）或是浏览商品（可能关注喜好、历史购买记录）的时候有着不同的含义。所谓的不同的场景，其实就是不同的限界上下文。子域在限界上下文中完成开发。限界上下文主要用来封装通用语言和领域模型，显式地定义了领域模型的边界。不同的限界上下文，都会有一套自己的通用语言。通过这样的划分方式，来让每个限界上下文都尽量保持简单，也算是<a href="https://en.wikipedia.org/wiki/Single_responsibility_principle" target="_blank" rel="external">SRP</a>原则在不同粒度上的一个体现。如果不去做这样的划分，可能最终这个软件就会演变成一个<a href="https://en.wikipedia.org/wiki/Big_ball_of_mud" target="_blank" rel="external">大泥球</a>，或者说是<a href="https://en.wikipedia.org/wiki/Monolithic_application" target="_blank" rel="external">单块系统</a>。尽管如此，对于比较小的业务或项目来说，可能只会有一个限界上下文。现在流行的<a href="https://en.wikipedia.org/wiki/Microservices" target="_blank" rel="external">微服务</a>，很大程度上就是按照限界上下文来划分服务。例如：商品上下文，订单上下文，物流上下文等。当然，如果子域很小，不见得非得微服务化。</p>
<p>不同的限界上下文之间，通过上下文映射图（Context Map）来进行交互。上下文映射图其实就是一个简单的框图，表示限界上下文之间的的映射关系。下面这张图就是一个简单的例子：<br><img src="/img/ddd-context-map.jpg" alt=""></p>
<p>U表示上游（Upstream）的被依赖方，D表示下游（Downstream）的依赖方。由于上下游的限界上下文模型不同，实现时，可以用RPC、Restful、消息机制等集成方式。另外，下游需要防腐层（Anticorruption Layer）来将上游的返回内容翻译为下游的领域模型。如果防腐层过多地使用了各种赋值，从而导致上下游的模型非常类似，那就需要看看是否下游过多地使用了上游的数据，从而导致自己的模型不清晰。</p>
<h2 id="战术建模（Tactical-Modeling）"><a href="#战术建模（Tactical-Modeling）" class="headerlink" title="战术建模（Tactical Modeling）"></a>战术建模（Tactical Modeling）</h2><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><h4 id="实体（Entity）"><a href="#实体（Entity）" class="headerlink" title="实体（Entity）"></a>实体（Entity）</h4><p>所谓领域，反映到代码里就是模型。模型分为实体和值对象两种。实体是有标识（Identity）的，两个拥有相同属性的实体不是相等的，除非它们的标识相等；而不同实体的标识不能相等。例如：某人下了两个相同的订单，里面都购买了相同的商品。这两个订单就是有标识（订单号）的两个实体，虽然内容相同，但它们是两个不同的实体。常用的标识有自增数字、Guid、自然标识（如邮箱、身份证号）等。实体具有生命周期，它们的内容可能在这期间会发生改变，但是标识是永远不会变化的。实体作为领域模型的主体，需要拥有自己的方法，方法名来自于通用语言。通过这些方法来保证自己始终是一致的状态，而非被调用者set来set去。例如：<code>people.runTo(x, y)</code>，而非<code>people.setX(x);people.setY(y);</code></p>
<h4 id="值对象（Value-Object）"><a href="#值对象（Value-Object）" class="headerlink" title="值对象（Value Object）"></a>值对象（Value Object）</h4><p>实体用来表示领域中的一个东西，而值对象只用于描述或度量一个东西。值对象没有任何标识，只要两个值对象的属性相等，那么它们就是相等的。值对象是不可变的，如果要改变值对象的内容，那就重新创建一个值对象。值对象没有生命周期，因为它只是值而已。例如：金额（含数值和货币单位），颜色（含rgb值）等。因为不需要标识，所以它们其实比实体要简单许多。Java里的String类，就具有一个值对象的行为；C#的Struct其实就是一个值对象，不过一般还是会用Class来表示值对象。</p>
<p>不同的领域需求可能会催生不同的建模。例如：考虑一下演出的售票系统。如果需求是对号入座，那么座位就是实体，一旦某张演出票关联了某个座位，那么这个座位就再也不能被其它的演出票所关联了。如果需求是先到先坐，那么座位就是值对象，我们只关心卖了多少张演出票，不要超过座位上限即可，而并不用关心哪个座位被哪张票所关联了。</p>
<p>DDD的一个反模式就是拥有一堆<code>get</code>和<code>set</code>方法的贫血领域对象（Anemic Domain Object）。这样的对象只是一个数据持有器（data holder），而非我们想要的领域模型。值对象和实体一样，都需要有自己的方法。例如：金额值对象，有一个<code>Add</code>的方法，接受一个金额参数，返回一个新的值对象。</p>
<p>实体里可以包含值对象，值对象里也可以包含实体。</p>
<h4 id="领域服务（Domain-Service）"><a href="#领域服务（Domain-Service）" class="headerlink" title="领域服务（Domain Service）"></a>领域服务（Domain Service）</h4><p>有些操作不属于实体或者值对象，那就不用强塞给它们，创建领域服务来提供这些操作吧。留意通用语言，如果里面出现了名词，那一般就是实体或值对象；如果里面出现了动词，那通常就意味着领域服务。例如：支付，这是一个比较明显的业务操作。另外，如果有什么操作会让实体变得臃肿，也可以使用领域服务来解决。但是，不能把所有的东西都堆到领域服务里，过度使用领域服务会导致贫血对象的产生。</p>
<p>据Eric Evans所言，设计良好的领域服务具有以下三个特征：</p>
<ul>
<li>操作不是实体/值对象的一个自然的部分</li>
<li>接口根据领域模型的其它元素定义</li>
<li>操作无状态</li>
</ul>
<p>还需要注意的是，不要把领域服务和应用服务混起来了。我们在领域服务里处理业务逻辑，而并不在应用服务里处理。应用服务是领域模型的直接客户，负责处理事务、安全等操作。</p>
<h4 id="领域事件（Domain-Event）"><a href="#领域事件（Domain-Event）" class="headerlink" title="领域事件（Domain Event）"></a>领域事件（Domain Event）</h4><p>《领域驱动设计》一书出版之后，DDD社区并没有停止前进的步伐。领域事件就是在那之后提出来的。领域事件是一个定义了领域专家所关心的事件的对象。当关心的状态由于模型行为而发生改变时，系统将发布领域事件。如果通用语言里出现了：“当……的时候，需要……”通常就意味着一个领域事件。例如：当订单完成支付时，商品需要出库。这里的订单完成支付就预示着一个OrderPaidEvent，里面持有着这个订单的标识。领域事件代表的是已经发生的事，所以命名上通常都使用过去时（如Paid）。对领域事件的处理就像是一个观察者模式，由领域事件的订阅方来决定。订阅方既可以是本地的限界上下文，也可以是外部的限界上下文。</p>
<h4 id="模块（Module）"><a href="#模块（Module）" class="headerlink" title="模块（Module）"></a>模块（Module）</h4><p>如果领域模型发展得比较快，很难整体来讨论它，因为太大了。我们可以将模块视为Java中的包或是C#中的命名空间。将模型组织到不同的模块中，可以有效地降低领域的复杂性。模块之间应该是低耦合的，而模块内部应该是高内聚的。模块的名称应该是通用语言的组成部分，反映出领域的深层知识。</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><h4 id="聚合（Aggregate）"><a href="#聚合（Aggregate）" class="headerlink" title="聚合（Aggregate）"></a>聚合（Aggregate）</h4><p>聚合就是一组应该呆在一起的对象，聚合根（Aggregate Root）就是聚合在一起的基础，并提供对这个聚合的操作。聚合除了聚合根以外，还有自己的边界（boundary），即聚合里有什么。例如：一个订单可以有多个订单明细，订单明细不可能脱离订单而存在，而订单也不可能没有订单明细。这种情况下，订单和订单明细就是一个聚合，而订单就是这个聚合的聚合根，订单和订单明细就处于这个聚合的边界之内。如果要变更订单明细，我们需要通过操作聚合根订单来实现，如<code>order.changeItemCount()</code>，而非订单明细自身。另外一个例子：一名客户可以有多个订单，订单不可能脱离客户而存在，而客户却可以没有订单。这种情况下，客户和订单就是不同的两个聚合，一个聚合以客户为聚合根，另一个聚合以订单为聚合根，引用客户的标识。客户里并不引用订单的标识，这样将关联减至最少有助于简化对象的关系网。但是带来的一个麻烦就是如果要查找某位客户的所有订单，就不得不从所有的订单里查，而不能从客户这个聚合里直接获得。最后再举一个多对多的例子：一个班级可以有多名学生，学生可以脱离这个班级而存在，而班级不能没有学生，学生也不能不在班级里。这种情况下，班级和学生也是不同的两个聚合，一个聚合以班级为聚合根，引用学生的标识；另一个聚合以学生为聚合根，引用班级的标识，将多对多转换成两个一对多。</p>
<p>聚合是持久化的一个单位，我们需要保证以聚合为单位的数据一致性。如果聚合太大，那就会导致并发修改困难，多人并发修改同一个聚合里的不同项目，结果就是只有第一个提交的人成功修改，其它人不得不重新刷新聚合才能再次修改。大聚合还会导致性能问题，因为操作实体时会将整个大聚合同时加载进内存。珍爱生命，拒绝大聚合。</p>
<p>聚合根必须是实体而非值对象，因为它需要整体持久化，所以一定会有标识。而聚合根里的各个元素，既可能是实体，也可能是值对象。例如：一个订单（聚合根）一般会有订单明细（实体）和送货地址（值对象）。这些元素里可以有对聚合根的引用，但是不能相互引用。任何对其它元素的操作都必须通过聚合根来进行。聚合根里的标识是全局的，聚合根里的实体标识是聚合里唯一的本地标识，因为对它的访问都是通过聚合根来操作的。聚合根拥有自己独立的生命周期，其实体的生命周期从属于其所属的聚合，值对象因为只是值而已，并没有生命周期。</p>
<h4 id="工厂（Factory）"><a href="#工厂（Factory）" class="headerlink" title="工厂（Factory）"></a>工厂（Factory）</h4><p>工厂是生命周期的开始阶段，它可以用来创建复杂的对象或是一整个聚合。复杂对象的创建是领域层的职责，但它并不属于被创建的对象自身的职责。实体和值对象的工厂不太一样，因为值对象是不可变的，所以需要工厂一次性创建一个完整的值对象出来。而实体工厂则可以选择创建之后再补充一些细节。</p>
<h4 id="资源库（Repository）"><a href="#资源库（Repository）" class="headerlink" title="资源库（Repository）"></a>资源库（Repository）</h4><p>资源库是生命周期的结束，它封装了基础设施以提供查询和持久化聚合的操作。这样能够让我们始终聚焦于模型，而把对象的存储和访问都委托给资源库来完成。以订单和订单明细的聚合为例，因为一定是通过订单这个聚合根来获取订单明细，所以可以有订单的资源库，但是不能有订单明细的资源库。也就是说，只有聚合才拥有资源库。需要注意的是，资源库并不是数据库的封装，而是领域层与基础设施之间的桥梁。DDD关心的是领域内的模型，而并非是数据库的操作。理想的资源库对客户（而非开发者）隐藏了内部的工作细节，委托基础设施层来干那些脏活，到关系型数据库、NOSQL、甚至内存里读取和存储数据。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://book.douban.com/subject/5344973/" target="_blank" rel="external">《领域驱动设计》</a><br><a href="https://book.douban.com/subject/25844633/" target="_blank" rel="external">《实现领域驱动设计》</a><br><a href="http://www.infoq.com/cn/minibooks/domain-driven-design-quickly-new" target="_blank" rel="external">《领域驱动设计精简版》</a> by InfoQ<br><a href="http://devlicio.us/blogs/casey/archive/2009/02/09/domain-driven-design-a-step-by-step-guide.aspx" target="_blank" rel="external">《Domain Driven Design: A Step by Step Guide》</a>系列</p>
]]></content>
      
        <categories>
            
            <category> architecture </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DDD </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[轻松上手数据库版本管理工具Flyway]]></title>
      <url>/flyway/</url>
      <content type="html"><![CDATA[<p><a href="https://flywaydb.org/" target="_blank" rel="external">Flyway</a>是一个用Java编写的开源数据库版本管理工具，或者说是数据库结构变更工具，旨在帮助开发和运维更容易地管理数据库演进过程中的各个版本。它的源代码在<a href="https://github.com/flyway/flyway" target="_blank" rel="external">github</a>上。<br><a id="more"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在开发过程中，数据库是不断向前演进的，可以说是拥有“版本”这个概念。通常当在生产环境部署新代码的时候，会由开发或者DBA来做数据库结构变更的操作。当数据库较小，环境数量少的时候，人工操作比较有把握，直接就人肉来做结构变更了。可要是在数据库复杂、环境数量多（开发、测试、预发布、生产……）的情况下，人工处理这样的事就开始有些令人担心了。如何保证所有环境的数据库结构是一致的？如何知道当前环境的数据库是哪个状态？如何知道生产环境的一个关于数据库的hotfix是否也在预发布环境中执行了？Flyway就是用来解决这样的问题的工具。它的原理非常简单，就是在数据库中创建一张自己用的表，例如schema_version，在里面存放数据库当前的状态，以此来管理数据库的版本。Flyway提供了<a href="https://flywaydb.org/getstarted/firststeps/commandline" target="_blank" rel="external">命令行</a>、<a href="https://flywaydb.org/getstarted/firststeps/api" target="_blank" rel="external">API</a>、<a href="https://flywaydb.org/getstarted/firststeps/maven" target="_blank" rel="external">Maven</a>、<a href="https://flywaydb.org/getstarted/firststeps/gradle" target="_blank" rel="external">Gradle</a>、<a href="https://flywaydb.org/getstarted/firststeps/ant" target="_blank" rel="external">Ant</a>、<a href="https://flywaydb.org/getstarted/firststeps/sbt" target="_blank" rel="external">SBT</a>等各种方式，来让我们更容易将其与自己的项目结合。类似的工具还有<a href="http://www.liquibase.org/" target="_blank" rel="external">Liquibase</a>、<a href="http://dbdeploy.com/" target="_blank" rel="external">dbdeploy</a>等。</p>
<p>本文将会用Docker来创建一个mysql的实例，用Maven来创建一个包含数据库的Java项目，并使用Flyway来进行版本管理。</p>
<h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><p>首先请自行安装Docker、Java、Maven和喜欢的IDE。我用的是<a href="https://www.jetbrains.com/idea/download/" target="_blank" rel="external">Intellij IDEA社区版</a>。我用Vagrant启动了一台已经安装过Docker的Ubuntu虚拟机，它的IP是<code>192.168.33.88</code>，可以用以下命令来直接启动mysql容器来提供数据库服务并创建ggg数据库：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker run -d --net=host --name=mysql -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7.12</div><div class="line">docker <span class="built_in">exec</span> -it mysql mysql -uroot -p123456 -e <span class="string">'create database ggg;'</span></div></pre></td></tr></table></figure></p>
<p>接下来新建一个Maven工程helloFlyway：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mvn archetype:generate -B \</div><div class="line">        -DarchetypeGroupId=org.apache.maven.archetypes \</div><div class="line">        -DarchetypeArtifactId=maven-archetype-quickstart \</div><div class="line">        -DarchetypeVersion=1.1 \</div><div class="line">        -DgroupId=org.ggg.flyway \</div><div class="line">        -DartifactId=helloFlyway \</div><div class="line">        -Dversion=1.0-SNAPSHOT \</div><div class="line">        -Dpackage=org.ggg.flyway</div></pre></td></tr></table></figure></p>
<p>在<code>helloFlyway/pom.xml</code>里加入flyway的maven插件和mysql-connector-java的依赖（别忘了根据你自己的数据库来配置jdbc）：<br><figure class="highlight xml"><figcaption><span>pom.xml</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">...</span>&gt;</span></div><div class="line">    ...</div><div class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.flywaydb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flyway-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">url</span>&gt;</span>jdbc:mysql://192.168.33.88:3306/ggg<span class="tag">&lt;/<span class="name">url</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">user</span>&gt;</span>root<span class="tag">&lt;/<span class="name">user</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">password</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">password</span>&gt;</span></div><div class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.38<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">                <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>接下来创建一个数据库版本1的文件：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> helloFlyway</div><div class="line">mkdir -p src/main/resources/db/migration/</div><div class="line">cat &lt;&lt; EOF &gt; src/main/resources/db/migration/V1__Create_person_table.sql</div><div class="line">create table PERSON (</div><div class="line">    ID int not null,</div><div class="line">    NAME varchar(100) not null</div><div class="line">);</div><div class="line">EOF</div></pre></td></tr></table></figure></p>
<p>工程创建好并用intellij导入后，应该是这样的：<br><img src="/img/flyway-new-project.jpg" alt=""></p>
<h2 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h2><p>使用以下命令来运行flyway：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mvn flyway:migrate</div></pre></td></tr></table></figure></p>
<p>出现<strong>BUILD SUCCESS</strong>就说明数据库结构变更已经完成了。我们可以登录到数据库看一看：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> -it mysql mysql -uroot -p123456</div></pre></td></tr></table></figure></p>
<p>运行以下sql就可以看到flyway确实已经起作用了：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">USE</span> ggg</div><div class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLES</span>;</div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> schema_version;</div></pre></td></tr></table></figure></p>
<p>而表schema_version里面也有了一条记录。接下来再创建一个数据库版本2的文件：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cat &lt;&lt; EOF &gt; src/main/resources/db/migration/V2__Add_people.sql</div><div class="line">insert into PERSON (ID, NAME) values (1, <span class="string">'Axel'</span>);</div><div class="line">insert into PERSON (ID, NAME) values (2, <span class="string">'Mr. Foo'</span>);</div><div class="line">insert into PERSON (ID, NAME) values (3, <span class="string">'Ms. Bar'</span>);</div><div class="line">EOF</div></pre></td></tr></table></figure></p>
<p>再次用同一条命令来运行flyway：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mvn flyway:migrate</div></pre></td></tr></table></figure></p>
<p>就会看到日志里显示<strong>Current version of schema `ggg`: 1</strong>和<strong>Migrating schema `ggg` to version 2 - Add people</strong>。如果我们重复运行<code>mvn flyway:migrate</code>，就会看到<strong>Schema `ggg` is up to date. No migration necessary</strong>。现在查看一下两张表：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> PERSON;</div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> schema_version;</div></pre></td></tr></table></figure></p>
<p>PERSON表里已经有了<code>V2__Add_people.sql</code>里的三条记录，而schema_version表里，就可以看到现在的版本为2。通过这样的方式，就可以管理数据库的版本了。</p>
<h2 id="历史数据库"><a href="#历史数据库" class="headerlink" title="历史数据库"></a>历史数据库</h2><p>如果数据库里已经有历史数据了，那就会稍微麻烦一点儿。我们来试试看，首先改造一下ggg数据库：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">RENAME</span> <span class="keyword">TABLE</span> PERSON <span class="keyword">TO</span> STUDENT;</div><div class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> schema_version;</div></pre></td></tr></table></figure></p>
<p>这样一来，数据库的版本便被清空，PERSON表也变成了STUDENT表。如果直接运行<code>mvn flyway:migrate</code>会报错：<strong>org.flywaydb.core.api.FlywayException: Found non-empty schema `ggg` without metadata table</strong>。这时候需要用到另一个命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mvn flyway:baseline</div></pre></td></tr></table></figure></p>
<p>上面的<code>baseline</code>命令会以现在的数据库结构为基础，创建一张schema_version表，标明现在的版本是1。接着运行<code>mvn flyway:migrate</code>还会报错：<strong>Migration of schema <code>ggg</code> to version 2 - Add people failed</strong>。这是因为数据库现在是版本1，所以会忽略<code>V1__Create_person_table.sql</code>而直接执行<code>V2__Add_people.sql</code>，而<code>V2__Add_people.sql</code>依赖于<code>V1__Create_person_table.sql</code>里创建的PERSON表，所以失败了。解决的方法也很简单，改变两个sql文件的版本即可：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mv src/main/resources/db/migration/V1__Create_person_table.sql src/main/resources/db/migration/V1_1__Create_person_table.sql</div><div class="line">mv src/main/resources/db/migration/V2__Add_people.sql src/main/resources/db/migration/V1_2__Add_people.sql</div><div class="line">mvn flyway:migrate</div></pre></td></tr></table></figure></p>
<p>Flyway的命名规范如下：以<code>V</code>开头，<code>.sql</code>结尾，版本号可以使用<code>.</code>或者<code>_</code>，版本号和描述之间用两个下划线<code>__</code>分开。要是执行成功，但是却看不到PERSON表，那很可能是因为schema_version表里的版本已经是一个<strong>错误的</strong>版本2了，运行repair之后再重新migrate即可：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mvn flyway:<span class="keyword">repair</span></div><div class="line">mvn flyway:migrate</div></pre></td></tr></table></figure></p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>Flyway认为<a href="https://flywaydb.org/documentation/faq.html#downgrade" target="_blank" rel="external">没有必要支持回滚</a>。可以通过<code>mvn flyway:info</code>命令来查看数据库的版本和和需要执行的sql脚本。通过<code>mvn flyway:clean</code>来清空数据库，这条命令对于测试很方便，但是<strong>千万要小心生产环境！！！</strong>此外，还有一个较常用的命令：<code>mvn flyway:validate</code>可以验证是否所有的sql都已经在数据库上运行完毕了。</p>
]]></content>
      
        <categories>
            
            <category> db </category>
            
        </categories>
        
        
        <tags>
            
            <tag> flyway </tag>
            
            <tag> db </tag>
            
            <tag> db migration </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[程序员常见的编码和转义]]></title>
      <url>/encoding-and-escaping/</url>
      <content type="html"><![CDATA[<p>作为一名天朝程序员，除了看惯了乱码之外，在日常的工作中经常会碰到编码和转义。如果能掌握这块领域的一些常识，就可以在开发和支持时游刃有余。<br><a id="more"></a></p>
<h2 id="编码（encoding）"><a href="#编码（encoding）" class="headerlink" title="编码（encoding）"></a>编码（encoding）</h2><h3 id="ASCII-amp-EASCII-amp-ISO-8859-1"><a href="#ASCII-amp-EASCII-amp-ISO-8859-1" class="headerlink" title="ASCII &amp; EASCII &amp; ISO-8859-1"></a>ASCII &amp; EASCII &amp; ISO-8859-1</h3><p>要聊编码，就需要从ASCII开始。众所周知，计算机的世界里，数据都是0和1这样的二进制。用它们的组合来表示字母、数字和常用符号的最通用编码标准就是<a href="https://zh.wikipedia.org/wiki/ASCII" target="_blank" rel="external">ASCII</a>（American Standard Code for Information Interchange，美国信息交换标准代码）。完整的ASCII编码可以从<a href="http://www.ascii-code.com/" target="_blank" rel="external">这里</a>找到。Mac或Linux可以用以下命令来查看所有的ASCII字符：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">man ascii</div></pre></td></tr></table></figure></p>
<p>其中，<code>00000000</code>到<code>00011111</code>的前32位字符和<code>01111111</code>是控制字符，<code>00100000</code>到<code>01111110</code>之间的都是可显示字符，一个字符占8位（bit），第1位总是<code>0</code>，这样能够支持2的7次方即128个符号编码。虽然ASCII编码能搞定美国大多数的应用场景，但是对于其它发达国家的语言来说就无能为力了。于是在其上发展出了<a href="https://zh.wikipedia.org/wiki/EASCII" target="_blank" rel="external">EASCII</a>（extended ASCII），通过扩展最前面的一位为<code>1</code>来提供多达256个符号编码的支持。可是这样又带来了两个问题：一来即使是256个编码，对于世界范围尤其是像中日这样的汉字国家来说还是远远不够；二来各个国家规定的EASCII编码都不一样，比如对于希腊来说EASCII表示的就是希腊字母，而对于法国来说可能就是某个带有注音符号的字母。这样的背景下，ISO（International Standard Organization，国际标准化组织）设计了<a href="https://zh.wikipedia.org/wiki/ISO/IEC_8859" target="_blank" rel="external">ISO/IEC 8859</a>字符集（不包含ASCII），力图一统拉丁语系。其实现的编码表<a href="https://zh.wikipedia.org/wiki/ISO_8859-1" target="_blank" rel="external">ISO-8859-1</a>（包含ASCII）应用得非常广泛。</p>
<h3 id="GB2312-amp-GBK-amp-GB18030-amp-ANSI"><a href="#GB2312-amp-GBK-amp-GB18030-amp-ANSI" class="headerlink" title="GB2312 &amp; GBK &amp; GB18030 &amp; ANSI"></a>GB2312 &amp; GBK &amp; GB18030 &amp; ANSI</h3><p>本节介绍的是解决EASCII带来的第一个问题的方法。对于中文来说，8位的编码远远不够，于是就会想到用两个8位来表示一个汉字。为了与ASCII码兼容，如果碰到0~127的字符，需要认定为ASCII编码字符。只有当两个大于127的字符连在一起时，才表示一个汉字。前一个字符称为高字节，后一个称为低字节，这样就诞生了<a href="https://zh.wikipedia.org/wiki/GB_2312" target="_blank" rel="external">GB2312</a>编码。每一个双字节字符就称为一个全角字符，而单字节字符就称为半角字符。再后来，发现编码还是不够用，干脆就允许低字节也使用0~127的字符，反正用高字节就能判断是否是汉字，这样就诞生了<a href="https://zh.wikipedia.org/wiki/GBK" target="_blank" rel="external">GBK</a>（K表示“扩展”）编码。GBK里甚至还包含了日语的假名和俄语字母。GB2312和GBK这两种编码都是单字节（表示ASCII）和双字节（表示汉字）混合使用的编码。我国最新的汉字编码国标是<a href="https://zh.wikipedia.org/wiki/GB_18030" target="_blank" rel="external">GB18030</a>，这是一种类似下文UTF-8那样的变长编码。</p>
<p>虽然中国解决了中文问题，但是世界各国都搞出了一套自己的编码系统，还是不能轻易相互转化。例如台湾用BIG5，日本用Shift-JIS。要想解决EASCII的第二个问题，还需要另寻他途。Window系统的记事本里，默认编码为ANSI，即根据系统语言的不同，而选用不同的编码。</p>
<h3 id="Unicode-amp-UTF-8"><a href="#Unicode-amp-UTF-8" class="headerlink" title="Unicode &amp; UTF-8"></a>Unicode &amp; UTF-8</h3><p>本节说的是解决EASCII带来的第二个问题的方法。ISO带来了一个囊括全球所有文字的编码：Unicode。它最初规定了所有的字符（包括ASCII）都使用两个字节来表示，这个版本称为<a href="https://zh.wikipedia.org/wiki/UCS-2" target="_blank" rel="external">UCS-2</a>（Universal Multiple-Octet Coded Character Set）或UTF-16。对于ASCII码来说，在它的前面加上<code>00000000</code>作为高字节即可。这样的好处是，由于高低字节可以同时包含0~256，能表示的字符数量就更多了，理论上可以达到256×256=65536个。即使如此，也只能说是基本上够用，要囊括所有文明的文字，还需要更多的字节。目前最多支持4个字节代表一个字符，称为<a href="https://zh.wikipedia.org/wiki/UCS-4" target="_blank" rel="external">UCS-4</a>或UTF-32，它的最高位规定必须为0，可以表示65536×65536÷2=2147483648个字符（这样是不是统一银河系也够用了）。与此同时，它包含的字符集也在不断的增加，甚至收录了<a href="https://zh.wikipedia.org/wiki/%E7%B9%AA%E6%96%87%E5%AD%97" target="_blank" rel="external">emoji</a>（绘文字），大大增加了文字符号的表现力，看看😂🐔📸🎸🎁🌀🌤🕘，是不是增加了很多乐趣呢。</p>
<p>Unicode就像是“书同文、车同轨”，极大地方便了各国的交流。可是它也有自身的缺点。一个问题是它与各国自身的标准不兼容（例如GB18030），但是这个问题貌似无解，因为各国的标准本来就是排斥的。另一个问题是随着Unicode标准的发展，出现了4个字节的字符。但是当设计Java的时候，是<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#unicode" target="_blank" rel="external">将unicode当做2个字节的定长字符来看待</a>的。这样就导致Java里需要用两个char来表示一个4字节的字符，如emoji（😂=\uD83D\uDE02）。<a href="http://www.oracle.com/technetwork/articles/javase/index-zh-cn-138452.html" target="_blank" rel="external">Java平台中的增补字符</a>就是Oracle官方写来专门解决长字节Unicode的。打开链接就会看到一堆的乱码，说明编码问题还真是普遍存在并难以解决的啊。好在还有<a href="http://www.oracle.com/technetwork/articles/javase/index-142761.html" target="_blank" rel="external">英文版</a>可供阅读。还有一个问题就是对于英文来说，用高字节为固定值的两个字节来保存数据，就会使原来一个字节的数据量翻倍，对于传输和存储来说都是较大负担。</p>
<p>解决上面这个问题的办法就是UTF-8。它是一种变长的编码方式。如果是ASCII码的字符，就用一个字节表示。否则就在前面增加一个高位字节（但是在8个bit之内）。这回英文符号是满意了，但是中文字符可能就会因为增加的高位字节从Unicode的占用两个字节变成UTF-8的占用三个字节。没有两全其美的事啊！这也是为什么GB2312和GBK今天仍被广泛使用的原因之一，我们也不想增加传输和存储的负担呀。</p>
<p>如果要打开一个文本文件，首先需要知道它的编码。位于文件头的<a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E5%85%83%E7%B5%84%E9%A0%86%E5%BA%8F%E8%A8%98%E8%99%9F" target="_blank" rel="external">BOM</a>（Byte order mark，字节顺序标记）可以用来标记文件的编码类型。它分为<a href="https://en.wikipedia.org/wiki/Endianness#Big-endian" target="_blank" rel="external">BE</a>（big-endian，大端序）和<a href="https://en.wikipedia.org/wiki/Endianness#Little-endian" target="_blank" rel="external">LE</a>（little-endian，小端序），指的是高字节的位置在前还是在后。但是在类Unix系统中，它很可能因为无法被程序识别而带来一系列问题。所以一般的纯文本文件还是建议保存为不带BOM形式的编码。Window系统的记事本里，如果输入<code>联通</code>保存，便会将其保存为无BOM的GB格式，再次用记事本打开此文件时，因为没有BOM信息，记事本就需要自己推断这个文件的编码是什么。显然window是上这个推断很有问题，误认为是UTF-8格式（可以从文件菜单里的“另存为”看出来）。而mac上默认的文本编辑表现还是不错的。如果用word来打开它，便可以在一系列的编码中，自行寻找合适的编码来打开。如果用记事本另存为UTF-8格式，便不会有问题。Sublime Text可以支持用许多不同的编码来打开或是保存，光是UTF系列的就不少，如下图：<br><img src="/img/sublime-text-encoding.png" alt="sublime-text-encoding"></p>
<p>对于Java来说，内部的String编码默认为UTF-16，但如果由于用不着而觉得浪费内存的话，可以在JVM打开<code>-XX:+UseCompressedStrings</code>，就会变成ISO-8859-1了。Intellij IDEA的Preference里，有两个关于encoding的选项：<br><img src="/img/intellij-idea-encoding.jpg" alt="Intellij-IDEA-encoding"></p>
<p>可以通过Project Encoding来指定项目的JVM里String的内部编码，默认为UTF-8。可以通过下面这两个表达式来看到，它们的编码是完全一致的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">"懒"</span>.getBytes()</div><div class="line"><span class="string">"懒"</span>.getBytes(<span class="string">"UTF-8"</span>)</div></pre></td></tr></table></figure></p>
<p>Java里可以用Integer.toHexString来看到汉字的unicode编码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out.println(<span class="string">"\\u"</span> + Integer.toHexString(<span class="string">'懒'</span>));</div><div class="line">System.out.println(<span class="string">"\u61d2"</span>);</div></pre></td></tr></table></figure></p>
<p>通过下面的语句，可以将字节数组byte[]还原为原先的字符串。如果指定错了编码，就会看到乱码产生啦：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">System.out.println(<span class="keyword">new</span> String(<span class="string">"懒"</span>.getBytes(<span class="string">"UTF-8"</span>), <span class="string">"UTF-8"</span>));  <span class="comment">// 正常</span></div><div class="line">System.out.println(<span class="keyword">new</span> String(<span class="string">"懒"</span>.getBytes(<span class="string">"UTF-8"</span>), <span class="string">"UTF-16"</span>)); <span class="comment">// 乱码:�</span></div><div class="line">System.out.println(<span class="keyword">new</span> String(<span class="string">"懒"</span>.getBytes(<span class="string">"UTF-16"</span>), <span class="string">"UTF-8"</span>)); <span class="comment">// 乱码:��a�</span></div></pre></td></tr></table></figure></p>
<p>读文件、流也是一样的道理，知道了它们的编码才能正确地读取，否则只好像微软的记事本那样去猜啦。Java还提供了一个小工具<code>native2ascii</code>，可以把本地编码的文件转换为各种格式：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> 懒程序员 &gt; ggg.txt</div><div class="line">native2ascii -encoding UTF-8 ggg.txt out.txt</div><div class="line">cat out.txt</div><div class="line">native2ascii -reverse -encoding UTF-8 out.txt</div></pre></td></tr></table></figure></p>
<h3 id="base64-amp-UTF-7"><a href="#base64-amp-UTF-7" class="headerlink" title="base64 &amp; UTF-7"></a>base64 &amp; UTF-7</h3><p><a href="https://zh.wikipedia.org/zh-hans/Base64" target="_blank" rel="external">Base64</a>是一种在网络上传递信息时常见的编码。它相当于是一张64条记录的映射表，键从<code>000000</code>到<code>111111</code>，值就是64个不同的字符。编码时，如果原字符的bit数正好能被6整除，那就查表得到每6个bit所对应的值，合起来就是base64编码的结果。如果不能被6整除，那就在末尾用0补足。每补两个0，就在最终结果的后面加一个<code>=</code>号。所以如果一段数据以等号结尾，那十有八九就是base64编码。Mac或Linux可以用以下命令来进行base64编码及解码：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> -n A | base64</div><div class="line"><span class="built_in">echo</span> -n AB | base64</div><div class="line"><span class="built_in">echo</span> -n ABC | base64</div><div class="line"><span class="built_in">echo</span> -n QQ== | base64 --decode</div><div class="line"><span class="built_in">echo</span> -n QUI= | base64 --decode</div><div class="line"><span class="built_in">echo</span> -n QUJD | base64 --decode</div></pre></td></tr></table></figure></p>
<p>JavaScript可以用以下命令来进行base64编码及解码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.btoa(<span class="string">"A"</span>)</div><div class="line"><span class="built_in">window</span>.atob(<span class="string">"QQ=="</span>)</div></pre></td></tr></table></figure></p>
<p><a href="https://zh.wikipedia.org/wiki/UTF-7" target="_blank" rel="external">UTF-7</a>理论上也属于一种base64编码，只不过它的64行映射表不一样罢了。过去的SMTP协议仅能接受7个bit（ASCII）的字符，Unicode无法直接传输。所以通过UTF-7编码的方式，将Unicode字符转换为7个bit以内的字符。UTF-7本身并不是Unicode的标准，现在也已经由于邮件和传输都支持UTF-8而退出历史舞台了。</p>
<p>写到这里感觉得收一下了，不然MD5、SHA什么的都要出来了。对散列、加密有兴趣的童鞋们可以参考我以前写的另一篇文章<a href="http://qinghua.github.io/certificate/">《证书的那些事儿》</a>。</p>
<h2 id="转义（escaping）"><a href="#转义（escaping）" class="headerlink" title="转义（escaping）"></a>转义（escaping）</h2><h3 id="html-amp-url"><a href="#html-amp-url" class="headerlink" title="html &amp; url"></a>html &amp; url</h3><p>下面说说转义，不少人都把它与编码混而一谈，以至于它也算作编码的一部分了。从最简单的html聊起吧。在html里，如果只写上一些文本，那当我们用浏览器打开这个html时，就会完完整整地显示这些文本的内容。我们也知道，html里无论输入多少个空格，只会显示一个空格。因为在html里，把空格当成了特殊字符。在这种情况下，如果想要在html里放上空格，就需要对空格编码，也就是大家熟知的<code>&amp;nbsp;</code>。其中nbsp大名唤作Non-Breaking Space（<a href="https://zh.wikipedia.org/wiki/%E4%B8%8D%E6%8D%A2%E8%A1%8C%E7%A9%BA%E6%A0%BC" target="_blank" rel="external">不换行空格</a>），除了名字以外，它也有自己的编码：<code>&amp;#160;</code>。除了空格，常见的还有代表标签的<code>&lt;</code>和<code>&gt;</code>。完整的html转义可以从<a href="http://www.ascii.cl/htmlcodes.htm" target="_blank" rel="external">这里</a>找到。奇怪的是这么常用的转义，js居然没有原生的函数支持。如果要转义<code>&lt;div&gt;</code>，可以使用下面这条语句来得到<code>&amp;lt;div&amp;gt;</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">htmlEncode</span>(<span class="params">html</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.createElement(<span class="string">'a'</span>).appendChild(<span class="built_in">document</span>.createTextNode(html)).parentNode.innerHTML;</div><div class="line">&#125;;</div><div class="line">htmlEncode(<span class="string">'&lt;div&gt;'</span>);</div></pre></td></tr></table></figure></p>
<p>解码的话，这样做：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">htmlDecode</span>(<span class="params">html</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> a = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</div><div class="line">    a.innerHTML = html;</div><div class="line">    <span class="keyword">return</span> a.textContent;</div><div class="line">&#125;;</div><div class="line">htmlDecode(<span class="string">'&amp;lt;div&amp;gt;'</span>);</div></pre></td></tr></table></figure></p>
<p>如果使用jQuery，思路一致，但是代码可以稍微短一点：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">htmlEncode</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> $(<span class="string">'&lt;div/&gt;'</span>).text(value).html();</div><div class="line">&#125;</div><div class="line">htmlEncode(<span class="string">'&lt;div&gt;'</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">htmlDecode</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> $(<span class="string">'&lt;div/&gt;'</span>).html(value).text();</div><div class="line">&#125;</div><div class="line">htmlDecode(<span class="string">'&amp;lt;div&amp;gt;'</span>);</div></pre></td></tr></table></figure></p>
<p>可惜的是上面的函数并不能解决空格和<code>&amp;nbsp;</code>之间的转换。想要个万能的？也许只好使用replace一个个地慢慢替换了。</p>
<p>想要请求一个html，需要先输入一个url。这里就涉及到了url转义。因为url里可能会有类似<code>?name=ggg</code>这样的参数，所以起码就需要对<code>?</code>和<code>=</code>进行转义。转义之后分别为<code>%3F</code>和<code>%3D</code>，这与ASCII码是相对应的。完整的url编码可以从<a href="http://www.w3school.com.cn/tags/html_ref_urlencode.html" target="_blank" rel="external">这里</a>找到。这回js终于有原生的函数支持了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">encodeURI</span>(<span class="string">'http://qinghua.github.io?name=g gg'</span>);</div><div class="line"><span class="built_in">encodeURIComponent</span>(<span class="string">'http://qinghua.github.io?name=g gg'</span>);</div></pre></td></tr></table></figure></p>
<p>用<code>encodeURI</code>函数的网址，不会去碰<code>http://</code>，所以编码后还是一个合法的网址。而<code>encodeURIComponent</code>会将一切都进行编码，网址也就不是网址了。不过它很适合将网址作为参数来使用。解码的话，这样做：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">decodeURI</span>(<span class="string">'http://qinghua.github.io?name=g%20gg'</span>);</div><div class="line"><span class="built_in">decodeURIComponent</span>(<span class="string">'http%3A%2F%2Fqinghua.github.io%3Fname%3Dg%20gg'</span>);</div></pre></td></tr></table></figure></p>
<p>在Java里可以用以下语句来完成url的转义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">URLEncoder.encode(<span class="string">"懒"</span>, <span class="string">"UTF-8"</span>);</div><div class="line">URLDecoder.decode(<span class="string">"%E6%87%92"</span>, <span class="string">"UTF-8"</span>);</div></pre></td></tr></table></figure></p>
<h3 id="XML-amp-YAML-amp-JSON-amp-CSV"><a href="#XML-amp-YAML-amp-JSON-amp-CSV" class="headerlink" title="XML &amp; YAML &amp; JSON &amp; CSV"></a>XML &amp; YAML &amp; JSON &amp; CSV</h3><p>在这些数据格式中，对xml的转义基本上跟html差不多，这里就不再赘述了。对于yaml来说，规则如下：</p>
<ol>
<li>在一个单引号标注的字符串中，一个单引号需要转义成两个单引号</li>
<li>在一个双引号标注的字符串中，大部分符号都需要用反斜杠来转义</li>
<li>如果字符串中有控制字符（如<code>\0</code>、<code>\n</code>等），需要用双引号来标注</li>
<li>如果字符串看起来像下面的样子，需要用引号（无所谓哪种）来标注：<ul>
<li><code>true</code>或<code>false</code></li>
<li><code>null</code>或<code>~</code></li>
<li>看起来像数字，如<code>2</code>，<code>14.9</code>，<code>12e7</code>等</li>
<li>看起来像日期，如<code>2014-12-31</code></li>
</ul>
</li>
</ol>
<p>完整的规则可以参考<a href="http://www.yaml.org/spec/1.2/spec.html#id2776092" target="_blank" rel="external">yaml规范</a>。</p>
<p>对与json来说，需要转义的字符如下图：<br><img src="http://www.json.org/string.gif" alt="json string escape"></p>
<p>对于csv来说，转义的规则只有两条：</p>
<ol>
<li>如果值里有逗号、换行或是双引号，需要用双引号来标注</li>
<li>如果值里有双引号，需要把它转义成两个双引号<code>&quot;&quot;</code></li>
</ol>
<h3 id="Java-amp-NET-amp-JS-amp-SQL"><a href="#Java-amp-NET-amp-JS-amp-SQL" class="headerlink" title="Java &amp; .NET &amp; JS &amp; SQL"></a>Java &amp; .NET &amp; JS &amp; SQL</h3><p>对于大部分的编程语言，例如Java、.NET还有JavaScript，甚至C、GO、Ruby等等来说，通常的转义都是通过反斜杠<code>\</code>来实现的。一般都包括如下几项：</p>
<ul>
<li>退格: <code>\b</code></li>
<li>换行: <code>\n</code></li>
<li>制表符: <code>\t</code></li>
<li>回车: <code>\r</code></li>
<li>换页: <code>\f</code></li>
<li>双引号: <code>\&quot;</code></li>
<li>反斜杠: <code>\\</code></li>
</ul>
<p>不过C和C++支持的16进制<code>\x</code>，在java里不被支持。所以<code>\x61\xd2</code>的这个“懒”字，在java中可以通以下这两个表达式来得到真实的字符：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">"\u61d2"</span></div><div class="line"><span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">byte</span>[] &#123;(<span class="keyword">byte</span>) <span class="number">0x61</span>, (<span class="keyword">byte</span>) <span class="number">0xd2</span>&#125;, <span class="string">"unicode"</span>)</div></pre></td></tr></table></figure></p>
<p>SQL有些不一样。它从语法层面支持模糊查询，所以即使在完全匹配中使用了<code>%</code>也不需要转义。但是代表字符串的单引号<code>&#39;</code>还是不得不转义成两个单引号<code>&#39;&#39;</code>。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>以上是关于编码和转义的一些常识，<a href="https://www.zhihu.com/question/23374078/answer/69732605#" target="_blank" rel="external">知乎上转的这篇回答</a>，系统地介绍了从ASCII到UTF-8，写得非常赞。平时需要编码和转义的时候，可以使用<a href="http://www.freeformatter.com/" target="_blank" rel="external">这个网站</a>在线转换，也挺方便的。</p>
]]></content>
      
        <categories>
            
            <category> development </category>
            
        </categories>
        
        
        <tags>
            
            <tag> encoding </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[人际风格与有效沟通实战]]></title>
      <url>/effective-communication/</url>
      <content type="html"><![CDATA[<p>程序猿和工程狮们（还有形形色色的其他角色）的日常工作中，一定会有需要跟别人沟通的时候。因为沟通的问题认为别人sb或者被人当成sb的惨剧应该不少吧？如果有共鸣，可以读一读本文。不少企业都会请有资质的专家，为员工做类似的培训。<br><a id="more"></a></p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>一般来说，一开始都需要给有效沟通下一个定义。干巴巴地说，就是这样：双方或几方针对共同的话题，发出和收集有意义的信息，从而达成一致的行动或共同的认识。我的观点是：沟通就是为了达成共识而采取的行动。官方定义以文为主，行动关注于信息；而我的定义能文能武（当然并不是推荐直接上暴力哈），只要达成共识即可。</p>
<p>沟通是有一个模型的：<br><img src="/img/communication-model.png" alt="沟通模型"></p>
<p>信息的发送者，根据自己的理解，将信息编码成介质（文字、语音、动作等），通过传播媒介（面对面、邮件、微信）发送出去，经过对介质的解码，到了接收者的大脑里。为什么提倡面对面的沟通呢？因为沟通模型里还有一个非常重要的一环：反馈。通过面对面的沟通，可以很容易感知对方的动作、表情、情绪，从而判断对方是否正确地理解了自己想要表达的信息。而这样的反馈，是电子邮件、电话等所难以做到的。</p>
<h2 id="行为风格"><a href="#行为风格" class="headerlink" title="行为风格"></a>行为风格</h2><p>人与人之间是很不一样的。有些话可能某些人就很受用，还有一些人无动于衷，说不定还会令其他人反感。如果能将人类行为模式分类，见人说人话，见鬼说鬼话，想必对有效沟通来说是很有用的。古希腊的希波克拉底最早以火、风、水、土为基础，分别映射到易怒、乐观、冷静和忧郁的情感上，定义了人类具有的四种基本性情。之后的许多行为理论皆以此为基础，但是主要用于专业的精神层面研究。1928年，美国心理学家<a href="https://en.wikipedia.org/wiki/William_Moulton_Marston" target="_blank" rel="external">马斯顿（William Moulton Marston）</a>出版了《常人的情绪》（Emotions of Normal People），为普通人引入了名为<a href="https://en.wikipedia.org/wiki/DISC_assessment" target="_blank" rel="external">DISC</a>的性格测验方法，DISC分别表示支配（Dominance）、影响（Influence）、稳健（Steadiness）与服从（Compliance），由这4种基本因子，可以构成每个人的不同性格。DISC现在是全球广泛采用的性格测评工具之一，许多企业会用之来选择、激励与管理人才。</p>
<p>用控制力的强弱与以人或事为主，便可以画出四个象限：<br><img src="/img/disc.png" alt="DISC"></p>
<p>用动物来表示不同的性格，有趣并且容易记忆。它们是老虎（D）、孔雀（I）、考拉（S）、猫头鹰（C）和变色龙（啥性格都能变）。老虎是产生故事的人，孔雀是讲故事的人，考拉是听故事的人，猫头鹰是分析故事的人。需要注意的是：</p>
<ol>
<li>每个人都有DISC，只是占比不同</li>
<li>没有理想的沟通风格，随心所欲级别的变色龙除外</li>
<li>这些性格都没有好坏、对错、是非之分，不要给人贴标签</li>
<li>不要对考拉太狠了，物极必反</li>
</ol>
<p>性格上面的互补很有用。一只猫头鹰完不成的事，可能另一只猫头鹰也完不成，但是孔雀可能可以轻易完成。团队、婚姻都是如此。西游记里的主角们，其实就代表了这不同的四种性格。猜猜看，谁是那种性格？对了：</p>
<ul>
<li>悟空：老虎，主动，果敢（妖精！吃俺老孙一棒）</li>
<li>唐僧：猫头鹰，以理服人，尽量客观（贫僧乃东土大唐而来）</li>
<li>八戒：孔雀，总是他去化缘，自来熟（女菩萨，也携带我和尚洗洗）</li>
<li>沙僧：考拉，任劳任怨，没有主见（大师兄，师傅被妖怪抓走了）</li>
</ul>
<p>对别人的性格有所了解，沟通起来才能更加有效，事半功倍。</p>
<h2 id="测测自己"><a href="#测测自己" class="headerlink" title="测测自己"></a>测测自己</h2><p>评完别人，可以用下面的方法来简单测评一下自己。在A表和B表的每一组句子中，圈选出一句最像自己的叙述，然后在下面记录选择的数量：</p>
<p>A表</p>
<ol>
<li>我做决定通常很迅速 vs 我喜欢从容做决定</li>
<li>我倾向于说话快速，带着感情丰富的辞藻 vs 我倾向慢条斯理说话，较少用动人心旋话语</li>
<li>坐着没事干，会令我感到难受 vs 我很享受安静、无所事事的时光</li>
<li>我认为自己生活型态很活跃 vs 我认为自己生活型态很低调</li>
<li>同时身兼数职，让我感到精神焕发 vs 我比较喜欢按部就班，一次做一件事</li>
<li>我很容易对步调慢的人失去耐心 vs 我不喜欢被催赶</li>
<li>我会很快地告诉别人自己的想法和感受 vs 我比较保留自己的想法与感受</li>
<li>我喜欢碰运气，尝试新鲜、不同的事物 vs 我不喜欢碰运气，喜欢用熟悉地方法做事</li>
<li>在社交场合，我倾向于向别人自我介绍 vs 在社交场合，我会等别人来介绍我</li>
<li>别人说话的时候，我很难去倾听 vs 别人说话的时候，我很很仔细的听</li>
<li>我喜欢掌控 vs 我比较喜欢遵从指示，尽力支持</li>
<li>我的反应倾向于迅速而随性 vs 我的反应比较趋向缓慢而特意安排</li>
</ol>
<p>A左（F - 快） <strong><strong>__</strong></strong> vs A右（S - 慢） <strong><strong>__</strong></strong></p>
<p>B表</p>
<ol>
<li>我对生活持严肃态度 vs 我对生活持玩乐态度</li>
<li>我倾向于保守自己的感觉 vs 我倾向于对别人分享自己的感觉</li>
<li>我喜欢谈论、听取事实与数据 vs 我喜欢述说与聆听有关人物的故事</li>
<li>我倾向于根据事实、目标与证据做决定 vs 我倾向于根据感觉、经验或人际关系做决定</li>
<li>我对闲聊比较不感兴趣 vs 我比较有兴趣闲聊</li>
<li>我对交往的对象有所节制 vs 我愿意发展新的人际关系，并深入了解他们</li>
<li>一般人可能会认为我很难被了解 vs 一般人可能会认为我很容易被了解</li>
<li>我比较喜欢独自工作 vs 我比较喜欢与别人并透过别人工作</li>
<li>我会讨论当今时事及手中进行的工作 vs 我喜欢谈人物、故事及奇文轶事</li>
<li>我自认是一个比较拘谨的人 vs 我自认是一个比较轻松自在的人</li>
<li>别人把我看成一个重思考的人 vs 别人把我看成一个重感觉的人</li>
<li>完成一件事，是我感觉最棒的时候 vs 当别人接纳我时，我感觉最好</li>
</ol>
<p>B左（T - 任务） <strong><strong>__</strong></strong> vs B右（P - 人际） <strong><strong>__</strong></strong></p>
<p>做完题后，就会得到4个数，例如F8、S4、T7、P5，将FS中的较小值（S4）丢弃，TP中的较小值（P5）丢弃，就变成了F8、T7。然后就可以根据这个坐标在下图中找到自己的象限了。对于F8、T7来说，是老虎：<br><img src="/img/disc-self-accessment.png" alt="DISC自我评测"></p>
<p>需要注意的是：</p>
<ol>
<li>据说它只有70%的准确性（再减20%可就是随机了）</li>
<li>身为一只猫头鹰，真想吐个槽：题目设计还不够科学，如果两张表都是奇数，就不至于出现两个6纠结于最大值了</li>
<li>4个6的话，除了变色龙，还真没法解释了</li>
</ol>
]]></content>
      
        <categories>
            
            <category> idea </category>
            
        </categories>
        
        
        <tags>
            
            <tag> soft skill </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[监控与管理dubbo服务]]></title>
      <url>/dubbo-3/</url>
      <content type="html"><![CDATA[<p><a href="https://github.com/alibaba/dubbo" target="_blank" rel="external">Dubbo</a>是阿里多年前开源的一套服务治理框架，在众多互联网企业里应用广泛。本文介绍了一些如何监控与管理dubbo服务。使用的工具与<a href="http://www.cnblogs.com/yjmyzz/p/dubbo-admin-monitor-deploy.html" target="_blank" rel="external">《dubbox 的各种管理和监管》</a>大致相同，本文更侧重于命令细节与实践。<br><a id="more"></a></p>
<p>首先参考<a href="/dubbo-1">《服务治理框架dubbo上手指南》</a>，实现自己的<code>HelloService</code>服务。在此基础上运行<code>Provider.java</code>启动服务，接下来就可以开始管理工作啦。让我们来下载dubbo的源码并安装：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">clone</span> https://github.com/alibaba/dubbo.git dubbo</div><div class="line"><span class="built_in">cd</span> ~/dubbo</div><div class="line">mvn clean install -Dmaven.test.skip</div></pre></td></tr></table></figure></p>
<h2 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h2><p>Dubbo支持使用telnet来查看服务状态。下面让我们来试一下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">telnet localhost 19880</div></pre></td></tr></table></figure></p>
<p>敲下回车便能看到<code>dubbo&gt;</code>的提示符了。以下命令可以看到服务列表、服务的方法详细信息列表和服务地址列表：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ls</div><div class="line">ls -l org.ggg.hello.service.HelloService</div><div class="line">ps -l</div></pre></td></tr></table></figure></p>
<p>以下命令可以跟踪服务方法的调用情况：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">trace org.ggg.hello.service.HelloService</div></pre></td></tr></table></figure></p>
<p>这时会看见光标停止住了。运行<code>Consumer.java</code>来消费服务，就可以看到跟踪结果啦。详细的命令可以参考<a href="https://github.com/alibaba/dubbo/wiki/user-guide-telnet-cmd-ref" target="_blank" rel="external">Telnet命令参考手册</a>。若是服务端没有开启监控，使用telnet命令对查看甚至配置服务来说，是依赖最少最简便的方式。</p>
<h2 id="简易监控中心"><a href="#简易监控中心" class="headerlink" title="简易监控中心"></a>简易监控中心</h2><p>先前安装过的dubbo项目里包含了<code>dubbo-monitor-simple</code>的包，解压之：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar zxvf dubbo-simple/dubbo-monitor-simple/target/dubbo-monitor-simple-2.5.4-SNAPSHOT-assembly.tar.gz</div></pre></td></tr></table></figure></p>
<p>配置<code>dubbo.properties</code>为自己的zk服务地址：<code>192.168.33.88:2181</code>：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 操作系统是Linux的话</span></div><div class="line">sed -i <span class="string">"s/multicast:\/\/224.5.6.7:1234/zookeeper:\/\/192.168.33.88:2181/"</span> dubbo-monitor-simple-2.5.4-SNAPSHOT/conf/dubbo.properties</div><div class="line"><span class="comment"># 操作系统是OS X的话（接下来的sed命令以OS X为例）</span></div><div class="line">sed -i <span class="string">""</span> <span class="string">"s/multicast:\/\/224.5.6.7:1234/zookeeper:\/\/192.168.33.88:2181/"</span> dubbo-monitor-simple-2.5.4-SNAPSHOT/conf/dubbo.properties</div></pre></td></tr></table></figure></p>
<p>简易监控中心以文件的方式记录监控数据。创建基本文件夹并运行<code>start.sh</code>启动简易监控中心：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mkdir ~/monitor</div><div class="line">dubbo-monitor-simple-2.5.4-SNAPSHOT/bin/start.sh</div></pre></td></tr></table></figure></p>
<p>访问<a href="http://localhost:8080/" target="_blank" rel="external">http://localhost:8080/</a>便能看到简易监控中心的首页了：<br><img src="/img/dubbo-monitor-simple-home.jpg" alt=""></p>
<p>在<code>Applications</code>里可以看到我们先前启动的<code>hello-world-app</code>和<code>simple-monitor</code>自己。可见<code>simple-monitor</code>也是一个dubbo服务，把自己注册到<code>dubbo.properties</code>里指定的配置中心里去。为了接收到监控数据，需要在dubbo服务端打开监控。在<code>provider.xml</code>文件里加入下面这行配置，然后重新启动dubbo服务：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dubbo:monitor</span> <span class="attr">protocol</span>=<span class="string">"registry"</span> /&gt;</span></div></pre></td></tr></table></figure></p>
<p>过一会儿就能看到监控的统计信息和图标了：<br><img src="/img/dubbo-monitor-simple-service-charts.jpg" alt=""></p>
<p>而运行<code>ls ~/monitor/</code>也能看到简易监控中心所生成的文件夹<code>charts</code>和<code>statistics</code>。如果迟迟没有生成这些信息，有一种可能是在多（虚拟）网卡的情况下，simple-monitor绑定到了错误的IP地址去了。万一真是如此，在<code>dubbo.properties</code>里增加一行<code>dubbo.protocol.host</code>的配置即可。</p>
<p>运行<code>stop.sh</code>停止简易监控中心服务：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dubbo-monitor-simple-2.5.4-SNAPSHOT/bin/stop.sh</div></pre></td></tr></table></figure></p>
<h2 id="管理控制台"><a href="#管理控制台" class="headerlink" title="管理控制台"></a>管理控制台</h2><p>Dubbo为服务治理提供了管理控制台。这是一个webapp，可以很轻松地运行在web容器中。经由源代码安装后便会生成<code>dubbo-admin-2.5.4-SNAPSHOT.war</code>文件，将其部署在tomcat容器中即可。这里用docker启动一个tomcat 7：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">docker run -d -p 8080:8080 --name=tomcat tomcat:7</div><div class="line">docker cp dubbo-admin/target/dubbo-admin-2.5.4-SNAPSHOT.war tomcat:/usr/<span class="built_in">local</span>/tomcat/webapps/</div><div class="line">docker <span class="built_in">exec</span> tomcat sed -i <span class="string">"s/127.0.0.1/192.168.33.88/"</span> /usr/<span class="built_in">local</span>/tomcat/webapps/dubbo-admin-2.5.4-SNAPSHOT/WEB-INF/dubbo.properties</div><div class="line">docker restart tomcat</div></pre></td></tr></table></figure></p>
<p>文件<code>dubbo.properties</code>里配置了zookeep的地址，所以用sed将其替换为自己的zk服务地址：<code>192.168.33.88</code>。里面还配置了root账户和guest账户的密码。默认即为<code>root</code>和<code>guest</code>。访问<a href="http://localhost:8080/dubbo-admin-2.5.4-SNAPSHOT/" target="_blank" rel="external">http://localhost:8080/dubbo-admin-2.5.4-SNAPSHOT/</a>并输入<code>root</code>和<code>root</code>，就能看到管理控制台的首页了：<br><img src="/img/dubbo-admin-home.jpg" alt=""></p>
<p>输入<code>hello</code>进行查询，便能看到我们的服务了：<br><img src="/img/dubbo-admin-service-governance.jpg" alt=""></p>
<p>可以在此页面进行各种服务治理操作。更详细的资料，请参考<a href="http://dubbo.io/Administrator+Guide-zh.htm#AdministratorGuide-zh-%E8%BF%90%E7%BB%B4%E6%89%8B%E5%86%8C" target="_blank" rel="external">运维手册</a>。</p>
<p>运行以下命令删除tomcat容器：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rm -f tomcat</div></pre></td></tr></table></figure></p>
<h2 id="dubbo-monitor"><a href="#dubbo-monitor" class="headerlink" title="dubbo-monitor"></a>dubbo-monitor</h2><p>简易监控中心和管理控制台的页面风格看起来还停留在上个世纪。韩都衣舍提供了一个<a href="https://github.com/handuyishe/dubbo-monitor" target="_blank" rel="external">dubbo-monitor</a>，除了更加现代化的页面，还用数据库代替了简易监控中心写文件的方式。除了mysql，还支持<a href="https://github.com/handuyishe/dubbo-monitor/tree/mongo" target="_blank" rel="external">mongo</a>。那我们先来下载代码：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> ..</div><div class="line">git <span class="built_in">clone</span> https://github.com/handuyishe/dubbo-monitor</div><div class="line"><span class="built_in">cd</span> dubbo-monitor</div></pre></td></tr></table></figure></p>
<p>然后启动一个mysql数据库实例：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker run -d --name=mysql -e MYSQL_ROOT_PASSWORD=raycool -v `<span class="built_in">pwd</span>`/sql/create.sql:/create.sql mysql:5.7.12</div><div class="line">docker <span class="built_in">exec</span> -it mysql mysql -uroot -praycool</div></pre></td></tr></table></figure></p>
<p>创建数据库和表（可能需要等数据库启动一小会儿之后才能连上去）：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> dubbokeeper <span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">DEFAULT</span> <span class="keyword">COLLATE</span> utf8_general_ci;</div><div class="line"><span class="keyword">USE</span> dubbokeeper;</div><div class="line">SOURCE /create.sql;</div><div class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLES</span>;</div><div class="line">exit</div></pre></td></tr></table></figure></p>
<p>修改配置文件<code>application.properties</code>并打包（目前版本中spring的引用有问题，所以也需要修改<code>pom.xml</code>）：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">MYSQL_IP=`docker <span class="built_in">exec</span> -it mysql hostname -i | sed <span class="string">'s/.$//'</span>`</div><div class="line">sed -i <span class="string">""</span> -e <span class="string">"s/dubbo.registry.address.*/dubbo.registry.address=zookeeper:\/\/192.168.33.88:2181/"</span> -e <span class="string">"s/default/<span class="variable">$&#123;MYSQL_IP&#125;</span>/"</span> src/main/resources/application.properties</div><div class="line">sed -i <span class="string">""</span> s/4.1.6.RELEASE/3.2.9.RELEASE/<span class="string">" pom.xml</span></div><div class="line">mvn clean package</div></pre></td></tr></table></figure></p>
<p>启动dubbo-monitor：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d -p 8080:8080 -v `<span class="built_in">pwd</span>`/target/dubbo-monitor-x.war:/usr/<span class="built_in">local</span>/tomcat/webapps/dubbo-monitor-x.war --name=tomcat tomcat:7</div></pre></td></tr></table></figure></p>
<p>访问<a href="http://localhost:8080/dubbo-monitor-x/" target="_blank" rel="external">http://localhost:8080/dubbo-monitor-x/</a>并输入<code>admin</code>和<code>admin</code>，就能看到dubbo-monitor的首页了：<br><img src="/img/dubbo-monitor-home.jpg" alt=""></p>
<p>可以在dubbo-monitor提供的页面上监控各种数据，但由于笔者是mac配docker版tomcat的方式，监控的dubbo服务只能绑定在docker内部IP上，导致监控数据过不去（com.alibaba.dubbo.remoting.RemotingException: message can not send, because channel is closed）。真正运行的时候还是使用linux+docker（配合net=host）或是mac+原生tomcat的方式吧。运行以下命令删除mysql和tomcat容器：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rm -f mysql tomcat</div></pre></td></tr></table></figure></p>
<h2 id="DubboKeeper"><a href="#DubboKeeper" class="headerlink" title="DubboKeeper"></a>DubboKeeper</h2><p>除了dubbo-monitor以外，github里还有一个社区版的<a href="https://github.com/dubboclub/dubbokeeper" target="_blank" rel="external">DubboKeeper</a>，功能最为强大。既提供监控功能，又提供服务治理功能。监控数据的持久化除了支持mysql和mongo，还支持lucene。现在下载代码并打包。Dubbokeeper的打包方式略有些不同，需要执行根目录里的<code>install-xxx.sh</code>脚本。这里还是以mysql为例：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> ..</div><div class="line">git <span class="built_in">clone</span> https://github.com/dubboclub/dubbokeeper</div><div class="line"><span class="built_in">cd</span> dubbokeeper</div><div class="line">./install-mysql.sh</div></pre></td></tr></table></figure></p>
<p>首先启动DubboKeeper的UI：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker run -d -p 8080:8080 -v `<span class="built_in">pwd</span>`/target/mysql-dubbokeeper-ui/dubbokeeper-ui-1.0.1.war:/usr/<span class="built_in">local</span>/tomcat/webapps/dubbokeeper-ui-1.0.1.war --name=tomcat tomcat:7</div><div class="line">docker <span class="built_in">exec</span> tomcat sed -i <span class="string">"s/localhost/192.168.33.88/"</span> /usr/<span class="built_in">local</span>/tomcat/webapps/dubbokeeper-ui-1.0.1/WEB-INF/classes/dubbo.properties</div><div class="line">docker restart tomcat</div></pre></td></tr></table></figure></p>
<p>访问<a href="http://localhost:8080/dubbokeeper-ui-1.0.1/index.htm#/statistics" target="_blank" rel="external">http://localhost:8080/dubbokeeper-ui-1.0.1/index.htm#/statistics</a>，就能看到DubboKeeper的首页了：<br><img src="/img/dubbo-keeper-home.jpg" alt=""></p>
<p>很显然在这些UI里，DubboKeeper的逼格是最高的。第二个tab就是<code>Admin</code>（管理）：<br><img src="/img/dubbo-keeper-admin.jpg" alt=""></p>
<p>接下来就是<code>Monitor</code>（监控），不过只有启动过监控数据存储端才能使用，现在点击会报<strong>后端系统出现异常，请稍后再试</strong>的错。接下来启动数据库：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker run -d --name=mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=19890314 -v `<span class="built_in">pwd</span>`/doc/storage/mysql/sql/application.sql:/create.sql mysql:5.7.12</div><div class="line">docker <span class="built_in">exec</span> -it mysql mysql -uroot -p19890314</div></pre></td></tr></table></figure></p>
<p>初始化数据库：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> dubbokeeper;</div><div class="line"><span class="keyword">USE</span> dubbokeeper;</div><div class="line">SOURCE /create.sql;</div><div class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLES</span>;</div><div class="line">exit</div></pre></td></tr></table></figure></p>
<p>修改监控数据存储端的配置并启动之：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sed -i <span class="string">""</span> -e <span class="string">"s/localhost:2181/192.168.33.88:2181/"</span> -e <span class="string">"s/dubbo-monitor/dubbokeeper/"</span> target/mysql-dubbokeeper-server/conf/dubbo-mysql.properties</div><div class="line">chmod +x target/mysql-dubbokeeper-server/bin/start-mysql.sh</div><div class="line">target/mysql-dubbokeeper-server/bin/start-mysql.sh</div></pre></td></tr></table></figure></p>
<p>现在就可以顺利打开监控页面了：<br><img src="/img/dubbo-keeper-monitor.jpg" alt=""></p>
<p>DubboKeeper甚至还提供了ZooKeeper的窥视版<code>ZooPeeper</code>：<br><img src="/img/dubbo-keeper-zoopeeper.jpg" alt=""></p>
<p>最后收尾，Ctrl+C掉监控数据存储端，并删除各个容器：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rm -f mysql tomcat</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> architecture </category>
            
        </categories>
        
        
        <tags>
            
            <tag> dubbo </tag>
            
            <tag> service governance </tag>
            
            <tag> monitor </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《DevOps实践》出版啦]]></title>
      <url>/practical-devops/</url>
      <content type="html"><![CDATA[<p>从开始试译到现在经过了半年多，我和马博文的译作<a href="https://book.douban.com/subject/26878481/" target="_blank" rel="external">《DevOps实践》</a>终于出版啦。这里简要地介绍一下本书，并放篇我为此书所作的译者序，安利一下。<br><a id="more"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>《DevOps实践》介绍了DevOps的起源和概览，并通过一个贯穿全书的例子，从架构开始，到代码的存储、构建、测试、部署、监控，直至流程的跟踪，推荐了许多可用的工具和可行的示范，是一本DevOps实践方面不可多得的参考书籍。</p>
<p>《DevOps实践》面向愿意承担更大责任的开发人员和系统管理员，也很适合愿意更好地支持开发人员的运维人员。无须任何DevOps知识即可快速上手！</p>
<p><img src="/img/practical_devops_en.jpg" alt=""><br><img src="/img/practical_devops_cn.png" alt=""></p>
<h2 id="译者序"><a href="#译者序" class="headerlink" title="译者序"></a>译者序</h2><p>什么是DevOps？我的前同事李光磊将其译为开发自运维，他还写了篇很有意思的博客来说明：<a href="http://liguanglei.name/blogs/2015/04/22/devops-chinese-name/" target="_blank" rel="external">http://liguanglei.name/blogs/2015/04/22/devops-chinese-name/</a>。这个将开发和运维结合起来的词，代表了一种文化，那就是大家共同协作。狭义上的大家，指的是开发和运维，广义上，指的是所有软件生命周期里参与的角色。</p>
<p>“共同协作”是个富有正能量的词。感觉上，随便往哪儿一套都是政治正确的。那为什么要在DevOps里着重强调呢？DevOps到底解决了什么问题？归根结底，就是提高产品质量。爱思考的你，可能心里已经有千万个提高产品质量的方案从脑海里呼啸而过。代码审查、自动化测试、持续集成、代码质量管理工具、程序员鼓励师……对对对，这些方案都能在某种程度上解决一些层次的问题。但是，产品质量的根源在哪儿呢？在于人。如果开发者对自己要做的事情不负责甚至压根儿不知道后果，怎么能指望这样的人能够生产出来高质量的代码呢？举个例子：作为开发者，我知道自己写的代码会由测试部门来进一步测试，在有进度压力的时候，我就会更倾向于去想：“那就先这么凑合吧着，反正有问题的话QA们会说的”。如果我不知道部署和维护产品是怎么一回事，我就不会主动地在产品里写上日志的代码。对于运维人员来说，由于处于软件生命周期的下游，相信对类似的场景感触更甚。DevOps能够做到的事，就是让人有这个意识：需要对产品的质量负责。DevOps能够提供一个平台或机制，让我能够从中找到所需的资源。</p>
<p>“共同协作”也是个虚无缥缈的词。它应该如何落地呢？这就是本书想要给读者们带来的内容。在实践上，从架构开始，到代码的存储、构建、测试、部署、监控，直至流程的跟踪，本书推荐了许多可用的工具和练习，确实无愧于《DevOps实战》之名。细度全文可以有一个全局的概览并充实读者们的DevOps工具箱；而在实际场景中再查阅本书，将其当做一本各种技术的快速参考手册也不失为明智之举。本书的许多实例通过Docker启动，在紧随潮流技术的同时也简化了练习步骤，值得花些时间试试。在企业里，使用自动化和持续交付来提高代码部署频率，降低代码上线间隔。这样的指标是比较容易统计的，在让管理人员满意的同时，也能减少开发和运维的痛苦。只有让各角色都真切地感受到实惠，大家才会更加愿意从心底接受并积极参与到这一过程中。</p>
<p>“共同协作”还是个看上去很美的词。为什么大家还不赶紧拥抱它？因为它的成本可能还挺高的。大型企业在管理上，通常权责分明，从而导致某个角色的成员都不愿意轻易踏足其它领域。流程繁琐，导致一个小小的改进也需要漫长的批复。安全性要求高，引发各种违规，进一步导致没有和其他人分享的意愿。员工操作权限管理精密，上不了网、下不了包、开不了虚拟机……这些问题，虽然不至于疾在骨髓，但起码也在肠胃了。而且，自动化测试、部署流水线等都需要比较大的成本。在看见收益和认清自己之前，可能大多数人也会像蔡桓公那样默认拒绝吧：“医之好治不病以为功”。成本最低的时候，可能就是开始写第一行产品代码的时候。话虽如此，任何时候都是实现DevOps的最佳时机，因为它的成本随企业的扩大和代码库的膨胀，一定是越来越高的。另外，完全地追求技术上的卓越而忽视成本也不是DevOps的推荐做法。读者们在阅读时，也会看到DevOps在一些状况下采取的权衡方案。</p>
<p>你希望在一个大家敞开心胸，相互拥抱的环境里共同协作打造最好的产品，还是守着自己的一亩三分地，与人争辩这是谁的责任，抱怨人们冷漠的同时拒绝其他人的“与你无关”的要求？从本书开始，应用自己获得的知识，并尝试改造这个世界吧！</p>
<h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>感谢作者Joakim Verona，本书涵盖了大量可以练习的实例，想必花了你很多的心血。<br>感谢ThoughtWorks，授人的不止是持续集成、持续交付，还有持续学习。<br>感谢林帆，没有你，我就不会有这样难忘的翻译经历。<a href="https://book.douban.com/subject/26670565/" target="_blank" rel="external">《CoreOS实践之路》</a>只是你的开始，希望能看到更多的佳作问世。<br>感谢永恒的侠少，让我可以集中精力专注于翻译之上，你还为本书想了一个漂亮的副标题。<br>感谢马博文，你的经验与高效让本书的翻译可以提前完成。顺祝你的另一本译作<a href="http://item.jd.com/11935577.html" target="_blank" rel="external">《Scala编程实战》</a>大卖。<br>感谢小伙伴张博，你给我的初稿指出了许多宝贵意见。<br>感谢文心、瑞民、光磊，这篇译者序里也流淌着你们的汗水。<br>感谢张骏，我从你的<a href="https://book.douban.com/subject/26772677/" target="_blank" rel="external">《微服务设计》</a>的代码库里获取了许多宝贵的经验与灵感。<br>感谢家人和朋友们，我永远离不开你们的支持。</p>
]]></content>
      
        <categories>
            
            <category> devops </category>
            
        </categories>
        
        
        <tags>
            
            <tag> book </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[不止于数据库连接池的Druid]]></title>
      <url>/alibaba_druid/</url>
      <content type="html"><![CDATA[<p><a href="https://github.com/alibaba/druid" target="_blank" rel="external">Druid</a>传说中是Java语言中最好的数据库连接池，能够提供强大的监控和扩展功能，甚至可以基于SQL语义来<a href="https://github.com/alibaba/druid/wiki/%E7%AE%80%E4%BB%8B_WallFilter" target="_blank" rel="external">防御SQL注入攻击</a>。它与其它数据库连接池的功能对比可以参考<a href="https://github.com/alibaba/druid/wiki/%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%AF%B9%E6%AF%94" target="_blank" rel="external">各种数据库连接池对比</a>，性能对比可以参考<a href="https://github.com/alibaba/druid/wiki/%E5%90%84%E7%A7%8D%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94%E6%B5%8B%E8%AF%95" target="_blank" rel="external">各种连接池性能对比测试</a>。网上的一些原code.alibabatech.com的链接已经失效，文档都转移到了github上，以<a href="https://github.com/alibaba/druid/wiki/%E9%A6%96%E9%A1%B5" target="_blank" rel="external">wiki</a>+<a href="https://github.com/alibaba/druid/wiki/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98" target="_blank" rel="external">FAQ</a>的方式提供，查起来有些混乱。下面我们来动手了解一下druid所提供的功能。<br><a id="more"></a></p>
<h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><p>既然是数据库连接池，首先要启动一个数据库。用docker来弄简单轻松：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d -e MYSQL_ROOT_PASSWORD=123456 --net=host --name=mysql mysql:5.7.12</div></pre></td></tr></table></figure></p>
<p>进入容器并连接上数据库：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> -it mysql mysql -uroot -p123456</div></pre></td></tr></table></figure></p>
<p>创建用户表并插入一些初始数据：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> spike;</div><div class="line"><span class="keyword">USE</span> spike;</div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> (</div><div class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</div><div class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    gender TINYINT <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    birthday <span class="keyword">TIMESTAMP</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>)</div><div class="line">);</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span>(<span class="keyword">name</span>, gender, birthday) <span class="keyword">VALUES</span>(<span class="string">'ggg'</span>, <span class="string">'1'</span>, <span class="string">'1999-01-01'</span>);</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span>(<span class="keyword">name</span>, gender, birthday) <span class="keyword">VALUES</span>(<span class="string">'Loic'</span>, <span class="string">'1'</span>, <span class="string">'2000-01-01'</span>);</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span>(<span class="keyword">name</span>, gender, birthday) <span class="keyword">VALUES</span>(<span class="string">'Hetty'</span>, <span class="string">'2'</span>, <span class="string">'2001-01-01'</span>);</div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span>;</div><div class="line"></div><div class="line">exit</div></pre></td></tr></table></figure></p>
<p>我在github上创建了一个druid的maven版测试工程，下载到本地并使用自己喜欢的IDE打开：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">clone</span> https://github.com/qinghua/druid</div></pre></td></tr></table></figure></p>
<p>然后打开<code>spring-context-dao.xml</code>文件，把数据源从<code>jdbc:mysql://192.168.33.88:3306/spike</code>替换为自己的本地数据源。</p>
<h2 id="各种监控"><a href="#各种监控" class="headerlink" title="各种监控"></a>各种监控</h2><p>以下命令可以直接启动jetty服务器：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> druid</div><div class="line">mvn jetty:run</div></pre></td></tr></table></figure></p>
<p>打开<a href="http://localhost:8080/hello?id=1" target="_blank" rel="external">http://localhost:8080/hello?id=1</a>便能看见<strong>Hello ggg</strong>，这个是程序的正常功能。</p>
<p>Druid的页面是通过在<code>web.xml</code>里配置<code>DruidStatView</code>的servlet来实现的。参数的具体配置可以参考<a href="https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE_StatViewServlet%E9%85%8D%E7%BD%AE" target="_blank" rel="external">这里</a>。打开<a href="http://localhost:8080/druid/index.html" target="_blank" rel="external">http://localhost:8080/druid/index.html</a>便能看见druid的首页了：<br><img src="/img/druid-index.jpg" alt=""></p>
<p>如果刚才访问过<a href="http://localhost:8080/hello?id=1" target="_blank" rel="external">hello</a>，通过点击<code>数据源</code>便能查看到程序新创建的数据源。可以在IDE里打开<code>spring-context-dao.xml</code>通过<code>dataSource</code>来查看数据源的配置，参数的具体配置可以参考<a href="https://github.com/alibaba/druid/wiki/DruidDataSource%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E5%88%97%E8%A1%A8" target="_blank" rel="external">这里</a>。通过<code>class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;</code>来使用druid。点击<code>SQL监控</code>便能体会到druid引以为傲的强大监控功能：<br><img src="/img/druid-sql-monitor.jpg" alt=""></p>
<p><code>SQL防火墙</code>是用来防止SQL注入的，配置可以参考<a href="https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE-wallfilter" target="_blank" rel="external">这里</a>。还可以通过在<code>web.xml</code>加入以下配置来启用web监控，参数的具体配置可以参考<a href="https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE_%E9%85%8D%E7%BD%AEWebStatFilter" target="_blank" rel="external">这里</a>：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>DruidWebStatFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.alibaba.druid.support.http.WebStatFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>exclusions<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>DruidWebStatFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>除了监控SQL和web，druid还能监控spring的一些调用信息。可以在IDE里打开<code>spring-context-druid.xml</code>查看程序的当前配置。参数的具体配置可以参考<a href="https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE_Druid%E5%92%8CSpring%E5%85%B3%E8%81%94%E7%9B%91%E6%8E%A7%E9%85%8D%E7%BD%AE" target="_blank" rel="external">这里</a>。通过点击<code>spring监控</code>便能查看到方法的调用时间和jdbc的一些状态：<br><img src="/img/druid-spring-monitor.jpg" alt=""></p>
<h2 id="其它功能"><a href="#其它功能" class="headerlink" title="其它功能"></a>其它功能</h2><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>监控里显示的都是敏感信息，可以通过在<code>web.xml</code>里加入以下配置来启用简单的登录功能：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DruidStatView<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.alibaba.druid.support.http.StatViewServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>loginUsername<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>ggg<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>loginPassword<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>这样访问druid界面的时候就需要输入用户名密码啦：<br><img src="/img/druid-login.jpg" alt=""></p>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>如果想在日志里看到执行的sql，可以根据<a href="https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE_LogFilter" target="_blank" rel="external">这里</a>的说明来配置。Druid支持多种<a href="https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AEdruid%E5%86%85%E7%BD%AE%E7%9A%84log%E5%AE%9E%E7%8E%B0" target="_blank" rel="external">日志组件</a>。显示执行的sql是debug级别，如果用的是log4j，可以在<code>log4j.properties</code>里这样配：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">log4j.logger.druid.sql=debug,stdout</div></pre></td></tr></table></figure></p>
<p>访问<a href="http://localhost:8080/hello?id=2" target="_blank" rel="external">hello页面</a>，便可以看到如下日志：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&#123;conn-10005&#125; connected</div><div class="line">&#123;conn-10005&#125; pool-connect</div><div class="line">&#123;conn-10005, pstmt-20000&#125; created. </div><div class="line">SELECT name FROM user WHERE id=?</div><div class="line">&#123;conn-10005, pstmt-20000&#125; Parameters : [2]</div><div class="line">&#123;conn-10005, pstmt-20000&#125; Types : [INTEGER]</div><div class="line">&#123;conn-10005, pstmt-20000&#125; executed. 1.351044 millis. </div><div class="line">SELECT name FROM user WHERE id=?</div><div class="line">&#123;conn-10005, pstmt-20000, rs-50000&#125; open</div><div class="line">&#123;conn-10005, pstmt-20000, rs-50000&#125; Header: [name]</div><div class="line">&#123;conn-10005, pstmt-20000, rs-50000&#125; Result: [Loic]</div><div class="line">&#123;conn-10005, pstmt-20000, rs-50000&#125; closed</div><div class="line">&#123;conn-10005, pstmt-20000&#125; clearParameters. </div><div class="line">&#123;conn-10005&#125; pool-recycle</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> db </category>
            
        </categories>
        
        
        <tags>
            
            <tag> druid </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用容器快速上手Elasticsearch]]></title>
      <url>/elastic-search/</url>
      <content type="html"><![CDATA[<p><a href="https://www.elastic.co/products/elasticsearch" target="_blank" rel="external">Elasticsearch</a>是用Java开发的基于<a href="https://lucene.apache.org/" target="_blank" rel="external">Apache Lucene</a>的一个近乎实时的分布式搜索分析引擎。维基百科、Stack Overflow、GitHub等都采用它来作为全文搜索引擎。本文旨在用docker来快速入门并尝试Elasticsearch提供的基本功能。</p>
<p>对<a href="http://lucene.apache.org/solr/" target="_blank" rel="external">Apache Solr</a>入门有兴趣的朋友请参考<a href="/solr">用容器快速上手Apache Solr</a>。<br><a id="more"></a></p>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>关于Elasticsearch的入门知识，有一本gitbook：<a href="https://www.gitbook.com/book/fuxiaopang/learnelasticsearch/details" target="_blank" rel="external">《Elasticsearch 权威指南》</a>翻译得不错。本文关心的是实际操作，所以这就开始吧。通过docker，一条命令就可以直接启动Elasticsearch：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d --net=host --name=es elasticsearch:2.3.5</div></pre></td></tr></table></figure></p>
<p>我用的是mac，通过<code>docker-machine env default</code>命令可以看到默认的<code>default docker-machine</code>的IP地址是<code>192.168.99.100</code>，于是便可以通过<a href="http://192.168.99.100:9200/" target="_blank" rel="external">http://192.168.99.100:9200/</a>来从Elasticsearch获得json数据了：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"name"</span> : <span class="string">"Lorvex"</span>,</div><div class="line">  <span class="attr">"cluster_name"</span> : <span class="string">"elasticsearch"</span>,</div><div class="line">  <span class="attr">"version"</span> : &#123;</div><div class="line">    <span class="attr">"number"</span> : <span class="string">"2.3.5"</span>,</div><div class="line">    <span class="attr">"build_hash"</span> : <span class="string">"90f439ff60a3c0f497f91663701e64ccd01edbb4"</span>,</div><div class="line">    <span class="attr">"build_timestamp"</span> : <span class="string">"2016-07-27T10:36:52Z"</span>,</div><div class="line">    <span class="attr">"build_snapshot"</span> : <span class="literal">false</span>,</div><div class="line">    <span class="attr">"lucene_version"</span> : <span class="string">"5.5.0"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">"tagline"</span> : <span class="string">"You Know, for Search"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>也可以使用<code>_cat</code>直接在命令行获取Elasticsearch的健康状态和节点状态：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">curl <span class="string">'192.168.99.100:9200/_cat/health?v'</span></div><div class="line">curl <span class="string">'192.168.99.100:9200/_cat/nodes?v'</span></div></pre></td></tr></table></figure></p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>与Solr不同，Elasticsearch只支持json格式。创建索引的过程，就是向服务器POST数据的过程：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">curl -XPOST <span class="string">'http://192.168.99.100:9200/megacorp/employee'</span> -d <span class="string">'</span></div><div class="line">&#123;</div><div class="line">    "first_name" : "John",</div><div class="line">    "last_name" :  "Smith",</div><div class="line">    "age" :        25,</div><div class="line">    "about" :      "I love to go rock climbing",</div><div class="line">    "interests": [ "sports", "music" ]</div><div class="line">&#125;'</div></pre></td></tr></table></figure></p>
<p>立刻就能得到Elasticsearch返回的结果：<strong>{“_index”:”megacorp”,”_type”:”employee”,”_id”:”AVbK2ssDm7bdYo65QJ6k”,”_version”:1,”_shards”:{“total”:2,”successful”:1,”failed”:0},”created”:true}</strong>。Url里的megacorp是索引的名字（想象成一个数据库），employee是类型的名字（想象成一张表）。返回的<code>_id</code>是Elasticsearch随机创建的一个ID，用于标识数据。</p>
<p>可以通过以下url获取Elasticsearch的索引信息：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl <span class="string">'http://192.168.99.100:9200/_cat/indices?v'</span></div></pre></td></tr></table></figure></p>
<p>修改索引的话，发出PUT请求就可以了（别忘了把ID换成你自己生成的<code>_id</code>）：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">curl -XPUT <span class="string">'http://192.168.99.100:9200/megacorp/employee/AVbK2ssDm7bdYo65QJ6k'</span> -d <span class="string">'</span></div><div class="line">&#123;</div><div class="line">    "first_name" : "Johnie",</div><div class="line">    "last_name" :  "Smithreen",</div><div class="line">    "age" :        38,</div><div class="line">    "about" :      "I do not love to go rock climbing",</div><div class="line">    "interests": []</div><div class="line">&#125;'</div></pre></td></tr></table></figure></p>
<p>如果指定的ID不存在，那么PUT也会新建一条记录。删除索引的话，发出DELETE请求就可以了：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -XDELETE <span class="string">'http://192.168.99.100:9200/megacorp/employee/AVbK2ssDm7bdYo65QJ6k'</span></div></pre></td></tr></table></figure></p>
<p>或者删除整个索引：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -XDELETE <span class="string">'http://192.168.99.100:9200/megacorp'</span></div></pre></td></tr></table></figure></p>
<p>再次获取索引信息，便会看到已经没有索引了。让我们加上三条数据，以备下一节搜索使用：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">curl -XPOST <span class="string">'http://192.168.99.100:9200/megacorp/employee/1'</span> -d <span class="string">'</span></div><div class="line">&#123;</div><div class="line">    "first_name" : "John",</div><div class="line">    "last_name" :  "Smith",</div><div class="line">    "age" :        25,</div><div class="line">    "about" :      "I love to go rock climbing",</div><div class="line">    "interests": [ "sports", "music" ]</div><div class="line">&#125;'</div><div class="line">curl -XPOST <span class="string">'http://192.168.99.100:9200/megacorp/employee/2'</span> -d <span class="string">'</span></div><div class="line">&#123;</div><div class="line">    "first_name" :  "Jane",</div><div class="line">    "last_name" :   "Smith",</div><div class="line">    "age" :         32,</div><div class="line">    "about" :       "I like to collect rock albums",</div><div class="line">    "interests":  [ "music" ]</div><div class="line">&#125;'</div><div class="line">curl -XPOST <span class="string">'http://192.168.99.100:9200/megacorp/employee/3'</span> -d <span class="string">'</span></div><div class="line">&#123;</div><div class="line">    "first_name" :  "Douglas",</div><div class="line">    "last_name" :   "Fir",</div><div class="line">    "age" :         35,</div><div class="line">    "about":        "I like to build cabinets",</div><div class="line">    "interests":  [ "forestry" ]</div><div class="line">&#125;'</div></pre></td></tr></table></figure></p>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>要查看刚刚创建的数据，直接get就可以了：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">curl <span class="string">'http://192.168.99.100:9200/megacorp/employee/1'</span></div><div class="line">curl <span class="string">'http://192.168.99.100:9200/megacorp/employee/2'</span></div><div class="line">curl <span class="string">'http://192.168.99.100:9200/megacorp/employee/3'</span></div></pre></td></tr></table></figure></p>
<p>全部查询改一下url就可以了：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">curl <span class="string">'http://192.168.99.100:9200/megacorp/employee/_search'</span></div><div class="line">curl <span class="string">'http://192.168.99.100:9200/megacorp/_search'</span></div><div class="line">curl <span class="string">'http://192.168.99.100:9200/_search'</span></div></pre></td></tr></table></figure></p>
<h3 id="简易搜索"><a href="#简易搜索" class="headerlink" title="简易搜索"></a>简易搜索</h3><p>上面的命令都只能算查询，还不算搜索。接下来让我们尝试Elasticsearch强大的搜索功能：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">curl <span class="string">'http://192.168.99.100:9200/megacorp/employee/_search?q=last_name:Smith'</span></div><div class="line">curl <span class="string">'http://192.168.99.100:9200/megacorp/employee/_search'</span> -d <span class="string">'</span></div><div class="line">&#123;</div><div class="line">    "query" : &#123;</div><div class="line">        "match" : &#123;</div><div class="line">            "last_name" : "Smith"</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;'</div></pre></td></tr></table></figure></p>
<h3 id="查询DSL"><a href="#查询DSL" class="headerlink" title="查询DSL"></a>查询DSL</h3><p>上面两条命令都是去获取<code>last_name</code>为<code>Smith</code>的数据，但是下面一条用到了<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html" target="_blank" rel="external">查询DSL</a>。这是Elasticsearch提供的DSL查询语言，可以通过它完成更加复杂的搜索。接下来除了<code>Smith</code>以外，我们还要增加30岁以上这一条件：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">curl <span class="string">'http://192.168.99.100:9200/megacorp/employee/_search'</span> -d <span class="string">'</span></div><div class="line">&#123;</div><div class="line">    "query" : &#123;</div><div class="line">        "filtered" : &#123;</div><div class="line">            "filter" : &#123;</div><div class="line">                "range" : &#123;</div><div class="line">                    "age" : &#123; "gt" : 30 &#125; </div><div class="line">                &#125;</div><div class="line">            &#125;,</div><div class="line">            "query" : &#123;</div><div class="line">                "match" : &#123;</div><div class="line">                    "last_name" : "smith" </div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;'</div></pre></td></tr></table></figure></p>
<p>在这里介绍一下<code>filter</code>和<code>query</code>。可以这么理解：<code>filter</code>是精确查找（想象成sql里where子句的=、&lt;、&gt;），速度快，有缓存。<code>query</code>是模糊查找（想象成sql里where子句的like，但是能根据匹配度打分），虽然没有<code>filter</code>那么快，但是查询结果能更准确一些。业务上的查询通常都是同时使用二者，通过<code>filter</code>快速找到对象数据，再通过<code>query</code>来匹配。</p>
<h3 id="全文搜索"><a href="#全文搜索" class="headerlink" title="全文搜索"></a>全文搜索</h3><p>接下来尝试全文搜索，从<code>about</code>的句子里查询想要的数据：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">curl <span class="string">'http://192.168.99.100:9200/megacorp/employee/_search'</span> -d <span class="string">'</span></div><div class="line">&#123;</div><div class="line">    "query" : &#123;</div><div class="line">        "match" : &#123;</div><div class="line">            "about" : "rock climbing"</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;'</div></pre></td></tr></table></figure></p>
<p>查到了两个结果。返回值包含了一项<code>_score</code>，既含有<code>rock</code>又含有<code>climbing</code>的数据，得分明显高于只含有<code>rock</code>的数据。理所当然的，得分高的数据排在上面。如果想要精确匹配<code>rock climbing</code>，把<code>match</code>改为<code>match_phrase</code>就可以了：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">curl <span class="string">'http://192.168.99.100:9200/megacorp/employee/_search'</span> -d <span class="string">'</span></div><div class="line">&#123;</div><div class="line">    "query" : &#123;</div><div class="line">        "match_phrase" : &#123;</div><div class="line">            "about" : "rock climbing"</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;'</div></pre></td></tr></table></figure></p>
<h3 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h3><p>查找最受欢迎的兴趣：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">curl <span class="string">'http://192.168.99.100:9200/megacorp/employee/_search'</span> -d <span class="string">'</span></div><div class="line">&#123;</div><div class="line">  "aggs": &#123;</div><div class="line">    "all_interests": &#123;</div><div class="line">      "terms": &#123; "field": "interests" &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;'</div></pre></td></tr></table></figure></p>
<p>查找每个兴趣的平均年龄：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">curl <span class="string">'http://192.168.99.100:9200/megacorp/employee/_search'</span> -d <span class="string">'</span></div><div class="line">&#123;</div><div class="line">    "aggs" : &#123;</div><div class="line">        "all_interests" : &#123;</div><div class="line">            "terms" : &#123; "field" : "interests" &#125;,</div><div class="line">            "aggs" : &#123;</div><div class="line">                "avg_age" : &#123;</div><div class="line">                    "avg" : &#123; "field" : "age" &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;'</div></pre></td></tr></table></figure></p>
<p>这些数据都是实时计算出来的。就像使用SQL来查询数据库一样，Elasticsearch提供了自己的DSL来让我们基于复杂的条件来搜索。<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html" target="_blank" rel="external">这里</a>是统计功能的官方文档。</p>
<h2 id="中文"><a href="#中文" class="headerlink" title="中文"></a>中文</h2><p>同Solr一样，要想让Elasticsearch支持中文分词，需要使用中文分词组件。这里我们还是用<a href="https://github.com/medcl/elasticsearch-analysis-mmseg" target="_blank" rel="external">mmseg插件</a>。首先下载并解压：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">wget -c https://github.com/medcl/elasticsearch-analysis-mmseg/releases/download/v1.9.4/elasticsearch-analysis-mmseg-1.9.4.zip</div><div class="line">unzip -d elasticsearch-analysis-mmseg-1.9.4 elasticsearch-analysis-mmseg-1.9.4.zip</div><div class="line">sed -i <span class="string">'s/2.3.4/2.3.5/'</span> elasticsearch-analysis-mmseg-1.9.4/plugin-descriptor.properties</div></pre></td></tr></table></figure></p>
<p>1.9.4版的插件只支持Elasticsearch 2.3.4版，要想支持2.3.5，就需要把<code>elasticsearch.version</code>配置改为<code>2.3.5</code>。除此之外，还需要加点儿东西到Elasticsearch的配置文件里：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">cat &lt;&lt; EOF &gt; es.yml</div><div class="line">network.host: 0.0.0.0</div><div class="line">index:</div><div class="line">  analysis:</div><div class="line">    analyzer:</div><div class="line">      mmseg_maxword:</div><div class="line">        <span class="built_in">type</span>: custom</div><div class="line">        filter:</div><div class="line">        - lowercase</div><div class="line">        tokenizer: mmseg_maxword</div><div class="line">      mmseg_maxword_with_cut_letter_digi:</div><div class="line">        <span class="built_in">type</span>: custom</div><div class="line">        filter:</div><div class="line">        - lowercase</div><div class="line">        - cut_letter_digit</div><div class="line">        tokenizer: mmseg_maxword</div><div class="line">EOF</div></pre></td></tr></table></figure></p>
<p>上述配置文件的具体语法可以参考<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis.html" target="_blank" rel="external">这里</a>。接下来就可以启动容器了，分别挂载配置文件和插件：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">docker rm -f es</div><div class="line">docker run -d --net=host --name=es \</div><div class="line">    -v `<span class="built_in">pwd</span>`/es.yml:/usr/share/elasticsearch/config/elasticsearch.yml \</div><div class="line">    -v `<span class="built_in">pwd</span>`/elasticsearch-analysis-mmseg-1.9.4/:/usr/share/elasticsearch/plugins/elasticsearch-analysis-mmseg-1.9.4/ \</div><div class="line">    elasticsearch:2.3.5</div></pre></td></tr></table></figure></p>
<p>Elasticsearch服务启动后，就可以增加索引和<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping.html" target="_blank" rel="external">映射</a>（mapping，可以理解为数据类型，有点像solr的schema），并且插入一些数据了：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">curl -XPUT http://192.168.99.100:9200/index</div><div class="line">curl -XPOST http://192.168.99.100:9200/index/fulltext/_mapping -d<span class="string">'</span></div><div class="line">&#123;</div><div class="line">    "fulltext": &#123;</div><div class="line">        "_all": &#123;</div><div class="line">            "analyzer": "mmseg_maxword",</div><div class="line">            "search_analyzer": "mmseg_maxword",</div><div class="line">            "term_vector": "no",</div><div class="line">            "store": "false"</div><div class="line">        &#125;,</div><div class="line">        "properties": &#123;</div><div class="line">            "content": &#123;</div><div class="line">                "type": "string",</div><div class="line">                "store": "no",</div><div class="line">                "term_vector": "with_positions_offsets",</div><div class="line">                "analyzer": "mmseg_maxword",</div><div class="line">                "search_analyzer": "mmseg_maxword",</div><div class="line">                "include_in_all": "true",</div><div class="line">                "boost": 8</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;'</div><div class="line"></div><div class="line">curl -XPOST http://192.168.99.100:9200/index/fulltext/1 -d<span class="string">'&#123;content:"美国留给伊拉克的是个烂摊子吗"&#125;'</span></div><div class="line">curl -XPOST http://192.168.99.100:9200/index/fulltext/2 -d<span class="string">'&#123;content:"公安部：各地校车将享最高路权"&#125;'</span></div><div class="line">curl -XPOST http://192.168.99.100:9200/index/fulltext/3 -d<span class="string">'&#123;content:"中韩渔警冲突调查：韩警平均每天扣1艘中国渔船"&#125;'</span></div><div class="line">curl -XPOST http://192.168.99.100:9200/index/fulltext/4 -d<span class="string">'&#123;content:"中国驻洛杉矶领事馆遭亚裔男子枪击 嫌犯已自首"&#125;'</span></div></pre></td></tr></table></figure></p>
<p>最后搜索<code>中国</code>看看：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">curl -XPOST http://192.168.99.100:9200/index/fulltext/_search  -d<span class="string">'</span></div><div class="line">&#123;</div><div class="line">    "query" : &#123; "term" : &#123; "content" : "中国" &#125;&#125;,</div><div class="line">    "highlight" : &#123;</div><div class="line">        "pre_tags" : ["&lt;tag1&gt;", "&lt;tag2&gt;"],</div><div class="line">        "post_tags" : ["&lt;/tag1&gt;", "&lt;/tag2&gt;"],</div><div class="line">        "fields" : &#123;</div><div class="line">            "content" : &#123;&#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">'</div></pre></td></tr></table></figure></p>
<p>可以使用<code>_analyze</code>来查看分析的过程：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl <span class="string">"http://192.168.99.100:9200/index/_analyze?analyzer=mmseg_maxword&amp;pretty=true"</span> -d <span class="string">"美国留给伊拉克的是个烂摊子吗"</span></div></pre></td></tr></table></figure></p>
<p>可见，这句话被解析成：美国、留给、伊、拉克、的、是个、烂、摊子、吗，还不是非常完美。<code>伊拉克</code>、<code>烂摊子</code>都没有很好地识别出来。</p>
<p>有兴趣的话，还可以重建容器，跟无中文分词的效果对比一下。除了mmseg，大神medcl还写了一个<a href="https://github.com/medcl/elasticsearch-rtf" target="_blank" rel="external">elasticsearch-rtf版本</a>，涵盖诸多中文分词工具，可以直接使用。</p>
]]></content>
      
        <categories>
            
            <category> devops </category>
            
        </categories>
        
        
        <tags>
            
            <tag> elasticsearch </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用容器轻松搭建redis主从和集群环境]]></title>
      <url>/redis-cluster/</url>
      <content type="html"><![CDATA[<p><a href="http://redis.io/" target="_blank" rel="external">Redis</a>是目前使用得非常广泛的开源分布式缓存。它支持诸多数据结构和数据持久化，并且通过<a href="http://redis.io/topics/sentinel" target="_blank" rel="external">Redis Sentinel</a>和<a href="http://redis.io/topics/cluster-tutorial" target="_blank" rel="external">Redis cluster</a>来支持高可用。本文旨在通过docker轻松搭建redis的主从/集群环境。<br><a id="more"></a></p>
<h2 id="主从"><a href="#主从" class="headerlink" title="主从"></a>主从</h2><p>用容器启动redis实例非常容易：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run --net=host --name=master -d redis:3.2.0</div></pre></td></tr></table></figure></p>
<p>这就搞定了。进去看一看：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> -it master redis-cli</div><div class="line"><span class="built_in">set</span> ggg 123</div><div class="line">keys *</div><div class="line">get ggg</div><div class="line"><span class="built_in">exit</span></div></pre></td></tr></table></figure></p>
<p>可以通过配置文件、启动参数或者命令来新建一个从实例。接下来我们用启动参数的方式：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run --net=host --name=slave -d redis:3.2.0 redis-server --port 6380 --slaveof 127.0.0.1 6379</div></pre></td></tr></table></figure></p>
<p>进去看一看，就能看到刚才创建的ggg已经被同步过来了：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> -it slave redis-cli</div><div class="line">keys *</div><div class="line">get ggg</div><div class="line"><span class="built_in">exit</span></div></pre></td></tr></table></figure></p>
<p>最后把刚刚创建的实例都删除掉：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rm -f master slave</div></pre></td></tr></table></figure></p>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>Redis的集群至少是3个实例。接下来为这3个实例创建3个端口不同的配置文件：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">cat &lt;&lt; EOF &gt; redis1.conf</div><div class="line">port 6381</div><div class="line">cluster-enabled yes</div><div class="line">cluster-config-file nodes.conf</div><div class="line">cluster-node-timeout 5000</div><div class="line">appendonly yes</div><div class="line">EOF</div><div class="line"></div><div class="line">cp redis1.conf redis2.conf</div><div class="line">sed -i <span class="string">'s/6381/6382/'</span> redis2.conf</div><div class="line"></div><div class="line">cp redis1.conf redis3.conf</div><div class="line">sed -i <span class="string">'s/6381/6383/'</span> redis3.conf</div></pre></td></tr></table></figure></p>
<p>通过刚刚创建的配置文件来启动3个redis实例：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker run --net=host --name=redis1 -v `<span class="built_in">pwd</span>`/redis1.conf:/usr/<span class="built_in">local</span>/etc/redis/redis.conf -d redis:3.2.0 redis-server /usr/<span class="built_in">local</span>/etc/redis/redis.conf</div><div class="line">docker run --net=host --name=redis2 -v `<span class="built_in">pwd</span>`/redis2.conf:/usr/<span class="built_in">local</span>/etc/redis/redis.conf -d redis:3.2.0 redis-server /usr/<span class="built_in">local</span>/etc/redis/redis.conf</div><div class="line">docker run --net=host --name=redis3 -v `<span class="built_in">pwd</span>`/redis3.conf:/usr/<span class="built_in">local</span>/etc/redis/redis.conf -d redis:3.2.0 redis-server /usr/<span class="built_in">local</span>/etc/redis/redis.conf</div></pre></td></tr></table></figure></p>
<p>创建集群最简单的方式是用源代码库里的<code>redis-trib.rb</code>脚本。我们需要先下载源代码并安装<code>redis</code>的gem使之能够运行这个脚本：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">clone</span> https://github.com/antirez/redis</div><div class="line"></div><div class="line">sudo gem install redis</div><div class="line"></div><div class="line">ruby redis/src/redis-trib.rb create 127.0.0.1:6381 127.0.0.1:6382 127.0.0.1:6383</div></pre></td></tr></table></figure></p>
<p>运行<code>redis-trib.rb</code>会提示：<strong>Can I set the above configuration? (type ‘yes’ to accept)</strong>，输入<code>yes</code>回车即可。Redis集群就这样搭建好了。我们进去看一看：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> -it redis1 redis-cli -p 6381</div><div class="line">cluster nodes</div><div class="line"><span class="built_in">set</span> ggg 123</div><div class="line"><span class="built_in">set</span> gggg 234</div><div class="line"><span class="built_in">exit</span></div></pre></td></tr></table></figure></p>
<p>第一个ggg可以顺利设置成功，但是第二个gggg就不行了，我们会看到错误：<strong>(error) MOVED 6392 127.0.0.1:6382</strong>。这是由于redis<a href="http://redis.io/topics/cluster-tutorial#redis-cluster-data-sharding" target="_blank" rel="external">分片（sharding）</a>的缘故。如果频繁地在控制台里切换实例也怪麻烦的，幸好<code>redis-cli</code>提供了一个<code>-c</code>的参数，允许以集群的方式连接：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> -it redis1 redis-cli -c -p 6381</div><div class="line"><span class="built_in">set</span> gggg 234</div><div class="line">keys *</div><div class="line"><span class="built_in">exit</span></div></pre></td></tr></table></figure></p>
<p>再次设置gggg，就会看到：<strong>Redirected to slot [6392] located at 127.0.0.1:6382</strong>，它表明redis已经把我们连接到6382的实例上去了。最后把前面创建的实例都删除掉：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rm -f redis1 redis2 redis3</div></pre></td></tr></table></figure></p>
<h2 id="主从集群"><a href="#主从集群" class="headerlink" title="主从集群"></a>主从集群</h2><p>主从集群就是给三个主实例各加一个从实例。现在已经有了三个主实例的配置文件了，再来三个从集群的，一共是6个：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">cp redis1.conf redis4.conf</div><div class="line">cp redis1.conf redis5.conf</div><div class="line">cp redis1.conf redis6.conf</div><div class="line"></div><div class="line">sed -i <span class="string">'s/6381/6384/'</span> redis4.conf</div><div class="line">sed -i <span class="string">'s/6381/6385/'</span> redis5.conf</div><div class="line">sed -i <span class="string">'s/6381/6386/'</span> redis6.conf</div><div class="line"></div><div class="line">docker run --net=host --name=redis1 -v `<span class="built_in">pwd</span>`/redis1.conf:/usr/<span class="built_in">local</span>/etc/redis/redis.conf -d redis:3.2.0 redis-server /usr/<span class="built_in">local</span>/etc/redis/redis.conf</div><div class="line">docker run --net=host --name=redis2 -v `<span class="built_in">pwd</span>`/redis2.conf:/usr/<span class="built_in">local</span>/etc/redis/redis.conf -d redis:3.2.0 redis-server /usr/<span class="built_in">local</span>/etc/redis/redis.conf</div><div class="line">docker run --net=host --name=redis3 -v `<span class="built_in">pwd</span>`/redis3.conf:/usr/<span class="built_in">local</span>/etc/redis/redis.conf -d redis:3.2.0 redis-server /usr/<span class="built_in">local</span>/etc/redis/redis.conf</div><div class="line">docker run --net=host --name=redis4 -v `<span class="built_in">pwd</span>`/redis4.conf:/usr/<span class="built_in">local</span>/etc/redis/redis.conf -d redis:3.2.0 redis-server /usr/<span class="built_in">local</span>/etc/redis/redis.conf</div><div class="line">docker run --net=host --name=redis5 -v `<span class="built_in">pwd</span>`/redis5.conf:/usr/<span class="built_in">local</span>/etc/redis/redis.conf -d redis:3.2.0 redis-server /usr/<span class="built_in">local</span>/etc/redis/redis.conf</div><div class="line">docker run --net=host --name=redis6 -v `<span class="built_in">pwd</span>`/redis6.conf:/usr/<span class="built_in">local</span>/etc/redis/redis.conf -d redis:3.2.0 redis-server /usr/<span class="built_in">local</span>/etc/redis/redis.conf</div></pre></td></tr></table></figure></p>
<p>一条命令即可启动主从集群：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ruby redis/src/redis-trib.rb create --replicas 1 127.0.0.1:6381 127.0.0.1:6382 127.0.0.1:6383 127.0.0.1:6384 127.0.0.1:6385 127.0.0.1:6386</div></pre></td></tr></table></figure></p>
<p>然后就可以在里面随意测试啦。最后把创建的实例都删除掉：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rm -f redis1 redis2 redis3 redis4 redis5 redis6</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> devops </category>
            
        </categories>
        
        
        <tags>
            
            <tag> redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用容器快速上手Apache Solr]]></title>
      <url>/solr/</url>
      <content type="html"><![CDATA[<p><a href="http://lucene.apache.org/solr/" target="_blank" rel="external">Apache Solr</a>是用Java开发的基于<a href="https://lucene.apache.org/" target="_blank" rel="external">Apache Lucene</a>的高性能全文检索服务器，可以运行在web容器里，提供搜索引擎服务。本文旨在用docker来快速入门并尝试Solr提供的各种功能。</p>
<p>对<a href="https://www.elastic.co/products/elasticsearch" target="_blank" rel="external">Elasticsearch</a>入门有兴趣的朋友请参考<a href="/elastic-search">用容器快速上手Elasticsearch</a>。<br><a id="more"></a></p>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>关于Solr的入门知识，有一本gitbook：<a href="https://www.gitbook.com/book/paynexu/create-your-vertical-search-engine-with-solr/details" target="_blank" rel="external">《用Solr构建垂直搜索引擎》</a>写得不错。本文关心的是实际操作，所以这就开始吧。通过docker，一条命令就可以直接启动Solr：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d -p 8983:8983 --name solr solr:6.1.0</div></pre></td></tr></table></figure></p>
<p>我用的是mac，通过<code>docker-machine env default</code>命令可以看到默认的<code>default docker-machine</code>的IP地址是<code>192.168.99.100</code>，于是便可以通过<a href="http://192.168.99.100:8983/solr" target="_blank" rel="external">http://192.168.99.100:8983/solr</a>来访问Solr Admin了：<br><img src="/img/solr-dashboard.jpg" alt=""></p>
<p>在Solr里，<a href="https://cwiki.apache.org/confluence/display/solr/Solr+Cores+and+solr.xml" target="_blank" rel="external">Core</a>可以认为是一个集合，一个Solr实例可以有多个Core。可以说Solr实例和Core的关系像是数据库实例和数据库的关系。现在我们来新建一个core，命名为ggg：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> -it --user=solr solr bin/solr create_core -c ggg</div></pre></td></tr></table></figure></p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>Solr支持<a href="https://cwiki.apache.org/confluence/display/solr/Uploading+Data+with+Index+Handlers#UploadingDatawithIndexHandlers-XMLFormattedIndexUpdates" target="_blank" rel="external">xml</a>、<a href="https://cwiki.apache.org/confluence/display/solr/Uploading+Data+with+Index+Handlers#UploadingDatawithIndexHandlers-JSONFormattedIndexUpdates" target="_blank" rel="external">json</a>和<a href="https://cwiki.apache.org/confluence/display/solr/Uploading+Data+with+Index+Handlers#UploadingDatawithIndexHandlers-CSVFormattedIndexUpdates" target="_blank" rel="external">csv</a>格式的数据文件用于索引。接下来让我们来试试。首先登录进solr容器：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> -it --user=solr solr bash</div></pre></td></tr></table></figure></p>
<h3 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h3><p>Solr存储的对象称为Document，每个Document数个Field组成，每个Field代表一个属性。现在按照<code>&lt;add&gt;&lt;doc&gt;&lt;field name=&quot;&quot;&gt;</code>的格式来生成一个xml文件：<br><figure class="highlight sh"><figcaption><span>solr</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">cat &lt;&lt;EOF &gt; books.xml</div><div class="line">&lt;add&gt;</div><div class="line">  &lt;doc&gt;</div><div class="line">    &lt;field name=<span class="string">"id"</span>&gt;978-0641723445&lt;/field&gt;</div><div class="line">    &lt;field name=<span class="string">"name"</span>&gt;The Lightning Thief&lt;/field&gt;</div><div class="line">    &lt;field name=<span class="string">"author"</span>&gt;Rick Riordan&lt;/field&gt;</div><div class="line">    &lt;field name=<span class="string">"series_t"</span>&gt;Percy Jackson and the Olympians&lt;/field&gt;</div><div class="line">    &lt;field name=<span class="string">"sequence_i"</span>&gt;1&lt;/field&gt;</div><div class="line">    &lt;field name=<span class="string">"genre_s"</span>&gt;fantasy&lt;/field&gt;</div><div class="line">    &lt;field name=<span class="string">"inStock"</span>&gt;<span class="literal">true</span>&lt;/field&gt;</div><div class="line">    &lt;field name=<span class="string">"price"</span>&gt;12.50&lt;/field&gt;</div><div class="line">    &lt;field name=<span class="string">"pages_i"</span>&gt;384&lt;/field&gt;</div><div class="line">  &lt;/doc&gt;</div><div class="line">  &lt;doc&gt;</div><div class="line">    &lt;field name=<span class="string">"id"</span>&gt;978-1423103349&lt;/field&gt;</div><div class="line">    &lt;field name=<span class="string">"name"</span>&gt;The Sea of Monsters&lt;/field&gt;</div><div class="line">    &lt;field name=<span class="string">"author"</span>&gt;Rick Riordan&lt;/field&gt;</div><div class="line">    &lt;field name=<span class="string">"series_t"</span>&gt;Percy Jackson and the Olympians&lt;/field&gt;</div><div class="line">    &lt;field name=<span class="string">"sequence_i"</span>&gt;2&lt;/field&gt;</div><div class="line">    &lt;field name=<span class="string">"inStock"</span>&gt;<span class="literal">true</span>&lt;/field&gt;</div><div class="line">    &lt;field name=<span class="string">"price"</span>&gt;6.49&lt;/field&gt;</div><div class="line">    &lt;field name=<span class="string">"pages_i"</span>&gt;304&lt;/field&gt;</div><div class="line">  &lt;/doc&gt;</div><div class="line">&lt;/add&gt;</div><div class="line">EOF</div></pre></td></tr></table></figure></p>
<p>细心的你可能已经发现了下面一条数据里并没有<code>fantasy</code>，我故意的~~现在用以下命令将这个xml导入索引：<br><figure class="highlight sh"><figcaption><span>solr</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/post -c ggg books.xml</div></pre></td></tr></table></figure></p>
<p>索引完成后，在Solr Admin的ggg Core的Query里，直接点击Execute Query便可以看到我们新索引的这两条数据：<br><img src="/img/solr-query.jpg" alt=""></p>
<p>在<code>q</code>里输入搜索的关键词便可以查询索引：</p>
<ul>
<li>Rick Riordan：匹配作者</li>
<li>Jackson：分词可以工作</li>
<li>the：不区分大小写</li>
<li>fantasy：不符合的记录不会被查询到</li>
<li>fantasy 0123：不是所有关键词都会被使用</li>
<li>0123：但如果只有查不到的关键词，那就是查不到</li>
<li>fantasy -Rick：<code>-</code>表示过滤</li>
<li>Lightni：单词不全不能匹配</li>
<li>Lightn?ng：<code>?</code>匹配一位</li>
<li>L*g：<code>*</code>匹配多位</li>
<li>Lightnixx~：<code>~</code>用于模糊查询</li>
<li>Lightnxxx~：<code>~</code>最多就匹配两位</li>
</ul>
<p>还有很多查询的技巧，可以在<a href="https://cwiki.apache.org/confluence/display/solr/The+Standard+Query+Parser" target="_blank" rel="external">这里</a>找到。</p>
<p>再次导入相同的数据：<br><figure class="highlight sh"><figcaption><span>solr</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/post -c ggg books.xml</div></pre></td></tr></table></figure></p>
<p>可以看到查询结果并没有变化。这是因为solr会根据<code>id</code>来区分每一个数据。如果更新xml再导入，那就会覆盖掉旧的数据。现在让我们把漏了的<code>fantasy</code>补上：<br><figure class="highlight sh"><figcaption><span>solr</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sed -i <span class="string">'/&lt;field name="sequence_i"&gt;2&lt;\/field&gt;/a \ \ \ \ &lt;field name="genre_s"&gt;fantasy&lt;\/field&gt;'</span> books.xml</div><div class="line">cat books.xml</div><div class="line">bin/post -c ggg books.xml</div></pre></td></tr></table></figure></p>
<p>可以查询<code>fantasy</code>看到结果变成了两条。</p>
<h3 id="json"><a href="#json" class="headerlink" title="json"></a>json</h3><p>接下来创建一个json文件并索引：<br><figure class="highlight sh"><figcaption><span>solr</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">cat &lt;&lt;EOF &gt; books.json</div><div class="line">[</div><div class="line">  &#123;</div><div class="line">    <span class="string">"id"</span> : <span class="string">"978-1857995879"</span>,</div><div class="line">    <span class="string">"cat"</span> : [<span class="string">"book"</span>,<span class="string">"paperback"</span>],</div><div class="line">    <span class="string">"name"</span> : <span class="string">"Sophie's World : The Greek Philosophers"</span>,</div><div class="line">    <span class="string">"author"</span> : <span class="string">"Jostein Gaarder"</span>,</div><div class="line">    <span class="string">"sequence_i"</span> : 1,</div><div class="line">    <span class="string">"genre_s"</span> : <span class="string">"fantasy"</span>,</div><div class="line">    <span class="string">"inStock"</span> : <span class="literal">true</span>,</div><div class="line">    <span class="string">"price"</span> : 3.07,</div><div class="line">    <span class="string">"pages_i"</span> : 64</div><div class="line">  &#125;</div><div class="line">,</div><div class="line">  &#123;</div><div class="line">    <span class="string">"id"</span> : <span class="string">"978-1933988177"</span>,</div><div class="line">    <span class="string">"cat"</span> : [<span class="string">"book"</span>,<span class="string">"paperback"</span>],</div><div class="line">    <span class="string">"name"</span> : <span class="string">"Lucene in Action, Second Edition"</span>,</div><div class="line">    <span class="string">"author"</span> : <span class="string">"Michael McCandless"</span>,</div><div class="line">    <span class="string">"sequence_i"</span> : 1,</div><div class="line">    <span class="string">"genre_s"</span> : <span class="string">"IT"</span>,</div><div class="line">    <span class="string">"inStock"</span> : <span class="literal">true</span>,</div><div class="line">    <span class="string">"price"</span> : 30.50,</div><div class="line">    <span class="string">"pages_i"</span> : 475</div><div class="line">  &#125;</div><div class="line">]</div><div class="line">EOF</div><div class="line"></div><div class="line">bin/post -c ggg books.json</div></pre></td></tr></table></figure></p>
<p>查询一下<code>978</code>，就能看到json文件的内容也被索引进来了。</p>
<h3 id="csv"><a href="#csv" class="headerlink" title="csv"></a>csv</h3><p>接下来创建一个csv文件并索引：<br><figure class="highlight sh"><figcaption><span>solr</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">cat &lt;&lt;EOF &gt; books.csv</div><div class="line">id,cat,name,price,inStock,author,series_t,sequence_i,genre_s</div><div class="line">0553573403,book,A Game of Thrones,7.99,<span class="literal">true</span>,George R.R. Martin,<span class="string">"A Song of Ice and Fire"</span>,1,fantasy</div><div class="line">0553579908,book,A Clash of Kings,7.99,<span class="literal">true</span>,George R.R. Martin,<span class="string">"A Song of Ice and Fire"</span>,2,fantasy</div><div class="line">055357342X,book,A Storm of Swords,7.99,<span class="literal">true</span>,George R.R. Martin,<span class="string">"A Song of Ice and Fire"</span>,3,fantasy</div><div class="line">0553293354,book,Foundation,7.99,<span class="literal">true</span>,Isaac Asimov,Foundation Novels,1,scifi</div><div class="line">0812521390,book,The Black Company,6.99,<span class="literal">false</span>,Glen Cook,The Chronicles of The Black Company,1,fantasy</div><div class="line">0812550706,book,Ender<span class="string">'s Game,6.99,true,Orson Scott Card,Ender,1,scifi</span></div><div class="line">0441385532,book,Jhereg,7.95,false,Steven Brust,Vlad Taltos,1,fantasy</div><div class="line">0380014300,book,Nine Princes In Amber,6.99,true,Roger Zelazny,the Chronicles of Amber,1,fantasy</div><div class="line">0805080481,book,The Book of Three,5.99,true,Lloyd Alexander,The Chronicles of Prydain,1,fantasy</div><div class="line">080508049X,book,The Black Cauldron,5.99,true,Lloyd Alexander,The Chronicles of Prydain,2,fantasy</div><div class="line">EOF</div><div class="line"></div><div class="line">bin/post -c ggg books.csv</div></pre></td></tr></table></figure></p>
<p>查询一下<code>*:*</code>，就能看到csv文件的内容也被索引进来了。一共有14条<code>numFound</code>记录，但是只会显示10条。通过<code>Query</code>页面上的<code>start, rows</code>，就可以很方便地查询分页。</p>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p><code>bin/post</code>这个命令也能索引文件夹，不管里面的文件是什么格式：<br><figure class="highlight sh"><figcaption><span>solr</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mkdir books</div><div class="line">mv books.xml books</div><div class="line">mv books.json books</div><div class="line">mv books.csv books</div><div class="line"></div><div class="line">bin/post -c ggg books</div></pre></td></tr></table></figure></p>
<p>还有一个比较基本的需求是使用The Data Import Handler (DIH)来索引数据库。可以参考<a href="https://cwiki.apache.org/confluence/display/solr/Uploading+Structured+Data+Store+Data+with+the+Data+Import+Handler" target="_blank" rel="external">https://cwiki.apache.org/confluence/display/solr/Uploading+Structured+Data+Store+Data+with+the+Data+Import+Handler</a>。</p>
<p>再有就是如何在程序中更新数据。Solr支持多种语言的客户端，对于Java来说，可以参考<a href="https://cwiki.apache.org/confluence/display/solr/Using+SolrJ" target="_blank" rel="external">SolrJ</a>。</p>
<p>还可以通过http请求来更新索引：<br><figure class="highlight sh"><figcaption><span>solr</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">curl <span class="string">'http://192.168.99.100:8983/solr/ggg/update?commit=true'</span> \</div><div class="line">  -H <span class="string">'Contenttype: application/json'</span> \</div><div class="line">  -d <span class="string">'[&#123;"id":"12345","name":"Practical DevOps","author":"Joakim Verona","gere_s":"IT"&#125;]'</span></div></pre></td></tr></table></figure></p>
<p>删除索引：<br><figure class="highlight sh"><figcaption><span>solr</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/post -c ggg -d <span class="string">"&lt;delete&gt;&lt;id&gt;12345&lt;/id&gt;&lt;/delete&gt;"</span></div></pre></td></tr></table></figure></p>
<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>其实上一节已经介绍了不少查询相关的内容了。在查询页面的右上角有一个url，例如<a href="http://192.168.99.100:8983/solr/ggg/select?indent=on&amp;q=*:*&amp;wt=json" target="_blank" rel="external">http://192.168.99.100:8983/solr/ggg/select?indent=on&amp;q=<em>:</em>&amp;wt=json</a>。只要对其发出<code>get</code>请求，便可以获取到查询结果。当然直接<code>curl</code>也可以：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl <span class="string">'http://192.168.99.100:8983/solr/ggg/select?indent=on&amp;q=*:*&amp;wt=json'</span></div></pre></td></tr></table></figure></p>
<p>至于<code>Query</code>页面上的其它查询条件，可以在<a href="http://wiki.apache.org/solr/CommonQueryParameters" target="_blank" rel="external">http://wiki.apache.org/solr/CommonQueryParameters</a>上查到。这里简介如下：</p>
<ul>
<li>fq（Filter Query）：过滤查询，可以指定多个条件并缓存。例如：<code>inStock:false</code></li>
<li>sort：排序。例如：<code>sequence_i desc</code></li>
<li>start：查询结果忽略掉前n条</li>
<li>rows：查询结果数量</li>
<li>fl（Field List）：指定查询结果字段。例如<code>author, sequence_i</code></li>
<li>df（Default Field）：指定查询字段。</li>
<li>wt（Write Type）：指定输出格式，有xml，json，python，ruby，php，csv等多项可选</li>
</ul>
<p>还有一些高级功能，本文旨在入门，就不细说了。访问<a href="http://192.168.99.100:8983/solr/ggg/browse" target="_blank" rel="external">http://192.168.99.100:8983/solr/ggg/browse</a>可以查看已索引的所有数据。最后输入<code>exit</code>退出solr容器。</p>
<h2 id="中文"><a href="#中文" class="headerlink" title="中文"></a>中文</h2><p>在没有使用任何中文分词组件的情况下，Solr会把所有中文的每个字当成一个词来检索。要想让Solr支持中文分词，需要使用中文分词组件。<a href="http://www.hansight.com/blog-lucene4.10-with-chinese-segment.html" target="_blank" rel="external">《与Lucene 4.10配合的中文分词比较》</a>一文里介绍了几种中文分词组件并做了比较。虽然我们用的是Solr 6.1.0版，但是也是很有参考意义的。接下来我们使用<a href="https://github.com/chenlb/mmseg4j-solr" target="_blank" rel="external">mmseg4j</a>来试一下。</p>
<p>目前的mmseg4j暂时不支持solr 6.1.0，不过已经有热心人士提交<a href="http://amao12580.github.io/post/2016/07/mmseg4j-solr-compatible-solr-6-1/" target="_blank" rel="external">pull request</a>了，只是还没合并进去。我们本着简单的原则，替换solr镜像成5.3.1版本。在作者的github上指定的<a href="https://pan.baidu.com/s/1dD7qMFf#path=%252Fmmseg4j-solr" target="_blank" rel="external">百度网盘</a>里下载<code>mmseg4j-solr-2.3.0-with-mmseg4j-core.zip</code>，解压后得到两个jar文件。之后重新创建一个solr容器并再次生成ggg的core：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">docker rm -f solr</div><div class="line">docker create -p 8983:8983 --name solr solr:5.3.1</div><div class="line">docker cp mmseg4j-core-1.10.0.jar solr:/opt/solr/server/solr-webapp/webapp/WEB-INF/lib/</div><div class="line">docker cp mmseg4j-solr-2.3.0.jar solr:/opt/solr/server/solr-webapp/webapp/WEB-INF/lib/</div><div class="line">docker start solr</div><div class="line">docker <span class="built_in">exec</span> -it --user=solr solr bin/solr create_core -c ggg</div></pre></td></tr></table></figure></p>
<p>现在用solr提供的<a href="https://cwiki.apache.org/confluence/display/solr/Schema+API" target="_blank" rel="external">Schema API</a>来配置mmseg4j：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> -it --user=solr solr bash</div><div class="line"></div><div class="line">curl -X POST -H <span class="string">'Content-type:application/json'</span> --data-binary <span class="string">'&#123;</span></div><div class="line">  "add-field-type":&#123;</div><div class="line">    "name":"textComplex",</div><div class="line">    "class":"solr.TextField",</div><div class="line">    "positionIncrementGap":"100",</div><div class="line">    "analyzer":&#123;</div><div class="line">      "tokenizer":&#123; </div><div class="line">        "class":"com.chenlb.mmseg4j.solr.MMSegTokenizerFactory",</div><div class="line">        "mode":"complex",</div><div class="line">        "dicPath":"dic"</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;' http://192.168.99.100:8983/solr/ggg/schema</div><div class="line"></div><div class="line">curl -X POST -H <span class="string">'Content-type:application/json'</span> --data-binary <span class="string">'&#123;</span></div><div class="line">  "add-field-type":&#123;</div><div class="line">    "name":"textMaxWord",</div><div class="line">    "class":"solr.TextField",</div><div class="line">    "positionIncrementGap":"100",</div><div class="line">    "analyzer":&#123;</div><div class="line">      "tokenizer":&#123; </div><div class="line">        "class":"com.chenlb.mmseg4j.solr.MMSegTokenizerFactory",</div><div class="line">        "mode":"max-word"</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;' http://192.168.99.100:8983/solr/ggg/schema</div></pre></td></tr></table></figure></p>
<p>上面的命令增加了<code>textComplex</code>和<code>textMaxWord</code>两种字段类型，它们的区别在<a href="https://paynexu.gitbooks.io/create-your-vertical-search-engine-with-solr/content/configure-mmseg4j-analyzer-on-solr5.html#complex和maxword两种类型的区别" target="_blank" rel="external">这里</a>解释得很清楚。下面就可以在<code>Analysis</code>页面上，看到我们的分词生效了：<br><img src="/img/solr-analysis.jpg" alt=""></p>
<p>还可以尝试用<code>孙悟空吃香蕉</code>这个短句来测试<code>textComplex</code>和<code>textMaxWord</code>的不同效果。接下来将<code>field desc</code>添加到<code>textComplex</code>里：<br><figure class="highlight sh"><figcaption><span>solr</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">curl -X POST -H <span class="string">'Content-type:application/json'</span> --data-binary <span class="string">'&#123;</span></div><div class="line">  "add-field":&#123;</div><div class="line">     "name":"desc",</div><div class="line">     "type":"textComplex",</div><div class="line">     "stored":true &#125;</div><div class="line">&#125;' http://192.168.99.100:8983/solr/ggg/schema</div></pre></td></tr></table></figure></p>
<p>现在让我们来索引几条包含<code>field desc</code>的中文数据：<br><figure class="highlight sh"><figcaption><span>solr</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">cat &lt;&lt;EOF &gt; cities.csv</div><div class="line">id,city,desc</div><div class="line">010,北京,简称“京”，是中华人民共和国首都、直辖市和京津冀城市群的中心，中国的政治、文化、交通、科技创新和国际交往中心，中国经济、金融的决策和管理中心</div><div class="line">021,上海,简称沪，别称申，中华人民共和国直辖市、国家中心城市之一，也是中国按行政区划主城区内人口排名的最大的城市</div><div class="line">EOF</div><div class="line"></div><div class="line">bin/post -c ggg cities.csv</div></pre></td></tr></table></figure></p>
<p>现在在<code>Query</code>页面上，输入<code>desc:中华人民共和国</code>就可以找到相对应的记录，而输入<code>desc:人民</code>就已经不能检索到结果啦。</p>
]]></content>
      
        <categories>
            
            <category> development </category>
            
        </categories>
        
        
        <tags>
            
            <tag> solr </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring Scheduler的使用与坑]]></title>
      <url>/spring-scheduler/</url>
      <content type="html"><![CDATA[<p><a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/" target="_blank" rel="external">Spring</a>给程序猿们带来了许多便利。它包含了用于定时任务处理的<a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/scheduling.html" target="_blank" rel="external">Spring Scheduler</a>。本文聊聊Scheduling模型和一些坑。<br><a id="more"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Spring Scheduler里有两个概念：任务（Task）和运行任务的框架（TaskExecutor/TaskScheduler）。TaskExecutor顾名思义，是任务的执行器，允许我们异步执行多个任务。TaskScheduler是任务调度器，来运行未来的定时任务。触发器Trigger可以决定定时任务是否该运行了，最常用的触发器是CronTrigger，具体用法会在下面章节中详细介绍。Spring内置了多种类型的TaskExecutor和TaskScheduler，方便用户根据不同业务场景选择。</p>
<p>本文聊的是Spring Scheduler，所以我们接下来主要介绍Scheduler的用法。</p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>用xml配置Spring Scheduler的话，这样就行了：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">       <span class="attr">xmlns:task</span>=<span class="string">"http://www.springframework.org/schema/task"</span></div><div class="line">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd</span></div><div class="line">                           http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-4.0.xsd"&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">task:scheduler</span> <span class="attr">id</span>=<span class="string">"myScheduler"</span>/&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">task:scheduled-tasks</span> <span class="attr">scheduler</span>=<span class="string">"myScheduler"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">task:scheduled</span> <span class="attr">ref</span>=<span class="string">"doSomethingTask"</span> <span class="attr">method</span>=<span class="string">"doSomething"</span> <span class="attr">cron</span>=<span class="string">"0 * * * * *"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">task:scheduled-tasks</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>当然需要能够reference到doSomethingTask这个实例了。</p>
<p>用注解配置Spring Scheduler的方式如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Scheduled;</div><div class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</div><div class="line"></div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoSomethingTask</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Scheduled</span>(cron=<span class="string">"0 * * * * *"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"do something"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>参考<a href="http://www.baeldung.com/spring-scheduled-tasks" target="_blank" rel="external">这篇短文</a>可以迅速了解。</p>
<h2 id="Cron"><a href="#Cron" class="headerlink" title="Cron"></a>Cron</h2><p>想了解Cron最好的方法是看<a href="http://www.quartz-scheduler.org/documentation/quartz-2.2.x/tutorials/crontrigger" target="_blank" rel="external">Quartz的官方文档</a>。本节也会大致介绍一下。</p>
<p>Cron表达式由6~7项组成，中间用空格分开。从左到右依次是：秒、分、时、日、月、周几、年（可省略）。值可以是数字，也可以是以下符号：<br><code>*</code>：所有值都匹配<br><code>?</code>：无所谓，不关心，通常放在“周几”里<br><code>,</code>：或者<br><code>/</code>：增量值<br><code>-</code>：区间</p>
<p>下面举几个例子，看了就知道了：<br><code>0 * * * * *</code>：每分钟（当秒为0的时候）<br><code>0 0 * * * *</code>：每小时（当秒和分都为0的时候）<br><code>*/10 * * * * *</code>：每10秒<br><code>0 5/15 * * * *</code>：每小时的5分、20分、35分、50分<br><code>0 0 9,13 * * *</code>：每天的9点和13点<br><code>0 0 8-10 * * *</code>：每天的8点、9点、10点<br><code>0 0/30 8-10 * * *</code>：每天的8点、8点半、9点、9点半、10点<br><code>0 0 9-17 * * MON-FRI</code>：每周一到周五的9点、10点…直到17点（含）<br><code>0 0 0 25 12 ?</code>：每年12约25日圣诞节的0点0分0秒（午夜）<br><code>0 30 10 * * ? 2016</code>：2016年每天的10点半</p>
<p>其中的<code>?</code>在用法上其实和<code>*</code>是相同的。但是<code>*</code>语义上表示全匹配，而<code>?</code>并不代表全匹配，而是不关心。比如对于<code>0 0 0 5 8 ? 2016</code>来说，2016年8月5日是周五，<code>?</code>表示我不关心它是周几。而<code>0 0 0 5 8 * 2016</code>中的<code>*</code>表示周一也行，周二也行……语义上和2016年8月5日冲突了，你说谁优先生效呢。</p>
<p>不记得也没关系，记住<a href="http://www.cronmaker.com/" target="_blank" rel="external">Cron Maker</a>也可以，它可以在线生成cron表达式。</p>
<h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><p>可能会想要在不同的环境配置不同的cron，比如产品环境就是真实的cron，而测试环境希望更频繁触发，可以设置每分钟都触发。</p>
<p>xml配置的解决方法：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">task:scheduler</span> <span class="attr">id</span>=<span class="string">"myScheduler"</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">task:scheduled-tasks</span> <span class="attr">scheduler</span>=<span class="string">"myScheduler"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">task:scheduled</span> <span class="attr">ref</span>=<span class="string">"doSomethingTask"</span> <span class="attr">method</span>=<span class="string">"doSomething"</span> <span class="attr">cron</span>=<span class="string">"$&#123;cron_expression&#125;"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">task:scheduled</span> <span class="attr">ref</span>=<span class="string">"doOtherThingTask"</span> <span class="attr">method</span>=<span class="string">"doOtherThing"</span> <span class="attr">cron</span>=<span class="string">"$&#123;cron_expression&#125;"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">task:scheduled-tasks</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>顺便提一句，java的properties文件支持value中带空格，所以可以放心地写<code>cron_expression=0 * * * * *</code>。</p>
<p>注解的解决方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Scheduled</span>(cron = <span class="string">"$&#123;cron_expression&#125;"</span>)</div></pre></td></tr></table></figure></p>
<h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><h3 id="同时运行"><a href="#同时运行" class="headerlink" title="同时运行"></a>同时运行</h3><p>同一个task，如果前一个还没跑完后面一个就不会触发，这没有问题。但是不同的task也不能同时运行就不太合理了。不过其实是scheduler的默认线程数为1的缘故。</p>
<p>解决方法1：如下配置pool-size，但这样会导致同一个task前一个还没跑完后面又被触发的问题。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">task:scheduler</span> <span class="attr">id</span>=<span class="string">"scheduler"</span> <span class="attr">pool-size</span>=<span class="string">"2"</span> /&gt;</span></div></pre></td></tr></table></figure></p>
<p>解决方法2：让任务分别运行在不同的scheduler里就好了。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">task:scheduler</span> <span class="attr">id</span>=<span class="string">"myScheduler1"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">task:scheduler</span> <span class="attr">id</span>=<span class="string">"myScheduler2"</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">task:scheduled-tasks</span> <span class="attr">scheduler</span>=<span class="string">"myScheduler1"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">task:scheduled</span> <span class="attr">ref</span>=<span class="string">"doSomethingTask"</span> <span class="attr">method</span>=<span class="string">"doSomething"</span> <span class="attr">cron</span>=<span class="string">"$&#123;0 * * * * *&#125;"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">task:scheduled-tasks</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">task:scheduled-tasks</span> <span class="attr">scheduler</span>=<span class="string">"myScheduler2"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">task:scheduled</span> <span class="attr">ref</span>=<span class="string">"doOtherThingTask"</span> <span class="attr">method</span>=<span class="string">"doOtherThing"</span> <span class="attr">cron</span>=<span class="string">"$&#123;0 * * * * *&#125;"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">task:scheduled-tasks</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="多实例"><a href="#多实例" class="headerlink" title="多实例"></a>多实例</h3><p>若是scheduler与web配置在一起，在高可用的情况下，如果有多个web容器实例，scheduler会在多个实例上同时运行。</p>
<p>解决方法1：部署的时候，针对不同实例，使用不同的配置。比如tomcat_1打开scheduler，tomcat_2关闭。带来的问题是：</p>
<ul>
<li>增加部署成本。</li>
<li>要是tomcat_1挂了，scheduler就不能运行了，高可用落空。</li>
</ul>
<p>解决方法2：在task的基类加入一些逻辑，当开始运行时，将状态（运行机器的IP、时间等）写入数据库、缓存或者zk，运行结束时重置状态。其它实例看到有这样的数据，就直接返回。带来的问题是：</p>
<ul>
<li>需要所有实例上的机器时间同步，不然一个刚结束另一个才开始，状态的维护就没有用了。</li>
<li>一定要保证结束运行后将状态重置，否则下一个运行周期，所有的task都会返回的。实在不行还得写一个task做这个事。</li>
<li>因为读写状态并非原子操作，偶尔也会发生task同时运行的事。</li>
</ul>
<p>解决方法3：将scheduler与web分开。这样还能避免后台任务影响web端。带来的问题是：</p>
<ul>
<li>增加部署成本。</li>
<li>scheduler的高可用需要重新考虑。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> development </category>
            
        </categories>
        
        
        <tags>
            
            <tag> spring </tag>
            
            <tag> scheduler </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用IntelliJ IDEA社区版动态加载webapp]]></title>
      <url>/intellij-idea-community-hotswap-webapp/</url>
      <content type="html"><![CDATA[<p><a href="https://dzone.com/articles/why-idea-better-eclipse" target="_blank" rel="external">IntelliJ IDEA在重构方面碾压eclipse</a>。但是IDEA的免费社区版<a href="https://www.jetbrains.com/idea/features/editions_comparison_matrix.html" target="_blank" rel="external">并不支持web应用开发</a>。好在Maven有一个<code>maven-jetty-plugin</code>插件。如果你正在用IDEA社区版开发一个web应用，可以使用它来动态加载并调试IDE里的web应用。笔者目前使用的IDEA版本为2016.1.1。<br><a id="more"></a></p>
<h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><p>假设我们有一个maven的web项目，已经用IDEA打开了。那么就可以在pom.xml里加上<code>maven-jetty-plugin</code>的插件：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&lt;project ...&gt;</div><div class="line">  ...</div><div class="line"></div><div class="line">  &lt;build&gt;</div><div class="line">    ...</div><div class="line"></div><div class="line">    &lt;plugins&gt;</div><div class="line">      &lt;plugin&gt;</div><div class="line">        &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;maven-jetty-plugin&lt;/artifactId&gt;</div><div class="line">        &lt;version&gt;6.1.26&lt;/version&gt;</div><div class="line">        &lt;configuration&gt;</div><div class="line">          &lt;contextPath&gt;/&lt;/contextPath&gt;</div><div class="line">          &lt;scanIntervalSeconds&gt;0&lt;/scanIntervalSeconds&gt;</div><div class="line">          &lt;connectors&gt;</div><div class="line">            &lt;connector implementation=<span class="string">"org.mortbay.jetty.nio.SelectChannelConnector"</span>&gt;</div><div class="line">              &lt;port&gt;8080&lt;/port&gt;</div><div class="line">              &lt;maxIdleTime&gt;60000&lt;/maxIdleTime&gt;</div><div class="line">            &lt;/connector&gt;</div><div class="line">          &lt;/connectors&gt;</div><div class="line">        &lt;/configuration&gt;</div><div class="line">      &lt;/plugin&gt;</div><div class="line">    &lt;/plugins&gt;</div><div class="line">  &lt;/build&gt;</div><div class="line">&lt;/project&gt;</div></pre></td></tr></table></figure></p>
<p>这样便可以在命令行里用以下命令直接启动jetty服务器：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mvn jetty:run</div></pre></td></tr></table></figure></p>
<h2 id="集成IDEA"><a href="#集成IDEA" class="headerlink" title="集成IDEA"></a>集成IDEA</h2><p>在菜单<code>Run</code>-&gt;<code>Edit Configurations</code>里，新增一个<code>Maven</code>，填入下图所示的参数：<br><img src="/img/idea-jetty-parameters.jpg" alt=""></p>
<ul>
<li>Name：Jetty</li>
<li>Working directory：默认就好</li>
<li>Command line：jetty:run</li>
</ul>
<p>然后在<code>Runner</code>标签里，填入下图所示的参数：<br><img src="/img/idea-jetty-runner.jpg" alt=""></p>
<ul>
<li>VM Options：-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=6006</li>
</ul>
<p>端口6006可以自行决定，别和其它端口冲突就行。在菜单<code>Run</code>-&gt;<code>Edit Configurations</code>里，新增一个<code>Remote</code>，填入下图所示的参数：<br><img src="/img/idea-jetty-debug.jpg" alt=""></p>
<ul>
<li>Name：Jetty-Remote-Debug</li>
<li>Port：6006</li>
</ul>
<p>和先前在<code>Runner</code>标签里填写的端口一致就行。</p>
<p>现在就可以试试啦。首先运行Jetty，然后调试Jetty-Remote-Debug。不出意外的话，现在可以访问自己的webapp，并且可以在程序中调试了。现在修改一段程序，编译之后，新程序就能立刻生效了。刷新一下页面看看？</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>照例附送一些Mac OS X的keymap快捷键：</p>
<ul>
<li>运行Jetty：Alt+Shift+F10</li>
<li>调试Jetty-Remote-Debug：Alt+Shift+F9</li>
<li>编译：Command+Shift+F9</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://gist.github.com/naaman/1053217/1fc1403d9d6ebc0194ecd0bf84cb0dec84b92eea" target="_blank" rel="external">https://gist.github.com/naaman/1053217/1fc1403d9d6ebc0194ecd0bf84cb0dec84b92eea</a></p>
]]></content>
      
        <categories>
            
            <category> tool </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IntelliJ IDEA </tag>
            
            <tag> jetty </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[思路被打断了怎么办]]></title>
      <url>/interrupt-train-of-thought/</url>
      <content type="html"><![CDATA[<p>程序猿和工程狮们的日常工作中，难免遇到代码写得正爽的时候被人打断。要重新进入状态需要时间和心力，万一又被打断，这一天就不能好好过了。本文聊一聊可以把副作用尽可能降低的一些办法。<br><a id="more"></a></p>
<h2 id="降低被打断概率"><a href="#降低被打断概率" class="headerlink" title="降低被打断概率"></a>降低被打断概率</h2><p>被打断是不可避免的，就像程序中我们不得不try…catch一样。但是我们可以想办法降低被exception产生的概率。</p>
<h3 id="自身原因"><a href="#自身原因" class="headerlink" title="自身原因"></a>自身原因</h3><p>首先看看都有哪些异常发生。以笔者为例，如果写代码进入真·状态，那只有别人找上门才能被干扰。如果是伪·状态，那么自己可能会突然想到：有一条微信没看，有一封邮件忘记回了，麻麻让我在网上买的东东忘记买了……于是就悲剧了。对于这种异常来说，最简单的方法就是预先把它们都给处理好。在办正事之前，先干杂事，收发邮件，手机静音，接杯水，上个厕所。至于有一些买东西、订日程之类的非日常事务，需要一个todo list。我一般是在接到任务的时候，记录到闹钟里，定一个比较有空的时间来做。没有了念想，突然想起有事没做的冷汗就不至于经常冒出来了。</p>
<p>另外，如果有什么任务可以很快完成（比如两分钟内），哪怕它的优先级不那么高，也可以先将它搞定，排除念想。</p>
<h3 id="他人原因"><a href="#他人原因" class="headerlink" title="他人原因"></a>他人原因</h3><p>接下来是被人打断的情况。如果要降低这种概率，一种办法是在工位的显眼处挂上一块如下牌子，等有空闲了再摘掉，就是有点儿不近人情。<br><img src="http://images.mydoorsign.com/img/lg/S/do-not-disturb-sign-s-4622.png" alt=""></p>
<p>稍微对用户友好的方法是加一个计时器，别人好歹能知道再过多久之后过来找你比较方便。如果像我这样实在下不了手挂牌子，那就只好用下文介绍的等一下大法了。</p>
<h3 id="等一下"><a href="#等一下" class="headerlink" title="等一下"></a>等一下</h3><p>花费较少大脑资源，请对方稍微等待一小段时间。但是不要冷冰冰地说：“等一下”。一下是多久？对方要不要找其他人帮忙？这样可能造成对方的困扰，说不定就影响团结了。好歹微笑一下：“稍微等我一会儿可以吗？”，自认在时间上靠谱的朋友还可以更加量化：“等我两分钟好吗”。两分钟之后，听一下对方的需求，是否自己可以迅速搞定，然后再决定是否让对方再等上半小时，或者推荐另一个人来处理。若是对方非常着急，那就花上半分钟记录一下当前手头上的进度和关键因素，就好比暂时让自己这台电脑在这个线程上休眠一下，过一会儿再唤醒。</p>
<h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><p>早晨和深夜，活动的人少，被打断的几率就小。不管是早起的鸟儿还是晚睡的虫子，抓住那段时间专心做不想被打断的事。</p>
<h3 id="判断优先级"><a href="#判断优先级" class="headerlink" title="判断优先级"></a>判断优先级</h3><p>也有火急火燎的事突然插进来。比如运维正在部署你的代码，然后出问题了。或者测试发现了一个非常严重的缺陷，需要马上解决。这些不得不立即处理的事情，就得靠下一章的办法来尽量降低副作用了。</p>
<h2 id="使自己不怕被打断"><a href="#使自己不怕被打断" class="headerlink" title="使自己不怕被打断"></a>使自己不怕被打断</h2><p>要是能让自己处于不怕被打断的状态，那么就可以来者不拒了。</p>
<h3 id="日常工作"><a href="#日常工作" class="headerlink" title="日常工作"></a>日常工作</h3><p>如果日常工作以业务开发为主，平时的开发过程可以分为三个阶段：</p>
<ol>
<li>拆分任务：把一个故事拆分成数个任务，每一个不要太大</li>
<li>实现任务：做完其中的一个任务</li>
<li>重构：虽然已经完成了，但是可以让代码更优雅</li>
</ol>
<p>首先是拆分任务。这个阶段应该是在不太长的时间内完成的。虽然很怕被打断，但是由于持续时间短，基本上不太会老被打断。接下来的实现任务会略微麻烦一些，最后再讲。现在说重构。重构是由坏味道驱动，由一系列的重构动作和频繁地运行测试组成的。这就决定了重构应该可以随时中止，所以不是那么怕打断，当然还是需要费时再次阅读代码。如果被打断之后回来不知道要干什么，那么多半是坏味道还不够强烈，这样的代码暂不处理也问题不大。最后讲实现任务。这个阶段的持续时间比较长，取决于具体任务，有可能怕被打断。不过好处是被打断回来也很容易从任务中知道你在做什么。尤其是如果使用TDD的方式，跑一下测试基本上思路就回来了。我们知道TDD有三个法则：</p>
<ol>
<li>在编好失败单元测试之前，不要编写任何产品代码</li>
<li>只要有一个单元测试失败了，就不要再写测试代码；无法通过编译也是一种失败情况</li>
<li>产品代码恰好能够让当前失败的单元测试成功通过即可，不要多写</li>
</ol>
<p>当我们编写测试时被打断，回来时测试名会告诉我们应该做啥了。当我们编写实现时被打断，回来时失败的测试会告诉我们应该做啥了。</p>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>笔者撰写本文的时候，被打断了无数次，确是别有一番滋味。但是我不是很怕被打断（当然还是有少许代价的），因为我也是按照日常工作的方式写作的。先拆分任务，把要写的文章分成不同模块，每个模块起好标题或者是写句话说明自己想在里面写点儿什么。然后实现任务，虽然没有TDD，但是因为文章的框架已经建立起来了，回来的时候很容易回到刚才写作的背景里去。最后是重构，把不通顺的字句重新整理，纠正错别字等。还是那句话，如果重构被打断，导致回来的时候不知道该做什么了，多半是文章还没糟糕到那种地步，凑活用用还是可以的。</p>
<h2 id="方法和工具"><a href="#方法和工具" class="headerlink" title="方法和工具"></a>方法和工具</h2><p>下面介绍一些时间管理方法，作为扩展阅读，读者可以选取自己喜欢的工具来使用。</p>
<h3 id="番茄工作法"><a href="#番茄工作法" class="headerlink" title="番茄工作法"></a>番茄工作法</h3><p><a href="http://www.baike.com/wiki/%E7%95%AA%E8%8C%84%E5%B7%A5%E4%BD%9C%E6%B3%95" target="_blank" rel="external">番茄工作法</a>无需我多说了，自己看看是不是适合吧。<a href="https://www.zhihu.com/question/20189826" target="_blank" rel="external">知乎</a>上也有个一千多赞的回答。</p>
<h3 id="GTD"><a href="#GTD" class="headerlink" title="GTD"></a>GTD</h3><p><a href="https://zh.wikipedia.org/wiki/%E5%B0%BD%E7%AE%A1%E5%8E%BB%E5%81%9A" target="_blank" rel="external">GTD</a>是英文Getting Things Done的缩写，是一种行为管理的方法。“主要原则在于一个人需要通过记录的方式把头脑中的各种任务移出来，通过这样的方式，头脑可以不用塞满各种需要完成的事情，而集中精力在正在完成的事情，是一种消灭压力的高效工作方法。”</p>
]]></content>
      
        <categories>
            
            <category> idea </category>
            
        </categories>
        
        
        <tags>
            
            <tag> soft skill </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用OS X轻松上手.NET Core]]></title>
      <url>/dot-net-core/</url>
      <content type="html"><![CDATA[<p>微软前几天<a href="https://blogs.msdn.microsoft.com/dotnet/2016/06/27/announcing-net-core-1-0/" target="_blank" rel="external">正式发布</a>了<a href="https://dotnet.github.io/" target="_blank" rel="external">.NET Core</a> 1.0。开源、跨平台、运行速度快的.NET Core很可能会成为Java强有力的竞争对手。它支持用ASP.NET开发web应用，但目前的问题是支持的第三方库太少了。本文尝试在Mac的OS X平台上开发.NET Core应用。<br><a id="more"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>请参考<a href="http://www.linuxidc.com/Linux/2016-06/132764.htm" target="_blank" rel="external">《.NET Core 1.0发布：微软开源跨平台大布局序幕》</a>和<a href="https://docs.microsoft.com/en-us/dotnet/articles/core/index" target="_blank" rel="external">《.NET Core》</a>。官方也提供了一个<a href="https://hub.docker.com/r/microsoft/dotnet/" target="_blank" rel="external">docker镜像</a>以供快速试用。</p>
<h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><p>根据微软的<a href="https://www.microsoft.com/net/core#macos" target="_blank" rel="external">Getting Started</a>文档介绍，首先需要安装最新版OpenSSL：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">brew update</div><div class="line">brew install openssl</div><div class="line">brew link --force openssl</div></pre></td></tr></table></figure></p>
<p>下载.NET Core SDK，50M左右：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget -c https://go.microsoft.com/fwlink/?LinkID=809124</div></pre></td></tr></table></figure></p>
<p>安装完SDK后，可以很轻易地启动一个Hello World应用：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mkdir hwapp</div><div class="line"><span class="built_in">cd</span> hwapp</div><div class="line">dotnet new</div><div class="line">dotnet restore</div><div class="line">dotnet run</div></pre></td></tr></table></figure></p>
<p>其中的<code>dotnet</code>命令就是.NET Core SDK提供的。顺利的话，就能看到控制台打印出了<code>Hello World!</code>。命令<code>dotnet new</code>会生成两个文件：<code>Program.cs</code>和<code>project.json</code>。打开生成的Program.cs就能看到其实就是一个标准的<code>Main</code>函数，内容为<code>Console.WriteLine(&quot;Hello World!&quot;);</code>。文件<code>project.json</code>内容如下所示，指定了依赖和框架：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0-*"</span>,</div><div class="line">  <span class="attr">"buildOptions"</span>: &#123;</div><div class="line">    <span class="attr">"debugType"</span>: <span class="string">"portable"</span>,</div><div class="line">    <span class="attr">"emitEntryPoint"</span>: <span class="literal">true</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">"dependencies"</span>: &#123;&#125;,</div><div class="line">  <span class="attr">"frameworks"</span>: &#123;</div><div class="line">    <span class="attr">"netcoreapp1.0"</span>: &#123;</div><div class="line">      <span class="attr">"dependencies"</span>: &#123;</div><div class="line">        <span class="attr">"Microsoft.NETCore.App"</span>: &#123;</div><div class="line">          <span class="attr">"type"</span>: <span class="string">"platform"</span>,</div><div class="line">          <span class="attr">"version"</span>: <span class="string">"1.0.0"</span></div><div class="line">        &#125;</div><div class="line">      &#125;,</div><div class="line">      <span class="attr">"imports"</span>: <span class="string">"dnxcore50"</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>命令<code>dotnet restore</code>会使用NuGet来导入<code>project.json</code>里指定的包并生成一个文件：<code>project.lock.json</code>。命令<code>dotnet run</code>编译并运行这个项目。如果只想编译，用<code>dotnet build</code>就可以了。现在把Hello World中的World改成<code>Qinghua</code>，再试一下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sed <span class="string">'s/World/Qinghua/'</span> Program.cs &gt; Program1.cs &amp;&amp; mv Program1.cs Program.cs</div><div class="line">cat Program.cs</div><div class="line">dotnet run</div></pre></td></tr></table></figure></p>
<p>果然就变成了<code>Hello Qinghua!</code>。</p>
<h2 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h2><p>下载Visual Studio Code集成开发环境，也是50M左右，解压后100多M：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget -c https://az764295.vo.msecnd.net/stable/fe7f407b95b7f78405846188259504b34ef72761/VSCode-darwin-stable.zip</div></pre></td></tr></table></figure></p>
<p>如果下载页面发生变化，那就参考<a href="https://code.visualstudio.com/" target="_blank" rel="external">Visual Studio Code的主页</a>下载。安装并打开Visual Studio Code之后，按下快捷键<code>⌘+P</code>并输入以下命令来安装C#的扩展：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ext install csharp</div></pre></td></tr></table></figure></p>
<p>IDE会提示重新启动。接下来就可以试试C#开发了。按下快捷键<code>⌘+O</code>并打开刚才生成的<code>Program.cs</code>文件，然后把<code>Qinghua</code>改为<code>世界</code>。再次<code>dotnet run</code>一下，就会看到<code>Hello 世界</code>，汉字支持良好。</p>
<p>整个IDE非常轻量，给人的印象比较简洁，不像Visual Studio那般花里胡哨。支持代码高亮、代码补全、错误提示、内置Git的支持，但是错误修复、重构等就没有了。甚至如何在里面运行代码也令人颇费一番周折。<br><img src="/img/vs-code-ide.jpg" alt=""></p>
<p>关于调试代码，可以参考<a href="https://github.com/OmniSharp/omnisharp-vscode/blob/master/debugger.md" target="_blank" rel="external">Instructions for setting up the .NET Core debugger</a>。如果<code>⌘+O</code>打开的是包含<code>project.json</code>的文件夹，C#扩展便会自动生成两个文件：<code>.vscode/tasks.json</code>和<code>.vscode/launch.json</code>。前者告诉VS Code如何来构建项目，后者告诉VS Code如何来运行程序。我们需要修改一下<code>launch.json</code>里，<code>name</code>为<code>.NET Core Launch (console)</code>的<code>program</code>，将<code>&lt;target-framework&gt;/&lt;project-name.dll&gt;</code>替换为<code>netcoreapp1.0/hwapp.dll</code>，这样便能在VS Code的调试窗口运行程序了：<br><img src="/img/vs-code-debug.jpg" alt=""></p>
<p>Visual Studio Code支持众多插件。除了C#以外，还有Python、C/C++、Go、PowerShell、JavaScript、Ruby等语言，除此之外，还有不少功能性插件，如Git Blame、IIS Express、ftp-sync等。完整列表请参考<a href="https://marketplace.visualstudio.com/vscode/Languages?sortBy=Downloads" target="_blank" rel="external">Marketplace</a>。</p>
<h2 id="C-Sharp"><a href="#C-Sharp" class="headerlink" title="C Sharp"></a>C Sharp</h2><p>语法层面上，C#比起Java来最吸引我的点就是Linq+Lambda。虽然Java 8也提供了lambda表达式，但是始终在整洁性上差了那么一点。Java 8 Stream和C#在Linq上的语法区别可以参考<a href="https://blog.informatech.cr/2013/03/24/java-streams-preview-vs-net-linq/" target="_blank" rel="external">《Java Streams Preview vs .Net High-Order Programming with LINQ》</a>，里面有着非常丰富的例子。现在我们来改造一下<code>Program.cs</code>，用Linq和Lambda输出10~90之间能被10整除的数字的平方：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> System;</div><div class="line"><span class="keyword">using</span> System.Linq;</div><div class="line"></div><div class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApplication</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></div><div class="line">    &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">var</span> arr = Enumerable.Range(<span class="number">1</span>, <span class="number">90</span>);</div><div class="line">            arr.Where(i =&gt; i % <span class="number">10</span> == <span class="number">0</span>).Select(i =&gt; i * i).ToList().ForEach(Console.WriteLine);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再次<code>dotnet run</code>一下，就会看到程序按照我们的预期输出了结果。</p>
<h2 id="ASP-NET"><a href="#ASP-NET" class="headerlink" title="ASP.NET"></a>ASP.NET</h2><p>下面让我们来试一下用.NET Core运行ASP.NET的官方教程。首先像Hello World的例子那样，创建一个新的工程：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> ..</div><div class="line">mkdir aspnetcoreapp</div><div class="line"><span class="built_in">cd</span> aspnetcoreapp</div><div class="line">dotnet new</div></pre></td></tr></table></figure></p>
<p>然后需要把<code>project.json</code>里的<code>&quot;dependencies&quot;: {},</code>替换成下文：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">"dependencies": &#123;</div><div class="line">  "Microsoft.NETCore.App": &#123;</div><div class="line">    "type": "platform",</div><div class="line">    "version": "1.0.0"</div><div class="line">  &#125;,</div><div class="line">  "Microsoft.AspNetCore.Server.Kestrel": "1.0.0"</div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<p>依赖变化了，需要<code>restore</code>一下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dotnet restore</div></pre></td></tr></table></figure></p>
<p>然后添加一个文件，处理http request：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> System;</div><div class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Builder;</div><div class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Hosting;</div><div class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Http;</div><div class="line"></div><div class="line"><span class="keyword">namespace</span> <span class="title">aspnetcoreapp</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Startup</span></div><div class="line">    &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app</span>)</span></div><div class="line">        &#123;</div><div class="line">            app.Run(context =&gt;</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">return</span> context.Response.WriteAsync(<span class="string">"Hello from ASP.NET Core!"</span>);</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来修改<code>Program.cs</code>文件来启动web服务：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> System;</div><div class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Hosting;</div><div class="line"></div><div class="line"><span class="keyword">namespace</span> <span class="title">aspnetcoreapp</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></div><div class="line">    &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">var</span> host = <span class="keyword">new</span> WebHostBuilder()</div><div class="line">                .UseKestrel()</div><div class="line">                .UseStartup&lt;Startup&gt;()</div><div class="line">                .Build();</div><div class="line"></div><div class="line">            host.Run();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在就可以运行啦：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dotnet run</div></pre></td></tr></table></figure></p>
<p>访问<a href="http://localhost:5000/" target="_blank" rel="external">http://localhost:5000/</a>就可以看到在<code>Startup.cs</code>里写的<code>Hello from ASP.NET Core!</code>啦。确实上手比较容易。</p>
]]></content>
      
        <categories>
            
            <category> development </category>
            
        </categories>
        
        
        <tags>
            
            <tag> .NET </tag>
            
            <tag> .NET Core </tag>
            
            <tag> C# </tag>
            
            <tag> ASP.NET </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用dubbox为dubbo提供REST服务]]></title>
      <url>/dubbo-2/</url>
      <content type="html"><![CDATA[<p><a href="https://github.com/alibaba/dubbo" target="_blank" rel="external">Dubbo</a>是阿里多年前开源的一套服务治理框架，在众多互联网企业里应用广泛。当当在dubbo的基础上开发了<a href="https://github.com/dangdangdotcom/dubbox" target="_blank" rel="external">dubbox</a>（Dubbo eXtensions），<a href="http://dangdangdotcom.github.io/dubbox/rest.html" target="_blank" rel="external">支持REST风格远程调用</a>。本文在<a href="/dubbo-1">服务治理框架dubbo上手指南</a>的基础上使用dubbox提供的REST服务。<br><a id="more"></a></p>
<p>首先参考<a href="/dubbo-1">服务治理框架dubbo上手指南</a>，实现自己的dubbo服务。在此基础上，让我们来看看<a href="http://dangdangdotcom.github.io/dubbox/rest.html" target="_blank" rel="external">在Dubbo中开发REST风格的远程调用</a>。REST的优势就不多说了，本文关注的是快速搭建环境。</p>
<p>光看dubbox的官方文档稍微有一点儿坑，因为它对于maven依赖的描述基本没有。Dubbo本身的维护已经不太活跃了，最新的版本是<code>2.5.4-SNAPSHOT</code>。当当接下了维护的重任，目前的最新版是<code>dubbox-2.8.4</code>，其实groupId和artifactId还是原来的不变，只是版本号有变化罢了。所以首先让我们来升级一下依赖，在<code>helloImpl</code>的<code>pom.xml</code>里升级dubbo：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-expression<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>使用<code>mvn dependency:tree</code>命令可以看到，dubbox依赖于spring的<code>3.2.9.RELEASE</code>版本。由于我们上一个dubbo的练习中使用了spring的<code>4.2.4.RELEASE</code>版本，所以会有依赖冲突。解决冲突的办法有两个，一是把我们的spring降级到dubbox依赖的<code>3.2.9.RELEASE</code>版本，二是使用exclusions把dubbox依赖的几个spring包都解除掉。这里我们的配置采用了后者。除了dubbox本身，我们还需要以下的依赖：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.101tec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zkclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>再然后就是<a href="https://github.com/dangdangdotcom/dubbox#user-content-rest风格远程调用" target="_blank" rel="external">dubbox自身的依赖</a>，不管有用没用，先加进来再说：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jboss.resteasy<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resteasy-jaxrs<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.7.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jboss.resteasy<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resteasy-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.7.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.validation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>validation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0.GA<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 如果要使用json序列化 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jboss.resteasy<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resteasy-jackson-provider<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.7.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 如果要使用xml序列化 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jboss.resteasy<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resteasy-jaxb-provider<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.7.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 如果要使用netty server --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jboss.resteasy<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resteasy-netty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.7.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 如果要使用Sun HTTP server --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jboss.resteasy<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resteasy-jdk-http<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.7.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 如果要使用tomcat server --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-logging-juli<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>这样就把所有的依赖都解决了，现在可以修改dubbo的服务配置文件<code>provider.xml</code>了：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--&lt;dubbo:protocol name="dubbo" port="19880" /&gt;--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"rest"</span> <span class="attr">server</span>=<span class="string">"tomcat"</span> <span class="attr">port</span>=<span class="string">"9090"</span> /&gt;</span></div></pre></td></tr></table></figure></p>
<p>把原来的dubbo协议注释掉，增加rest协议，用内置的tomcat启动，端口为9090。这里为了清晰起见，注释掉了dubbo协议，而实际上协议是可以并存的。接下来可以改造我们的<code>HelloServiceImpl</code>了。直接放上最后的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.ggg.hello.service.provider;</div><div class="line"></div><div class="line"><span class="keyword">import</span> javax.ws.rs.GET;</div><div class="line"><span class="keyword">import</span> javax.ws.rs.Path;</div><div class="line"><span class="keyword">import</span> javax.ws.rs.Produces;</div><div class="line"><span class="keyword">import</span> javax.ws.rs.QueryParam;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.ggg.hello.service.HelloService;</div><div class="line"></div><div class="line"><span class="meta">@Path</span>(<span class="string">"demo"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@GET</span></div><div class="line">    <span class="meta">@Path</span>(<span class="string">"greeting"</span>)</div><div class="line">    <span class="meta">@Produces</span>(<span class="string">"application/json; charset=UTF-8"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(@QueryParam(<span class="string">"name"</span>)</span> String name) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span> + name;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先我们在类上增加了一个注解<code>@Path(&quot;demo&quot;)</code>，它指定访问HelloService的URL相对路径是/demo，即<code>http://localhost:9090/demo</code>。方法上也有一个<code>@Path(&quot;greeting&quot;)</code>，相当于访问这个方法的URL为<code>http://localhost:9090/demo/greeting</code>。<code>@GET</code>就不用多说了，<code>@Produces</code>可以在Response Headers里增加<code>Content-Type: application/json;charset=UTF-8</code>。如果有必要，也可以来一个相对应的<code>@Consumes(&quot;application/json&quot;)</code>。在参数上还有一个注解<code>@QueryParam(&quot;name&quot;)</code>，有了它就可以通过URL参数的方式传值过来了。启动<code>Provider</code>之后，没有意外的话应该能看见控制台的日志：<strong>Starting ProtocolHandler [“http-nio-9090”]</strong>，接下来就可以通过访问<a href="http://localhost:9090/demo/greeting?name=ggg" target="_blank" rel="external">http://localhost:9090/demo/greeting?name=ggg</a>来访问我们的服务了。屏幕上可以看到：<strong>Hello ggg</strong>。</p>
<p>至此，我们以一个并不太RESTful的URL完成了一个REST请求。</p>
]]></content>
      
        <categories>
            
            <category> architecture </category>
            
        </categories>
        
        
        <tags>
            
            <tag> dubbo </tag>
            
            <tag> service governance </tag>
            
            <tag> dubbox </tag>
            
            <tag> rest </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[服务治理框架dubbo上手指南]]></title>
      <url>/dubbo-1/</url>
      <content type="html"><![CDATA[<p><a href="https://github.com/alibaba/dubbo" target="_blank" rel="external">Dubbo</a>是阿里多年前开源的一套服务治理框架，在众多互联网企业里应用广泛。它的<a href="http://dubbo.io/" target="_blank" rel="external">文档</a>也非常全面。本文将会大致介绍dubbo的思想，旨在快速上手自己搭建一套服务。<br><a id="more"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Dubbo是当服务数量很多的时候，用来解决服务治理的问题。服务治理包括服务编排、服务路由、服务发现等一系列功能。它的<a href="http://dubbo.io/User+Guide-zh.htm" target="_blank" rel="external">用户指南</a>里介绍得很清楚了，这里就不再赘述了。Dubbo支持多种协议来进行远程调用，但是并不支持REST方式。当当在dubbo的基础上开发了<a href="https://github.com/dangdangdotcom/dubbox" target="_blank" rel="external">dubbox</a>（Dubbo eXtensions），<a href="http://dangdangdotcom.github.io/dubbox/rest.html" target="_blank" rel="external">支持REST风格远程调用</a>。</p>
<p>本文将会创建一个dubbo的服务提供者，注册到zookeeper服务注册中心，然后创建一个服务消费者，通过dubbo协议调用服务提供者的方法。<a href="/dubbo-2">下一篇文章</a>将会介绍在dubbo里使用dubbox提供的REST服务。</p>
<h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><p>首先请自行安装Java、Maven和喜欢的IDE。我用的是<a href="https://www.jetbrains.com/idea/download/" target="_blank" rel="external">Intellij IDEA社区版</a>。Dubbo可以使用Zookeeper来作为服务的注册中心，所以可以自行安装Zookeeper。我这里用Vagrant启动了一台已经安装过Docker的Ubuntu虚拟机，它的IP是<code>192.168.33.88</code>，可以用以下命令来直接启动Zookeeper容器来提供服务：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run --name=zk -d -p 2181:2181 -p 2888:2888 -p 3888:3888 jplock/zookeeper:3.4.8</div></pre></td></tr></table></figure></p>
<p>接下来新建一个Maven工程helloService，再给它添加两个Module，分别为helloApi（接口和模型，被消费者所依赖）和helloImpl（实现，依赖helloApi）。GroupId随意设置便可，我填的是<code>org.ggg.dubbo</code>。工程创建好了应该是这样的：<br><img src="/img/dubbo-new-project.jpg" alt=""></p>
<h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><h3 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h3><p>一切就绪，开搞。首先给helloApi添加一个服务提供者：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.ggg.hello.service;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</div><div class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">(String name)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>很简单，只是提供了一个sayHello的接口。</p>
<h3 id="实现服务"><a href="#实现服务" class="headerlink" title="实现服务"></a>实现服务</h3><p>接下来就要在helloImpl里实现这个服务了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.ggg.hello.service.provider;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.ggg.hello.service.HelloService;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span> + name;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为了编译通过，需要在helloImpl里添加对helloApi的依赖。</p>
<h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>为了启动我们的hello服务，我们需要依赖spring。先往helloImpl的resource里增加spring的配置文件provider.xml：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></div><div class="line">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://code.alibabatech.com/schema/dubbo        http://code.alibabatech.com/schema/dubbo/dubbo.xsd"</span>&gt;</div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"hello-world-app"</span> /&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- 使用zookeeper注册中心暴露服务地址 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">protocol</span>=<span class="string">"zookeeper"</span> <span class="attr">address</span>=<span class="string">"192.168.33.88:2181"</span> /&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- 用dubbo协议在19880端口暴露服务 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"19880"</span> /&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- 声明需要暴露的服务接口 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"org.ggg.hello.service.HelloService"</span> <span class="attr">ref</span>=<span class="string">"helloService"</span> /&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- 和本地bean一样实现服务 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloService"</span> <span class="attr">class</span>=<span class="string">"org.ggg.hello.service.provider.HelloServiceImpl"</span> /&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>然后往helloImpl里增加一个入口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.ggg.hello.service.provider;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"provider.xml"</span>);</div><div class="line">        context.start();</div><div class="line"></div><div class="line">        System.in.read();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这时候需要增加spring和dubbo的依赖了。我用的是<code>org.springframework:spring-context:4.2.4.RELEASE</code>和<code>com.alibaba:dubbo:2.5.3</code>。安装完依赖，就可以直接运行Provider了。要是一切顺利，应该看不到错误信息了。在安装zookeeper的虚拟机上，用以下命令可以连接上zookeeper：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> -it zk bin/zkCli.sh</div></pre></td></tr></table></figure></p>
<p>用以下命令应该能看到多了dubbo的路径：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ls /</div><div class="line">ls /dubbo</div><div class="line">ls /dubbo/org.ggg.hello.service.HelloService</div><div class="line"></div><div class="line">quit</div></pre></td></tr></table></figure></p>
<p>这就证明我们的dubbo已经连接到zookeeper的服务注册中心了。</p>
<h3 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h3><p>服务提供方已经搞定，然后就该是服务的消费者了。按理来说消费者应该是另一个项目，这里为了简单起见，我们姑且认为消费者是一个测试。首先在helloImpl的test文件夹里增加一个resources目录，标记为Test Resources Root。往里新增一个文件consumer.xml：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></div><div class="line">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://code.alibabatech.com/schema/dubbo        http://code.alibabatech.com/schema/dubbo/dubbo.xsd"</span>&gt;</div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"consumer-of-helloworld-app"</span> /&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- 使用zookeeper注册中心暴露发现服务地址 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">protocol</span>=<span class="string">"zookeeper"</span> <span class="attr">address</span>=<span class="string">"192.168.33.88:2181"</span> /&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- 生成远程服务代理，可以和本地bean一样使用helloService --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"helloService"</span> <span class="attr">interface</span>=<span class="string">"org.ggg.hello.service.HelloService"</span> /&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>然后往test里新增一个类，权当是测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.ggg.hello.service.provider;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.ggg.hello.service.HelloService;</div><div class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"consumer.xml"</span>);</div><div class="line">        context.start();</div><div class="line"></div><div class="line">        HelloService helloService = (HelloService) context.getBean(<span class="string">"helloService"</span>);</div><div class="line">        String hello = helloService.sayHello(<span class="string">"world"</span>);</div><div class="line"></div><div class="line">        System.out.println(hello);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样，helloImpl的项目结构应该是这样子的：<br><img src="/img/dubbo-helloImpl.jpg" alt=""></p>
<h3 id="验证服务"><a href="#验证服务" class="headerlink" title="验证服务"></a>验证服务</h3><p>运行这个Consumer类，应该就能看到<code>Hello world</code>啦。如果在运行Consumer之前把Provider停了，就会看见这样的错误消息：<code>Failed to check the status of the service org.ggg.hello.service.HelloService</code>。</p>
<h3 id="直接连接"><a href="#直接连接" class="headerlink" title="直接连接"></a>直接连接</h3><p>Dubbo支持不用服务注册中心，直接连接本地的服务。这样的话测试起来就非常方便了。在consumer.xml里这么配置：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></div><div class="line">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://code.alibabatech.com/schema/dubbo        http://code.alibabatech.com/schema/dubbo/dubbo.xsd"</span>&gt;</div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"consumer-of-helloworld-app"</span> /&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- 生成远程服务代理，可以和本地bean一样使用helloService --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"helloService"</span> <span class="attr">interface</span>=<span class="string">"org.ggg.hello.service.HelloService"</span> <span class="attr">url</span>=<span class="string">"dubbo://localhost:19880"</span> /&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>移除dubbo:registry，在dubbo:reference里增加本地的url即可。还是非常方便的吧，别忘记把服务先启动起来。</p>
]]></content>
      
        <categories>
            
            <category> architecture </category>
            
        </categories>
        
        
        <tags>
            
            <tag> dubbo </tag>
            
            <tag> service governance </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用IntelliJ IDEA社区版调试tomcat]]></title>
      <url>/intellij-idea-community-run-tomcat/</url>
      <content type="html"><![CDATA[<p><a href="https://dzone.com/articles/why-idea-better-eclipse" target="_blank" rel="external">IntelliJ IDEA在重构方面碾压eclipse</a>。但是IDEA的免费社区版是<a href="https://www.jetbrains.com/idea/features/editions_comparison_matrix.html" target="_blank" rel="external">不支持tomcat插件的</a>。如果你正在用IDEA社区版开发一个web应用，可以使用下文的方式来调试运行在tomcat里的web应用。笔者目前使用的IDEA版本为2016.1.1。<br><a id="more"></a></p>
<h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><p>假设我们有一个项目，已经用IDEA打开了，并且这个项目可以构建成一个<code>ggg-webapp.war</code>的包。在菜单<code>Run</code>-&gt;<code>Edit Configurations</code>里，新增一个<code>Remote</code>，填入下图所示的参数：<br><img src="/img/idea-debug-configurations.jpg" alt=""></p>
<ul>
<li>Name：叫啥都行，这里是tomcat-debug</li>
<li>Host：准备运行tomcat的机器IP，可以是vagrant虚拟机</li>
<li>Port：随便选一个端口就好，别跟其它端口冲突</li>
</ul>
<p>Tomcat的话可以用docker启动，比较方便。这里选用的是tomcat:7。复制<code>Command line arguments for running remote JVM</code>里的值，用它代替下面的<code>JAVA_OPTS</code>参数里的内容，然后运行tomcat并把war包复制到webapps目录里：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker run -d --net=host --name=tomcat -e JAVA_OPTS=<span class="string">'-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=7007'</span> tomcat:7</div><div class="line">docker cp ggg-webapp.war tomcat:/usr/<span class="built_in">local</span>/tomcat/webapps/</div></pre></td></tr></table></figure></p>
<p>Tomcat启动完成后，选择菜单<code>Run</code>-&gt;<code>Debug &#39;tomcat-debug&#39;</code>，就会显示<code>Connected to the target VM, address: &#39;192.168.33.88:7007&#39;, transport: &#39;socket&#39;</code>，然后就可以顺利debug了。</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>附送一些调试快捷键：</p>
<ul>
<li>F7：Step into</li>
<li>F8：Step over</li>
<li>F9：Run</li>
<li>Shift+F7：Smart step into（弹出对话框让你选择进入哪个方法）</li>
<li>Shift+F8：Step out</li>
<li>Ctrl+F8 / Command+F8：Toggle Breakpoint</li>
<li>Alt+F8：Evaluate expression</li>
<li>Alt+F9：Run To Cursor</li>
</ul>
]]></content>
      
        <categories>
            
            <category> tool </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IntelliJ IDEA </tag>
            
            <tag> tomcat </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[轻松了解Kubernetes认证功能]]></title>
      <url>/kubernetes-security/</url>
      <content type="html"><![CDATA[<p><a href="http://kubernetes.io/docs/whatisk8s/" target="_blank" rel="external">Kubernetes</a>简称k8s，是谷歌于2014年开始主导的开源项目，提供了以容器为中心的部署、伸缩和运维平台。截止目前它的最新版本为1.2。搭建环境之前建议先了解一下kubernetes的相关知识，可以参考<a href="/kubernetes-in-mesos-1">《如果有10000台机器，你想怎么玩？》</a>系列文章。本文介绍kubernetes的安全性配置。<br><a id="more"></a></p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先需要搭建kubernetes集群环境，可以参考<a href="/kubernetes-installation">《轻松搭建Kubernetes 1.2版运行环境》</a>来安装自己的kubernetes集群，运行到flannel配置完成即可。接下来的api server等设置的参数可以参考本文。</p>
<p>结果应该是有三台虚拟机，一台叫做<strong>master</strong>，它的IP是<strong>192.168.33.17</strong>，运行着k8s的api server、controller manager和scheduler；另两台叫做<strong>node1</strong>和<strong>node2</strong>，它们的IP分别是<strong>192.168.33.18</strong>和<strong>192.168.33.19</strong>，运行着k8s的kubelet和kube-proxy，当做k8s的两个节点。</p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>最简单的方式就是通过基于CSV的基本认证。首先需要创建api server的基本认证文件：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mkdir security</div><div class="line"></div><div class="line"><span class="built_in">echo</span> 123456,admin,qinghua &gt; security/basic_auth.csv                      <span class="comment"># 格式：用户名,密码,用户ID</span></div></pre></td></tr></table></figure></p>
<p>然后就可以生成CA和api server的证书了：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> security</div><div class="line"></div><div class="line">openssl genrsa -out ca.key 2048</div><div class="line">openssl req -x509 -new -nodes -key ca.key -subj <span class="string">"/CN=192.168.33.17"</span> -days 10000 -out ca.crt</div><div class="line">openssl genrsa -out server.key 2048</div><div class="line">openssl req -new -key server.key -subj <span class="string">"/CN=192.168.33.17"</span> -out server.csr</div><div class="line">openssl x509 -req -<span class="keyword">in</span> server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out server.crt -days 10000</div><div class="line"></div><div class="line"><span class="built_in">cd</span> ..</div></pre></td></tr></table></figure></p>
<p>上面的命令会生成若干证书相关文件，作用如下：</p>
<ul>
<li>ca.key：自己生成的CA的私钥，用于模拟一个CA</li>
<li>ca.crt：用自己的私钥自签名的CA证书</li>
<li>server.key：api server的私钥，用于配置api server的https</li>
<li>server.csr：api server的证书请求文件，用于请求api server的证书</li>
<li>server.crt：用自己模拟的CA签发的api server的证书，用于配置api server的https</li>
</ul>
<p>接下来启动api server，参数的作用可以参考<a href="http://kubernetes.io/docs/admin/kube-apiserver/" target="_blank" rel="external">kube-apiserver官方文档</a>：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">docker run -d \</div><div class="line">  --name=apiserver \</div><div class="line">  --net=host \</div><div class="line">  -v /home/vagrant/security:/security \</div><div class="line">  gcr.io/google_containers/kube-apiserver:e68c6af15d4672feef7022e94ee4d9af \</div><div class="line">  kube-apiserver \</div><div class="line">  --advertise-address=192.168.33.17 \</div><div class="line">  --admission-control=ServiceAccount \</div><div class="line">  --insecure-bind-address=0.0.0.0 \</div><div class="line">  --etcd-servers=http://192.168.33.17:4001 \</div><div class="line">  --service-cluster-ip-range=11.0.0.0/16 \</div><div class="line">  --tls-cert-file=/security/server.crt \</div><div class="line">  --tls-private-key-file=/security/server.key \</div><div class="line">  --secure-port=443 \</div><div class="line">  --basic-auth-file=/security/basic_auth.csv</div></pre></td></tr></table></figure></p>
<p>还需要启动controller manager，参数的作用可以参考<a href="http://kubernetes.io/docs/admin/kube-controller-manager/" target="_blank" rel="external">kube-controller-manager官方文档</a>：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">docker run -d \</div><div class="line">  --name=cm \</div><div class="line">  -v /home/vagrant/security:/security \</div><div class="line">  gcr.io/google_containers/kube-controller-manager:b9107c794e0564bf11719dc554213f7b \</div><div class="line">  kube-controller-manager \</div><div class="line">  --master=192.168.33.17:8080 \</div><div class="line">  --cluster-cidr=10.245.0.0/16 \</div><div class="line">  --allocate-node-cidrs=<span class="literal">true</span> \</div><div class="line">  --root-ca-file=/security/ca.crt \</div><div class="line">  --service-account-private-key-file=/security/server.key</div></pre></td></tr></table></figure></p>
<p>最后是scheduler，参数的作用可以参考<a href="http://kubernetes.io/docs/admin/kube-scheduler/" target="_blank" rel="external">kube-scheduler官方文档</a>：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">docker run -d \</div><div class="line">  --name=scheduler \</div><div class="line">  gcr.io/google_containers/kube-scheduler:903b34d5ed7367ec4dddf846675613c9 \</div><div class="line">  kube-scheduler \</div><div class="line">  --master=192.168.33.17:8080</div></pre></td></tr></table></figure></p>
<p>可以运行以下命令来确认安全配置已经生效：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">curl -k -u admin:123456 https://127.0.0.1/</div><div class="line">curl -k -u admin:123456 https://127.0.0.1/api/v1</div></pre></td></tr></table></figure></p>
<p>最后启动kubelet和kube-proxy，参数的作用可以参考<a href="http://kubernetes.io/docs/admin/kubelet/" target="_blank" rel="external">kubelet官方文档</a>和<a href="http://kubernetes.io/docs/admin/kube-proxy/" target="_blank" rel="external">kube-proxy官方文档</a>：<br><figure class="highlight sh"><figcaption><span>node1 node2</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">NODE_IP=`ifconfig eth1 | grep <span class="string">'inet addr:'</span> | cut -d: -f2 | cut -d<span class="string">' '</span> -f1`</div><div class="line"></div><div class="line">sudo kubernetes/server/bin/kubelet \</div><div class="line">  --api-servers=192.168.33.17:8080 \</div><div class="line">  --cluster-dns=11.0.0.10 \</div><div class="line">  --cluster-domain=cluster.local \</div><div class="line">  --hostname-override=<span class="variable">$NODE_IP</span> \</div><div class="line">  --node-ip=<span class="variable">$NODE_IP</span> &gt; kubelet.log 2&gt;&amp;1 &amp;</div><div class="line"></div><div class="line">sudo kubernetes/server/bin/kube-proxy \</div><div class="line">  --master=192.168.33.17:8080 \</div><div class="line">  --hostname-override=<span class="variable">$NODE_IP</span> &gt; proxy.log 2&gt;&amp;1 &amp;</div></pre></td></tr></table></figure></p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>如果需要通过https访问，kubectl的命令就略微有点儿麻烦了，需要用<code>basic_auth.csv</code>里配置的<code>admin/123456</code>来登录：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubernetes/server/bin/kubectl -s https://192.168.33.17 --insecure-skip-tls-verify=<span class="literal">true</span> --username=admin --password=123456 get po</div></pre></td></tr></table></figure></p>
<p>因为8080端口还开着，所以也可以通过http访问：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubernetes/server/bin/kubectl -s http://192.168.33.17:8080 get po</div></pre></td></tr></table></figure></p>
<p>配置完成后，可以看到系统里有TYPE为<code>kubernetes.io/service-account-token</code>的秘密：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubernetes/server/bin/kubectl -s http://192.168.33.17:8080 get secret</div></pre></td></tr></table></figure></p>
<p>里面有三条数据，分别是<code>ca.crt</code>，<code>namespace</code>和<code>token</code>，可以通过以下命令看到：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubernetes/server/bin/kubectl -s http://192.168.33.17:8080 describe secret</div></pre></td></tr></table></figure></p>
<p>如果你通过kubernetes启动了一个pod，就可以在容器的<code>/var/run/secrets/kubernetes.io/serviceaccount/</code>目录里看到以三个文件的形式看到这三条数据（这是<code>--admission-control=ServiceAccount</code>的功劳），当pod需要访问系统服务的时候，就可以使用它们了。可以使用以下命令看到系统的服务账号：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubernetes/server/bin/kubectl -s http://192.168.33.17:8080 get serviceAccount</div></pre></td></tr></table></figure></p>
<h2 id="简化kubectl"><a href="#简化kubectl" class="headerlink" title="简化kubectl"></a>简化kubectl</h2><p>如果我们通过设置<code>--insecure-port=0</code>把api server的http端口关闭，那它就只能通过https访问了：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">docker rm -f apiserver</div><div class="line">docker run -d \</div><div class="line">  --name=apiserver \</div><div class="line">  --net=host \</div><div class="line">  -v /home/vagrant/security:/security \</div><div class="line">  gcr.io/google_containers/kube-apiserver:e68c6af15d4672feef7022e94ee4d9af \</div><div class="line">  kube-apiserver \</div><div class="line">  --advertise-address=192.168.33.17 \</div><div class="line">  --admission-control=ServiceAccount \</div><div class="line">  --insecure-bind-address=0.0.0.0 \</div><div class="line">  --etcd-servers=http://192.168.33.17:4001 \</div><div class="line">  --service-cluster-ip-range=11.0.0.0/16 \</div><div class="line">  --tls-cert-file=/security/server.crt \</div><div class="line">  --tls-private-key-file=/security/server.key \</div><div class="line">  --secure-port=443 \</div><div class="line">  --basic-auth-file=/security/basic_auth.csv \</div><div class="line">  --insecure-port=0</div></pre></td></tr></table></figure></p>
<p>这样的话，就连取个pod都得这么麻烦：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubernetes/server/bin/kubectl -s https://192.168.33.17 --insecure-skip-tls-verify=<span class="literal">true</span> --username=admin --password=123456 get po</div></pre></td></tr></table></figure></p>
<p>幸运的是，kubernetes提供了一种方式，让我们可以大大简化命令，只用这样就好了：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubernetes/server/bin/kubectl get po</div></pre></td></tr></table></figure></p>
<p>下面就让我们来试一下吧！首先用<code>kubectl config</code>命令来配置admin用户：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubernetes/server/bin/kubectl config <span class="built_in">set</span>-credentials admin --username=admin --password=123456</div></pre></td></tr></table></figure></p>
<p>然后是api server的访问方式，给集群起个名字叫qinghua：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubernetes/server/bin/kubectl config <span class="built_in">set</span>-cluster qinghua --insecure-skip-tls-verify=<span class="literal">true</span> --server=https://192.168.33.17</div></pre></td></tr></table></figure></p>
<p>接下来创建一个context，它连接用户admin和集群qinghua：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubernetes/server/bin/kubectl config <span class="built_in">set</span>-context default/qinghua --user=admin --namespace=default --cluster=qinghua</div></pre></td></tr></table></figure></p>
<p>最后设置一下默认的context：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubernetes/server/bin/kubectl config use-context default/qinghua</div></pre></td></tr></table></figure></p>
<p>然后就可以用我们的简化版啦：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubernetes/server/bin/kubectl get po</div></pre></td></tr></table></figure></p>
<p>可以通过以下命令来看到当前kubectl的配置：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubernetes/server/bin/kubectl config view</div></pre></td></tr></table></figure></p>
<p>能够看到如下内容：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">apiVersion: v1</div><div class="line">clusters:</div><div class="line">- cluster:</div><div class="line">    insecure-skip-tls-verify: <span class="literal">true</span></div><div class="line">    server: https://192.168.33.17</div><div class="line">  name: qinghua</div><div class="line">contexts:</div><div class="line">- context:</div><div class="line">    cluster: qinghua</div><div class="line">    namespace: default</div><div class="line">    user: admin</div><div class="line">  name: default/qinghua</div><div class="line">current-context: default/qinghua</div><div class="line">kind: Config</div><div class="line">preferences: &#123;&#125;</div><div class="line">users:</div><div class="line">- name: admin</div><div class="line">  user:</div><div class="line">    password: <span class="string">"123456"</span></div><div class="line">    username: admin</div></pre></td></tr></table></figure></p>
<p>实际上这些配置都存放在<code>~/.kube/config</code>文件里：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat ~/.kube/config</div></pre></td></tr></table></figure></p>
<p>修改这个文件也可以实时生效。细心的童鞋们可以看到，cluster、context和users都是集合，也就是说如果需要切换用户和集群等，只需要设置默认context就可以了，非常方便。</p>
]]></content>
      
        <categories>
            
            <category> devops </category>
            
        </categories>
        
        
        <tags>
            
            <tag> docker </tag>
            
            <tag> kubernetes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[轻松了解Kubernetes部署功能]]></title>
      <url>/kubernetes-deployment/</url>
      <content type="html"><![CDATA[<p><a href="http://kubernetes.io/docs/whatisk8s/" target="_blank" rel="external">Kubernetes</a>简称k8s，是谷歌于2014年开始主导的开源项目，提供了以容器为中心的部署、伸缩和运维平台。截止目前它的最新版本为1.2。搭建环境之前建议先了解一下kubernetes的相关知识，可以参考<a href="/kubernetes-in-mesos-1">《如果有10000台机器，你想怎么玩？》</a>系列文章。本文介绍kubernetes的基本部署功能。<br><a id="more"></a></p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先需要搭建kubernetes集群环境，可以参考<a href="/kubernetes-installation">《轻松搭建Kubernetes 1.2版运行环境》</a>来安装自己的kubernetes集群。</p>
<p>结果应该是有三台虚拟机，一台叫做<strong>master</strong>，它的IP是<strong>192.168.33.17</strong>，运行着k8s的api server、controller manager和scheduler；另两台叫做<strong>node1</strong>和<strong>node2</strong>，它们的IP分别是<strong>192.168.33.18</strong>和<strong>192.168.33.19</strong>，运行着k8s的kubelet和kube-proxy，当做k8s的两个节点。</p>
<h2 id="部署（deployment）"><a href="#部署（deployment）" class="headerlink" title="部署（deployment）"></a>部署（deployment）</h2><p>启动一个容器最简单的方法应该就是使用以下命令了：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubernetes/server/bin/kubectl -s 192.168.33.17:8080 run my-nginx --image=nginx:1.7.9</div></pre></td></tr></table></figure></p>
<p>如果一切工作正常，应该能看到一条消息<strong>deployment “my-nginx” created</strong>。<a href="http://kubernetes.io/docs/user-guide/deployments/" target="_blank" rel="external">Deployment</a>是kubernetes 1.2的一个新引入的概念，它包含着对<a href="http://kubernetes.io/docs/user-guide/pods/" target="_blank" rel="external">Pod</a>和将要代替<a href="http://kubernetes.io/docs/user-guide/replication-controller/" target="_blank" rel="external">Replication Controller</a>的<a href="http://kubernetes.io/docs/user-guide/replicasets/" target="_blank" rel="external">Replica Set</a>的描述。</p>
<p>为了简化命令，我们设置一个别名：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">alias</span> kubectl=<span class="string">"kubernetes/server/bin/kubectl -s 192.168.33.17:8080"</span></div></pre></td></tr></table></figure></p>
<p>使用以下命令可以看到目前集群里的信息：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">kubectl get po                          <span class="comment"># 查看目前所有的pod</span></div><div class="line">kubectl get rs                          <span class="comment"># 查看目前所有的replica set</span></div><div class="line">kubectl get deployment                  <span class="comment"># 查看目前所有的deployment</span></div><div class="line">kubectl describe po my-nginx            <span class="comment"># 查看my-nginx pod的详细状态</span></div><div class="line">kubectl describe rs my-nginx            <span class="comment"># 查看my-nginx replica set的详细状态</span></div><div class="line">kubectl describe deployment my-nginx    <span class="comment"># 查看my-nginx deployment的详细状态</span></div></pre></td></tr></table></figure></p>
<p>用<code>kubectl describe po my-nginx</code>可以查看到这个pod被分配到哪台node上去。当<code>kubectl get po</code>显示<strong>1/1 Running</strong>时，说明容器已经启动完成了。SSH到那台虚拟机上，<code>docker ps</code>一下，能够看到有两个容器启动完成了，一个是nginx，另一个就是负责网络的pause。使用<code>docker rm -f</code>将nginx容器删除，再用<code>kubectl get po</code>查看，一会儿便会显示<strong>0/1 ContainerCreating</strong>，随即又变成<strong>1/1 Running</strong>，这是replica set的功劳。当它检测到容器挂掉的时候，便会重新启动一个容器来保证服务不中断。不仅是容器挂掉，停止虚拟机也能使容器被再分配到另一台node上，有兴趣的朋友可以自行尝试，虚拟机重启回来后记得再次运行flannel和kubelet哦。</p>
<p>使用以下命令可以删除my-nginx deployment，my-nginx replica set和my-nginx pod（抵消第一条run命令的作用）：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubectl delete deployment my-nginx</div></pre></td></tr></table></figure></p>
<p>可以使用<code>kubectl get</code>命令来查看删除后的结果。一般我们会把部署信息写在一个yaml格式的文件里，这样比较容易查看，并且方便写入各种参数：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">cat &lt;&lt; EOF &gt;nginx.yaml</div><div class="line">apiVersion: extensions/v1beta1</div><div class="line">kind: Deployment</div><div class="line">metadata:</div><div class="line">  name: nginx-deployment</div><div class="line">spec:</div><div class="line">  replicas: 2</div><div class="line">  template:</div><div class="line">    metadata:</div><div class="line">      labels:</div><div class="line">        app: nginx</div><div class="line">    spec:</div><div class="line">      containers:</div><div class="line">      - name: nginx</div><div class="line">        image: nginx:1.7.9</div><div class="line">        ports:</div><div class="line">        - containerPort: 80</div><div class="line">        resources:</div><div class="line">          requests:</div><div class="line">            cpu: 400m</div><div class="line">EOF</div><div class="line"></div><div class="line">kubectl create -f nginx.yaml --record</div></pre></td></tr></table></figure></p>
<p>Deployment文件的详细说明可以看<a href="http://kubernetes.io/docs/api-reference/extensions/v1beta1/definitions/" target="_blank" rel="external">Extensions API定义</a>，通用参数的详细信息可以看<a href="http://kubernetes.io/docs/api-reference/v1/definitions/" target="_blank" rel="external">Kubernetes API定义</a>。由于这次的replicas设置为2，kubernetes会帮我们启动并维持两个实例。如果我们想要更新部署的yaml，有两种方法。第一种是使用edit直接修改：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubectl edit deployment/nginx-deployment</div></pre></td></tr></table></figure></p>
<p>把<code>nginx:1.7.9</code>修改为<code>nginx:1.9.11</code>，保存退出。Kubernetes就会自动帮我们升级镜像。通过<code>kubectl get deployment nginx</code>的Events里可以看到升级的事件。不管是哪一种方法，升级的过程都是这样的：</p>
<ul>
<li>启动一个新容器</li>
<li>停止两个旧容器</li>
<li>启动一个新容器<br>启动一个新的容器，然后停止一个旧的，重复这个过程直到旧的容器全部停止为止。这样可以保证</li>
</ul>
<p>第二种是修改yaml文件，然后apply：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sed -i <span class="string">"s/nginx:1.7.9/nginx:1.91/g"</span> nginx.yaml</div><div class="line">kubectl apply -f nginx.yaml</div></pre></td></tr></table></figure></p>
<p>细心的你可能已经发现我在上面的命令里把<code>nginx:1.9.1</code>打成<code>nginx:1.91</code>了。如果此时用<code>kubectl describe po nginx</code>命令，就能看到<strong>Error syncing pod, skipping: failed to “StartContainer” for “nginx” with ErrImagePull: “Tag 1.91 not found in repository docker.io/library/nginx”</strong>的错误。现在我需要停止这次升级。我们可以用这条命令来查看升级历史：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubectl rollout <span class="built_in">history</span> deployment/nginx-deployment</div></pre></td></tr></table></figure></p>
<p>由于<code>kubectl create</code>的时候用了<code>--record</code>的标志，我们能够直接看到命令，方便定位到上一次正确的升级<strong>2 kubectl -s 192.168.33.17:8080 edit deployment/nginx-deployment</strong>，查看详细的deployment内容：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubectl rollout <span class="built_in">history</span> deployment/nginx-deployment --revision=2</div></pre></td></tr></table></figure></p>
<p>有两种方法可以回退到这个版本：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">kubectl rollout undo deployment/nginx-deployment</div><div class="line">kubectl rollout undo deployment/nginx-deployment --to-revision=2</div></pre></td></tr></table></figure></p>
<h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><p>前面创建了nginx的部署对象，那么别人如何使用nginx这个服务呢？首先要确定的是，这个nginx服务，是给内部使用的，还是外部。如果是内部使用，那就可以不用设置服务的类型（默认为ClusterIP），否则，可以将服务类型设置为NodePort，通过node的端口暴露出来给外部使用；或者是LoadBalancer，由云服务商提供一个负载均衡直接挂在服务上。这里我们使用NodePort，暴露出30088端口给外部使用。如果不指定nodePort，那么kubernetes会随机生成一个。下面让我们来启动服务：<br><figure class="highlight sh"><figcaption><span>master master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">cat &lt;&lt; EOF &gt;nginx-svc.yaml</div><div class="line">apiVersion: v1</div><div class="line">kind: Service</div><div class="line">metadata:</div><div class="line">  name: nginx</div><div class="line">  labels:</div><div class="line">    app: nginx</div><div class="line">spec:</div><div class="line">  <span class="built_in">type</span>: NodePort</div><div class="line">  selector:</div><div class="line">    app: nginx</div><div class="line">  ports:</div><div class="line">  - port: 80</div><div class="line">    targetPort: 80</div><div class="line">    nodePort: 30088</div><div class="line">EOF</div><div class="line"></div><div class="line">kubectl create -f nginx-svc.yaml</div></pre></td></tr></table></figure></p>
<p>这样便可以通过<a href="http://192.168.33.18:30088" target="_blank" rel="external">http://192.168.33.18:30088</a>或<a href="http://192.168.33.19:30088" target="_blank" rel="external">http://192.168.33.19:30088</a>访问nginx服务了：<br><img src="/img/nginx.jpg" alt=""></p>
<p>可以使用以下命令来删除服务及nginx的部署：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">kubectl delete -f nginx-svc.yaml</div><div class="line">kubectl delete -f nginx.yaml</div></pre></td></tr></table></figure></p>
<h2 id="一次性任务（job）"><a href="#一次性任务（job）" class="headerlink" title="一次性任务（job）"></a>一次性任务（job）</h2><p>Kubernetes 1.1版时将<a href="http://kubernetes.io/docs/user-guide/jobs/" target="_blank" rel="external">Job</a>还是Beta版，1.2之后已经可用于生产环境。Job是包含着若干pod的一次性任务。它与Replication Controller和Replica Set最大的区别就是当容器正常停止后，不会再次重启以维持一定数量的pod提供服务。下面我们用busybox运行一个耗时30s的任务：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">cat &lt;&lt; EOF &gt;busybox.yaml</div><div class="line">apiVersion: batch/v1</div><div class="line">kind: Job</div><div class="line">metadata:</div><div class="line">  name: busybox</div><div class="line">spec:</div><div class="line">  template:</div><div class="line">    metadata:</div><div class="line">      name: busybox</div><div class="line">    spec:</div><div class="line">      containers:</div><div class="line">      - name: busybox</div><div class="line">        image: busybox:1.24.1</div><div class="line">        <span class="built_in">command</span>:</div><div class="line">          - sleep</div><div class="line">          - <span class="string">"30"</span></div><div class="line">      restartPolicy: Never</div><div class="line">EOF</div><div class="line"></div><div class="line">kubectl create -f busybox.yaml</div></pre></td></tr></table></figure></p>
<p>可以使用以下命令来取得目前的job：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubectl get <span class="built_in">jobs</span></div></pre></td></tr></table></figure></p>
<p>可以看到，30s之后，SUCCESSFUL从0变为1了，说明这个job已经顺利完成了。可以使用以下命令来查看所有的pod，包含在busybox的job里正常结束的pod：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubectl get pods --show-all</div></pre></td></tr></table></figure></p>
<p>Job完成之后仍然会在那里。如果需要删除，运行以下两条命令之一：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">kubectl delete job busybox</div><div class="line">kubectl delete -f busybox.yaml</div></pre></td></tr></table></figure></p>
<p>相关的pod也会一并被删除。不过容器仍然会留在运行过这个pod的node上。这可以通过设置kubelet的<code>--maximum-dead-containers</code>和<code>--maximum-dead-containers-per-container</code>参数来解决。</p>
<h2 id="Daemon-Sets"><a href="#Daemon-Sets" class="headerlink" title="Daemon Sets"></a>Daemon Sets</h2><p>有时候需要每个node上都运行一个pod，比如监控或是日志收集等。这时候使用Daemon Sets就非常方便。我们用一个tomcat容器来做例子：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">cat &lt;&lt; EOF &gt;tomcat.yaml</div><div class="line">apiVersion: extensions/v1beta1</div><div class="line">kind: DaemonSet</div><div class="line">metadata:</div><div class="line">  name: tomcat-ds</div><div class="line">spec:</div><div class="line">  template:</div><div class="line">    metadata:</div><div class="line">      labels:</div><div class="line">        app: tomcat</div><div class="line">    spec:</div><div class="line">      containers:</div><div class="line">      - name: tomcat</div><div class="line">        image: tomcat:8.0.30-jre8</div><div class="line">        ports:</div><div class="line">        - containerPort: 8080</div><div class="line">EOF</div><div class="line"></div><div class="line">kubectl create -f tomcat.yaml</div></pre></td></tr></table></figure></p>
<p>运行完毕后，通过以下命令来取得运行结果：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">kubectl get ds</div><div class="line">kubectl get pods</div></pre></td></tr></table></figure></p>
<p>这个yaml文件和一开始的deployment的yaml文件格式很像，虽然我们没有指定replicas，但还是起了两个pod（因为我们有两个node）。可以ssh到这两个node上看看是不是每一个node上都启动了一个tomcat容器。</p>
]]></content>
      
        <categories>
            
            <category> devops </category>
            
        </categories>
        
        
        <tags>
            
            <tag> docker </tag>
            
            <tag> kubernetes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[VR和其他科技的结合意味着什么]]></title>
      <url>/vr-mix-with-other-techs/</url>
      <content type="html"><![CDATA[<p>随着VR走进现实，人们的双眼纷纷看到了它在影视、游戏等产业的巨大钱景。借用熊节在<a href="http://gigix.thoughtworkers.org/2015/8/28/driverless-cars/" target="_blank" rel="external">《无人驾驶汽车意味着什么》</a>里的一句话：“然而技术的成熟与投入实用远不是变革的终点，恰恰相反，这只是一场更为深远的变革的起点”。我脑洞大开，畅想一下VR和其他科技结合之后，将会如何影响我们的生活。看上去下一个十年又要迎来一次技术大爆炸。<br><a id="more"></a></p>
<h2 id="无人机"><a href="#无人机" class="headerlink" title="无人机"></a>无人机</h2><p>曾几何时，拍照、摄像还是摄影师的专利，随着数码相机的普及尤其是手机摄像头的发展，到了现在的自媒体时代，人人都喜欢拍一点什么。数量上去了，大家就开始想到提高质量。无人机给了我们这样一个上帝视角，在某种程度上圆了人类的飞行梦。现在的技术可以做到实时在手机上查看无人机正在拍摄的高清视频。VR结合无人机，会产生什么样的效果呢？看看这幅图：<br><img src="/img/vr-skydiving.jpg" alt=""></p>
<p>跳伞的话，只能下不能上，横向移动范围有限。VR结合无人机，能够带来更高一筹的高空体验，并且大大降低了安全事故发生的概率。当然无人机坏掉砸在路人脑袋上这种事就不在我们讨论范围内了…</p>
<h2 id="机器人"><a href="#机器人" class="headerlink" title="机器人"></a>机器人</h2><p>VR结合无人机，无论多么狂拽炫酷吊炸天，仍然是小众玩家的福利。而真正能够影响普通人的，应该算是和机器人结合。想像这样的世界：虽然分身乏术，但是你可以购买一个机器人，让它帮你去远方开会，到时候VR直接连接上这个机器人就好啦。这种方案的话，需要成熟的无人驾驶技术的配合，才能让机器人自动到达目的地。<br><img src="/img/vr-robot.jpg" alt=""></p>
<p>继续往里思考，为什么非要买一个机器人跑到远方去呢？是不是可以直接租赁一个远方的机器人呢？假设有一个提供机器人租赁的公司，直接在开会地点附近有一个机器人租赁点，与会人员就没必要派遣机器人过去了，直接每个人租一个机器人开会就好啦。</p>
<h2 id="3D打印"><a href="#3D打印" class="headerlink" title="3D打印"></a>3D打印</h2><p>虽然VR结合机器人听起来令人心动，但是有一个问题就是，大家都是机器人了，那我在VR里看出去都是一堆的机器人有什么用？根本不知道谁是谁，干脆直接电话会议或者视频会议不就好了嘛，反正表情动作眼神都很难感觉出来。这时候3D打印就派上用场了。假设到时候的3D打印技术非常成熟，你在家里就能很轻易地将你现在的模型传送给机器人租赁公司，而公司可以在较短的时间内打印一个像你一样的机器人，于是你在别人的眼里并不是一个机器人，而是真正的“你”。每个人都是自己的样子，开会就像是在现场一样。到时候的材料工艺也应该有很大进步，可以实现材料回收再利用，这样可以大大降低租用机器人的成本。<br><img src="/img/vr-humanoid.jpg" alt=""></p>
<p>想象一下在一个会议里，里面所有的“人”都只是躯壳，而真实的人都在其它地方，是不是有点儿感觉怪怪的了？</p>
<h2 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h2><p>VR结合3D打印，开始带来一丝怪异的感觉了。再加上人工智能的混入，就已经不是“怪异”两个字就能形容的了。想象你面对一个“人”，音容笑貌都是某个你熟悉的人，但“ta”可能并不是你熟悉的“ta”…“ta”可能是个具有人工智能的机器人！在良性的环境下，“ta”只可能是真人戴着VR在跟你交流，或者由于真人在忙其它事情，“ta”现在是个尽力在模仿真人的善意人工智能；在恶性的环境下，“它”可能被其他人所控制，要对你做出一些诈骗等恶意行为；最恶劣的是“ta”可能发展了自己的意识，你根本不知道“ta”在想什么，“ta”想干什么。这里引用霍金的预言：“成功制造出一台人工智能机器人将是人类历史上的里程碑。但不幸的是，它也可能会成为我们历史上最后的一个里程碑”。黑客帝国里的场景，也有可能变成现实。</p>
<h2 id="其他畅想"><a href="#其他畅想" class="headerlink" title="其他畅想"></a>其他畅想</h2><p>在上文的模型里，可以预见的是，信息安全将会是未来的重中之重。传输自己的模型给机器人公司，需要小心传错对象或被黑客拦截；VR连接远程机器人，需要小心机器人可能被其他人捷足先登；对人工智能，也许也需要必要的防范。虽然有许多安全上的顾虑，但也正是这些技术，可以让我们更加安全。矿工附身在机器人上，用自己的娴熟技巧采矿；消防员附身在机器人上，可以身冲火海而不会收到任何损伤；对于户外极限运动爱好者来说，这真的是加了无数条命呀。话说回来，如果要实现这样的效果，光自动驾驶是远远不够的。可能还需要如下的几点：</p>
<ul>
<li>高带宽+低延迟的移动网络：没有高带宽的支持，收到的VR场景数据可能分辨率或刷新率低，降低沉浸式体验。没有低延迟的支持，机器人反应慢就不那么适合争分夺秒型任务。</li>
<li><p>移动：现在大多数的VR都不支持移动。即使像HTC Vive那样，由于受到空间制约，也只是有限支持。如果要实用化，下图的平面移动能够满足一定的需求，不过还需考虑包含上下的三维空间。<br><img src="/img/vr-move.jpg" alt=""></p>
</li>
<li><p>材料和传感器：为了完美体验触感，也许还需要能够快速打印出具有一定质量、密度、硬度的物质，需要极高的材料工艺，并且需要机器人身上安装高精度传感器实时传回需要的材料数据。</p>
</li>
<li>环境：微风轻抚和狂风暴雨是完全不一样的感受。还要考虑温度、湿度等感觉。</li>
<li>嗅觉支持：虽然人类的鼻子没有狗鼻子那么灵敏，但是现实生活中，有时候气味是决定下一步行动的原因。比如闻到了焦糊味就去厨房看看。相比起来，对于味觉的支持就可以缓一缓了。</li>
<li>梦境或意识：除了上面的移动、材料和传感器的硬派支持，还有一种方式是以类似催眠、梦境或者存意识的方式来支持这种感觉的传递。阿凡达！！</li>
</ul>
<p>由于有了机器人替身，战争的形式也应该会发生变化。士兵们不需要搏命了，也许打战变成了一场游戏。开战前拔掉对方的VR中心可能变成了一种战略选择。毕竟如果存在由人控制的机器人对人类的战争，那结果应该像是现代兵器对战冷兵器时代，是一边倒的。希望不要有战争。即使有战争也别培育出作战型人工智能。</p>
<p>再想点儿其他贴近生活的方面，可能人们就不太需要出行了。现在的上班族大多经历过天天挤公交地铁或者开车堵在路上的罪。以后不需要了。公司摆一个你的机器人躯壳，家里来副VR眼镜，一切搞定。还有什么场景需要出行？旅游？现在的VR都已经快要解决这个问题了，各大VR视频资源库里已经有不少全景漫游的视频了。风景变化不大，甚至不需要机器人的代劳，直接数字化就好了。什么九寨沟一年四季各有各的看点？巴尔夏明神庙被炸毁？华南虎灭绝了？统统都能看到。购物也是同理，送货上门应该算是未来商店最基本的服务之一了。探亲？这个确实有些不好回答，也许有些家庭无所谓真的假的，有些家庭会更倾向于真人探亲。对了，吃饭和看病机器人就没法代劳了吧？何不反过来想想这个问题，虽然机器人不能代替你去饭店吃饭，但是大厨可以附身在你家的机器人上，给你做出美味佳肴！没有趁手的工具？3D打印！看病也是同理，就是可能会由于医疗器械比较昂贵或者各种许可证、专利问题，也许最终还是得你亲自跑一趟。上厕所？想必你每天上厕所不至于跑个几公里吧…不管怎样，VR和其他技术的结合确实能够大大减少出行的次数。</p>
]]></content>
      
        <categories>
            
            <category> vr </category>
            
        </categories>
        
        
        <tags>
            
            <tag> thought </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用RADOSGW联盟网关跨域同步]]></title>
      <url>/ceph-radosgw-replication/</url>
      <content type="html"><![CDATA[<p><a href="http://ceph.com/" target="_blank" rel="external">Ceph</a>是一个高性能的PB级分布式文件系统。它能够在一个系统中提供对象存储、块存储和文件存储。本文的主要内容是如何<a href="http://docs.ceph.com/docs/master/radosgw/federated-config/" target="_blank" rel="external">通过RADOSGW备份一个可用区</a>。</p>
<ul>
<li>对如何加载使用块存储和文件存储感兴趣可以参考<a href="/ceph-demo">《用容器轻松搭建ceph实验环境》</a></li>
<li>对RADOSGW如何暴露S3和Swift接口感兴趣可以参考<a href="/ceph-radosgw">《通过RADOSGW提供ceph的S3和Swift接口》</a><a id="more"></a>
</li>
</ul>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>我们需要先安装<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="external">virtualBox</a>和<a href="https://www.vagrantup.com/downloads.html" target="_blank" rel="external">vagrant</a>。通过vagrant来驱动virtualBox搭建一个虚拟测试环境。首先在本地任意路径新建一个空文件夹比如<code>test</code>，运行以下命令：<br><figure class="highlight sh"><figcaption><span>virtual box host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mkdir <span class="built_in">test</span></div><div class="line"><span class="built_in">cd</span> <span class="built_in">test</span></div><div class="line">vagrant init minimum/ubuntu-trusty64-docker</div><div class="line">vi Vagrantfile</div></pre></td></tr></table></figure></p>
<p>里面应该有一句<code>config.vm.box = &quot;minimum/ubuntu-trusty64-docker&quot;</code>，在它的下面添加如下几行代码，相当于给它分配三台虚拟机，一台叫做<strong>us-east</strong>，它的IP是<strong>192.168.33.15</strong>；另一台叫做<strong>us-west</strong>，它的IP是<strong>192.168.33.16</strong>；第三台叫做<strong>eu-east</strong>，它的IP是<strong>192.168.33.17</strong>。<br><figure class="highlight ruby"><figcaption><span>Vagrantfile</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">config.vm.define <span class="string">"us-east"</span> <span class="keyword">do</span> <span class="params">| host |</span></div><div class="line">  host.vm.hostname = <span class="string">"us-east"</span></div><div class="line">  host.vm.network <span class="string">"private_network"</span>, <span class="symbol">ip:</span> <span class="string">"192.168.33.15"</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">config.vm.define <span class="string">"us-west"</span> <span class="keyword">do</span> <span class="params">| host |</span></div><div class="line">  host.vm.hostname = <span class="string">"us-west"</span></div><div class="line">  host.vm.network <span class="string">"private_network"</span>, <span class="symbol">ip:</span> <span class="string">"192.168.33.16"</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">config.vm.define <span class="string">"eu-east"</span> <span class="keyword">do</span> <span class="params">| host |</span></div><div class="line">  host.vm.hostname = <span class="string">"eu-east"</span></div><div class="line">  host.vm.network <span class="string">"private_network"</span>, <span class="symbol">ip:</span> <span class="string">"192.168.33.17"</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p>然后分别在三个终端运行以下命令启动并连接三台虚拟机。<br><figure class="highlight sh"><figcaption><span>virtual box host terminal 1</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vagrant up</div><div class="line">vagrant ssh us-east</div></pre></td></tr></table></figure></p>
<figure class="highlight sh"><figcaption><span>virtual box host terminal 2</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vagrant ssh us-west</div></pre></td></tr></table></figure>
<figure class="highlight sh"><figcaption><span>virtual box host terminal 3</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vagrant ssh eu-east</div></pre></td></tr></table></figure>
<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p><a href="http://docs.ceph.com/docs/master/radosgw/" target="_blank" rel="external">Ceph对象网关（Ceph Object Gateway，radosgw）</a>提供了S3和Swift的API，同时也支持S3的一些概念。<a href="http://docs.ceph.com/docs/master/radosgw/config-ref/#regions" target="_blank" rel="external">辖区（region）</a>表明了一个地理位置，比如us。在这个辖区里可以有多个<a href="http://docs.ceph.com/docs/master/radosgw/config-ref/#zones" target="_blank" rel="external">域（zone）</a>，比如east和west。一个域里可以有多个实例，一个实例可以有多个<a href="http://docs.ceph.com/docs/master/glossary/#term-ceph-node" target="_blank" rel="external">节点（node）</a>。同时，配置一个域需要一系列的<a href="http://docs.ceph.com/docs/master/radosgw/config-ref/#pools" target="_blank" rel="external">存储池（pool）</a>。如下图：<br><img src="/img/ceph-radosgw-replication-config.png" alt=""></p>
<p>对于这次练习，我们使用下图的架构：<br><img src="/img/ceph-radosgw-replication-example.png" alt=""></p>
<p>一个us辖区里有us-east和us-west两个域，每个域里各有一个实例，分别为us-east-1和us-west-1。还有一个eu的辖区，里面有一个eu-east的域，一个为eu-east-1的实例。我们将会首先实现同一个辖区（us）里的同步，然后是不同辖区的同步。相同辖区可以同步元数据和数据对象，而不同的辖区只能同步元数据而不能同步数据对象。元数据包括网关用户和存储桶（bucket）。</p>
<h2 id="相同辖区的同步"><a href="#相同辖区的同步" class="headerlink" title="相同辖区的同步"></a>相同辖区的同步</h2><p>首先需要安装一些ceph、radosgw的依赖包：<br><figure class="highlight sh"><figcaption><span>us-east us-west eu-east</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update</div><div class="line">sudo apt-get -y --force-yes install ceph-common radosgw radosgw-agent</div></pre></td></tr></table></figure></p>
<p>为了提供HTTP服务，还需要所有虚拟机都安装apache2和FastCGI：<br><figure class="highlight sh"><figcaption><span>us-east us-west eu-east</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get -y --force-yes install apache2 libapache2-mod-fastcgi</div></pre></td></tr></table></figure></p>
<p>然后就可以分别启动ceph/demo这个容器来轻松提供ceph服务了：<br><figure class="highlight sh"><figcaption><span>us-east</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d --net=host -v /etc/ceph:/etc/ceph -e MON_IP=192.168.33.15 -e CEPH_NETWORK=192.168.33.15/24 --name=ceph ceph/demo</div></pre></td></tr></table></figure></p>
<figure class="highlight sh"><figcaption><span>us-west</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d --net=host -v /etc/ceph:/etc/ceph -e MON_IP=192.168.33.16 -e CEPH_NETWORK=192.168.33.16/24 --name=ceph ceph/demo</div></pre></td></tr></table></figure>
<p>然后手动在各自虚拟机上创建一些提供给域使用的存储池，这一步不是必须的，因为我们创建的网关用户是有权限自动创建存储池的：<br><figure class="highlight sh"><figcaption><span>us-east</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> -it ceph bash</div><div class="line">ceph osd pool create .us-east.rgw.root 16 16</div><div class="line">ceph osd pool create .us-east.rgw.control 16 16</div><div class="line">ceph osd pool create .us-east.rgw.gc 16 16</div><div class="line">ceph osd pool create .us-east.rgw.buckets 512 512</div><div class="line">ceph osd pool create .us-east.rgw.buckets.index 32 32</div><div class="line">ceph osd pool create .us-east.rgw.buckets.extra 16 16</div><div class="line">ceph osd pool create .us-east.log 16 16</div><div class="line">ceph osd pool create .us-east.intent-log 16 16</div><div class="line">ceph osd pool create .us-east.usage 16 16</div><div class="line">ceph osd pool create .us-east.users 16 16</div><div class="line">ceph osd pool create .us-east.users.email 16 16</div><div class="line">ceph osd pool create .us-east.users.swift 16 16</div><div class="line">ceph osd pool create .us-east.users.uid 16 16</div><div class="line"><span class="built_in">exit</span></div></pre></td></tr></table></figure></p>
<figure class="highlight sh"><figcaption><span>us-west</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> -it ceph bash</div><div class="line">ceph osd pool create .us-west.rgw.root 16 16</div><div class="line">ceph osd pool create .us-west.rgw.control 16 16</div><div class="line">ceph osd pool create .us-west.rgw.gc 16 16</div><div class="line">ceph osd pool create .us-west.rgw.buckets 512 512</div><div class="line">ceph osd pool create .us-west.rgw.buckets.index 32 32</div><div class="line">ceph osd pool create .us-west.rgw.buckets.extra 16 16</div><div class="line">ceph osd pool create .us-west.log 16 16</div><div class="line">ceph osd pool create .us-west.intent-log 16 16</div><div class="line">ceph osd pool create .us-west.usage 16 16</div><div class="line">ceph osd pool create .us-west.users 16 16</div><div class="line">ceph osd pool create .us-west.users.email 16 16</div><div class="line">ceph osd pool create .us-west.users.swift 16 16</div><div class="line">ceph osd pool create .us-west.users.uid 16 16</div><div class="line"><span class="built_in">exit</span></div></pre></td></tr></table></figure>
<p>两台虚拟机对应两个实例，接下来为这两个实例分别创建密钥环（keyring），用它生成网关的用户和密钥（key），增加密钥的rwx权限并让其有权限访问Ceph对象集群：<br><figure class="highlight sh"><figcaption><span>us-east</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sudo ceph auth del client.radosgw.gateway</div><div class="line">sudo ceph-authtool --create-keyring /etc/ceph/ceph.client.radosgw.keyring</div><div class="line">sudo chmod +r /etc/ceph/ceph.client.radosgw.keyring</div><div class="line">sudo ceph-authtool /etc/ceph/ceph.client.radosgw.keyring -n client.radosgw.us-east-1 --gen-key</div><div class="line">sudo ceph-authtool -n client.radosgw.us-east-1 --<span class="built_in">cap</span> osd <span class="string">'allow rwx'</span> --<span class="built_in">cap</span> mon <span class="string">'allow rw'</span> /etc/ceph/ceph.client.radosgw.keyring</div><div class="line">sudo ceph -k /etc/ceph/ceph.client.admin.keyring auth add client.radosgw.us-east-1 -i /etc/ceph/ceph.client.radosgw.keyring</div></pre></td></tr></table></figure></p>
<figure class="highlight sh"><figcaption><span>us-west</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sudo ceph auth del client.radosgw.gateway</div><div class="line">sudo ceph-authtool --create-keyring /etc/ceph/ceph.client.radosgw.keyring</div><div class="line">sudo chmod +r /etc/ceph/ceph.client.radosgw.keyring</div><div class="line">sudo ceph-authtool /etc/ceph/ceph.client.radosgw.keyring -n client.radosgw.us-west-1 --gen-key</div><div class="line">sudo ceph-authtool -n client.radosgw.us-west-1 --<span class="built_in">cap</span> osd <span class="string">'allow rwx'</span> --<span class="built_in">cap</span> mon <span class="string">'allow rw'</span> /etc/ceph/ceph.client.radosgw.keyring</div><div class="line">sudo ceph -k /etc/ceph/ceph.client.admin.keyring auth add client.radosgw.us-west-1 -i /etc/ceph/ceph.client.radosgw.keyring</div></pre></td></tr></table></figure>
<p>接下来创建一个apache2的配置文件，监听80端口并把请求转发到radosgw提供的FastCGI 9000端口（稍后将会配置）上：<br><figure class="highlight sh"><figcaption><span>us-east us-west</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">cat &lt;&lt; EOF &gt; rgw.conf</div><div class="line">FastCgiExternalServer /var/www/s3gw.fcgi -host localhost:9000</div><div class="line"></div><div class="line">&lt;VirtualHost *:80&gt;</div><div class="line">    ServerName localhost</div><div class="line">    ServerAlias *.localhost</div><div class="line">    ServerAdmin qinghua@ggg.com</div><div class="line">    DocumentRoot /var/www</div><div class="line">    RewriteEngine On</div><div class="line">    RewriteRule  ^/(.*) /s3gw.fcgi?%&#123;QUERY_STRING&#125; [E=HTTP_AUTHORIZATION:%&#123;HTTP:Authorization&#125;,L]</div><div class="line"></div><div class="line">    &lt;IfModule mod_fastcgi.c&gt;</div><div class="line">           &lt;Directory /var/www&gt;</div><div class="line">            Options +ExecCGI</div><div class="line">            AllowOverride All</div><div class="line">            SetHandler fastcgi-script</div><div class="line">            Order allow,deny</div><div class="line">            Allow from all</div><div class="line">            AuthBasicAuthoritative Off</div><div class="line">        &lt;/Directory&gt;</div><div class="line">    &lt;/IfModule&gt;</div><div class="line"></div><div class="line">    AllowEncodedSlashes On</div><div class="line">    ErrorLog /var/<span class="built_in">log</span>/apache2/error.log</div><div class="line">    CustomLog /var/<span class="built_in">log</span>/apache2/access.log combined</div><div class="line">    ServerSignature Off</div><div class="line">&lt;/VirtualHost&gt;</div><div class="line">EOF</div><div class="line"></div><div class="line">sudo mv rgw.conf /etc/apache2/conf-enabled/rgw.conf</div></pre></td></tr></table></figure></p>
<p>由于上述配置需要用到apache2默认未加载的<a href="http://httpd.apache.org/docs/current/mod/mod_rewrite.html" target="_blank" rel="external">rewrite模块</a>，所以需要加载并重新启动apache2：<br><figure class="highlight sh"><figcaption><span>us-east us-west</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo a2enmod rewrite</div><div class="line">sudo service apache2 restart</div></pre></td></tr></table></figure></p>
<p>FastCGI需要一个脚本来启用兼容S3的接口，同样也是所有虚拟机都要配，但是实例名略有区别：<br><figure class="highlight sh"><figcaption><span>us-east</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">cat &lt;&lt; EOF &gt; s3gw.fcgi</div><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line"><span class="built_in">exec</span> /usr/bin/radosgw -c /etc/ceph/ceph.conf -n client.radosgw.us-east-1</div><div class="line">EOF</div><div class="line"></div><div class="line">sudo mv s3gw.fcgi /var/www/s3gw.fcgi</div><div class="line">sudo chmod +x /var/www/s3gw.fcgi</div></pre></td></tr></table></figure></p>
<figure class="highlight sh"><figcaption><span>us-west</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">cat &lt;&lt; EOF &gt; s3gw.fcgi</div><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line"><span class="built_in">exec</span> /usr/bin/radosgw -c /etc/ceph/ceph.conf -n client.radosgw.us-west-1</div><div class="line">EOF</div><div class="line"></div><div class="line">sudo mv s3gw.fcgi /var/www/s3gw.fcgi</div><div class="line">sudo chmod +x /var/www/s3gw.fcgi</div></pre></td></tr></table></figure>
<p>现在到了在<code>ceph.conf</code>配置实例的时候了：<br><figure class="highlight sh"><figcaption><span>us-east</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">sudo sed -i <span class="string">'$a rgw region root pool = .us.rgw.root'</span> /etc/ceph/ceph.conf</div><div class="line">sudo sed -i <span class="string">'$a rgw zonegroup root pool = .us.rgw.root'</span> /etc/ceph/ceph.conf</div><div class="line">sudo sed -i $<span class="string">'$a \\\n'</span> /etc/ceph/ceph.conf</div><div class="line">sudo sed -i <span class="string">'$a [client.radosgw.us-east-1]'</span> /etc/ceph/ceph.conf</div><div class="line">sudo sed -i <span class="string">'$a rgw region = us'</span> /etc/ceph/ceph.conf</div><div class="line">sudo sed -i <span class="string">'$a rgw zone = us-east'</span> /etc/ceph/ceph.conf</div><div class="line">sudo sed -i <span class="string">'$a rgw zone root pool = .us-east.rgw.root'</span> /etc/ceph/ceph.conf</div><div class="line">sudo sed -i <span class="string">'$a rgw dns name = us-east'</span> /etc/ceph/ceph.conf</div><div class="line">sudo sed -i <span class="string">'$a host = us-east'</span> /etc/ceph/ceph.conf</div><div class="line">sudo sed -i <span class="string">'$a keyring = /etc/ceph/ceph.client.radosgw.keyring'</span> /etc/ceph/ceph.conf</div><div class="line">sudo sed -i <span class="string">'$a rgw socket path = ""'</span> /etc/ceph/ceph.conf</div><div class="line">sudo sed -i <span class="string">'$a log file = /var/log/radosgw/client.radosgw.us-east-1.log'</span> /etc/ceph/ceph.conf</div><div class="line">sudo sed -i <span class="string">'$a rgw frontends = fastcgi socket_port=9000 socket_host=0.0.0.0'</span> /etc/ceph/ceph.conf</div><div class="line">sudo sed -i <span class="string">'$a rgw print continue = false'</span> /etc/ceph/ceph.conf</div><div class="line">sudo sed -i $<span class="string">'$a \\\n'</span> /etc/ceph/ceph.conf</div></pre></td></tr></table></figure></p>
<figure class="highlight sh"><figcaption><span>us-west</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">sudo sed -i <span class="string">'$a rgw region root pool = .us.rgw.root'</span> /etc/ceph/ceph.conf</div><div class="line">sudo sed -i <span class="string">'$a rgw zonegroup root pool = .us.rgw.root'</span> /etc/ceph/ceph.conf</div><div class="line">sudo sed -i $<span class="string">'$a \\\n'</span> /etc/ceph/ceph.conf</div><div class="line">sudo sed -i <span class="string">'$a [client.radosgw.us-west-1]'</span> /etc/ceph/ceph.conf</div><div class="line">sudo sed -i <span class="string">'$a rgw region = us'</span> /etc/ceph/ceph.conf</div><div class="line">sudo sed -i <span class="string">'$a rgw zone = us-west'</span> /etc/ceph/ceph.conf</div><div class="line">sudo sed -i <span class="string">'$a rgw zone root pool = .us-west.rgw.root'</span> /etc/ceph/ceph.conf</div><div class="line">sudo sed -i <span class="string">'$a rgw dns name = us-west'</span> /etc/ceph/ceph.conf</div><div class="line">sudo sed -i <span class="string">'$a host = us-west'</span> /etc/ceph/ceph.conf</div><div class="line">sudo sed -i <span class="string">'$a keyring = /etc/ceph/ceph.client.radosgw.keyring'</span> /etc/ceph/ceph.conf</div><div class="line">sudo sed -i <span class="string">'$a rgw socket path = ""'</span> /etc/ceph/ceph.conf</div><div class="line">sudo sed -i <span class="string">'$a log file = /var/log/radosgw/client.radosgw.us-west-1.log'</span> /etc/ceph/ceph.conf</div><div class="line">sudo sed -i <span class="string">'$a rgw frontends = fastcgi socket_port=9000 socket_host=0.0.0.0'</span> /etc/ceph/ceph.conf</div><div class="line">sudo sed -i <span class="string">'$a rgw print continue = false'</span> /etc/ceph/ceph.conf</div></pre></td></tr></table></figure>
<p>配置参数及其作用可以在<a href="http://docs.ceph.com/docs/master/radosgw/config-ref/" target="_blank" rel="external">这里</a>查到，下面列出了一部分与辖区和域有关的参数：</p>
<ul>
<li><strong>rgw region root pool</strong>：v.67版本中指定辖区所使用的存储池</li>
<li><strong>rgw zonegroup root pool</strong>：Jewel版本中指定辖区所使用的存储池</li>
<li><strong>rgw region</strong>：指定该实例的辖区名</li>
<li><strong>rgw zone</strong>：指定该实例的域名</li>
<li><strong>rgw zone root pool</strong>：指定域所使用的存储池</li>
</ul>
<p>接下来在各自实例上生成一个相同的json格式的辖区文件：<br><figure class="highlight sh"><figcaption><span>us-east us-west</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> -it ceph bash</div><div class="line">cat &lt;&lt; EOF &gt; us.json</div><div class="line">&#123;</div><div class="line">  <span class="string">"name"</span>: <span class="string">"us"</span>,</div><div class="line">  <span class="string">"api_name"</span>: <span class="string">"us"</span>,</div><div class="line">  <span class="string">"is_master"</span>: <span class="string">"true"</span>,</div><div class="line">  <span class="string">"endpoints"</span>: [<span class="string">"http:\/\/192.168.33.15:80\/"</span>],</div><div class="line">  <span class="string">"master_zone"</span>: <span class="string">"us-east"</span>,</div><div class="line">  <span class="string">"zones"</span>: [</div><div class="line">    &#123;</div><div class="line">      <span class="string">"name"</span>: <span class="string">"us-east"</span>,</div><div class="line">      <span class="string">"endpoints"</span>: [<span class="string">"http:\/\/192.168.33.15:80\/"</span>],</div><div class="line">      <span class="string">"log_meta"</span>: <span class="string">"true"</span>,</div><div class="line">      <span class="string">"log_data"</span>: <span class="string">"true"</span></div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">      <span class="string">"name"</span>: <span class="string">"us-west"</span>,</div><div class="line">      <span class="string">"endpoints"</span>: [<span class="string">"http:\/\/192.168.33.16:80\/"</span>],</div><div class="line">      <span class="string">"log_meta"</span>: <span class="string">"true"</span>,</div><div class="line">      <span class="string">"log_data"</span>: <span class="string">"true"</span></div><div class="line">    &#125;</div><div class="line">  ],</div><div class="line">  <span class="string">"placement_targets"</span>: [</div><div class="line">   &#123;</div><div class="line">     <span class="string">"name"</span>: <span class="string">"default-placement"</span>,</div><div class="line">     <span class="string">"tags"</span>: []</div><div class="line">   &#125;</div><div class="line">  ],</div><div class="line">  <span class="string">"default_placement"</span>: <span class="string">"default-placement"</span></div><div class="line">&#125;</div><div class="line">EOF</div><div class="line"><span class="built_in">exit</span></div></pre></td></tr></table></figure></p>
<p>然后通过辖区文件生成us辖区并设置其为默认辖区：<br><figure class="highlight sh"><figcaption><span>us-east</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> -it ceph bash</div><div class="line">radosgw-admin region <span class="built_in">set</span> --infile us.json --name client.radosgw.us-east-1</div><div class="line">radosgw-admin region default --rgw-region=us --name client.radosgw.us-east-1</div><div class="line">radosgw-admin regionmap update --name client.radosgw.us-east-1</div><div class="line"><span class="built_in">exit</span></div></pre></td></tr></table></figure></p>
<figure class="highlight sh"><figcaption><span>us-west</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> -it ceph bash</div><div class="line">radosgw-admin region <span class="built_in">set</span> --infile us.json --name client.radosgw.us-west-1</div><div class="line">radosgw-admin region default --rgw-region=us --name client.radosgw.us-west-1</div><div class="line">radosgw-admin regionmap update --name client.radosgw.us-west-1</div><div class="line"><span class="built_in">exit</span></div></pre></td></tr></table></figure>
<p>辖区搞定之后，就轮到域啦。在各自实例上生成两个相同的json格式的域文件：<br><figure class="highlight sh"><figcaption><span>us-east us-west</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> -it ceph bash</div><div class="line">cat &lt;&lt; EOF &gt; us-east.json</div><div class="line">&#123;</div><div class="line">  <span class="string">"domain_root"</span>: <span class="string">".us-east.domain.rgw"</span>,</div><div class="line">  <span class="string">"control_pool"</span>: <span class="string">".us-east.rgw.control"</span>,</div><div class="line">  <span class="string">"gc_pool"</span>: <span class="string">".us-east.rgw.gc"</span>,</div><div class="line">  <span class="string">"log_pool"</span>: <span class="string">".us-east.log"</span>,</div><div class="line">  <span class="string">"intent_log_pool"</span>: <span class="string">".us-east.intent-log"</span>,</div><div class="line">  <span class="string">"usage_log_pool"</span>: <span class="string">".us-east.usage"</span>,</div><div class="line">  <span class="string">"user_keys_pool"</span>: <span class="string">".us-east.users"</span>,</div><div class="line">  <span class="string">"user_email_pool"</span>: <span class="string">".us-east.users.email"</span>,</div><div class="line">  <span class="string">"user_swift_pool"</span>: <span class="string">".us-east.users.swift"</span>,</div><div class="line">  <span class="string">"user_uid_pool"</span>: <span class="string">".us-east.users.uid"</span>,</div><div class="line">  <span class="string">"system_key"</span>: &#123;</div><div class="line">    <span class="string">"access_key"</span>: <span class="string">""</span>,</div><div class="line">    <span class="string">"secret_key"</span>: <span class="string">""</span></div><div class="line">  &#125;,</div><div class="line">  <span class="string">"placement_pools"</span>: [</div><div class="line">    &#123;</div><div class="line">      <span class="string">"key"</span>: <span class="string">"default-placement"</span>,</div><div class="line">      <span class="string">"val"</span>: &#123;</div><div class="line">        <span class="string">"index_pool"</span>: <span class="string">".us-east.rgw.buckets.index"</span>,</div><div class="line">        <span class="string">"data_pool"</span>: <span class="string">".us-east.rgw.buckets"</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;</div><div class="line">EOF</div><div class="line"></div><div class="line">sed <span class="string">'s/east/west/g'</span> us-east.json &gt; us-west.json</div><div class="line"><span class="built_in">exit</span></div></pre></td></tr></table></figure></p>
<p>然后通过域文件生成两个域并更新辖区图（region map）：<br><figure class="highlight sh"><figcaption><span>us-east</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> -it ceph bash</div><div class="line">radosgw-admin zone <span class="built_in">set</span> --rgw-zone=us-east --infile us-east.json --name client.radosgw.us-east-1</div><div class="line">radosgw-admin zone <span class="built_in">set</span> --rgw-zone=us-west --infile us-west.json --name client.radosgw.us-east-1</div><div class="line">radosgw-admin regionmap update --name client.radosgw.us-east-1</div><div class="line"><span class="built_in">exit</span></div></pre></td></tr></table></figure></p>
<figure class="highlight sh"><figcaption><span>us-west</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> -it ceph bash</div><div class="line">radosgw-admin zone <span class="built_in">set</span> --rgw-zone=us-east --infile us-east.json --name client.radosgw.us-west-1</div><div class="line">radosgw-admin zone <span class="built_in">set</span> --rgw-zone=us-west --infile us-west.json --name client.radosgw.us-west-1</div><div class="line">radosgw-admin regionmap update --name client.radosgw.us-west-1</div><div class="line"><span class="built_in">exit</span></div></pre></td></tr></table></figure>
<p>在<code>us-east-1</code>实例上，生成<code>us-east</code>的用户，并用生成的<code>access_key</code>和<code>secret_key</code>填充刚才为空的<code>us-east.json</code>文件，并将其复制到<code>us-west</code>虚拟机上：<br><figure class="highlight sh"><figcaption><span>us-east</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> -it ceph bash</div><div class="line">radosgw-admin user create --uid=<span class="string">"us-east"</span> --display-name=<span class="string">"Region-US Zone-East"</span> --name client.radosgw.us-east-1 --system | tee eastuser.txt</div><div class="line"><span class="built_in">export</span> SRC_ACCESS_KEY=`sed -n <span class="string">'s/ *"access_key": "\(.*\)",/\1/p'</span> eastuser.txt`</div><div class="line"><span class="built_in">export</span> SRC_SECRET_KEY=`sed -n <span class="string">'s/ *"secret_key": "\(.*\)"/\1/p'</span> eastuser.txt`</div><div class="line">sed -i <span class="string">"s/access_key\": \"/access_key\": \"<span class="variable">$SRC_ACCESS_KEY</span>/g"</span> us-east.json</div><div class="line">sed -i <span class="string">"s/secret_key\": \"/secret_key\": \"<span class="variable">$SRC_SECRET_KEY</span>/g"</span> us-east.json</div><div class="line"><span class="built_in">exit</span></div><div class="line"></div><div class="line">docker cp ceph:us-east.json us-east.json</div><div class="line">scp us-east.json vagrant@192.168.33.16:/home/vagrant    <span class="comment"># vagrant的密码也是vagrant</span></div></pre></td></tr></table></figure></p>
<p>在<code>us-west-1</code>实例上，生成<code>us-west</code>的用户，也用生成的<code>access_key</code>和<code>secret_key</code>填充刚才为空的<code>us-west.json</code>文件，并将其复制到<code>us-east</code>虚拟机上：<br><figure class="highlight sh"><figcaption><span>us-west</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> -it ceph bash</div><div class="line">radosgw-admin user create --uid=<span class="string">"us-west"</span> --display-name=<span class="string">"Region-US Zone-West"</span> --name client.radosgw.us-west-1 --system | tee westuser.txt</div><div class="line"><span class="built_in">export</span> DEST_ACCESS_KEY=`sed -n <span class="string">'s/ *"access_key": "\(.*\)",/\1/p'</span> westuser.txt`</div><div class="line"><span class="built_in">export</span> DEST_SECRET_KEY=`sed -n <span class="string">'s/ *"secret_key": "\(.*\)"/\1/p'</span> westuser.txt`</div><div class="line">sed -i <span class="string">"s/access_key\": \"/access_key\": \"<span class="variable">$DEST_ACCESS_KEY</span>/g"</span> us-west.json</div><div class="line">sed -i <span class="string">"s/secret_key\": \"/secret_key\": \"<span class="variable">$DEST_SECRET_KEY</span>/g"</span> us-west.json</div><div class="line"><span class="built_in">exit</span></div><div class="line"></div><div class="line">docker cp ceph:us-west.json us-west.json</div><div class="line">scp us-west.json vagrant@192.168.33.15:/home/vagrant    <span class="comment"># vagrant的密码也是vagrant</span></div></pre></td></tr></table></figure></p>
<p>现在两台虚拟机的用户主文件夹里都有对方的json文件，分别复制进ceph容器里：<br><figure class="highlight sh"><figcaption><span>us-east</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker cp us-west.json ceph:/us-west.json</div></pre></td></tr></table></figure></p>
<figure class="highlight sh"><figcaption><span>us-west</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker cp us-east.json ceph:/us-east.json</div></pre></td></tr></table></figure>
<p>接下来分别在两个实例里更新带了<code>access_key</code>和<code>secret_key</code>的各两个域：<br><figure class="highlight sh"><figcaption><span>us-east</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> ceph radosgw-admin zone <span class="built_in">set</span> --rgw-zone=us-east --infile us-east.json --name client.radosgw.us-east-1</div><div class="line">docker <span class="built_in">exec</span> ceph radosgw-admin zone <span class="built_in">set</span> --rgw-zone=us-west --infile us-west.json --name client.radosgw.us-east-1</div></pre></td></tr></table></figure></p>
<figure class="highlight sh"><figcaption><span>us-west</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> ceph radosgw-admin zone <span class="built_in">set</span> --rgw-zone=us-east --infile us-east.json --name client.radosgw.us-west-1</div><div class="line">docker <span class="built_in">exec</span> ceph radosgw-admin zone <span class="built_in">set</span> --rgw-zone=us-west --infile us-west.json --name client.radosgw.us-west-1</div></pre></td></tr></table></figure>
<p>都完成了以后，就可以重启ceph服务和apache2啦：<br><figure class="highlight sh"><figcaption><span>us-east us-west</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker restart ceph</div><div class="line">sudo /etc/init.d/radosgw start</div><div class="line">sudo service apache2 restart</div></pre></td></tr></table></figure></p>
<p>Apache2启动完成后，在浏览器打开<a href="http://192.168.33.15/" target="_blank" rel="external">http://192.168.33.15/</a>或<a href="http://192.168.33.16/" target="_blank" rel="external">http://192.168.33.16/</a>应该能看到下面的xml：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ListAllMyBucketsResult</span> <span class="attr">xmlns</span>=<span class="string">"http://s3.amazonaws.com/doc/2006-03-01/"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">Owner</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ID</span>&gt;</span>anonymous<span class="tag">&lt;/<span class="name">ID</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">DisplayName</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">Owner</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">Buckets</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ListAllMyBucketsResult</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>如果只看到了500的错误，等一会儿再刷新一次即可。如果遇到麻烦，可以这样调试：输入命令<code>sudo lsof -i :9000</code>看看是否radosgw启动了这个端口。如果没有，输入命令<code>ps -ef | grep radosgw</code>看看radosgw是否正常启动。若是正常启动，应该会有一个<code>/usr/bin/radosgw -n client.radosgw.us-east-1</code>的进程。若是没有正常启动，可以检查<code>/ect/ceph/ceph.conf</code>的内容，一般都是配置有问题。</p>
<p>搞定ceph和apache2后，在<code>us-east</code>里用python的boto库给<code>us-east-1</code>实例创建一个名为<code>my-new-bucket</code>的存储桶，并给<code>ggg</code>的key上传一句<strong>Hello world</strong>：<br><figure class="highlight sh"><figcaption><span>us-east</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> SRC_ACCESS_KEY=`sed -n <span class="string">'s/ *"access_key": "\(.*\)",/\1/p'</span> us-east.json`</div><div class="line"><span class="built_in">export</span> SRC_SECRET_KEY=`sed -n <span class="string">'s/ *"secret_key": "\(.*\)"/\1/p'</span> us-east.json`</div><div class="line"></div><div class="line">cat &lt;&lt; EOF &gt; s3test.py</div><div class="line">import boto</div><div class="line">import boto.s3</div><div class="line">import boto.s3.connection</div><div class="line">import os</div><div class="line">from boto.s3.key import Key</div><div class="line"></div><div class="line">access_key = os.environ[<span class="string">"SRC_ACCESS_KEY"</span>]</div><div class="line">secret_key = os.environ[<span class="string">"SRC_SECRET_KEY"</span>]</div><div class="line">conn = boto.connect_s3(</div><div class="line">  aws_access_key_id = access_key,</div><div class="line">  aws_secret_access_key = secret_key,</div><div class="line">  host = <span class="string">'192.168.33.15'</span>,</div><div class="line">  is_secure=False,</div><div class="line">  calling_format = boto.s3.connection.OrdinaryCallingFormat(),</div><div class="line">)</div><div class="line">bucket = conn.create_bucket(<span class="string">'my-new-bucket'</span>)</div><div class="line"></div><div class="line">k = Key(bucket)</div><div class="line">k.key = <span class="string">'ggg'</span></div><div class="line">k.set_contents_from_string(<span class="string">'Hello world'</span>)</div><div class="line"></div><div class="line"><span class="keyword">for</span> bucket <span class="keyword">in</span> conn.get_all_buckets():</div><div class="line">  <span class="built_in">print</span> <span class="string">"&#123;name&#125;\t&#123;created&#125;"</span>.format(</div><div class="line">    name = bucket.name,</div><div class="line">    created = bucket.creation_date,</div><div class="line">)</div><div class="line">EOF</div><div class="line"></div><div class="line">python s3test.py</div></pre></td></tr></table></figure></p>
<p>现在就该启动<code>radosgw-agent</code>来同步数据啦：<br><figure class="highlight sh"><figcaption><span>us-west</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> SRC_ACCESS_KEY=`sed -n <span class="string">'s/ *"access_key": "\(.*\)",/\1/p'</span> us-east.json`</div><div class="line"><span class="built_in">export</span> SRC_SECRET_KEY=`sed -n <span class="string">'s/ *"secret_key": "\(.*\)"/\1/p'</span> us-east.json`</div><div class="line"><span class="built_in">export</span> DEST_ACCESS_KEY=`sed -n <span class="string">'s/ *"access_key": "\(.*\)",/\1/p'</span> us-west.json`</div><div class="line"><span class="built_in">export</span> DEST_SECRET_KEY=`sed -n <span class="string">'s/ *"secret_key": "\(.*\)"/\1/p'</span> us-west.json`</div><div class="line"></div><div class="line">cat &lt;&lt; EOF &gt; cluster-data-sync.conf</div><div class="line">src_zone: us-east</div><div class="line"><span class="built_in">source</span>: http://192.168.33.15</div><div class="line">src_access_key: <span class="variable">$SRC_ACCESS_KEY</span></div><div class="line">src_secret_key: <span class="variable">$SRC_SECRET_KEY</span></div><div class="line">dest_zone: us-west</div><div class="line">destination: http://192.168.33.16</div><div class="line">dest_access_key: <span class="variable">$DEST_ACCESS_KEY</span></div><div class="line">dest_secret_key: <span class="variable">$DEST_SECRET_KEY</span></div><div class="line">log_file: /var/<span class="built_in">log</span>/radosgw/radosgw-sync-us-east-west.log</div><div class="line">EOF</div><div class="line"></div><div class="line">sudo radosgw-agent -c cluster-data-sync.conf</div></pre></td></tr></table></figure></p>
<p>再打开一个终端窗口，用以下命令查看<code>us-west-1</code>实例是不是已经把<code>my-new-bucket</code>同步过来啦：<br><figure class="highlight sh"><figcaption><span>us-west</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> ceph radosgw-admin metadata bucket list --name client.radosgw.us-west-1</div></pre></td></tr></table></figure></p>
<p>可能是由于单机<code>ceph/demo</code>容器的性能极差，在同步对象的时候基本上就一直停在<strong>INFO:radosgw_agent.worker:syncing bucket “my-new-bucket”</strong>上。如果有真实环境的ceph应该能够很快同步过来。如果同步成功，可以用以下命令来得到刚才的<strong>Hello world</strong>：<br><figure class="highlight sh"><figcaption><span>us-west</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">cat &lt;&lt; EOF &gt; s3download.py</div><div class="line">import boto</div><div class="line">import boto.s3</div><div class="line">import boto.s3.connection</div><div class="line">import os</div><div class="line">from boto.s3.key import Key</div><div class="line"></div><div class="line">access_key = os.environ[<span class="string">"SRC_ACCESS_KEY"</span>]</div><div class="line">secret_key = os.environ[<span class="string">"SRC_SECRET_KEY"</span>]</div><div class="line">conn = boto.connect_s3(</div><div class="line">  aws_access_key_id = access_key,</div><div class="line">  aws_secret_access_key = secret_key,</div><div class="line">  host = <span class="string">'192.168.33.16'</span>,</div><div class="line">  is_secure=False,</div><div class="line">  calling_format = boto.s3.connection.OrdinaryCallingFormat(),</div><div class="line">)</div><div class="line">bucket = conn.get_bucket(<span class="string">'my-new-bucket'</span>)</div><div class="line"></div><div class="line">key = bucket.get_key(<span class="string">'ggg'</span>)</div><div class="line"><span class="built_in">print</span> key.get_contents_as_string()</div><div class="line">EOF</div><div class="line"></div><div class="line">python s3download.py</div></pre></td></tr></table></figure></p>
<p>下面是一张同辖区同步示意图：<br><img src="http://docs.ceph.com/docs/master/_images/zone-sync.png" alt=""></p>
<h2 id="不同辖区的同步"><a href="#不同辖区的同步" class="headerlink" title="不同辖区的同步"></a>不同辖区的同步</h2><p>不同的辖区只能同步元数据而不能同步数据对象。接下来我们在eu-east上，尝试同步us-east的元数据。有了<a href="/ceph-radosgw-replication/#u76F8_u540C_u8F96_u533A_u7684_u540C_u6B65">相同辖区的同步</a>的经验，这回就不详细介绍下面的命令了：<br><figure class="highlight sh"><figcaption><span>eu-east</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line">docker run -d --net=host -v /etc/ceph:/etc/ceph -e MON_IP=192.168.33.17 -e CEPH_NETWORK=192.168.33.17/24 --name=ceph ceph/demo</div><div class="line"></div><div class="line"><span class="comment"># 创建存储池这一步也同上面一样是可选</span></div><div class="line">docker <span class="built_in">exec</span> -it ceph bash</div><div class="line">ceph osd pool create .eu-east.rgw.root 16 16</div><div class="line">ceph osd pool create .eu-east.rgw.control 16 16</div><div class="line">ceph osd pool create .eu-east.rgw.gc 16 16</div><div class="line">ceph osd pool create .eu-east.rgw.buckets 512 512</div><div class="line">ceph osd pool create .eu-east.rgw.buckets.index 32 32</div><div class="line">ceph osd pool create .eu-east.rgw.buckets.extra 16 16</div><div class="line">ceph osd pool create .eu-east.log 16 16</div><div class="line">ceph osd pool create .eu-east.intent-log 16 16</div><div class="line">ceph osd pool create .eu-east.usage 16 16</div><div class="line">ceph osd pool create .eu-east.users 16 16</div><div class="line">ceph osd pool create .eu-east.users.email 16 16</div><div class="line">ceph osd pool create .eu-east.users.swift 16 16</div><div class="line">ceph osd pool create .eu-east.users.uid 16 16</div><div class="line"><span class="built_in">exit</span></div><div class="line"></div><div class="line"><span class="comment"># 创建密钥环和网关用户</span></div><div class="line">sudo ceph auth del client.radosgw.gateway</div><div class="line">sudo ceph-authtool --create-keyring /etc/ceph/ceph.client.radosgw.keyring</div><div class="line">sudo chmod +r /etc/ceph/ceph.client.radosgw.keyring</div><div class="line">sudo ceph-authtool /etc/ceph/ceph.client.radosgw.keyring -n client.radosgw.eu-east-1 --gen-key</div><div class="line">sudo ceph-authtool -n client.radosgw.eu-east-1 --<span class="built_in">cap</span> osd <span class="string">'allow rwx'</span> --<span class="built_in">cap</span> mon <span class="string">'allow rw'</span> /etc/ceph/ceph.client.radosgw.keyring</div><div class="line">sudo ceph -k /etc/ceph/ceph.client.admin.keyring auth add client.radosgw.eu-east-1 -i /etc/ceph/ceph.client.radosgw.keyring</div><div class="line"></div><div class="line"><span class="comment"># 配置apache2</span></div><div class="line">cat &lt;&lt; EOF &gt; rgw.conf</div><div class="line">FastCgiExternalServer /var/www/s3gw.fcgi -host localhost:9000</div><div class="line"></div><div class="line">&lt;VirtualHost *:80&gt;</div><div class="line"></div><div class="line">    ServerName localhost</div><div class="line">    ServerAlias *.localhost</div><div class="line">    ServerAdmin qinghua@ggg.com</div><div class="line">    DocumentRoot /var/www</div><div class="line">    RewriteEngine On</div><div class="line">    RewriteRule  ^/(.*) /s3gw.fcgi?%&#123;QUERY_STRING&#125; [E=HTTP_AUTHORIZATION:%&#123;HTTP:Authorization&#125;,L]</div><div class="line"></div><div class="line">    &lt;IfModule mod_fastcgi.c&gt;</div><div class="line">           &lt;Directory /var/www&gt;</div><div class="line">            Options +ExecCGI</div><div class="line">            AllowOverride All</div><div class="line">            SetHandler fastcgi-script</div><div class="line">            Order allow,deny</div><div class="line">            Allow from all</div><div class="line">            AuthBasicAuthoritative Off</div><div class="line">        &lt;/Directory&gt;</div><div class="line">    &lt;/IfModule&gt;</div><div class="line"></div><div class="line">    AllowEncodedSlashes On</div><div class="line">    ErrorLog /var/<span class="built_in">log</span>/apache2/error.log</div><div class="line">    CustomLog /var/<span class="built_in">log</span>/apache2/access.log combined</div><div class="line">    ServerSignature Off</div><div class="line"></div><div class="line">&lt;/VirtualHost&gt;</div><div class="line">EOF</div><div class="line"></div><div class="line">sudo mv rgw.conf /etc/apache2/conf-enabled/rgw.conf</div><div class="line"></div><div class="line"><span class="comment"># 配置FastCGI</span></div><div class="line">cat &lt;&lt; EOF &gt; s3gw.fcgi</div><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line"><span class="built_in">exec</span> /usr/bin/radosgw -c /etc/ceph/ceph.conf -n client.radosgw.eu-east-1</div><div class="line">EOF</div><div class="line"></div><div class="line">sudo mv s3gw.fcgi /var/www/s3gw.fcgi</div><div class="line">sudo chmod +x /var/www/s3gw.fcgi</div><div class="line"></div><div class="line"><span class="comment"># 配置ceph</span></div><div class="line">sudo sed -i <span class="string">'$a rgw region root pool = .eu.rgw.root'</span> /etc/ceph/ceph.conf</div><div class="line">sudo sed -i <span class="string">'$a rgw zonegroup root pool = .eu.rgw.root'</span> /etc/ceph/ceph.conf</div><div class="line">sudo sed -i $<span class="string">'$a \\\n'</span> /etc/ceph/ceph.conf</div><div class="line">sudo sed -i <span class="string">'$a [client.radosgw.eu-east-1]'</span> /etc/ceph/ceph.conf</div><div class="line">sudo sed -i <span class="string">'$a rgw region = eu'</span> /etc/ceph/ceph.conf</div><div class="line">sudo sed -i <span class="string">'$a rgw zone = eu-east'</span> /etc/ceph/ceph.conf</div><div class="line">sudo sed -i <span class="string">'$a rgw zone root pool = .eu-east.rgw.root'</span> /etc/ceph/ceph.conf</div><div class="line">sudo sed -i <span class="string">'$a rgw dns name = eu-east'</span> /etc/ceph/ceph.conf</div><div class="line">sudo sed -i <span class="string">'$a host = eu-east'</span> /etc/ceph/ceph.conf</div><div class="line">sudo sed -i <span class="string">'$a keyring = /etc/ceph/ceph.client.radosgw.keyring'</span> /etc/ceph/ceph.conf</div><div class="line">sudo sed -i <span class="string">'$a rgw socket path = ""'</span> /etc/ceph/ceph.conf</div><div class="line">sudo sed -i <span class="string">'$a log file = /var/log/radosgw/client.radosgw.eu-east-1.log'</span> /etc/ceph/ceph.conf</div><div class="line">sudo sed -i <span class="string">'$a rgw frontends = fastcgi socket_port=9000 socket_host=0.0.0.0'</span> /etc/ceph/ceph.conf</div><div class="line">sudo sed -i <span class="string">'$a rgw print continue = false'</span> /etc/ceph/ceph.conf</div><div class="line">sudo sed -i $<span class="string">'$a \\\n'</span> /etc/ceph/ceph.conf</div></pre></td></tr></table></figure></p>
<p>接下来就是辖区和域的配置了。需要设置us的辖区和eu自己的辖区，否则会报错：<strong>AssertionError: No master zone found for region default</strong>。但是域只用设置eu自己的就好：<br><figure class="highlight sh"><figcaption><span>eu-east</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> -it ceph bash</div><div class="line"></div><div class="line">cat &lt;&lt; EOF &gt; us.json</div><div class="line">&#123;</div><div class="line">  <span class="string">"name"</span>: <span class="string">"us"</span>,</div><div class="line">  <span class="string">"api_name"</span>: <span class="string">"us"</span>,</div><div class="line">  <span class="string">"is_master"</span>: <span class="string">"true"</span>,</div><div class="line">  <span class="string">"endpoints"</span>: [<span class="string">"http:\/\/192.168.33.15:80\/"</span>],</div><div class="line">  <span class="string">"master_zone"</span>: <span class="string">"us-east"</span>,</div><div class="line">  <span class="string">"zones"</span>: [</div><div class="line">    &#123;</div><div class="line">      <span class="string">"name"</span>: <span class="string">"us-east"</span>,</div><div class="line">      <span class="string">"endpoints"</span>: [<span class="string">"http:\/\/192.168.33.15:80\/"</span>],</div><div class="line">      <span class="string">"log_meta"</span>: <span class="string">"true"</span>,</div><div class="line">      <span class="string">"log_data"</span>: <span class="string">"true"</span></div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">      <span class="string">"name"</span>: <span class="string">"us-west"</span>,</div><div class="line">      <span class="string">"endpoints"</span>: [<span class="string">"http:\/\/192.168.33.16:80\/"</span>],</div><div class="line">      <span class="string">"log_meta"</span>: <span class="string">"true"</span>,</div><div class="line">      <span class="string">"log_data"</span>: <span class="string">"true"</span></div><div class="line">    &#125;</div><div class="line">  ],</div><div class="line">  <span class="string">"placement_targets"</span>: [</div><div class="line">   &#123;</div><div class="line">     <span class="string">"name"</span>: <span class="string">"default-placement"</span>,</div><div class="line">     <span class="string">"tags"</span>: []</div><div class="line">   &#125;</div><div class="line">  ],</div><div class="line">  <span class="string">"default_placement"</span>: <span class="string">"default-placement"</span></div><div class="line">&#125;</div><div class="line">EOF</div><div class="line"></div><div class="line">cat &lt;&lt; EOF &gt; eu.json</div><div class="line">&#123;</div><div class="line">  <span class="string">"name"</span>: <span class="string">"eu"</span>,</div><div class="line">  <span class="string">"api_name"</span>: <span class="string">"eu"</span>,</div><div class="line">  <span class="string">"is_master"</span>: <span class="string">"false"</span>,</div><div class="line">  <span class="string">"endpoints"</span>: [<span class="string">"http:\/\/192.168.33.15:80\/"</span>],</div><div class="line">  <span class="string">"master_zone"</span>: <span class="string">"eu-east"</span>,</div><div class="line">  <span class="string">"zones"</span>: [</div><div class="line">    &#123;</div><div class="line">      <span class="string">"name"</span>: <span class="string">"eu-east"</span>,</div><div class="line">      <span class="string">"endpoints"</span>: [<span class="string">"http:\/\/192.168.33.17:80\/"</span>],</div><div class="line">      <span class="string">"log_meta"</span>: <span class="string">"true"</span>,</div><div class="line">      <span class="string">"log_data"</span>: <span class="string">"true"</span></div><div class="line">    &#125;</div><div class="line">  ],</div><div class="line">  <span class="string">"placement_targets"</span>: [</div><div class="line">   &#123;</div><div class="line">     <span class="string">"name"</span>: <span class="string">"default-placement"</span>,</div><div class="line">     <span class="string">"tags"</span>: []</div><div class="line">   &#125;</div><div class="line">  ],</div><div class="line">  <span class="string">"default_placement"</span>: <span class="string">"default-placement"</span></div><div class="line">&#125;</div><div class="line">EOF</div><div class="line"></div><div class="line"><span class="comment"># 设置辖区</span></div><div class="line">radosgw-admin region <span class="built_in">set</span> --infile us.json --name client.radosgw.eu-east-1</div><div class="line">radosgw-admin regionmap update --name client.radosgw.eu-east-1</div><div class="line"></div><div class="line">radosgw-admin region <span class="built_in">set</span> --infile eu.json --name client.radosgw.eu-east-1</div><div class="line">radosgw-admin region default --rgw-region=eu --name client.radosgw.eu-east-1</div><div class="line">radosgw-admin regionmap update --name client.radosgw.eu-east-1</div><div class="line"></div><div class="line">cat &lt;&lt; EOF &gt; eu-east.json</div><div class="line">&#123;</div><div class="line">  <span class="string">"domain_root"</span>: <span class="string">".eu-east.domain.rgw"</span>,</div><div class="line">  <span class="string">"control_pool"</span>: <span class="string">".eu-east.rgw.control"</span>,</div><div class="line">  <span class="string">"gc_pool"</span>: <span class="string">".eu-east.rgw.gc"</span>,</div><div class="line">  <span class="string">"log_pool"</span>: <span class="string">".eu-east.log"</span>,</div><div class="line">  <span class="string">"intent_log_pool"</span>: <span class="string">".eu-east.intent-log"</span>,</div><div class="line">  <span class="string">"usage_log_pool"</span>: <span class="string">".eu-east.usage"</span>,</div><div class="line">  <span class="string">"user_keys_pool"</span>: <span class="string">".eu-east.users"</span>,</div><div class="line">  <span class="string">"user_email_pool"</span>: <span class="string">".eu-east.users.email"</span>,</div><div class="line">  <span class="string">"user_swift_pool"</span>: <span class="string">".eu-east.users.swift"</span>,</div><div class="line">  <span class="string">"user_uid_pool"</span>: <span class="string">".eu-east.users.uid"</span>,</div><div class="line">  <span class="string">"system_key"</span>: &#123;</div><div class="line">    <span class="string">"access_key"</span>: <span class="string">""</span>,</div><div class="line">    <span class="string">"secret_key"</span>: <span class="string">""</span></div><div class="line">  &#125;,</div><div class="line">  <span class="string">"placement_pools"</span>: [</div><div class="line">    &#123;</div><div class="line">      <span class="string">"key"</span>: <span class="string">"default-placement"</span>,</div><div class="line">      <span class="string">"val"</span>: &#123;</div><div class="line">        <span class="string">"index_pool"</span>: <span class="string">".eu-east.rgw.buckets.index"</span>,</div><div class="line">        <span class="string">"data_pool"</span>: <span class="string">".eu-east.rgw.buckets"</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;</div><div class="line">EOF</div><div class="line"></div><div class="line"><span class="comment"># 设置域</span></div><div class="line">radosgw-admin zone <span class="built_in">set</span> --rgw-zone=eu-east --infile eu-east.json --name client.radosgw.eu-east-1</div><div class="line">radosgw-admin regionmap update --name client.radosgw.eu-east-1</div><div class="line"></div><div class="line"><span class="comment"># 创建用户</span></div><div class="line">radosgw-admin user create --uid=<span class="string">"eu-east"</span> --display-name=<span class="string">"Region-EU Zone-East"</span> --name client.radosgw.eu-east-1 --system | tee eastuser.txt</div><div class="line"><span class="built_in">export</span> SRC_ACCESS_KEY=`sed -n <span class="string">'s/ *"access_key": "\(.*\)",/\1/p'</span> eastuser.txt`</div><div class="line"><span class="built_in">export</span> SRC_SECRET_KEY=`sed -n <span class="string">'s/ *"secret_key": "\(.*\)"/\1/p'</span> eastuser.txt`</div><div class="line">sed -i <span class="string">"s/access_key\": \"/access_key\": \"<span class="variable">$SRC_ACCESS_KEY</span>/g"</span> eu-east.json</div><div class="line">sed -i <span class="string">"s/secret_key\": \"/secret_key\": \"<span class="variable">$SRC_SECRET_KEY</span>/g"</span> eu-east.json</div><div class="line"></div><div class="line">radosgw-admin zone <span class="built_in">set</span> --rgw-zone=eu-east --infile eu-east.json --name client.radosgw.eu-east-1</div><div class="line"></div><div class="line"><span class="built_in">exit</span></div></pre></td></tr></table></figure></p>
<p>都完成了以后，就可以重启ceph服务和apache2啦：<br><figure class="highlight sh"><figcaption><span>eu-east</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">docker restart ceph</div><div class="line">sudo /etc/init.d/radosgw start</div><div class="line">sudo a2enmod rewrite</div><div class="line">sudo service apache2 restart</div></pre></td></tr></table></figure></p>
<p>最后同步元数据：<br><figure class="highlight sh"><figcaption><span>eu-east</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">scp vagrant@192.168.33.15:/home/vagrant/us-east.json .    <span class="comment"># vagrant的密码也是vagrant</span></div><div class="line"></div><div class="line">docker cp ceph:eu-east.json eu-east.json</div><div class="line"><span class="built_in">export</span> SRC_ACCESS_KEY=`sed -n <span class="string">'s/ *"access_key": "\(.*\)",/\1/p'</span> us-east.json`</div><div class="line"><span class="built_in">export</span> SRC_SECRET_KEY=`sed -n <span class="string">'s/ *"secret_key": "\(.*\)"/\1/p'</span> us-east.json`</div><div class="line"><span class="built_in">export</span> DEST_ACCESS_KEY=`sed -n <span class="string">'s/ *"access_key": "\(.*\)",/\1/p'</span> eu-east.json`</div><div class="line"><span class="built_in">export</span> DEST_SECRET_KEY=`sed -n <span class="string">'s/ *"secret_key": "\(.*\)"/\1/p'</span> eu-east.json`</div><div class="line"></div><div class="line">cat &lt;&lt; EOF &gt; cluster-data-sync.conf</div><div class="line">src_zone: us-east</div><div class="line"><span class="built_in">source</span>: http://192.168.33.15</div><div class="line">src_access_key: <span class="variable">$SRC_ACCESS_KEY</span></div><div class="line">src_secret_key: <span class="variable">$SRC_SECRET_KEY</span></div><div class="line">dest_zone: eu-east</div><div class="line">destination: http://192.168.33.17</div><div class="line">dest_access_key: <span class="variable">$DEST_ACCESS_KEY</span></div><div class="line">dest_secret_key: <span class="variable">$DEST_SECRET_KEY</span></div><div class="line">log_file: /var/<span class="built_in">log</span>/radosgw/radosgw-sync-eu-east-west.log</div><div class="line">EOF</div><div class="line"></div><div class="line">sudo radosgw-agent -c cluster-data-sync.conf --metadata-only</div></pre></td></tr></table></figure></p>
<p>如果不加<code>--metadata-only</code>，则会报错：<strong>ERROR:root:data sync can only occur between zones in the same region</strong>。同步完成后，我们运行以下命令查看现在<code>eu-east-1</code>实例里的存储桶：<br><figure class="highlight sh"><figcaption><span>eu-east</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> ceph radosgw-admin metadata bucket list --name client.radosgw.eu-east-1</div></pre></td></tr></table></figure></p>
<p>应该能够看到先前在<code>us-east-1</code>创建的<code>my-new-bucket</code>。下面是一张不同辖区同步示意图：<br><img src="http://docs.ceph.com/docs/master/_images/region-sync.png" alt=""></p>
<h2 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h2><p>再介绍一些ceph的常见命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">rados lspools                                                <span class="comment"># 列出所有的存储池</span></div><div class="line">rados ls -p .rgw.root                                        <span class="comment"># 列出.rgw.root存储池的所有对象</span></div><div class="line">rados get zone_info.default obj.txt -p .rgw.root             <span class="comment"># 将.rgw.root存储池的zone_info.default对象内容保存到obj.txt文件</span></div><div class="line">rados rm region_info.default -p .us.rgw.root                 <span class="comment"># 删除.us.rgw.root存储池的region_info.default对象</span></div><div class="line">radosgw-admin region list --name client.radosgw.us-east-1    <span class="comment"># 列出client.radosgw.us-east-1实例的所有辖区</span></div><div class="line">radosgw-admin region get --name client.radosgw.us-east-1     <span class="comment"># 查看client.radosgw.us-east-1实例的主辖区</span></div><div class="line">radosgw-admin zone list --name client.radosgw.us-east-1      <span class="comment"># 列出client.radosgw.us-east-1实例的所有域</span></div><div class="line">radosgw-admin zone get --name client.radosgw.us-east-1       <span class="comment"># 查看client.radosgw.us-east-1实例的主域</span></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> devops </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ceph </tag>
            
            <tag> radosgw </tag>
            
            <tag> storage </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[光学字符识别软件tesseract-ocr]]></title>
      <url>/tesseract/</url>
      <content type="html"><![CDATA[<p><a href="https://github.com/tesseract-ocr/tesseract/wiki" target="_blank" rel="external">Tesseract</a>是一个可以将图片转换成文字的<a href="https://zh.wikipedia.org/wiki/%E5%85%89%E5%AD%A6%E5%AD%97%E7%AC%A6%E8%AF%86%E5%88%AB" target="_blank" rel="external">OCR</a>（Optical Character Recognition）软件，支持包括中文简繁体的<a href="https://github.com/tesseract-ocr/tesseract/blob/master/doc/tesseract.1.asc#languages" target="_blank" rel="external">多种语言</a>，简单易用，可以用来识别验证码。让我们来看一看吧。<br><a id="more"></a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Tesseract只是一个小应用程序，在mac里直接安装就好啦：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install tesseract</div></pre></td></tr></table></figure></p>
<p>下面是张包含了一些英文的图片：<br><img src="/img/test.png" alt=""></p>
<p>把图片保存到本地之后，使用以下命令将其转成文字：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tesseract ~/Downloads/test.png out</div><div class="line">cat out.txt</div></pre></td></tr></table></figure></p>
<p>可以看到，对于正常字体来说，粗体、斜体、大小字号等的识别率还是很不错的。如果是手写体的字体，识别率将会严重下降。</p>
<h2 id="中文"><a href="#中文" class="headerlink" title="中文"></a>中文</h2><p>Tesseract支持多种语言，不过除了英语以外，都必须先下载语言数据：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wget -c https://github.com/tesseract-ocr/tessdata/blob/master/chi_sim.traineddata?raw=<span class="literal">true</span></div><div class="line">mv chi_sim.traineddata\?raw\=<span class="literal">true</span> /usr/<span class="built_in">local</span>/Cellar/tesseract/3.04.00/share/tessdata/chi_sim.traineddata</div></pre></td></tr></table></figure></p>
<p>从后缀名traineddata可以看出来，tesseract是可以通过训练来提高识别率的。网上有许多教程，有兴趣的朋友可以自行尝试。下面是张包含了一些中文的图片：<br><img src="/img/testcn.png" alt=""></p>
<p>把图片保存到本地之后，使用以下命令将其转成文字：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">tesseract ~/Downloads/testcn.png out -l chi_sim</div><div class="line">cat out.txt</div><div class="line">tesseract ~/Downloads/testcn.png out -l eng+chi_sim</div><div class="line">cat out.txt</div></pre></td></tr></table></figure></p>
<p>毕竟汉字内容多，这回没有英文识别率那么高了，想要更加实用可能需要更多训练和校对。</p>
<h2 id="PDF"><a href="#PDF" class="headerlink" title="PDF"></a>PDF</h2><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>很简单，在<code>tesseract</code>命令的最后面加上<code>pdf</code>就好了：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tesseract ~/Downloads/test.png out pdf</div><div class="line">open out.pdf</div></pre></td></tr></table></figure></p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>虽然tesseract不能直接处理PDF，但是借助<a href="https://www.imagemagick.org/script/index.php" target="_blank" rel="external">ImageMagick</a>和<a href="http://www.ghostscript.com/" target="_blank" rel="external">Ghostscript</a>可以轻松地把PDF转换成图片文件：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">brew install imagemagick</div><div class="line">brew install ghostscript</div><div class="line">convert -density 100 -trim input.pdf output%04d.jpg</div></pre></td></tr></table></figure></p>
<p>这里的100表示DPI，<code>%04d</code>表示分页储存。有了图片之后就可以用tesseract随意操作啦。</p>
]]></content>
      
        <categories>
            
            <category> tool </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OCR </tag>
            
            <tag> tesseract </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[轻松搭建OpenStack Swift存储测试环境]]></title>
      <url>/openstack-swift/</url>
      <content type="html"><![CDATA[<p><a href="http://docs.openstack.org/developer/swift/" target="_blank" rel="external">Swift</a>（OpenStack Object Storage）是Rackspace开发的高可用分布式对象存储，贡献给了<a href="http://www.openstack.org/" target="_blank" rel="external">OpenStack</a>。上次在<a href="/ceph-radosgw">《通过RADOSGW提供ceph的S3和Swift接口》</a>一文里介绍了ceph RADOSGW的Swift接口，这次让我们直接来试试原生的swift吧！<br><a id="more"></a></p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>我们需要先安装<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="external">virtualBox</a>和<a href="https://www.vagrantup.com/downloads.html" target="_blank" rel="external">vagrant</a>。通过vagrant来驱动virtualBox搭建一个虚拟测试环境。首先在本地任意路径新建一个空文件夹比如<code>test</code>，运行以下命令：<br><figure class="highlight sh"><figcaption><span>virtual box host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mkdir <span class="built_in">test</span></div><div class="line"><span class="built_in">cd</span> <span class="built_in">test</span></div><div class="line">vagrant init minimum/ubuntu-trusty64-docker</div><div class="line">vi Vagrantfile</div></pre></td></tr></table></figure></p>
<p>里面应该有一句<code>config.vm.box = &quot;minimum/ubuntu-trusty64-docker&quot;</code>，在它的下面添加如下几行代码，相当于给它分配一台IP为<strong>192.168.33.17</strong>，内存为1G的虚拟机。<br><figure class="highlight ruby"><figcaption><span>Vagrantfile</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">config.vm.network <span class="string">"private_network"</span>, <span class="symbol">ip:</span> <span class="string">"192.168.33.17"</span></div><div class="line">config.vm.provider <span class="string">"virtualbox"</span> <span class="keyword">do</span> <span class="params">|v|</span></div><div class="line">  v.memory = <span class="number">1024</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p>这个vagrant镜像已经在ubuntu的基础上帮我们安装了docker，用起来很方便。然后终端运行以下命令启动并连接虚拟机。<br><figure class="highlight sh"><figcaption><span>virtual box host terminal</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vagrant up</div><div class="line">vagrant ssh</div></pre></td></tr></table></figure></p>
<h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p>这里参考了Swift的官方文档<a href="http://docs.openstack.org/developer/swift/development_saio.html" target="_blank" rel="external">Swift All In One</a>来搭建一个swift测试环境。首先需要安装各种依赖包：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update</div><div class="line">sudo apt-get -y install curl gcc memcached rsync sqlite3 xfsprogs \</div><div class="line">                        git-core libffi-dev python-setuptools \</div><div class="line">                        liberasurecode-dev</div><div class="line">sudo apt-get -y install python-coverage python-dev python-nose \</div><div class="line">                        python-xattr python-eventlet \</div><div class="line">                        python-greenlet python-pastedeploy \</div><div class="line">                        python-netifaces python-pip python-dnspython \</div><div class="line">                        python-mock</div><div class="line">sudo pip install --upgrade pip</div></pre></td></tr></table></figure></p>
<p>这里就不用<code>fdisk</code>而使用较简单的环回设备来当做我们的存储：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo mkdir /srv</div><div class="line">sudo truncate -s 1GB /srv/swift-disk</div><div class="line">sudo mkfs.xfs /srv/swift-disk</div><div class="line">sudo sh -c <span class="string">'echo "/srv/swift-disk /mnt/sdb1 xfs loop,noatime,nodiratime,nobarrier,logbufs=8 0 0" &gt;&gt; /etc/fstab'</span></div></pre></td></tr></table></figure></p>
<p>生成挂载点和link：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">sudo mkdir /mnt/sdb1</div><div class="line">sudo mount /mnt/sdb1</div><div class="line">sudo mkdir /mnt/sdb1/1 /mnt/sdb1/2 /mnt/sdb1/3 /mnt/sdb1/4</div><div class="line">sudo chown vagrant:vagrant /mnt/sdb1/*</div><div class="line"><span class="keyword">for</span> x <span class="keyword">in</span> &#123;1..4&#125;; <span class="keyword">do</span> sudo ln -s /mnt/sdb1/<span class="variable">$x</span> /srv/<span class="variable">$x</span>; <span class="keyword">done</span></div><div class="line">sudo mkdir -p /srv/1/node/sdb1 /srv/1/node/sdb5 \</div><div class="line">              /srv/2/node/sdb2 /srv/2/node/sdb6 \</div><div class="line">              /srv/3/node/sdb3 /srv/3/node/sdb7 \</div><div class="line">              /srv/4/node/sdb4 /srv/4/node/sdb8 \</div><div class="line">              /var/run/swift</div><div class="line">sudo chown -R vagrant:vagrant /var/run/swift</div><div class="line"><span class="keyword">for</span> x <span class="keyword">in</span> &#123;1..4&#125;; <span class="keyword">do</span> sudo chown -R vagrant:vagrant /srv/<span class="variable">$x</span>/; <span class="keyword">done</span></div></pre></td></tr></table></figure></p>
<p>在<code>rc.local</code>里增加几条创建文件夹和授权的命令，使之能够被开机执行：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo sed -i <span class="string">'$i mkdir -p /var/cache/swift /var/cache/swift2 /var/cache/swift3 /var/cache/swift4'</span> /etc/rc.local</div><div class="line">sudo sed -i <span class="string">'$i chown vagrant:vagrant /var/cache/swift*'</span> /etc/rc.local</div><div class="line">sudo sed -i <span class="string">'$i mkdir -p /var/run/swift'</span> /etc/rc.local</div><div class="line">sudo sed -i <span class="string">'$i chown vagrant:vagrant /var/run/swift'</span> /etc/rc.local</div></pre></td></tr></table></figure></p>
<p>接下来需要安装swift和它的客户端：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span>; git <span class="built_in">clone</span> https://github.com/openstack/python-swiftclient.git</div><div class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span>/python-swiftclient; git checkout 2.7.0; sudo python setup.py develop; <span class="built_in">cd</span> -</div><div class="line">git <span class="built_in">clone</span> https://github.com/openstack/swift.git</div><div class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span>/swift; git checkout 2.7.0</div><div class="line">sed -i <span class="string">"s/;python_version&lt;'3.0'//"</span> requirements.txt</div><div class="line">sed -i <span class="string">"/dnspython3&gt;=1.12.0;python_version&gt;='3.0'/d"</span> requirements.txt</div><div class="line">sudo pip install -r requirements.txt; sudo python setup.py develop; sudo pip install -r <span class="built_in">test</span>-requirements.txt</div></pre></td></tr></table></figure></p>
<p>然后需要配置rsync：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo cp <span class="variable">$HOME</span>/swift/doc/saio/rsyncd.conf /etc/</div><div class="line">sudo sed -i <span class="string">"s/&lt;your-user-name&gt;/vagrant/"</span> /etc/rsyncd.conf</div><div class="line">sudo sed -i <span class="string">"s/RSYNC_ENABLE=false/RSYNC_ENABLE=true/"</span> /etc/default/rsync</div><div class="line">sudo service rsync restart</div></pre></td></tr></table></figure></p>
<p>使用以下命令来验证rsync，应该能看到一堆的account、container和object：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rsync rsync://pub@localhost/</div></pre></td></tr></table></figure></p>
<p>我们前面已经安装了memcached，验证一下服务是可用的：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo service memcached status</div></pre></td></tr></table></figure></p>
<p>接下来需要配置各个节点：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span>/swift/doc; sudo cp -r saio/swift /etc/swift; <span class="built_in">cd</span> -</div><div class="line">sudo chown -R <span class="variable">$&#123;USER&#125;</span>:<span class="variable">$&#123;USER&#125;</span> /etc/swift</div><div class="line">find /etc/swift/ -name \*.conf | xargs sudo sed -i <span class="string">"s/&lt;your-user-name&gt;/<span class="variable">$&#123;USER&#125;</span>/"</span></div></pre></td></tr></table></figure></p>
<p>然后配置swift脚本，<code>/etc/swift/test.conf</code>为我们添加了三个测试账户：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">mkdir -p <span class="variable">$HOME</span>/bin</div><div class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span>/swift/doc; cp saio/bin/* <span class="variable">$HOME</span>/bin; <span class="built_in">cd</span> -</div><div class="line">chmod +x <span class="variable">$HOME</span>/bin/*</div><div class="line"><span class="built_in">echo</span> <span class="string">"export SAIO_BLOCK_DEVICE=/srv/swift-disk"</span> &gt;&gt; <span class="variable">$HOME</span>/.bashrc</div><div class="line">sed -i <span class="string">"/^find/d"</span> <span class="variable">$HOME</span>/bin/resetswift</div><div class="line">cp <span class="variable">$HOME</span>/swift/<span class="built_in">test</span>/sample.conf /etc/swift/test.conf</div><div class="line"><span class="built_in">echo</span> <span class="string">"export SWIFT_TEST_CONFIG_FILE=/etc/swift/test.conf"</span> &gt;&gt; <span class="variable">$HOME</span>/.bashrc</div><div class="line"><span class="built_in">echo</span> <span class="string">"export PATH=<span class="variable">$&#123;PATH&#125;</span>:<span class="variable">$HOME</span>/bin"</span> &gt;&gt; <span class="variable">$HOME</span>/.bashrc</div><div class="line">. <span class="variable">$HOME</span>/.bashrc</div></pre></td></tr></table></figure></p>
<p>Swift里有一个非常重要的概念，<a href="http://docs.openstack.org/developer/swift/overview_ring.html?highlight=ring" target="_blank" rel="external">ring</a>。通过它可以找到数据的物理位置。它的存储模型是这样的：一个账号（account）里可以有多个容器（container），容器里可以有许多个键值对，字典里的值称为对象（object）。账号和容器被存储在SQLite数据库里，而对象是以文件方式存储的。账号数据库、容器数据库和每个单独对象都有自己的ring。下面我们来构建一些ring：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">remakerings</div></pre></td></tr></table></figure></p>
<h2 id="启动环境"><a href="#启动环境" class="headerlink" title="启动环境"></a>启动环境</h2><p>现在我们就可以用<code>startmain</code>启动swift啦：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo sed -i <span class="string">'s/bind_ip = 127.0.0.1/bind_ip = 192.168.33.17/'</span> /etc/swift/proxy-server.conf</div><div class="line">startmain</div></pre></td></tr></table></figure></p>
<p>然后用<code>test:tester/testing</code>这个预先创建好的测试账户登录：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">curl -i -H <span class="string">'X-Storage-User: test:tester'</span> -H <span class="string">'X-Storage-Pass: testing'</span> http://192.168.33.17:8080/auth/v1.0 | tee auth.txt</div><div class="line">sudo apt-get -y install dos2unix</div><div class="line">dos2unix auth.txt</div><div class="line"><span class="built_in">export</span> X_AUTH_TOKEN=`cat auth.txt | sed -n <span class="string">'s/X-Auth-Token: \(.*\)/\1/p'</span>`</div><div class="line"><span class="built_in">export</span> X_STORAGE_URL=`cat auth.txt | sed -n <span class="string">'s/X-Storage-Url: \(.*\)/\1/p'</span>`</div><div class="line">curl -v -H <span class="string">"X-Auth-Token: <span class="variable">$X_AUTH_TOKEN</span>"</span> <span class="variable">$X_STORAGE_URL</span></div></pre></td></tr></table></figure></p>
<p>上面用到<code>dos2unix</code>是因为取到的<code>X-Storage-Url</code>最后面带着<code>^M$</code>的特殊字符。直接管道的话，下一个<code>curl</code>会报错：<code>Illegal characters found in URL</code>。可以保存成文件之后使用<code>cat -A</code>来查看这些特殊字符。<br>登录完成后，就能看到swift的状态和所有容器啦：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">swift -A http://192.168.33.17:8080/auth/v1.0 -U <span class="built_in">test</span>:tester -K testing <span class="built_in">stat</span></div><div class="line">swift -A http://192.168.33.17:8080/auth/v1.0 -U <span class="built_in">test</span>:tester -K testing list</div></pre></td></tr></table></figure></p>
<h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><h3 id="Swift测试"><a href="#Swift测试" class="headerlink" title="Swift测试"></a>Swift测试</h3><p>有兴趣的话，还可以运行下面的单元测试、功能测试和探索性测试：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$HOME</span>/swift/.unittests</div><div class="line"><span class="variable">$HOME</span>/swift/.functests</div><div class="line"><span class="variable">$HOME</span>/swift/.probetests</div></pre></td></tr></table></figure></p>
<h3 id="Docker-Registry测试"><a href="#Docker-Registry测试" class="headerlink" title="Docker Registry测试"></a>Docker Registry测试</h3><p>在Docker Registry的<code>config.yml</code>里使用以下配置：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="attr">storage:</span></div><div class="line"><span class="attr">  swift:</span></div><div class="line"><span class="attr">    username:</span> <span class="attr">test:tester</span> </div><div class="line"><span class="attr">    password:</span> <span class="string">testing</span> </div><div class="line"><span class="attr">    authurl:</span> <span class="attr">http://192.168.33.17:8080/auth/v1.0</span></div><div class="line"><span class="attr">    container:</span> <span class="string">swift</span></div></pre></td></tr></table></figure></p>
<p>可以测试<code>docker push</code>啦。不过记得需要先登录用户哦。</p>
]]></content>
      
        <categories>
            
            <category> devops </category>
            
        </categories>
        
        
        <tags>
            
            <tag> storage </tag>
            
            <tag> openstack swift </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用RADOSGW提供ceph的S3和Swift接口]]></title>
      <url>/ceph-radosgw/</url>
      <content type="html"><![CDATA[<p><a href="http://ceph.com/" target="_blank" rel="external">Ceph</a>是一个高性能的PB级分布式文件系统。它能够在一个系统中提供对象存储、块存储和文件存储。对如何加载使用这些存储感兴趣的话可以参考<a href="/ceph-demo">《用容器轻松搭建ceph实验环境》</a>。它还可以通过RADOSGW来实现S3和OpenStack Swift存储接口。不管RADOSGW还是块存储或文件存储都是基于对象存储来提供服务。本文的主要内容是如何通过RADOSGW来暴露S3和SWIFT接口。由于Docker Registry在2.4版本<a href="https://github.com/docker/distribution/commit/5967d333425a8dd5d36c5bb456098839654d38af" target="_blank" rel="external">移除了对rados的支持</a>，所以如果使用ceph作为后端存储就需要利用RADOSGW了。<br><a id="more"></a></p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>我们需要先安装<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="external">virtualBox</a>和<a href="https://www.vagrantup.com/downloads.html" target="_blank" rel="external">vagrant</a>。通过vagrant来驱动virtualBox搭建一个虚拟测试环境。首先在本地任意路径新建一个空文件夹比如<code>test</code>，运行以下命令：<br><figure class="highlight sh"><figcaption><span>virtual box host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mkdir <span class="built_in">test</span></div><div class="line"><span class="built_in">cd</span> <span class="built_in">test</span></div><div class="line">vagrant init minimum/ubuntu-trusty64-docker</div><div class="line">vi Vagrantfile</div></pre></td></tr></table></figure></p>
<p>里面应该有一句<code>config.vm.box = &quot;minimum/ubuntu-trusty64-docker&quot;</code>，在它的下面添加如下几行代码，相当于给它分配一台IP为<strong>192.168.33.111</strong>，内存为1G的虚拟机。<br><figure class="highlight ruby"><figcaption><span>Vagrantfile</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">config.vm.network <span class="string">"private_network"</span>, <span class="symbol">ip:</span> <span class="string">"192.168.33.111"</span></div><div class="line">config.vm.provider <span class="string">"virtualbox"</span> <span class="keyword">do</span> <span class="params">|v|</span></div><div class="line">  v.memory = <span class="number">1024</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p>这个vagrant镜像已经在ubuntu的基础上帮我们安装了docker，用起来很方便。然后终端运行以下命令启动并连接虚拟机。<br><figure class="highlight sh"><figcaption><span>virtual box host terminal</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vagrant up</div><div class="line">vagrant ssh</div></pre></td></tr></table></figure></p>
<h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p>首先需要安装一些ceph、radosgw的依赖包，还有python-boto、swift客户端等工具可以用于测试。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update</div><div class="line">sudo apt-get -y --force-yes install ceph-common radosgw python-boto</div><div class="line">sudo pip install --upgrade setuptools</div><div class="line">sudo pip install --upgrade python-swiftclient</div></pre></td></tr></table></figure></p>
<p>然后就可以启动ceph/demo这个容器来轻松提供ceph服务了：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d --net=host -v /etc/ceph:/etc/ceph -e MON_IP=192.168.33.111 -e CEPH_NETWORK=192.168.33.111/24 --name=ceph ceph/demo</div></pre></td></tr></table></figure></p>
<p>接下来的步骤主要参考的是有一点坑的<a href="http://docs.ceph.com/docs/master/radosgw/config/" target="_blank" rel="external">官方教程</a>。需要为radosgw生成一个名为<code>gateway</code>的用户：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo ceph auth del client.radosgw.gateway</div><div class="line">sudo ceph auth get-or-create client.radosgw.gateway osd <span class="string">'allow rwx'</span> mon <span class="string">'allow rwx'</span> -o /etc/ceph/ceph.client.radosgw.keyring</div></pre></td></tr></table></figure></p>
<p>然后需要把这个用户加到<code>ceph.conf</code>配置里，提供端口为9000的<a href="https://en.wikipedia.org/wiki/FastCGI" target="_blank" rel="external">FastCGI</a>服务：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">sudo sed -i $<span class="string">'$a \\\n'</span> /etc/ceph/ceph.conf</div><div class="line">sudo sed -i <span class="string">'$a [client.radosgw.gateway]'</span> /etc/ceph/ceph.conf</div><div class="line">sudo sed -i <span class="string">'$a host = vagrant-ubuntu-trusty-64'</span> /etc/ceph/ceph.conf</div><div class="line">sudo sed -i <span class="string">'$a keyring = /etc/ceph/ceph.client.radosgw.keyring'</span> /etc/ceph/ceph.conf</div><div class="line">sudo sed -i <span class="string">'$a rgw socket path = ""'</span> /etc/ceph/ceph.conf</div><div class="line">sudo sed -i <span class="string">'$a log file = /var/log/radosgw/client.radosgw.gateway.log'</span> /etc/ceph/ceph.conf</div><div class="line">sudo sed -i <span class="string">'$a rgw frontends = fastcgi socket_port=9000 socket_host=0.0.0.0'</span> /etc/ceph/ceph.conf</div><div class="line">sudo sed -i <span class="string">'$a rgw print continue = false'</span> /etc/ceph/ceph.conf</div></pre></td></tr></table></figure></p>
<p>其中第二行的<code>vagrant-ubuntu-trusty-64</code>，必须使用<code>hostname -s</code>得出的结果。如果是按照<a href="/ceph-radosgw/#u51C6_u5907_u5DE5_u4F5C">准备工作</a>的做法，是不需要变的。另外<a href="https://segmentfault.com/q/1010000000256516" target="_blank" rel="external">这里</a>的第一个回答非常清晰地解释了CGI和FastCGI。<br>配置完成后就可以重启ceph容器并启动radosgw：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker restart ceph</div><div class="line">sudo /etc/init.d/radosgw start</div></pre></td></tr></table></figure></p>
<p>为了提供HTTP服务，需要安装apache2（Red Hat系是httpd）：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get -y --force-yes install apache2</div></pre></td></tr></table></figure></p>
<p>接下来创建一个apache2的配置文件，监听80端口并把请求转发到radosgw提供的FastCGI 9000端口上：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">cat &lt;&lt; EOF &gt; rgw.conf</div><div class="line">&lt;VirtualHost *:80&gt;</div><div class="line">ServerName localhost</div><div class="line">DocumentRoot /var/www/html</div><div class="line"></div><div class="line">ErrorLog /var/<span class="built_in">log</span>/apache2/rgw_error.log</div><div class="line">CustomLog /var/<span class="built_in">log</span>/apache2/rgw_access.log combined</div><div class="line"></div><div class="line"><span class="comment"># LogLevel debug</span></div><div class="line"></div><div class="line">RewriteEngine On</div><div class="line"></div><div class="line">RewriteRule .* - [E=HTTP_AUTHORIZATION:%&#123;HTTP:Authorization&#125;,L]</div><div class="line"></div><div class="line">SetEnv proxy-nokeepalive 1</div><div class="line"></div><div class="line">ProxyPass / fcgi://localhost:9000/</div><div class="line"></div><div class="line">&lt;/VirtualHost&gt;</div><div class="line">EOF</div><div class="line"></div><div class="line">sudo mv rgw.conf /etc/apache2/conf-enabled/rgw.conf</div></pre></td></tr></table></figure></p>
<p>由于上述配置需要用到一些apache2默认未加载的模块，所以需要加载并重新启动apache2：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo a2enmod rewrite</div><div class="line">sudo a2enmod proxy_http</div><div class="line">sudo a2enmod proxy_fcgi</div><div class="line">sudo service apache2 restart</div></pre></td></tr></table></figure></p>
<h2 id="测试服务"><a href="#测试服务" class="headerlink" title="测试服务"></a>测试服务</h2><h3 id="S3"><a href="#S3" class="headerlink" title="S3"></a>S3</h3><p>RADOSGW的基本配置已经完成，现在我们测试一下s3接口。它的存储模型是这样的：用户可以创建和管理多个<a href="http://docs.aws.amazon.com/zh_cn/AmazonS3/latest/dev/UsingBucket.html" target="_blank" rel="external">存储桶（bucket）</a>，每个存储桶里可以存放无限多个对象（object），每个对象是一个键值对。存储桶的名称与区域无关，全球唯一。</p>
<p>接下来先创建一个s3用户：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> ceph radosgw-admin user create --uid=<span class="string">"testuser"</span> --display-name=<span class="string">"First User"</span> | tee user.txt</div><div class="line"><span class="built_in">export</span> ACCESS_KEY=`sed -n <span class="string">'s/ *"access_key": "\(.*\)",/\1/p'</span> user.txt`</div><div class="line"><span class="built_in">export</span> SECRET_KEY=`sed -n <span class="string">'s/ *"secret_key": "\(.*\)"/\1/p'</span> user.txt`</div></pre></td></tr></table></figure></p>
<p>使用以下python代码来测试我们的s3接口是否已经可用：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">cat &lt;&lt; EOF &gt; s3test.py</div><div class="line">import boto</div><div class="line">import boto.s3.connection</div><div class="line">import os</div><div class="line"></div><div class="line">access_key = os.environ[<span class="string">"ACCESS_KEY"</span>]</div><div class="line">secret_key = os.environ[<span class="string">"SECRET_KEY"</span>]</div><div class="line">conn = boto.connect_s3(</div><div class="line">aws_access_key_id = access_key,</div><div class="line">aws_secret_access_key = secret_key,</div><div class="line">host = <span class="string">'192.168.33.111'</span>,</div><div class="line">is_secure=False,</div><div class="line">calling_format = boto.s3.connection.OrdinaryCallingFormat(),</div><div class="line">)</div><div class="line">bucket = conn.create_bucket(<span class="string">'my-new-bucket'</span>)</div><div class="line"><span class="keyword">for</span> bucket <span class="keyword">in</span> conn.get_all_buckets():</div><div class="line">    <span class="built_in">print</span> <span class="string">"&#123;name&#125;\t&#123;created&#125;"</span>.format(</div><div class="line">        name = bucket.name,</div><div class="line">        created = bucket.creation_date,</div><div class="line">)</div><div class="line">EOF</div><div class="line"></div><div class="line">python s3test.py</div></pre></td></tr></table></figure></p>
<p>如果显示了<code>my-new-bucket</code>，那就说明测试成功地通过s3接口创建了一个存储桶。可以使用以下命令来获取这个存储桶和实例的信息：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> ceph radosgw-admin metadata bucket list</div><div class="line">docker <span class="built_in">exec</span> ceph radosgw-admin metadata get bucket:my-new-bucket  | tee bucket.txt</div><div class="line"><span class="built_in">export</span> BUCKET_ID=`cat bucket.txt | sed -n <span class="string">'s/ *"bucket_id": "\(.*\)"/\1/p'</span>`</div><div class="line">docker <span class="built_in">exec</span> ceph radosgw-admin metadata get bucket.instance:my-new-bucket:<span class="variable">$BUCKET_ID</span></div></pre></td></tr></table></figure></p>
<p>还可以修改实例的信息并PUT回去，具体做法可参见<a href="http://blog.widodh.nl/2013/11/changing-the-region-of-a-rgw-bucket/" target="_blank" rel="external">《Changing the region of a RGW bucket》</a>。</p>
<h3 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h3><p>接下来测试swift。对于swift来说，它的存储模型是这样的：一个账号（account）里可以有多个容器（container），容器里可以有许多个键值对，字典里的值称为对象（object）。账号和容器被存储在SQLite数据库里，而对象是以文件方式存储的。</p>
<p>首先需要创建swift用户并生成secret：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> ceph radosgw-admin subuser create --uid=testuser --subuser=testuser:swift --access=full</div><div class="line">docker <span class="built_in">exec</span> ceph radosgw-admin key create --subuser=testuser:swift --key-type=swift --gen-secret | tee subuser.txt</div><div class="line"><span class="built_in">export</span> PASSWORD=`sed -n <span class="string">'/testuser:swift/&#123;N;p;&#125;'</span> subuser.txt | sed -n <span class="string">'s/ *"secret_key": "\(.*\)"/\1/p'</span>`</div></pre></td></tr></table></figure></p>
<p>然后就可以用以下命令查看swift里所有的容器：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">swift -A http://192.168.33.111/auth/v1.0 -U testuser:swift -K <span class="variable">$PASSWORD</span> list</div></pre></td></tr></table></figure></p>
<p>应该能看到刚才测试s3接口时创建的<code>my-new-bucket</code>，在这里s3的存储桶和swift的容器是同一个概念。接下来我们自己创建容器：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">swift -A http://192.168.33.111/auth/v1.0 -U testuser:swift -K <span class="variable">$PASSWORD</span> post qinghua</div><div class="line">swift -A http://192.168.33.111/auth/v1.0 -U testuser:swift -K <span class="variable">$PASSWORD</span> list qinghua</div></pre></td></tr></table></figure></p>
<p>创建成功，里面没有文件。现在可以上传、下载文件试试：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> Hello World &gt; hw.txt</div><div class="line">swift -A http://192.168.33.111/auth/v1.0 -U testuser:swift -K <span class="variable">$PASSWORD</span> upload qinghua hw.txt</div><div class="line">swift -A http://192.168.33.111/auth/v1.0 -U testuser:swift -K <span class="variable">$PASSWORD</span> list qinghua</div><div class="line">mv hw.txt hw.bak</div><div class="line">swift -A http://192.168.33.111/auth/v1.0 -U testuser:swift -K <span class="variable">$PASSWORD</span> download qinghua hw.txt</div><div class="line">cat hw.txt</div></pre></td></tr></table></figure></p>
<p>搞定！</p>
]]></content>
      
        <categories>
            
            <category> devops </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ceph </tag>
            
            <tag> radosgw </tag>
            
            <tag> storage </tag>
            
            <tag> s3 </tag>
            
            <tag> openstack swift </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用容器轻松搭建Rancher运行环境]]></title>
      <url>/rancher/</url>
      <content type="html"><![CDATA[<p><a href="http://rancher.com/" target="_blank" rel="external">Rancher</a>是开源的容器平台，功能齐全，部署简单，支持Kubernets和Docker Swarm。它把自己定位在持续交付流水线上的后半段上，如下图所示:<br><img src="/img/rancher-feature.png" alt=""></p>
<p>2016年3月底刚刚发布了1.0正式版。借着这个契机，下面就让我们用容器来部署一套Rancher环境试试它的功能吧！<br><a id="more"></a></p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>我们需要先安装<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="external">virtualBox</a>和<a href="https://www.vagrantup.com/downloads.html" target="_blank" rel="external">vagrant</a>。通过vagrant来驱动virtualBox搭建一个虚拟测试环境。首先在本地任意路径新建一个空文件夹比如<code>test</code>，运行以下命令：<br><figure class="highlight sh"><figcaption><span>virtual box host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mkdir <span class="built_in">test</span></div><div class="line"><span class="built_in">cd</span> <span class="built_in">test</span></div><div class="line">vagrant init minimum/ubuntu-trusty64-docker</div><div class="line">vi Vagrantfile</div></pre></td></tr></table></figure></p>
<p>里面应该有一句<code>config.vm.box = &quot;minimum/ubuntu-trusty64-docker&quot;</code>，在它的下面添加如下几行代码，相当于给它分配三台虚拟机，一台叫做<strong>server</strong>，它的IP是<strong>192.168.33.17</strong>；另两台分别是<strong>agent1</strong>和<strong>agent2</strong>，它们的IP是<strong>192.168.33.18</strong>和<strong>192.168.33.19</strong>。<br><figure class="highlight ruby"><figcaption><span>Vagrantfile</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">config.vm.define <span class="string">"server"</span> <span class="keyword">do</span> <span class="params">| host |</span></div><div class="line">  host.vm.hostname = <span class="string">"server"</span></div><div class="line">  host.vm.network <span class="string">"private_network"</span>, <span class="symbol">ip:</span> <span class="string">"192.168.33.17"</span></div><div class="line">  host.vm.provider <span class="string">"virtualbox"</span> <span class="keyword">do</span> <span class="params">|v|</span></div><div class="line">    v.memory = <span class="number">1024</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">config.vm.define <span class="string">"agent1"</span> <span class="keyword">do</span> <span class="params">| host |</span></div><div class="line">  host.vm.hostname = <span class="string">"agent1"</span></div><div class="line">  host.vm.network <span class="string">"private_network"</span>, <span class="symbol">ip:</span> <span class="string">"192.168.33.18"</span></div><div class="line">  host.vm.provider <span class="string">"virtualbox"</span> <span class="keyword">do</span> <span class="params">|v|</span></div><div class="line">    v.memory = <span class="number">1024</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">config.vm.define <span class="string">"agent2"</span> <span class="keyword">do</span> <span class="params">| host |</span></div><div class="line">  host.vm.hostname = <span class="string">"agent2"</span></div><div class="line">  host.vm.network <span class="string">"private_network"</span>, <span class="symbol">ip:</span> <span class="string">"192.168.33.19"</span></div><div class="line">  host.vm.provider <span class="string">"virtualbox"</span> <span class="keyword">do</span> <span class="params">|v|</span></div><div class="line">    v.memory = <span class="number">1024</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p>这个vagrant镜像已经在ubuntu的基础上帮我们安装了docker，用起来很方便。然后分别在三个终端运行以下命令启动并连接三台虚拟机。<br><figure class="highlight sh"><figcaption><span>virtual box host terminal 1</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vagrant up</div><div class="line">vagrant ssh server</div></pre></td></tr></table></figure></p>
<figure class="highlight sh"><figcaption><span>virtual box host terminal 2</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vagrant ssh agent1</div></pre></td></tr></table></figure>
<figure class="highlight sh"><figcaption><span>virtual box host terminal 3</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vagrant ssh agent2</div></pre></td></tr></table></figure>
<p>如果想要在接下来的步骤中获得良好体验，建议先下载以下镜像：<br><figure class="highlight sh"><figcaption><span>server agent1 agent2</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">docker pull rancher/server:v1.0.0</div><div class="line">docker pull rancher/agent:v0.11.0</div><div class="line">docker pull rancher/agent-instance:v0.8.1</div><div class="line">docker pull tomcat:8.0.30-jre8</div><div class="line">docker pull busybox:1.24.1</div><div class="line">docker pull mysql:5.7.10</div><div class="line">docker pull wordpress:4.4.2</div><div class="line">docker pull rancher/etcd:v2.3.0</div></pre></td></tr></table></figure></p>
<h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p>启动Rancher服务器相当简单，一条命令而已：<br><figure class="highlight sh"><figcaption><span>server</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">docker run -d \</div><div class="line">    --name=rs \</div><div class="line">    --restart=always \</div><div class="line">    -p 8080:8080 \</div><div class="line">    rancher/server:v1.0.0</div></pre></td></tr></table></figure></p>
<p>稍待片刻，就可以访问Rancher主页<a href="http://192.168.33.17:8080" target="_blank" rel="external">http://192.168.33.17:8080</a>了：<br><img src="/img/rancher-applications.jpg" alt=""></p>
<p>不像其他的web应用一开始没有数据时都是显示一片空白，Rancher展示了非常丰富的信息来帮助我们尽快上手。菜单上的<strong>ADMIN</strong>有个红色的感叹号，这是因为我们刚启动服务器，还没有配置认证信息。点击这个感叹号就可以开始配置，除了本地设置用户名密码以外，还支持与AD、GitHub和LDAP的集成。这里我们更加关注容器管理部分，对鉴权有兴趣的朋友可以自行尝试认证信息的配置。点击菜单上的<strong>INFRASTRUCTURE</strong>并点击<strong>Add Host</strong>按钮，可以增加一个agent host。由于现在我们用的是内部IP<strong>192.168.33.17</strong>，Rancher会提示我们是否真的连接到这里，不用管它直接点击<strong>Save</strong>按钮就可以了。复制下一个页面中第5步的命令，在agent上1运行即可。在我的虚拟机上是这样子的：<br><figure class="highlight sh"><figcaption><span>agent1</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo docker run -d --privileged -v /var/run/docker.sock:/var/run/docker.sock -v /var/lib/rancher:/var/lib/rancher rancher/agent:v0.11.0 http://192.168.33.17:8080/v1/scripts/B9EAC6780C8126FB739E:1460016000000:Adj9D4Qp3smSmIscdUVT0JSCPdM</div></pre></td></tr></table></figure></p>
<p>然后就可以点击<strong>Close</strong>，稍待片刻，就能看到agent1已经被加入到Hosts里了：<br><img src="/img/rancher-infrastructure.jpg" alt=""></p>
<p>在agent2上重复执行一遍命令，把agent2也加入到Hosts里。Rancher的server和agent都是设置为<code>restart=true</code>的，所以重启虚拟机之类的行为也不会影响Rancher正常工作。现在看到的Hosts应该是这样的：<br><img src="/img/rancher-hosts.jpg" alt=""></p>
<h2 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h2><p>接下来运行一个tomcat容器试试。点击agent1上的<strong>Add Container</strong>按钮，如下填入参数：</p>
<ul>
<li><strong>Name</strong>：tomcat</li>
<li><strong>Select Image</strong>：tomcat:8.0.30-jre8</li>
<li><strong>Public (on Host) IP/Port</strong>：8080</li>
<li><strong>Private (in Container) Port</strong>：8080</li>
</ul>
<p>然后点击最下方的<strong>Create</strong>按钮：<br><img src="/img/rancher-add-container.jpg" alt=""></p>
<p>过一段时间，便能看到如下的容器已经启动完成了：<br><img src="/img/rancher-standalone-container.jpg" alt=""></p>
<p>之所以需要等一段时间，是因为它像kubernetes一样，需要给容器配一个网络代理Network Agent，不过功能要复杂得多，拥有跨网络通信、健康检查等功能。当前版本下使用的网络代理镜像为<code>rancher/agent-instance:v0.8.1</code>。在agent1上运行<code>docker ps</code>便能看到这两个容器。还可以通过<a href="http://192.168.33.18:8080" target="_blank" rel="external">http://192.168.33.18:8080</a>来访问tomcat服务。在页面上点击某个容器比如tomcat，可以看到容器的基本信息和一些基本监控数据。如图：<br><img src="/img/rancher-tomcat-container.jpg" alt=""></p>
<p>自行启动的容器也能被Rancher监控到。我们来启动一个小容器：<br><figure class="highlight sh"><figcaption><span>agent1</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d --name=bb busybox:1.24.1 sleep 3600</div></pre></td></tr></table></figure></p>
<p>在界面上便能看到这个bb容器已经启动完成了：<br><img src="/img/rancher-self-container.jpg" alt=""></p>
<p>通过Rancher启动的容器IP是在<code>10.42.*.*</code>区间的，自行启动的bb容器的IP是在它之外的。如果想用相同IP段，可以使用以下命令：<br><figure class="highlight sh"><figcaption><span>agent1</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d --name=bb2 --label io.rancher.container.network=<span class="literal">true</span> busybox:1.24.1 sleep 3600</div></pre></td></tr></table></figure></p>
<p>在界面上可以看到bb2容器的IP已经落入区间了：<br><img src="/img/rancher-self-container2.jpg" alt=""></p>
<h2 id="运行应用"><a href="#运行应用" class="headerlink" title="运行应用"></a>运行应用</h2><p>上面我们在指定的虚拟机上创建容器。不过对于一个真实的网络应用，我们并不关心它运行在哪里，只关心服务地址罢了。下面我们来创建一个这样的WordPress应用。它包含一个MySQL数据库，两个WordPress实例和一套负载均衡。首先点击<strong>APPLICATIONS</strong>，然后点击Default的<strong>Add Service</strong>。填入：</p>
<ul>
<li><strong>Name</strong>：database</li>
<li><strong>Select Image</strong>：mysql:5.7.10</li>
<li><strong>Always pull image before creating</strong>：false</li>
<li><strong>Environment Vars</strong>：MYSQL_ROOT_PASSWORD=pass1</li>
</ul>
<p>然后点击<strong>Create</strong>来创建这个MySQL服务。接下来是WordPress，还是像MySQL那样新建服务。填入：</p>
<ul>
<li><strong>Scale</strong>：2</li>
<li><strong>Name</strong>：mywordpress</li>
<li><strong>Select Image</strong>：wordpress:4.4.2</li>
<li><strong>Always pull image before creating</strong>：false</li>
<li><strong>Service Links</strong>：database &gt; mysql</li>
</ul>
<p>然后点击<strong>Create</strong>来创建这个WordPress服务。最后是负载均衡，点击<strong>Add Service</strong>旁边的向下箭头，选择<strong>Add Load Balancer</strong>。填入：</p>
<ul>
<li><strong>Scale</strong>：Always run one instance of this container on every host</li>
<li><strong>Name</strong>：wordpresslb</li>
<li><strong>Source IP/Port</strong>：80</li>
<li><strong>Default Target Port</strong>：80</li>
<li><strong>Target Service</strong>：mywordpress</li>
</ul>
<p>点击<strong>Save</strong>来创建这个负载均衡。稍待片刻，就可以看到wordpresslb变为Active状态了，然后就可以访问<a href="http://192.168.33.18" target="_blank" rel="external">http://192.168.33.18</a>或<a href="http://192.168.33.19" target="_blank" rel="external">http://192.168.33.19</a>来使用WordPress服务了：<br><img src="/img/wordpress.jpg" alt=""></p>
<p>Rancher负载均衡使用和网络代理一样的<code>rancher/agent-instance</code>镜像。它内置了HAProxy，默认使用轮询。</p>
<h2 id="预置模板"><a href="#预置模板" class="headerlink" title="预置模板"></a>预置模板</h2><p>点击<strong>CATALOG</strong>，便能看到Rancher为我们预置了一系列的应用模板。我们用个小镜像Etcd试试。首先找到Etcd的图标：<br><img src="/img/rancher-etcd.jpg" alt=""></p>
<p>点击<strong>View Details</strong>进入etcd详细页面，滚动到最下方。由于我们只有两个agent，在<strong>Number of Nodes</strong>里填入1，然后点击<strong>Launch</strong>按钮。很快，一个etcd服务就启动起来了。按如下参数给这个服务增加一套负载均衡：</p>
<ul>
<li><strong>Scale</strong>：Always run one instance of this container on every host</li>
<li><strong>Name</strong>：etcdlb</li>
<li><strong>Source IP/Port</strong>：2379</li>
<li><strong>Protocol</strong>：tcp</li>
<li><strong>Default Target Port</strong>：2379</li>
<li><strong>Target Service</strong>：etcd</li>
</ul>
<p>还可以点击<strong>Preview</strong>来查看<code>docker-compose.yml</code>和<code>rancher-compose.yml</code>文件，里面也有比较详细的注释。<code>docker-compose.yml</code>不必多说，<code>rancher-compose.yml</code>类似于它但更小一些。可以在任何Rancher页面的右下方点击<strong>Download CLI</strong>来下载rancher compose命令行工具，这样就可以通过命令行而非在网页上点来点去来管理容器和服务了。最后点击<strong>Save</strong>并等待负载均衡启动完成，就可以访问啦：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">curl -L http://192.168.33.18:2379/version</div><div class="line">curl -L http://192.168.33.19:2379/version</div></pre></td></tr></table></figure></p>
<p>太方便了，简直是爽得不能不能的。最后送上全家福大图一张：<br><img src="/img/rancher-applications-stack.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> devops </category>
            
        </categories>
        
        
        <tags>
            
            <tag> rancher </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mac上的git图形工具GitUp]]></title>
      <url>/gitup/</url>
      <content type="html"><![CDATA[<p>已经11岁的<a href="https://git-scm.com/" target="_blank" rel="external">Git</a>现在应该算是最流行的版本管理系统了。不过它的上手过程略令人感伤：为什么要用<code>git reset HEAD</code>而不是<code>git unadd/unstage</code>？Mac的朋友们有福了，<a href="http://gitup.co/" target="_blank" rel="external">GitUp</a>来拯救懒程序员们啦。它提供了一个简约而不简单的界面，让我们可以凭直觉轻松地打出git组合拳来处理各种状况。在2016年4月的<a href="https://www.thoughtworks.com/radar/tools/gitup" target="_blank" rel="external">ThoughtWorks技术雷达</a>上，它处于试验阶段，也就是值得追求，建议尝试。让我们来看看它有什么能力吧。<br><a id="more"></a></p>
<h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><p>GitUp只是一个小应用程序，下载下来就能用啦：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mkdir gitup</div><div class="line"><span class="built_in">cd</span> gitup</div><div class="line">wget -c https://s3-us-west-2.amazonaws.com/gitup-builds/stable/GitUp.zip</div><div class="line">unzip GitUp.zip</div><div class="line">open GitUp.app</div></pre></td></tr></table></figure></p>
<p>打开GitUp就能看见下面的界面：<br><img src="/img/gitup-welcome.jpg" alt=""></p>
<p>然后我们新建一个git repo：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">mkdir <span class="built_in">test</span></div><div class="line"><span class="built_in">cd</span> <span class="built_in">test</span></div><div class="line">git init</div><div class="line"></div><div class="line"><span class="built_in">echo</span> a &gt; a.txt</div><div class="line"><span class="built_in">echo</span> b &gt; b.txt</div><div class="line"><span class="built_in">echo</span> c &gt; c.txt</div><div class="line">git add a.txt</div><div class="line">git commit -m <span class="string">"a"</span></div><div class="line">git add b.txt</div><div class="line">git commit -m <span class="string">"bb"</span></div><div class="line">git add c.txt</div><div class="line">git commit -m <span class="string">"c"</span></div></pre></td></tr></table></figure></p>
<h2 id="查看历史"><a href="#查看历史" class="headerlink" title="查看历史"></a>查看历史</h2><p>在刚才的GitUp欢迎界面上选择新建的test文件夹，就能看到简洁的版本历史图，有三个commit，其中两个是小圆点，一个是现在所处的HEAD。随便单击选择一个commit：<br><img src="/img/gitup-map.jpg" alt=""></p>
<p>可以看到这个commit的信息，按上下键可以选择其它commit，按空格切换commit详细页面。在commit上右击，便能看到所有支持的操作。我们可以先右击中间的commit，选择<strong>Edit Message</strong>把先前的提交消息”bb”改成”b”。很简单吧！比输命令易用多了。之后在HEAD上右击并选择<strong>Create Branch</strong>来新建一个分支，分支名为temp。然后就能看到下图：<br><img src="/img/gitup-new-branch.jpg" alt=""></p>
<p>可以在终端中运行<code>git branch</code>来确认自己在temp分支上。然后加点代码：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> d &gt;&gt; c.txt</div><div class="line">cat c.txt</div></pre></td></tr></table></figure></p>
<p>这时切回GitUp的界面，选择中间的视图，如下图所示：<br><img src="/img/gitup-commit.jpg" alt=""></p>
<p>看起来很像<code>git gui</code>吧。双击<code>c.txt</code>就可以切换文件的状态。输入提交消息<code>cd</code>，然后点击<strong>Commit</strong>按钮来提交。于是就能看到下图：<br><img src="/img/gitup-new-branch-commit.jpg" alt=""></p>
<p>双击master的小黄点就可以切换到master分支上了。然后也加点代码：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> e &gt;&gt; c.txt</div><div class="line">cat c.txt</div><div class="line">git commit -am <span class="string">"ce"</span></div></pre></td></tr></table></figure></p>
<p>这回的图变成这样了：<br><img src="/img/gitup-master-commit.jpg" alt=""></p>
<h2 id="合并和衍合"><a href="#合并和衍合" class="headerlink" title="合并和衍合"></a>合并和衍合</h2><p>我们来试一下合并分支。右击temp上的小圆圈，选择<strong>Merge into Current Branch</strong>，然后点击<strong>Merge</strong>按钮就能看到冲突了。可以使用<strong>Open with Default Editor</strong>来自己解决冲突，也可以使用<strong>Resolve in Merge Tool</strong>来解决。如果是前者，可以注意一个小细节：这里的冲突提示是ours和theirs，看起来人性化了不少。合并完成后，点击<strong>Mark as Resolved</strong>，然后<strong>Commit</strong>，就可以看到图变成这样了：<br><img src="/img/gitup-merge.jpg" alt=""></p>
<p>衍合也是类似。GitUp提供了一个逆天功能Command+Z，可以快速回退到上一次操作（再次前进是Command+Shift+Z）。这样我们很轻松就能再来一次衍合。右击temp上的小圆圈，选择<strong>Rebase Current Branch onto Here</strong>，剩下的和合并分支类似。提交之后，就可以看到图变成这样了：<br><img src="/img/gitup-rebase.jpg" alt=""></p>
<p>GitUp还提供了强大的快照功能。我们可以点击右上方的时钟按钮来选择自己想要的快照，就像Time Machine似的。如下图：<br><img src="/img/gitup-snapshot.jpg" alt=""></p>
<h2 id="查看stash"><a href="#查看stash" class="headerlink" title="查看stash"></a>查看stash</h2><p>那么第三个视图是干什么的呢？我们先stash一段代码：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> f &gt;&gt; c.txt</div><div class="line">cat c.txt</div><div class="line">git stash</div><div class="line"><span class="built_in">echo</span> g &gt;&gt; c.txt</div></pre></td></tr></table></figure></p>
<p>打开第三个视图，原来是stash列表，这回可以很容易看清楚了。也可以在这里stash：点击左下方的加号按钮，输入一个消息然后<strong>Save Stash</strong>，就可以看到下图：<br><img src="/img/gitup-stashes.jpg" alt=""></p>
<p>还可以在这里轻松地<strong>Apply</strong>想要的stash，这个可视化可以有。可惜还是不支持选择特定文件stash。</p>
]]></content>
      
        <categories>
            
            <category> tool </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
            <tag> GitUp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用容器轻松搭建Prometheus运行环境]]></title>
      <url>/prometheus/</url>
      <content type="html"><![CDATA[<p><a href="https://prometheus.io/" target="_blank" rel="external">Prometheus</a>是一个开源的监控解决方案，包括数据采集、汇聚、存储、可视化、监控、告警等。除了基本的监控数据，也支持通过自定义exporter来获取自己想要的数据。本文从零开始用容器搭建一个prometheus环境，并介绍一些基本功能。<br><a id="more"></a></p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>我们需要先安装<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="external">virtualBox</a>和<a href="https://www.vagrantup.com/downloads.html" target="_blank" rel="external">vagrant</a>。通过vagrant来驱动virtualBox搭建一个虚拟测试环境。首先在本地任意路径新建一个空文件夹比如<code>test</code>，运行以下命令：<br><figure class="highlight sh"><figcaption><span>virtual box host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mkdir <span class="built_in">test</span></div><div class="line"><span class="built_in">cd</span> <span class="built_in">test</span></div><div class="line">vagrant init minimum/ubuntu-trusty64-docker</div><div class="line">vi Vagrantfile</div></pre></td></tr></table></figure></p>
<p>里面应该有一句<code>config.vm.box = &quot;minimum/ubuntu-trusty64-docker&quot;</code>，在它的下面添加如下代码，相当于给它分配一台IP是<strong>192.168.33.18</strong>的虚拟机。<br><figure class="highlight ruby"><figcaption><span>Vagrantfile</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">config.vm.network <span class="string">"private_network"</span>, <span class="symbol">ip:</span> <span class="string">"192.168.33.18"</span></div></pre></td></tr></table></figure></p>
<p>这个vagrant镜像已经在ubuntu的基础上帮我们安装了docker，用起来很方便。然后在终端运行以下命令启动并连接虚拟机。<br><figure class="highlight sh"><figcaption><span>virtual box host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vagrant up</div><div class="line">vagrant ssh</div></pre></td></tr></table></figure></p>
<h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p>Prometheus的环境搭建起来非常简单，只要一个docker镜像即可。绿色的压缩包安装方式可以参考<a href="https://prometheus.io/docs/introduction/getting_started/" target="_blank" rel="external">官方文档</a>。此外还需要一个配置文件：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">cat &lt;&lt; EOF &gt;prometheus.yml</div><div class="line">global:</div><div class="line">  scrape_interval: 15s</div><div class="line">  external_labels:</div><div class="line">    monitor: <span class="string">'codelab-monitor'</span></div><div class="line">scrape_configs:</div><div class="line">  - job_name: <span class="string">'prometheus'</span></div><div class="line">    scrape_interval: 5s</div><div class="line">    target_groups:</div><div class="line">      - targets: [<span class="string">'localhost:9090'</span>]</div><div class="line">EOF</div><div class="line"></div><div class="line">sudo mkdir /etc/prometheus</div><div class="line">sudo mv prometheus.yml /etc/prometheus</div></pre></td></tr></table></figure></p>
<p>配置文件中，<code>scrape_interval</code>指的是数据获取间隔，<code>prometheus</code>这个任务里的<code>scrape_interval</code>将会在这个任务里覆盖掉默认的<code>global</code>全局值，也就是这个任务每5秒钟获取一次数据，其它任务则是每15秒钟。完整的配置文件格式，请参考<a href="http://prometheus.io/docs/operating/configuration/" target="_blank" rel="external">官方文档</a>。接下来启动Prometheus：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/usr/bin/docker run -d \</div><div class="line">    --name=prometheus \</div><div class="line">    --publish=9090:9090 \</div><div class="line">    -v /etc/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml \</div><div class="line">    -v /var/prometheus/storage:/prometheus \</div><div class="line">    prom/prometheus:0.17.0</div></pre></td></tr></table></figure></p>
<p>启动完成后，将会在<a href="http://192.168.33.18:9090" target="_blank" rel="external">http://192.168.33.18:9090</a>看到prometheus的首页：<br><img src="/img/prometheus-home.jpg" alt=""></p>
<h2 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h2><p>在<a href="http://192.168.33.18:9090/metrics" target="_blank" rel="external">http://192.168.33.18:9090/metrics</a>可以看到prometheus收集到的数据。其中有一个<code>prometheus_target_interval_length_seconds</code>，表示真实的数据获取间隔。在prometheus首页输入它并回车，就可以看到一系列的数据，它们有着不同的quantile，从0.01至0.99不等。0.99的意思是有99%的数据都在这个值以内。如果我们只关心这个数，我们可以输入<code>prometheus_target_interval_length_seconds{quantile=&quot;0.99&quot;}</code>来查看。查询还支持函数，比如<code>count(prometheus_target_interval_length_seconds)</code>可以查询数量。完整的表达式可以参考<a href="https://prometheus.io/docs/querying/basics/" target="_blank" rel="external">官方文档</a>。</p>
<p>点击<strong>Console</strong>旁边的<strong>Graph</strong>标签就可以看见时序图了：<br><img src="/img/prometheus-graph.jpg" alt=""></p>
<p>可以随意选择指标和函数试一试，比如<code>rate(prometheus_local_storage_chunk_ops_total[1m])</code>。</p>
<h2 id="Exporter"><a href="#Exporter" class="headerlink" title="Exporter"></a>Exporter</h2><p>Prometheus支持官方/非官方的许多种<a href="https://prometheus.io/docs/instrumenting/exporters/" target="_blank" rel="external">exporter</a>，如HAProxy，Jenkins，MySQL等，也有一些软件直接支持Prometheus而无需exporter，如Etcd，Kubernetes等。我们试一下node exporter：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">docker run -d \</div><div class="line">  --name=ne \</div><div class="line">  -p 9100:9100 \</div><div class="line">  prom/node-exporter</div></pre></td></tr></table></figure></p>
<p>Node exporter暴露的端口是9100，所以我们需要修改一下prometheus的配置文件：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">cat &lt;&lt; EOF &gt;prometheus.yml</div><div class="line">global:</div><div class="line">  scrape_interval: 15s</div><div class="line">  external_labels:</div><div class="line">    monitor: <span class="string">'codelab-monitor'</span></div><div class="line">scrape_configs:</div><div class="line">  - job_name: <span class="string">'node'</span></div><div class="line">    scrape_interval: 5s</div><div class="line">    target_groups:</div><div class="line">      - targets: [<span class="string">'192.168.33.18:9100'</span>]</div><div class="line">EOF</div><div class="line"></div><div class="line">sudo cp prometheus.yml /etc/prometheus</div></pre></td></tr></table></figure></p>
<p>重启prometheus：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker stop prometheus</div><div class="line">sudo rm -rf /var/prometheus/storage</div><div class="line">docker start prometheus</div></pre></td></tr></table></figure></p>
<p>这样在页面上就可以选择节点的一些指标了。也可以访问<a href="http://192.168.33.18:9100/" target="_blank" rel="external">http://192.168.33.18:9100/</a>来直接查看Exporter的指标。</p>
<h2 id="Push-Gateway"><a href="#Push-Gateway" class="headerlink" title="Push Gateway"></a>Push Gateway</h2><p>Prometheus采集数据是用的pull也就是拉模型，这从我们刚才设置的5秒参数就能看出来。但是有些数据并不适合采用这样的方式，对这样的数据可以使用Push Gateway服务。它就相当于一个缓存，当数据采集完成之后，就上传到这里，由Prometheus稍后再pull过来。我们来试一下，首先启动Push Gateway：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">docker run -d \</div><div class="line">  --name=pg \</div><div class="line">  -p 9091:9091 \</div><div class="line">  prom/pushgateway</div></pre></td></tr></table></figure></p>
<p>可以访问<a href="http://192.168.33.18:9091/" target="_blank" rel="external">http://192.168.33.18:9091/</a>来查看它的页面。下个命令将会往Push Gateway上传数据：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> <span class="string">"some_metric 3.14"</span> | curl --data-binary @- http://192.168.33.18:9091/metrics/job/some_job</div></pre></td></tr></table></figure></p>
<p>效果是酱紫滴：<br><img src="/img/prometheus-push-gateway.jpg" alt=""></p>
<p>而在Prometheus的配置文件里，只要把端口换成<code>9100</code>便能采集到Push Gateway的数据了。</p>
<h2 id="Grafana"><a href="#Grafana" class="headerlink" title="Grafana"></a>Grafana</h2><p><a href="https://prometheus.io/docs/visualization/grafana/" target="_blank" rel="external">Grafana</a>是目前比较流行的监控可视化UI，它从2.5.0版开始直接支持Prometheus的数据。我们来试一下。首先启动grafana：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">docker run -d \</div><div class="line">  --name grafana \</div><div class="line">  -p 3000:3000 \</div><div class="line">  grafana/grafana:2.6.0</div></pre></td></tr></table></figure></p>
<p>打开<a href="http://192.168.33.18:3000/" target="_blank" rel="external">http://192.168.33.18:3000/</a>，就能看到grafana的登录页面了。输入默认的admin/admin登录grafana。选择左侧的<strong>Data Sources</strong>，然后点击上面的<strong>Add new</strong>按钮，便可以把prometheus作为数据源导入grafana：<br><img src="/img/grafana-prometheus-data-source.jpg" alt=""></p>
<p>输入下面的值：</p>
<ul>
<li>Name：prometheus</li>
<li>Default：true</li>
<li>Type：Prometheus</li>
<li>Url：<a href="http://192.168.33.18:9090/" target="_blank" rel="external">http://192.168.33.18:9090/</a></li>
</ul>
<p>然后点击<strong>Add</strong>按钮。之后会出来一个<strong>Test Connection</strong>的按钮，点击它便可以收到<strong>Data source is working</strong>的消息。点击左边的<strong>Dashboards</strong>回到主页，点击上面的<strong>Home</strong>，选择<strong>+ New</strong>，会出来一个绿色的小竖条，点击它便会弹出来一个菜单：<br><img src="/img/grafana-dashboard-menu.jpg" alt=""></p>
<p>选择<strong>Add Panel</strong>和<strong>Graph</strong>，便会出来一个图。然后就可以在<strong>Query</strong>里输入prometheus支持的查询了：<br><img src="/img/grafana-prometheus-graph.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> devops </category>
            
        </categories>
        
        
        <tags>
            
            <tag> prometheus </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TOSCA简介]]></title>
      <url>/tosca/</url>
      <content type="html"><![CDATA[<p><a href="https://www.oasis-open.org/committees/tosca/" target="_blank" rel="external">TOSCA</a>（Topology and Orchestration Specification for Cloud Applications）是由OASIS组织制定的云应用拓扑编排规范。通俗地说，就是制定了一个标准，用来描述云平台上应用的拓扑结构。目前支持XML和YAML，Cloudiy的蓝图就是基于这个规范而来。这个规范比较庞大，本文尽量浓缩了<a href="http://docs.oasis-open.org/tosca/TOSCA-Simple-Profile-YAML/v1.0/TOSCA-Simple-Profile-YAML-v1.0.html" target="_blank" rel="external">TOSCA的YAML版</a>前两章，以便用尽量少的时间了解尽量多的规范内容。<br><a id="more"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>TOSCA的基本概念只有两个：节点（node）和关系（relationship）。节点有许多类型，可以是一台服务器，一个网络，一个计算节点等等。关系描述了节点之间是如何连接的。举个栗子：一个nodejs应用（节点）部署在（关系）名为host的主机（节点）上。节点和关系都可以通过程序来扩展和实现。</p>
<p>目前它的开源实现有OpenStack (Heat-Translator，Tacker，Senlin)，Alien4Cloud，Cloudify等。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><p>首先登场的是广大程序猿和攻城狮们都喜闻乐见的Hello World，但是其实里面并没有Hello World，只是比较简单而已。先看下面这段描述文件：</p>
<pre>
tosca_definitions_version: tosca_simple_yaml_1_0

description: Template for deploying a single server with predefined properties.

topology_template:
  node_templates:
    my_server:
      type: tosca.nodes.Compute
      capabilities:
        host:
          properties:
            num_cpus: 1
            disk_size: 10 GB
            mem_size: 4096 MB
        os:
          properties:
            architecture: x86_64
            type: linux 
            distribution: rhel 
            version: 6.5 
</pre>

<p>除了TOSCA的版本<code>tosca_definitions_version</code>和描述信息<code>description</code>以外，就是这个<code>topology_template</code>了。这里我们看到有一个名为<code>my_server</code>的节点，它的类型是<code>tosca.nodes.Compute</code>。这个类型预置了两个<code>capabilities</code>信息，一个是<code>host</code>，定义了硬件信息；另一个是<code>os</code>，定义了操作系统信息。</p>
<h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><p>再看看下面这个描述文件：</p>
<pre>
topology_template:
  <b style="color:magenta">inputs</b>:
    cpus:
      type: integer
      description: Number of CPUs for the server.
      constraints:
        - valid_values: [ 1, 2, 4, 8 ]

  node_templates:
    my_server:
      type: tosca.nodes.Compute
      capabilities:
        host:
          properties:
            num_cpus: { get_input: cpus }
            mem_size: 2048  MB
            disk_size: 10 GB

  <b style="color:magenta">outputs</b>:
    server_ip:
      description: The private IP address of the provisioned server.
      value: { get_attribute: [ my_server, private_address ] }
</pre>

<p>这里的<code>inputs</code>和<code>outputs</code>分别定义了输入和输出。输入的<code>cpus</code>是在1，2，4和8中的一个整数，而输出的<code>server_ip</code>就是<code>my_server</code>这个节点的<code>private_address</code>也就是私有IP地址。另外一点是TOSCA提供了一些内置函数，在上面这个文件中使用了<code>get_input</code>和<code>get_attribute</code>。输入参数可以通过<code>get_input</code>被使用。</p>
<h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><p>第三个描述文件如下：</p>
<pre>
topology_template:
  inputs:
    # 略

  node_templates:
    mysql:
      type: <b style="color:magenta">tosca.nodes.DBMS.MySQL</b>
      properties:
        root_password: { get_input: my_mysql_rootpw }
        port: { get_input: my_mysql_port }
      <b style="color:magenta">requirements</b>:
        - host: db_server

    db_server:
      type: tosca.nodes.Compute
      capabilities:
        # 略
</pre>

<p>我们看到了一个新的节点类型：<code>tosca.nodes.DBMS.MySQL</code>。这个类型允许接收<code>root_password</code>和<code>port</code>的参数。在<code>requirements</code>里定义了<code>mysql</code>这个节点需要被安装到<code>db_server</code>这个节点上，这就是“关系”。如果只想表明依赖，比如说<code>service_a</code>依赖于<code>service_b</code>，也可以直接用<code>- dependency: service_b</code>来描述。上面文件的拓扑结构如下图：<br><img src="http://docs.oasis-open.org/tosca/TOSCA-Simple-Profile-YAML/v1.0/csprd02/TOSCA-Simple-Profile-YAML-v1.0-csprd02_files/image003.png" alt=""></p>
<h3 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h3><p>第四个描述文件如下：</p>
<pre>
  node_templates:
    my_db:
      type: <b style="color:magenta">tosca.nodes.Database.MySQL</b>
      properties:
        name: { get_input: database_name }
        user: { get_input: database_user }
        password: { get_input: database_password }
        port: { get_input: database_port }
      <b style="color:magenta">artifacts</b>:
        db_content:
          file: files/my_db_content.txt
          type: tosca.artifacts.File
      requirements:
        - host: mysql
      interfaces:
        <b style="color:magenta">Standard:
          create:
            implementation: db_create.sh</b>
            inputs:
              db_data: { get_artifact: [ SELF, db_content ] }

    mysql:
      type: tosca.nodes.DBMS.MySQL
      properties:
        root_password: { get_input: mysql_rootpw }
        port: { get_input: mysql_port }
      requirements:
        - host: db_server

    db_server:
      # 略
</pre>

<p>这里的<code>tosca.nodes.Database.MySQL</code>表示一个MySQL数据库的实例。在<code>artifacts</code>的<code>db_content</code>里指定了一个文本文件，而这个文件将被<code>interfaces</code>里的<code>Create</code>所用，为<code>db_create.sh</code>脚本提供数据。<code>Standard</code>表示生命周期，可能会包含<code>configure</code>、<code>start</code>、<code>stop</code>等各种操作，而<code>db_create.sh</code>本身是对<code>tosca.nodes.Database.MySQL</code>提供的默认<code>create</code>操作的一个重写。如下图：<br><img src="http://docs.oasis-open.org/tosca/TOSCA-Simple-Profile-YAML/v1.0/csprd02/TOSCA-Simple-Profile-YAML-v1.0-csprd02_files/image004.png" alt=""></p>
<h3 id="两层应用"><a href="#两层应用" class="headerlink" title="两层应用"></a>两层应用</h3><p>再来看看第五个描述文件：</p>
<pre>
  node_templates:
    wordpress:
      type: tosca.nodes.WebApplication.WordPress
      properties:
        context_root: { get_input: context_root }
        admin_user: { get_input: wp_admin_username }
        admin_password: { get_input: wp_admin_password }
        db_host: { get_attribute: [ db_server, private_address ] }
      <b style="color:magenta">requirements:
        - host: apache
        - database_endpoint: wordpress_db</b>
      interfaces:
        Standard:
          inputs:
            db_host: { get_attribute: [ db_server, private_address ] }
            db_port: { get_property: [ wordpress_db, port ] }
            db_name: { get_property: [ wordpress_db, name ] }
            db_user: { get_property: [ wordpress_db, user ] }
            db_password: { get_property: [ wordpress_db, password ] }  
    apache:
      type: tosca.nodes.WebServer.Apache
      properties:
        # 略
      <b style="color:magenta">requirements:
        - host: web_server</b>
    web_server:
      type: tosca.nodes.Compute
      # 略

    wordpress_db:
      type: tosca.nodes.Database.MySQL
      # 略
    mysql:
      type: tosca.nodes.DBMS.MySQL
      # 略
    db_server:
      type: tosca.nodes.Compute
      # 略
</pre>

<p>这个文件描述了一个很常见的拓扑结构：<code>mysql</code>里有一个<code>wordpress_db</code>，运行在<code>db_server</code>上；<code>apache</code>部署了一个<code>wordpress</code>，运行在<code>web_server</code>上。<code>wordpress</code>需要<code>wordpress_db</code>。</p>
<h3 id="关系定制化"><a href="#关系定制化" class="headerlink" title="关系定制化"></a>关系定制化</h3><p>第六个描述文件：</p>
<pre>
  node_templates:
    wordpress:
      type: tosca.nodes.WebApplication.WordPress
      properties:
        # 略
      requirements:
        - host: apache
        - database_endpoint:
            node: wordpress_db
            <b style="color:magenta">relationship: my.types.WordpressDbConnection</b>
    wordpress_db:
      type: tosca.nodes.Database.MySQL
      properties:
        # 略
      requirements:
        - host: mysql
  <b style="color:magenta">relationship_templates:
    my.types.WordpressDbConnection:</b>
      type: ConnectsTo
      interfaces:
        Configure:
          pre_configure_source: scripts/wp_db_configure.sh
</pre>

<p>这里的关注点是<code>relationship</code>里的<code>my.types.WordpressDbConnection</code>。这是一个自定义的关系，在文件的下半部分描述了详细定义。它实际上是一个<code>ConnectsTo</code>类型，为<code>pre_configure_source</code>操作提供了一个自定义脚本。这个定义也可以单独提出一个文件，就像下面这样：</p>
<pre>
tosca_definitions_version: tosca_simple_yaml_1_0

description: Definition of custom WordpressDbConnection relationship type

<b style="color:magenta">relationship_types:
  my.types.WordpressDbConnection:</b>
    derived_from: tosca.relationships.ConnectsTo
    interfaces:
      Configure:
        pre_configure_source: scripts/wp_db_configure.sh
</pre>

<h3 id="限定需求资源"><a href="#限定需求资源" class="headerlink" title="限定需求资源"></a>限定需求资源</h3><p>再看一个描述文件：</p>
<pre>
  node_templates:
    mysql:
      type: tosca.nodes.DBMS.MySQL
      properties:
        # 略
      requirements:
        - host:
            <b style="color:magenta">node_filter</b>:
              capabilities:
                - host:
                    properties:
                      - num_cpus: { <b style="color:magenta">in_range</b>: [ 1, 4 ] }
                      - mem_size: { <b style="color:magenta">greater_or_equal</b>: 2 GB }
                - os:
                    properties:
                      - architecture: { <b style="color:magenta">equal</b>: x86_64 }
                      - type: linux
                      - distribution: ubuntu
</pre>

<p>需要关注的是<code>node_filter</code>。这里并没有指定mysql在哪个节点上启动，但是指定了一些节点信息，只有符合的节点才能够启动它。也可以抽出来做个模板：</p>
<pre>
  node_templates:
    mysql:
      type: tosca.nodes.DBMS.MySQL
      properties:
        # 略
      requirements:
        - host: <b style="color:magenta">mysql_compute</b>

    <b style="color:magenta">mysql_compute</b>:
      type: Compute
      node_filter:
        capabilities:
          - host:
              properties:
                num_cpus: { equal: 2 }
                mem_size: { greater_or_equal: 2 GB }
          - os:
              properties:
                architecture: { equal: x86_64 }
                type: linux
                distribution: ubuntu
</pre>

<p>数据库也可以使用：</p>
<pre>
  node_templates:
    my_app:
      type: my.types.MyApplication
      properties:
        admin_user: { get_input: admin_username }
        admin_password: { get_input: admin_password }
        db_endpoint_url: { get_property: [SELF, <b style="color:magenta">database_endpoint</b>, url_path ] }         
      requirements:
        - <b style="color:magenta">database_endpoint</b>:
            node: my.types.nodes.MyDatabase
            <b style="color:magenta">node_filter</b>:
              properties:
                - db_version: { greater_or_equal: 5.5 }
</pre>

<p>上面指定了数据库的版本。也可以抽出来做个模板：</p>
<pre>
  node_templates:
    my_app:
      type: my.types.MyApplication
      properties:
        admin_user: { get_input: admin_username }
        admin_password: { get_input: admin_password }
        db_endpoint_url: { get_property: [SELF, database_endpoint, url_path ] }         
      requirements:
        - database_endpoint: <b style="color:magenta">my_abstract_database</b>
    <b style="color:magenta">my_abstract_database</b>:
      type: my.types.nodes.MyDatabase
      properties:
        - db_version: { greater_or_equal: 5.5 }
</pre>

<h3 id="节点模板替换"><a href="#节点模板替换" class="headerlink" title="节点模板替换"></a>节点模板替换</h3><p>再看一个描述文件：</p>
<pre>
  node_templates:
    web_app:
      type: tosca.nodes.WebApplication.MyWebApp
      requirements:
        - host: web_server
        - database_endpoint: <b style="color:magenta">db</b>

    web_server:
      type: tosca.nodes.WebServer
      requirements:
        - host: server

    server:
      type: tosca.nodes.Compute
      # 略

    <b style="color:magenta">db</b>:
      # 这是一个抽象节点
      type: tosca.nodes.Database
      properties:
        user: my_db_user
        password: secret
        name: my_db_name
</pre>

<p>这里的<code>db</code>是一个抽象节点，可以被下面的描述文件所替换：</p>
<pre>
topology_template:
  inputs:
    db_user:
      type: string
    # 略
  <b style="color:magenta">substitution_mappings:
    node_type: tosca.nodes.Database
    capabilities:
      database_endpoint: [ database, database_endpoint ]</b>
  node_templates:
    database:
      type: tosca.nodes.Database
      properties:
        user: { get_input: db_user }
        # 略
      requirements:
        - host: dbms
    dbms:
      type: tosca.nodes.DBMS
      # 略
    server:
      type: tosca.nodes.Compute
      # 略
</pre>

<p>这里的<code>database_endpoint</code>是由<code>database</code>节点提供的<code>database_endpoint</code>。两个文件联系起来看，表明了上面的<code>web_app</code>不需要管<code>db</code>是什么样子的，有什么拓扑结构，它关心的只是<code>database_endpoint</code>。而下面由<code>database</code>、<code>dbms</code>和<code>server</code>三个节点组成的模板正好可以提供<code>database_endpoint</code>，从而替换掉<code>db</code>这个抽象节点。另外，这样的替换也支持嵌套。</p>
<h3 id="节点模板组"><a href="#节点模板组" class="headerlink" title="节点模板组"></a>节点模板组</h3><p>再看一个描述文件：</p>
<pre>
  node_templates:
    apache:
      type: tosca.nodes.WebServer.Apache
      properties:
        # 略
      requirements:
        - host: server
    server:
      type: tosca.nodes.Compute
        # 略
  <b style="color:magenta">groups</b>:
    <b style="color:magenta">webserver_group</b>:
      type: tosca.groups.Root
      members: [ apache, server ]

  <b style="color:magenta">policies</b>:
    - my_anti_collocation_policy:
        type: my.policies.anticolocateion
        targets: [ <b style="color:magenta">webserver_group</b> ]
        # 可以一起处理
</pre>

<p>这个例子表明了<code>apache</code>和<code>server</code>应该是一组的关系。这样它们就可以一起被处理，比如说伸缩。</p>
<h3 id="YAML宏"><a href="#YAML宏" class="headerlink" title="YAML宏"></a>YAML宏</h3><p>下面这个描述文件使用了宏来避免重复：</p>
<pre>
<b style="color:magenta">dsl_definitions:
  my_compute_node_props: &my_compute_node_props</b>
    disk_size: 10 GB
    num_cpus: 1
    mem_size: 2 GB

topology_template:
  node_templates:
    my_server:
      type: Compute
      capabilities:
        - host:
            properties: <b style="color:magenta">*my_compute_node_props</b>

    my_database:
      type: Compute
      capabilities:
        - host:
            properties: <b style="color:magenta">*my_compute_node_props</b>
</pre>

<h3 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h3><p>先看一个描述文件：</p>
<pre>
  node_templates: 
    wordpress:
      type: tosca.nodes.WebApplication.WordPress
      requirements:
        - database_endpoint: mysql_database
      interfaces:
        Standard:
          <b style="color:magenta">inputs</b>:
            wp_db_port: { get_property: [ SELF, database_endpoint, port ] }
          configure:
            implementation: wordpress_configure.sh           
            <b style="color:magenta">inputs</b>:
              wp_db_port: { get_property: [ SELF, database_endpoint, port ] }
</pre>

<p>这个例子有两个<code>inputs</code>，前者指的是为所有操作都声明一个变量，后者指的是为<code>configure</code>这个操作声明一个变量。再看下一个文件：</p>
<pre>
  node_templates: 
    frontend: 
      type: MyTypes.SomeNodeType    
      attributes: 
        url: { <b style="color:magenta">get_operation_output</b>: [ SELF, Standard, create, generated_url ] } 
      interfaces: 
        Standard: 
          create: 
            implementation: scripts/frontend/create.sh
          configure: 
            implementation: scripts/frontend/configure.sh 
            inputs: 
              data_dir: { <b style="color:magenta">get_operation_output</b>: [ SELF, Standard, create, data_dir ] }
</pre>

<p>在这个例子里有两个<code>get_operation_output</code>，前者指的是将<code>create</code>操作的环境变量<code>generated_url</code>设置到<code>url</code>里，后者是将<code>data_dir</code>传递给<code>configure</code>操作。</p>
<h3 id="取动态值"><a href="#取动态值" class="headerlink" title="取动态值"></a>取动态值</h3><p>最后一个描述文件：</p>
<pre>
node_types:
  ServerNode:
    derived_from: SoftwareComponent
    properties:
      <b style="color:magenta">notification_port</b>:
        type: integer
    capabilities:
      # 略
  ClientNode:
    derived_from: SoftwareComponent
    properties:
      # 略
    requirements:
      - server:
          capability: Endpoint
          node: ServerNode 
          relationship: ConnectsTo
topology_template:          
  node_templates:
    my_server:
      type: ServerNode 
      properties:
        notification_port: 8000
    my_client:
      type: ClientNode
      requirements:
        - server:
            node: my_server
            relationship: <b style="color:magenta">my_connection</b>
  relationship_templates:
    <b style="color:magenta">my_connection</b>:
      type: ConnectsTo
      interfaces:
        Configure:
          inputs:
            <b style="color:magenta">targ_notify_port: { get_attribute: [ TARGET, notification_port ] }</b>
            # 略
</pre>

<p>这个例子里，类型为<code>ClientNode</code>的<code>my_client</code>在<code>my_connection</code>关系的<code>Configure</code>操作上需要<code>notification_port</code>变量。这样的话，当类型为<code>ServerNode</code>的<code>my_server</code>连接过来时，就能取到它的<code>notification_port</code>变量，并设置到<code>targ_notify_port</code>环境变量里。有一点值得注意的是，真实的<code>notification_port</code>可能是8000，也可能不是。所以在这种情况下，不用<code>get_property</code>，而用<code>get_attribute</code>函数。</p>
]]></content>
      
        <categories>
            
            <category> devops </category>
            
        </categories>
        
        
        <tags>
            
            <tag> cloudify </tag>
            
            <tag> tosca </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[轻松搭建Cloudify运行环境]]></title>
      <url>/cloudify/</url>
      <content type="html"><![CDATA[<p><a href="http://getcloudify.org/" target="_blank" rel="external">Cloudify</a>是一个开源的云应用编排系统，它允许使用DSL来描述应用的拓扑结构，并部署到任意环境中。本文大量参考了<a href="http://docs.getcloudify.org/3.3.1/intro/what-is-cloudify/" target="_blank" rel="external">官方教程</a>从零开始搭建并管理一个cloudify 3.3.1集群。<br><a id="more"></a></p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>我们需要先安装<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="external">virtualBox</a>和<a href="https://www.vagrantup.com/downloads.html" target="_blank" rel="external">vagrant</a>。通过vagrant来驱动virtualBox搭建一个虚拟测试环境。首先在本地任意路径新建一个空文件夹比如<code>test</code>，运行以下命令：<br><figure class="highlight sh"><figcaption><span>virtual box host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mkdir <span class="built_in">test</span></div><div class="line"><span class="built_in">cd</span> <span class="built_in">test</span></div><div class="line">vagrant init minimum/ubuntu-trusty64-docker</div><div class="line">vi Vagrantfile</div></pre></td></tr></table></figure></p>
<p>里面应该有一句<code>config.vm.box = &quot;minimum/ubuntu-trusty64-docker&quot;</code>，注释掉并在它的下面添加如下几行代码，相当于给它分配两台虚拟机，一台叫做<strong>manager</strong>，它的IP是<strong>192.168.33.17</strong>；另一台叫做<strong>agent</strong>，它们的IP是<strong>192.168.33.18</strong>。<br><figure class="highlight ruby"><figcaption><span>Vagrantfile</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">config.vm.define <span class="string">"manager"</span> <span class="keyword">do</span> <span class="params">| host |</span></div><div class="line">  host.vm.box = <span class="string">"cloudify-virtualbox_3.3.0-ga-b300.box"</span></div><div class="line">  host.vm.box_url = <span class="string">"http://repository.cloudifysource.org/org/cloudify3/3.3.0/ga-RELEASE/cloudify-virtualbox_3.3.0-ga-b300.box"</span></div><div class="line">  host.vm.hostname = <span class="string">"manager"</span></div><div class="line">  host.vm.network <span class="string">"private_network"</span>, <span class="symbol">ip:</span> <span class="string">"192.168.33.17"</span></div><div class="line">  host.vm.provider <span class="string">"virtualbox"</span> <span class="keyword">do</span> <span class="params">|v|</span></div><div class="line">    v.memory = <span class="number">2048</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">config.vm.define <span class="string">"agent"</span> <span class="keyword">do</span> <span class="params">| host |</span></div><div class="line">  host.vm.box = <span class="string">"minimum/ubuntu-trusty64-docker"</span></div><div class="line">  host.vm.hostname = <span class="string">"agent"</span></div><div class="line">  host.vm.network <span class="string">"private_network"</span>, <span class="symbol">ip:</span> <span class="string">"192.168.33.18"</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p>虚拟机agent所用的vagrant镜像已经在ubuntu的基础上帮我们安装了docker，用起来很方便。虚拟机manager用的远程镜像是cloudify官方镜像，提供了cloudify manager功能。然后分别在两个终端运行以下命令启动并连接两台虚拟机。<br><figure class="highlight sh"><figcaption><span>virtual box host terminal 1</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vagrant up</div><div class="line">vagrant ssh manager</div></pre></td></tr></table></figure></p>
<figure class="highlight sh"><figcaption><span>virtual box host terminal 2</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vagrant ssh agent</div></pre></td></tr></table></figure>
<h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p>在Ubuntu上安装cloudify很简单，在agent上运行以下命令即可：<br><figure class="highlight sh"><figcaption><span>agent</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wget -c http://repository.cloudifysource.org/org/cloudify3/get-cloudify.py</div><div class="line">sudo python get-cloudify.py</div></pre></td></tr></table></figure></p>
<p>安装完了之后，运行以下命令可以看到cloudify命令行的版本及帮助文档：<br><figure class="highlight sh"><figcaption><span>agent</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cfy --version</div><div class="line">cfy -h</div></pre></td></tr></table></figure></p>
<h2 id="部署应用"><a href="#部署应用" class="headerlink" title="部署应用"></a>部署应用</h2><p>Cloudify的应用被称为<a href="http://docs.getcloudify.org/3.3.1/intro/blueprints/" target="_blank" rel="external">蓝图</a>（blueprint），这个名字很好地诠释了它在主页上声称的“从蓝图到生产环境（From Blueprint to Production）”。官方已经为我们的第一次使用准备了一个Hello World，让我们先下载下来：<br><figure class="highlight sh"><figcaption><span>agent</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">wget -c https://github.com/cloudify-examples/simple-python-webserver-blueprint/archive/master.zip</div><div class="line">sudo apt-get install -f unzip</div><div class="line">unzip master.zip</div><div class="line"><span class="built_in">cd</span> simple-python-webserver-blueprint-master/</div></pre></td></tr></table></figure></p>
<p>接下来初始化下载的蓝图并传入端口等参数：<br><figure class="highlight sh"><figcaption><span>agent</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cfy <span class="built_in">local</span> init --blueprint-path blueprint.yaml --inputs <span class="string">'&#123;"webserver_port": "8000", "host_ip":"localhost"&#125;'</span></div></pre></td></tr></table></figure></p>
<p>Cloudify使用工作流（workflow）来管理应用程序。现在启动install工作流来部署一个python的web服务器：<br><figure class="highlight sh"><figcaption><span>agent</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cfy <span class="built_in">local</span> execute --workflow install</div><div class="line">curl localhost:8000</div></pre></td></tr></table></figure></p>
<p>也可以在启动vagrant虚拟机的主机上访问：<a href="http://192.168.33.18:8000" target="_blank" rel="external">http://192.168.33.18:8000</a>：<br><img src="/img/cloudify-hello-world.jpg" alt=""></p>
<p>短短几步，我们便顺利部署了一个应用。通过以下命令可以看到一些运行的参数：<br><figure class="highlight sh"><figcaption><span>agent</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cfy <span class="built_in">local</span> outputs</div></pre></td></tr></table></figure></p>
<p>我们看到的内容称之为模型（model）。蓝图是应用的模板，蓝图的实例称为部署（deployment），部署就是模型的内容之一。蓝图里的每个实体称之为节点（node），节点在部署里称为节点实例（node-instances），它们是一对多的关系。但是在这个例子里，我们有两个节点，每个节点各有一个节点实例。可以用以下命令查看节点实例：<br><figure class="highlight sh"><figcaption><span>agent</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cfy <span class="built_in">local</span> instances</div></pre></td></tr></table></figure></p>
<p>我们能看到这两个节点实例分别是host和http_web_server，其中http_web_server运行在host之上。可以用以下命令来结束部署：<br><figure class="highlight sh"><figcaption><span>agent</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cfy <span class="built_in">local</span> execute -w uninstall</div></pre></td></tr></table></figure></p>
<h2 id="蓝图解析"><a href="#蓝图解析" class="headerlink" title="蓝图解析"></a>蓝图解析</h2><p>现在让我们看一看刚才所用的蓝图的结构：<br><figure class="highlight sh"><figcaption><span>agent</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat blueprint.yaml</div></pre></td></tr></table></figure></p>
<p>这就是一个yaml格式的文件，里面都是cloudify的DSL。文件分为以下五个部分：</p>
<ul>
<li>tosca_definitions_version：蓝图的DSL版本，这里是cloudify_dsl_1_2</li>
<li>imports：引用yaml文件的地址</li>
<li>inputs：蓝图的配置信息，也就是一开始初始化蓝图时传入的参数</li>
<li>node_templates：描述了应用的资源以及应用是如何被部署的，可以跟刚才看到的节点实例相对应起来</li>
<li>outputs：输出信息，也就是刚才看到的模型里的内容</li>
</ul>
<p>其中包括了三个内置函数（Intrinsic Functions），分别是<code>get_input</code>，<code>get_property</code>和<code>concat</code>，只能在蓝图里使用。它们的意思也都比较明显，可以从函数名推断出来。所有的内置函数可以在<a href="http://docs.getcloudify.org/3.3.1/blueprints/spec-intrinsic-functions/" target="_blank" rel="external">这里</a>查看到。</p>
<h2 id="部署容器"><a href="#部署容器" class="headerlink" title="部署容器"></a>部署容器</h2><p>Cloudify通过<a href="http://docs.getcloudify.org/3.3.1/plugins/docker/" target="_blank" rel="external">docker插件</a>来支持docker。这个插件依赖于Docker Python API库，而不是Docker CLI，所以体验上有所不同。比如说，<code>docker run</code>将会被分解为<code>docker create</code>和<code>docker start</code>。接下来让我们来尝试部署一个tomcat容器。首先需要生成一个tomcat容器的蓝图：<br><figure class="highlight sh"><figcaption><span>agent</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">mkdir ../docker</div><div class="line"><span class="built_in">cd</span> ../docker</div><div class="line"></div><div class="line">cat &lt;&lt; EOF &gt; blueprint.yaml</div><div class="line">tosca_definitions_version: cloudify_dsl_1_2</div><div class="line">imports:</div><div class="line">  - http://www.getcloudify.org/spec/cloudify/3.4m3/types.yaml</div><div class="line">  - http://www.getcloudify.org/spec/docker-plugin/1.3.1/plugin.yaml</div><div class="line">inputs:</div><div class="line">  host_ip:</div><div class="line">      description: &gt;</div><div class="line">        The ip of the host the application will be deployed on</div><div class="line">      default: 127.0.0.1</div><div class="line">  tomcat_container_port_bindings:</div><div class="line">    description: &gt;</div><div class="line">      A dict of port bindings <span class="keyword">for</span> the node container.</div><div class="line">    default:</div><div class="line">      8080: 8080</div><div class="line">node_templates:</div><div class="line">  host:</div><div class="line">    <span class="built_in">type</span>: cloudify.nodes.Compute</div><div class="line">    properties:</div><div class="line">      install_agent: <span class="literal">false</span></div><div class="line">      ip: &#123; get_input: host_ip &#125;</div><div class="line">  tomcat_container:</div><div class="line">    <span class="built_in">type</span>: cloudify.docker.Container</div><div class="line">    properties:</div><div class="line">      name: tomcat</div><div class="line">      image:</div><div class="line">        repository: tomcat</div><div class="line">        tag: 8.0.30-jre8</div><div class="line">    interfaces:</div><div class="line">      cloudify.interfaces.lifecycle:</div><div class="line">        create:</div><div class="line">          implementation: docker.docker_plugin.tasks.create_container</div><div class="line">          inputs:</div><div class="line">            params:</div><div class="line">              stdin_open: <span class="literal">true</span></div><div class="line">              tty: <span class="literal">true</span></div><div class="line">        start:</div><div class="line">          implementation: docker.docker_plugin.tasks.start</div><div class="line">          inputs:</div><div class="line">            params:</div><div class="line">              port_bindings: &#123; get_input: tomcat_container_port_bindings &#125;</div><div class="line">    relationships:</div><div class="line">      - <span class="built_in">type</span>: cloudify.relationships.contained_in</div><div class="line">        target: host</div><div class="line">outputs:</div><div class="line">  http_endpoint:</div><div class="line">    description: Tomcat web server endpoint</div><div class="line">    value: &#123; <span class="string">'http://localhost:8080'</span> &#125;</div><div class="line">EOF</div></pre></td></tr></table></figure></p>
<p>这个蓝图需要docker的插件，所以必须先安装一下，然后就可以初始化蓝图（这次不传参数，使用默认值）：<br><figure class="highlight sh"><figcaption><span>agent</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cfy <span class="built_in">local</span> create-requirements -o requirements.txt -p blueprint.yaml</div><div class="line">sudo pip install -r requirements.txt</div><div class="line">cfy <span class="built_in">local</span> init -p blueprint.yaml</div></pre></td></tr></table></figure></p>
<p>现在可以运行啦。由于第一次运行需要下载镜像，可能会比较慢：<br><figure class="highlight sh"><figcaption><span>agent</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cfy <span class="built_in">local</span> execute -w install</div><div class="line">docker ps</div><div class="line">docker images</div></pre></td></tr></table></figure></p>
<p>总算是可以访问了：<br><figure class="highlight sh"><figcaption><span>agent</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl localhost:8080</div></pre></td></tr></table></figure></p>
<p>也可以在启动vagrant虚拟机的主机上访问：<a href="http://192.168.33.18:8080" target="_blank" rel="external">http://192.168.33.18:8080</a>。查看运行参数和节点实例：<br><figure class="highlight sh"><figcaption><span>agent</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cfy <span class="built_in">local</span> outputs</div><div class="line">cfy <span class="built_in">local</span> instances</div></pre></td></tr></table></figure></p>
<p>可以用以下命令来结束部署：<br><figure class="highlight sh"><figcaption><span>agent</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cfy <span class="built_in">local</span> execute -w uninstall</div><div class="line">docker ps -a</div></pre></td></tr></table></figure></p>
<p>看起来容器会被删除。感觉怎么样？你愿意天天这样来部署docker么？</p>
<h2 id="Cloudify管理器"><a href="#Cloudify管理器" class="headerlink" title="Cloudify管理器"></a>Cloudify管理器</h2><p>除了命令行以外，cloudify也支持使用管理器来部署应用。Cloudify管理器有自己的用户界面，提供历史记录、授权和鉴权等功能，并且支持并行运行工作流。下面我们来试着安装一个cloudify管理器。启动cloudify管理器就像是启动一个普通的蓝图一样。可是安装需要下载一大堆的依赖，比较繁琐，有兴趣的童鞋可以参考<a href="http://docs.getcloudify.org/3.3.1/manager/bootstrapping/" target="_blank" rel="external">官方教程</a>。官方另外还提供了一个<a href="http://docs.getcloudify.org/3.3.1/manager/getting-started/" target="_blank" rel="external">vagrant镜像</a>，里面已经配置好了整个Cloudify管理器，因为我们启动vagrant的时候就已经导入了，直接用它更方便。只要虚拟机启动起来（按照本教程的话，现在是起来的状态），可以直接访问<a href="http://192.168.33.17/" target="_blank" rel="external">http://192.168.33.17/</a>来打开cloudify管理器的页面了：<br><img src="/img/cloudify-manager-blueprint.jpg" alt=""></p>
<p>接下来我们来上传一个官方的蓝图，这是nodejs调用mongodb的应用：<br><figure class="highlight sh"><figcaption><span>manager</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> blueprints</div><div class="line">git <span class="built_in">clone</span> https://github.com/cloudify-cosmo/cloudify-nodecellar-example</div><div class="line"><span class="built_in">cd</span> cloudify-nodecellar-example/</div><div class="line">git checkout tags/3.3</div><div class="line">cfy blueprints upload -b nodecellar -p simple-blueprint.yaml</div></pre></td></tr></table></figure></p>
<p><code>-b</code>参数的nodecellar是这个蓝图的名字。刷新蓝图的界面，我们就能看到一个名为nodecellar的蓝图。点击进去，还能看到更详细的拓扑结构、节点信息等。甚至还可以点击图上的各个组件查看详细信息：<br><img src="/img/cloudify-blueprint-topology.jpg" alt=""></p>
<p>这里有4个节点：</p>
<ol>
<li>host：部署的主机</li>
<li>mongod：mongoDB，运行在host上</li>
<li>nodejs：nodejs服务器，运行在host上</li>
<li>nodec…：显示不下的nodecellar，也就是这个酒窖应用，运行在nodejs服务器上，它会去访问mongoDB</li>
</ol>
<p>接下来让我们生成一个部署对象：<br><figure class="highlight plain"><figcaption><span>manager</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sed -i &apos;s/host_ip: .*/host_ip: 192.168.33.17/&apos; ../inputs/nodecellar-singlehost.yaml</div><div class="line">cfy deployments create -b nodecellar -d nodecellar --inputs ../inputs/nodecellar-singlehost.yaml</div></pre></td></tr></table></figure></p>
<p><code>-d</code>参数的nodecellar是这个部署的ID。页面上点击左边的Deployments，我们就能看到ID为nodecellar的部署了。而Logs &amp; Events里面也生成了好几页日志和事件。与此同时，最左下的Nodes也出现了4条记录。接下来，真正地开始部署：<br><figure class="highlight plain"><figcaption><span>manager</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cfy executions start -w install -d nodecellar</div></pre></td></tr></table></figure></p>
<p>部署需要一些时间，在笔者的mac上大约5分钟。这时如果刷新部署页面，就能看到Action显示Install，旁边还有一个<code>×</code>号，可以通过点击它来取消本次部署。点击部署页面上nodecellar的ID，就能看到一系列详细信息，甚至还有监控：<br><img src="/img/cloudify-deployments-monitoring.jpg" alt=""></p>
<p>部署完成后，就可以直接访问<a href="http://192.168.33.17:8080/" target="_blank" rel="external">http://192.168.33.17:8080/</a>来打开这个nodejs酒窖的网站了：<br><img src="/img/cloudify-node-cellar.jpg" alt=""></p>
<p>还可以用以下命令来停止nodecellar的部署，并删除这个部署：<br><figure class="highlight plain"><figcaption><span>manager</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cfy executions start -w uninstall -d nodecellar</div><div class="line">cfy deployments delete -d nodecellar</div></pre></td></tr></table></figure></p>
<p>值得一提的是，刚才我们输入的命令，都可以通过cloudify manager的界面来操作。如果需要停止cloudify manager，可以用以下命令：<br><figure class="highlight plain"><figcaption><span>manager</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cfy teardown -f</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> devops </category>
            
        </categories>
        
        
        <tags>
            
            <tag> cloudify </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[轻松搭建Kubernetes 1.2版运行环境]]></title>
      <url>/kubernetes-installation/</url>
      <content type="html"><![CDATA[<p><a href="http://kubernetes.io/docs/whatisk8s/" target="_blank" rel="external">Kubernetes</a>简称k8s，是谷歌于2014年开始主导的开源项目，提供了以容器为中心的部署、伸缩和运维平台。截止目前它的最新版本为1.2。搭建环境之前建议先了解一下kubernetes的相关知识，可以参考<a href="/kubernetes-in-mesos-1">《如果有10000台机器，你想怎么玩？》</a>系列文章。本文从零开始搭建一个kubernetes集群。<br><a id="more"></a></p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>我们需要先安装<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="external">virtualBox</a>和<a href="https://www.vagrantup.com/downloads.html" target="_blank" rel="external">vagrant</a>。通过vagrant来驱动virtualBox搭建一个虚拟测试环境。首先在本地任意路径新建一个空文件夹比如<code>test</code>，运行以下命令：<br><figure class="highlight sh"><figcaption><span>virtual box host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mkdir <span class="built_in">test</span></div><div class="line"><span class="built_in">cd</span> <span class="built_in">test</span></div><div class="line">vagrant init minimum/ubuntu-trusty64-docker</div><div class="line">vi Vagrantfile</div></pre></td></tr></table></figure></p>
<p>里面应该有一句<code>config.vm.box = &quot;minimum/ubuntu-trusty64-docker&quot;</code>，在它的下面添加如下几行代码，相当于给它分配三台虚拟机，一台叫做<strong>master</strong>，它的IP是<strong>192.168.33.17</strong>；另两台叫做<strong>node1</strong>和<strong>node2</strong>，它们的IP是<strong>192.168.33.18</strong>和<strong>192.168.33.19</strong>。<br><figure class="highlight ruby"><figcaption><span>Vagrantfile</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">config.vm.define <span class="string">"master"</span> <span class="keyword">do</span> <span class="params">| host |</span></div><div class="line">  host.vm.hostname = <span class="string">"master"</span></div><div class="line">  host.vm.network <span class="string">"private_network"</span>, <span class="symbol">ip:</span> <span class="string">"192.168.33.17"</span></div><div class="line">  host.vm.provider <span class="string">"virtualbox"</span> <span class="keyword">do</span> <span class="params">|v|</span></div><div class="line">    v.memory = <span class="number">1024</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">config.vm.define <span class="string">"node1"</span> <span class="keyword">do</span> <span class="params">| host |</span></div><div class="line">  host.vm.hostname = <span class="string">"node1"</span></div><div class="line">  host.vm.network <span class="string">"private_network"</span>, <span class="symbol">ip:</span> <span class="string">"192.168.33.18"</span></div><div class="line">  host.vm.provider <span class="string">"virtualbox"</span> <span class="keyword">do</span> <span class="params">|v|</span></div><div class="line">    v.memory = <span class="number">2048</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">config.vm.define <span class="string">"node2"</span> <span class="keyword">do</span> <span class="params">| host |</span></div><div class="line">  host.vm.hostname = <span class="string">"node2"</span></div><div class="line">  host.vm.network <span class="string">"private_network"</span>, <span class="symbol">ip:</span> <span class="string">"192.168.33.19"</span></div><div class="line">  host.vm.provider <span class="string">"virtualbox"</span> <span class="keyword">do</span> <span class="params">|v|</span></div><div class="line">    v.memory = <span class="number">2048</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p>这个vagrant镜像已经在ubuntu的基础上帮我们安装了docker，用起来很方便。然后分别在三个终端运行以下命令启动并连接三台虚拟机。<br><figure class="highlight sh"><figcaption><span>virtual box host terminal 1</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vagrant up</div><div class="line">vagrant ssh master</div></pre></td></tr></table></figure></p>
<figure class="highlight sh"><figcaption><span>virtual box host terminal 2</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vagrant ssh node1</div></pre></td></tr></table></figure>
<figure class="highlight sh"><figcaption><span>virtual box host terminal 3</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vagrant ssh node2</div></pre></td></tr></table></figure>
<p>这个vagrant镜像默认的docker版本为1.9.0，如果你愿意，可以用下面的命令将其升级为1.10.3，但这不是必须的：<br><figure class="highlight sh"><figcaption><span>all or none</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">sudo apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 --recv-keys 58118E89F3A912897C070ADBF76221572C52609D</div><div class="line">sudo sh -c <span class="string">"echo deb https://apt.dockerproject.org/repo ubuntu-trusty main &gt; /etc/apt/sources.list.d/docker.list"</span></div><div class="line">sudo apt-get update</div><div class="line">sudo apt-get purge lxc-docker</div><div class="line">sudo apt-cache policy docker-engine</div><div class="line">sudo apt-get install docker-engine</div><div class="line">sudo service docker restart</div><div class="line">docker -v</div></pre></td></tr></table></figure></p>
<h2 id="搭建网络环境"><a href="#搭建网络环境" class="headerlink" title="搭建网络环境"></a>搭建网络环境</h2><p>为了打通不同主机上的容器的网络连接，最简单的方法是安装一个覆盖网络，这里我们使用flannel。它使用etcd来配置，所以我们需要先运行一个etcd实例。下面在master虚拟机上用容器运行一个etcd实例：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">docker run -d \</div><div class="line">  --net=host \</div><div class="line">  --restart=always \</div><div class="line">  --name=etcd \</div><div class="line">  -v /var/etcd/data:/var/etcd/data \</div><div class="line">  kubernetes/etcd:2.0.5 \</div><div class="line">  /usr/<span class="built_in">local</span>/bin/etcd \</div><div class="line">  --addr=192.168.33.17:4001 \</div><div class="line">  --<span class="built_in">bind</span>-addr=0.0.0.0:4001 \</div><div class="line">  --data-dir=/var/etcd/data</div></pre></td></tr></table></figure></p>
<p>接下来往etcd里插入flannel的配置数据。这里指定flannel可以使用的IP地址为<code>10.0.0.0/8</code>区间：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> -it etcd etcdctl <span class="built_in">set</span> /qinghua.github.io/network/config <span class="string">'&#123;"Network": "10.0.0.0/8"&#125;'</span></div></pre></td></tr></table></figure></p>
<p>然后安装并在后台运行flannel：<br><figure class="highlight sh"><figcaption><span>master node1 node2</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">wget -c https://github.com/coreos/flannel/releases/download/v0.5.5/flannel-0.5.5-linux-amd64.tar.gz</div><div class="line">tar zxvf flannel-0.5.5-linux-amd64.tar.gz</div><div class="line">sudo flannel-0.5.5/flanneld --etcd-endpoints=http://192.168.33.17:4001 --etcd-prefix=/qinghua.github.io/network --iface=eth1 &gt; flannel.log 2&gt;&amp;1 &amp;</div><div class="line">cat flannel.log</div></pre></td></tr></table></figure></p>
<p>Flannel启动完成后，会获得一个可用于分配的IP集合，并存放到<code>/run/flannel/subnet.env</code>里。我们需要配置一下docker的可用IP为可用于分配的IP：<br><figure class="highlight sh"><figcaption><span>master node1 node2</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">source</span> /run/flannel/subnet.env</div><div class="line">sudo sh -c <span class="string">"echo DOCKER_OPTS=\\\"--bip=<span class="variable">$FLANNEL_SUBNET</span> --mtu=<span class="variable">$FLANNEL_MTU</span>\\\" &gt;&gt; /etc/default/docker"</span></div><div class="line">sudo service docker restart</div></pre></td></tr></table></figure></p>
<h2 id="搭建k8s环境"><a href="#搭建k8s环境" class="headerlink" title="搭建k8s环境"></a>搭建k8s环境</h2><p>终于轮到k8s啦。首先需要下载并解压kubernetes 1.2.0版：<br><figure class="highlight sh"><figcaption><span>master node1 node2</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">wget -c https://github.com/kubernetes/kubernetes/releases/download/v1.2.0/kubernetes.tar.gz</div><div class="line">tar zxvf kubernetes.tar.gz</div><div class="line">tar zxvf kubernetes/server/kubernetes-server-linux-amd64.tar.gz</div></pre></td></tr></table></figure></p>
<p>解压出来的文件里面含了一些启动master需要的docker镜像文件，将它们导入：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">docker load -i kubernetes/server/bin/kube-apiserver.tar</div><div class="line">docker load -i kubernetes/server/bin/kube-controller-manager.tar </div><div class="line">docker load -i kubernetes/server/bin/kube-scheduler.tar</div><div class="line">docker images</div></pre></td></tr></table></figure></p>
<p>有条件科学上网的童鞋可以自行准备<code>gcr.io/google_containers/etcd:2.2.1</code>这个镜像，否则就凑合着使用先前的<code>kubernetes/etcd:2.0.5</code>。注意，这里为了简单起见，使用同一套etcd。真实环境里，flannel和kubernetes使用的etcd是分开的。接下来开始启动api server：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">docker run -d \</div><div class="line">  --name=apiserver \</div><div class="line">  --net=host \</div><div class="line">  gcr.io/google_containers/kube-apiserver:e68c6af15d4672feef7022e94ee4d9af \</div><div class="line">  kube-apiserver \</div><div class="line">  --insecure-bind-address=192.168.33.17 \</div><div class="line">  --service-cluster-ip-range=11.0.0.0/16 \</div><div class="line">  --etcd-servers=http://192.168.33.17:4001</div></pre></td></tr></table></figure></p>
<p>然后是controller manager：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">docker run -d \</div><div class="line">  --name=cm \</div><div class="line">  gcr.io/google_containers/kube-controller-manager:b9107c794e0564bf11719dc554213f7b \</div><div class="line">  kube-controller-manager \</div><div class="line">  --master=192.168.33.17:8080</div></pre></td></tr></table></figure></p>
<p>最后是scheduler：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">docker run -d \</div><div class="line">  --name=scheduler \</div><div class="line">  gcr.io/google_containers/kube-scheduler:903b34d5ed7367ec4dddf846675613c9 \</div><div class="line">  kube-scheduler \</div><div class="line">  --master=192.168.33.17:8080</div></pre></td></tr></table></figure></p>
<p>服务器启动完毕，可以运行以下命令来查看版本，咱们用的是1.2：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubernetes/server/bin/kubectl -s 192.168.33.17:8080 version</div></pre></td></tr></table></figure></p>
<p>接下来该客户端了。首先启动kubelet：<br><figure class="highlight sh"><figcaption><span>node1 node2</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NODE_IP=`ifconfig eth1 | grep <span class="string">'inet addr:'</span> | cut -d: -f2 | cut -d<span class="string">' '</span> -f1`</div><div class="line">sudo kubernetes/server/bin/kubelet --api-servers=192.168.33.17:8080 --node-ip=<span class="variable">$NODE_IP</span> &gt; kubelet.log 2&gt;&amp;1 &amp;</div><div class="line">cat kubelet.log</div></pre></td></tr></table></figure></p>
<p>Kubelet启动完成后，在master上就可以看到了：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubernetes/server/bin/kubectl -s 192.168.33.17:8080 get no</div></pre></td></tr></table></figure></p>
<p>最后启动kube-proxy：<br><figure class="highlight sh"><figcaption><span>node1 node2</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo kubernetes/server/bin/kube-proxy --master=192.168.33.17:8080 &gt; proxy.log 2&gt;&amp;1 &amp;</div><div class="line">cat proxy.log</div></pre></td></tr></table></figure></p>
<h2 id="测试k8s环境"><a href="#测试k8s环境" class="headerlink" title="测试k8s环境"></a>测试k8s环境</h2><p>环境安装好了，接下来试着启动一个pod。启动之前，由于kubernetes需要通过gcr.io/google_containers/pause:2.0的小镜像来管理pod的网络。在解压出来的kubernetes文件夹里可以导入：<br><figure class="highlight sh"><figcaption><span>node1 node2</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker load -i kubernetes/addons/gcr.io~google_containers~pause:2.0.tar</div></pre></td></tr></table></figure></p>
<p>然后就可以用命令行在任意一台虚拟机上运行一个tomcat，并生成服务：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">cat &lt;&lt; EOF &gt;tomcat.yaml</div><div class="line">apiVersion: v1</div><div class="line">kind: ReplicationController</div><div class="line">metadata:</div><div class="line">  name: tomcat</div><div class="line">spec:</div><div class="line">  replicas: 1</div><div class="line">  selector:</div><div class="line">    app: tomcat</div><div class="line">  template:</div><div class="line">    metadata:</div><div class="line">      name: tomcat</div><div class="line">      labels:</div><div class="line">        app: tomcat</div><div class="line">    spec:</div><div class="line">      containers:</div><div class="line">      - name: tomcat</div><div class="line">        image: tomcat:8.0.30-jre8</div><div class="line">        ports:</div><div class="line">        - containerPort: 8080</div><div class="line">---</div><div class="line">apiVersion: v1</div><div class="line">kind: Service</div><div class="line">metadata:</div><div class="line">  name: tomcat</div><div class="line">  labels: </div><div class="line">    app: tomcat</div><div class="line">spec:</div><div class="line">  <span class="built_in">type</span>: NodePort</div><div class="line">  selector:</div><div class="line">    app: tomcat</div><div class="line">  ports:</div><div class="line">  - port: 80</div><div class="line">    targetPort: 8080</div><div class="line">    nodePort: 30088</div><div class="line">EOF</div><div class="line"></div><div class="line">kubernetes/server/bin/kubectl -s 192.168.33.17:8080 create -f tomcat.yaml</div></pre></td></tr></table></figure></p>
<p>一开始由于需要下载tomcat镜像可能会慢点，随时可以用下面的命令来查看进度：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubernetes/server/bin/kubectl -s 192.168.33.17:8080 describe po tomcat</div></pre></td></tr></table></figure></p>
<p>可以用下面的命令来查看pod、replication controller、service和endpoint：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">kubernetes/server/bin/kubectl -s 192.168.33.17:8080 get po</div><div class="line">kubernetes/server/bin/kubectl -s 192.168.33.17:8080 get rc</div><div class="line">kubernetes/server/bin/kubectl -s 192.168.33.17:8080 get svc</div><div class="line">kubernetes/server/bin/kubectl -s 192.168.33.17:8080 get ep</div></pre></td></tr></table></figure></p>
<p>我们看到的endpoint里，应该有一个tomcat。在我的虚拟机上它的ENDPOINTS是<code>10.0.8.3:8080</code>，访问一下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">POD_IP=`kubernetes/server/bin/kubectl -s 192.168.33.17:8080 get ep tomcat -o jsonpath=&#123;.subsets[*].addresses[*].ip&#125;`</div><div class="line"><span class="built_in">echo</span> <span class="variable">$POD_IP</span></div><div class="line">curl <span class="variable">$POD_IP</span>:8080</div></pre></td></tr></table></figure></p>
<p>顺利的话，这三台虚拟机任意一台都可以访问这个tomcat的endpoint。由于启动这三台vagrant虚拟机的主机上并没有安装flannel，所以目前就别想用主机的浏览器打开这个网址啦。但是，由于我们创建服务的时候类型设置为NodePort，这样外部是可以通过任意node的特定端口访问这个服务的。也就是说，下面这两个url都是可以在集群外部访问的，并且效果一样：</p>
<ul>
<li><a href="http://192.168.33.18:30088/" target="_blank" rel="external">http://192.168.33.18:30088/</a></li>
<li><a href="http://192.168.33.19:30088/" target="_blank" rel="external">http://192.168.33.19:30088/</a></li>
</ul>
<p>初步测试完毕，可以使用以下命令来删除刚才创建的tomcat系列对象：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubernetes/server/bin/kubectl -s 192.168.33.17:8080 delete -f tomcat.yaml</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> devops </category>
            
        </categories>
        
        
        <tags>
            
            <tag> docker </tag>
            
            <tag> kubernetes </tag>
            
            <tag> flannel </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如果有10000台机器，你想怎么玩？（九）安全性]]></title>
      <url>/kubernetes-in-mesos-9/</url>
      <content type="html"><![CDATA[<p>这次聊聊mesos+k8s的安全性，还有多租户。</p>
<ul>
<li><a href="/kubernetes-in-mesos-1">如果有10000台机器，你想怎么玩？（一）概述</a></li>
<li><a href="/kubernetes-in-mesos-2">如果有10000台机器，你想怎么玩？（二）高可用</a></li>
<li><a href="/kubernetes-in-mesos-3">如果有10000台机器，你想怎么玩？（三）持久化</a></li>
<li><a href="/kubernetes-in-mesos-4">如果有10000台机器，你想怎么玩？（四）监控</a></li>
<li><a href="/kubernetes-in-mesos-5">如果有10000台机器，你想怎么玩？（五）日志</a></li>
<li><a href="/kubernetes-in-mesos-6">如果有10000台机器，你想怎么玩？（六）性能</a></li>
<li><a href="/kubernetes-in-mesos-7">如果有10000台机器，你想怎么玩？（七）生命周期</a></li>
<li><a href="/kubernetes-in-mesos-8">如果有10000台机器，你想怎么玩？（八）网络</a></li>
<li><a href="/kubernetes-in-mesos-9">如果有10000台机器，你想怎么玩？（九）安全性</a><a id="more"></a>
</li>
</ul>
<h2 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h2><h3 id="鉴权和授权"><a href="#鉴权和授权" class="headerlink" title="鉴权和授权"></a>鉴权和授权</h3><p>身份认证分为鉴权（authentication）和授权（authorization）。前者是看你能不能登录，后者是看你登录后有什么权限。Kubernetes的1.2版支持以下<a href="http://kubernetes.io/docs/admin/authentication/" target="_blank" rel="external">5种鉴权</a>方式：</p>
<ul>
<li>CA认证（Client certificate authentication）：就是基于SSL证书的认证，基本概念可以参考<a href="/certificate">证书的那些事儿</a></li>
<li>Token文件认证（Token File）：用一个CSV文件指定用户名、用户id和组名，组名是为了给下面的授权使用的</li>
<li>OpenID认证（OpenID Connect ID Token）：基于第三方的<a href="http://openid.net/specs/openid-connect-core-1_0.html" target="_blank" rel="external">OpenID</a></li>
<li>基本认证（Basic authentication）：也是CSV文件，指定了用户名、密码和用户id</li>
<li>Keystone认证（Keystone authentication）：基于openstack的身份认证服务<a href="http://docs.openstack.org/developer/keystone/" target="_blank" rel="external">Keystone</a></li>
</ul>
<p>身份验证通过，接下来就是授权。Kubernetes的1.2版支持以下<a href="http://kubernetes.io/docs/admin/authorization/" target="_blank" rel="external">4种授权</a>方式：</p>
<ul>
<li>总是拒绝（AlwaysDeny）：这个一般用于测试</li>
<li>总是允许（AlwaysAllow）：只要能登录进来，就有所有权限</li>
<li>用户配置（ABAC）：基于用户授权配置，可以对资源（比如pod、service等）和命名空间设置用户/组的只读或可写权限，多租户管理的时候很有用</li>
<li>钩子（Webhook）：也能实现类似用户配置的粒度，只不过是基于一个远程的REST服务</li>
</ul>
<h3 id="账户"><a href="#账户" class="headerlink" title="账户"></a>账户</h3><p>用户账户（User account）和<a href="http://kubernetes.io/docs/user-guide/service-accounts/" target="_blank" rel="external">服务账户</a>（Service account）在kubernetes里是不同的两个东西。用户账户是给人使用的，不可重复，目前创建的时候需要重启API Server。而服务账户是给pod里的容器使用的，在不同的命名空间中可以重复，比较轻量级一点，可以动态创建。如果创建pod的时候指定了服务账户，那就没的说，直接用就好了；但要是没有指定，k8s会自动为pod指定一个指定命名空间的名为default的服务账户。它是在创建命名空间时自动生成的。</p>
<h3 id="秘密"><a href="#秘密" class="headerlink" title="秘密"></a>秘密</h3><p>想象一个正常的开发场景，比如tomcat容器访问mysql，攻城狮们理所当然地把mysql的密码存放在tomcat容器里。Kubernetes提供了<a href="http://kubernetes.io/docs/user-guide/secrets/" target="_blank" rel="external">秘密</a>（Secret）这个对象用来保存这样的敏感信息。需要用的时候像挂卷一样把秘密挂载到pod里就好了，密码就不需要直接写了。有了秘密，妈妈再也不用担心我的霸气侧漏了。实际上，上面提到的服务账户本质上就是秘密的集合。</p>
<h3 id="多租户"><a href="#多租户" class="headerlink" title="多租户"></a>多租户</h3><p>Kubernetes本身支持用不同的命名空间来区分多租户，它们之间不会相互干扰。还有一个系统使用的命名空间叫做<code>kube-system</code>。但是系统的资源是恒定的，如果有个租户打算扶着墙进来，再扶着墙出去，是不是其他人都没得吃了？Kubernetes有一个<a href="http://kubernetes.io/docs/admin/resource-quota/" target="_blank" rel="external">资源限额</a>（Resource Quota）的概念，可以用于命名空间上。目前可以限制的资源有CPU和内存。除了资源，在pod、rc、服务等的数量上也可以进行限制。这样就能很方便地像现在的CaaS那样卖实例吧。</p>
<h2 id="Mesos"><a href="#Mesos" class="headerlink" title="Mesos"></a>Mesos</h2><p>Mesos默认使用<a href="https://en.wikipedia.org/wiki/CRAM-MD5" target="_blank" rel="external">CRAM-MD5</a><a href="http://mesos.apache.org/documentation/latest/authentication/" target="_blank" rel="external">鉴权</a>。最典型的用法是master启动的时候，指定一个文件，里面含有用户名（mesos里叫principal）和密码（mesos里叫secret）。只有通过鉴权的framework和slave才能注册进来。<a href="http://mesos.apache.org/documentation/latest/authorization/" target="_blank" rel="external">授权</a>是通过ACLs（Access Control Lists）来实现的，目前可以支持以下十种行为的授权：</p>
<ul>
<li>register_frameworks: 注册framework</li>
<li>run_tasks: 运行任务</li>
<li>teardown_frameworks: 解除framework</li>
<li>set_quotas: 设置配额</li>
<li>remove_quotas: 移除配额</li>
<li>reserve_resources: 保留资源</li>
<li>unreserve_resources: 解除保留资源</li>
<li>create_volumes: 创建持久化卷</li>
<li>destroy_volumes: 删除持久化卷</li>
<li>update_weights: 更新权重</li>
</ul>
<p>Kubernetes的这些多租户的概念，mesos基本上也都有。就是在名称和具体功效上略有差别。比如，mesos的<a href="http://mesos.apache.org/documentation/latest/roles/" target="_blank" rel="external">角色</a>（role）就像是k8s的命名空间一样，指定role的framework只能使用特定role的mesos slave。在资源限额上，mesos支持<a href="http://mesos.apache.org/documentation/latest/quota/" target="_blank" rel="external">配额</a>和<a href="http://mesos.apache.org/documentation/latest/weights/" target="_blank" rel="external">权重</a>（Weights）。配额管的是保留资源以供未来使用，权重管的是角色分配的资源比例。可惜的是对角色和权重的修改都必须重新启动mesos master，而配额可以通过http请求动态修改。</p>
]]></content>
      
        <categories>
            
            <category> devops </category>
            
        </categories>
        
        
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> mesos </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[证书的那些事儿]]></title>
      <url>/certificate/</url>
      <content type="html"><![CDATA[<p>现在网络这么发达，许多人都在上面购物、理财、预约挂号…网络上传送的可都是自己的重要资料，比如身份证号，信用卡密码等。因特网如何才能保证这些敏感信息的安全？本文试着来探讨一下加密、证书等那些事儿。<br><a id="more"></a></p>
<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><h3 id="隐藏信息"><a href="#隐藏信息" class="headerlink" title="隐藏信息"></a>隐藏信息</h3><p>古代交通不便，一般都是通过送信的方式传递信息。那么如何保证信件的内容不被泄露呢？一种方法是隐藏字迹。中国古代使用矾书，也就是用明矾水来书写保密书信。水干之后没有任何痕迹，泡水时字才显示。还有一招是使用淀粉水在纸上写字，再把纸泡在碘水中显示字迹。据知乎的水波说<a href="https://www.zhihu.com/question/20986883/answer/16811680" target="_blank" rel="external">在西方世界里，也有使用牛奶或者羊奶书写信息，待干掉以后再用高温烘烤使之重新显现字迹的说法</a>。这些办法一旦为人所知，便会轻易被破解，而且还有点儿此地无银三百两的意思。</p>
<h3 id="加密信息"><a href="#加密信息" class="headerlink" title="加密信息"></a>加密信息</h3><p>除了隐藏信息以外，还有加密的方法。在宋代兵书《武经总要》里，<a href="https://www.zhihu.com/question/34846340/answer/60080691" target="_blank" rel="external">约定了40个常用的军事短语</a>，送信内容为一首40个字的五言律诗，每个字代表一个军事短语。然后在相应的字上做标记，对方就明白了，这个叫字验。这个就有点儿密码表的意思了。从知乎某匿名用户的回答上找了一张图：<br><img src="/img/ziyan.jpg" alt=""></p>
<p>在西方世界里，古希腊军队将长条羊皮纸缠绕在约定长度和粗细的木棍上书写，木棍称为Scytale。把羊皮纸解下来后就变成没有意义的字母了。古罗马的凯撒大帝用的是字母移位的办法。比如有封信写着：IFMMP，多半我们是不知道啥意思的。要是对方事先说明了把每个字母都右移一位的方法，也就是A变成B，B变成C…Z变成A，那我们就能很轻松地把IFMMP变成HELLO，明白对方的意思。</p>
<h2 id="现代"><a href="#现代" class="headerlink" title="现代"></a>现代</h2><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>对上文说的凯撒大帝移位法而言，“右移”就是算法（algorithm），一位的“1”就是密钥（key）。计算机普及后，最早的有影响力的算法是<a href="https://en.wikipedia.org/wiki/Data_Encryption_Standard" target="_blank" rel="external">DES</a>（Data Encryption Standard），它的秘钥是64位，但只有56位会用来计算。所以，只要最多尝试2<sup>56</sup>（大约是七万亿）次的暴力破解，就能解密。随着计算机硬件的发展，这个数量级在1998年只要56小时就能破解，到了1999年变成了24小时以内。这样就不够安全了。于是四年之后，<a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard" target="_blank" rel="external">AES</a>（Advanced Encryption Standard）取代了DES成为了新的标准。它可以使用128、192或256位密钥。最低的128位也能承受大约三千万亿亿次的暴力破解，至少目前看起来还算是比较安全的。在DES向AES的过渡期间，使用了<a href="https://en.wikipedia.org/wiki/Triple_DES" target="_blank" rel="external">3DES</a>算法。所谓3DES，可以理解成重要的事情做三遍，用不同密钥的DES加密三次，几乎也就等同于56×3=168位的密钥，这样也算是比较安全了。</p>
<h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>对称密钥有一个问题，就是密钥通过什么渠道来传输。加密算法再好，密钥被偷走了，也无济于事。在这样的背景下，非对称加密问世了。它的密钥包含着一个公钥和一个私钥。私钥顾名思义是只有你自己的电脑才知道的，公钥是公开的。用私钥加密的数据只有用公钥才能解开，同样的，用公钥加密的数据只有用私钥才能解开。假如两台电脑甲和乙相互通信，双方先把自己的公钥告诉对方。当甲给乙发消息时，用乙的公钥来加密，由于只有乙有相对应的私钥，所以只有乙能解密，甲要是忘记了消息内容连自己都解不了，更遑论第三方了。反之亦然。非对称加密最常用的算法是<a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)" target="_blank" rel="external">RSA</a>（发明者Rivest、Shmir和Adleman的姓氏首字母）。它的私钥和公钥是通过至少百位的大质数来生成的。由于在数学上很难计算大整数的因数，所以目前来说是比较安全的。万一哪天数学或<a href="http://www.guokr.com/question/530973/" target="_blank" rel="external">量子计算机</a>上有了突破，这种算法也就不再可靠了。1999年，512位的RSA被成功分解。2009年，768位的RSA也被成功分解。现在通用的1024位密钥可能也不那么可靠了，从安全的角度来说应该升级到2048位或以上。密钥这么大，非对称加密的速度比较慢（与对称加密有千倍的差距）也是可以理解的。所以在实际的使用当中一般用对称加密来加密数据，非对称加密来加密对称加密的密钥。</p>
<h3 id="散列算法"><a href="#散列算法" class="headerlink" title="散列算法"></a>散列算法</h3><p>好吧，密码破解不了，但是攻击者可以截取加密后的数据包，然后篡改。这样“传位十四皇子”就变成了“传位于四皇子”啦。散列算法堵死了这条路。它能把很长的数据变成固定长度的文本。也称为数据的<a href="https://en.wikipedia.org/w/index.php?title=Message_digest&amp;redirect=no" target="_blank" rel="external">摘要</a>（digest）或<a href="https://en.wikipedia.org/wiki/Fingerprint_(computing)" target="_blank" rel="external">指纹</a>（fingerprint）。相同数据的摘要一定是一样的，不同数据的摘要有可能一样，但是通常不一样。正因如此，散列算法是不可逆的，也就是说不能从数据摘要倒推出数据来。但是它可以用来校验数据是否被更改。如果数据有变化，那么摘要通常都是不一样的，概率取决于散列的长度，越长越不容易相同。配合上文所说的非对称加密，如果我用自己的私钥加密了某个摘要，那它就只有用我的公钥才能解密。这就说明了这个摘要一定是我发出的，因为别人不可能有我的私钥。进而推导出摘要所代表的消息也是由我发出的。这个加了密的摘要称为<a href="https://en.wikipedia.org/wiki/Digital_signature" target="_blank" rel="external">数字签名</a>（Digital signature）。它保证数据的完整性，确定数据的发出者，是具有法律效力的。</p>
<p>原来常用的散列算法有<a href="https://en.wikipedia.org/wiki/MD5" target="_blank" rel="external">MD5</a>和<a href="https://en.wikipedia.org/wiki/SHA-1" target="_blank" rel="external">SHA1</a>，2004年后，山东大学的王小云教授通过碰撞法分别攻破了这两种算法。也就是说，在已知摘要的情况下，可以很快计算出另一个拥有相同摘要的文本，这样就实现了文本篡改。行话叫散列碰撞（Hash Collision）。所以<a href="https://en.wikipedia.org/wiki/National_Security_Agency" target="_blank" rel="external">NSA</a>推出了<a href="https://en.wikipedia.org/wiki/SHA-2" target="_blank" rel="external">SHA2</a>和<a href="https://en.wikipedia.org/wiki/SHA-3" target="_blank" rel="external">SHA3</a>成为了新的标准。虽然MD5和SHA1被破解，也不用特别在意。因为虽然能找到相同摘要的数据，但是篡改者并不能随心所欲地把数据修改成自己想要的样子。</p>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><h3 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL/TLS"></a>SSL/TLS</h3><p>有了加密算法，是不是传输就安全了呢？确实如果严格去用的话，是安全了，但是也麻烦了很多。每次都要跟对方沟通用什么算法，传送密钥，传送摘要…累不累？所以需要有一套协议，大家都遵守这样的协议，就能少掉很多我们不需要太关注的、技术上的事情。这个协议叫做<a href="https://en.wikipedia.org/w/index.php?title=Secure_Sockets_Layer&amp;redirect=no" target="_blank" rel="external">SSL</a>（Secure Sockets Layer）。它所做的事情，主要就是上面说的交换公钥，用对方的公钥加密数据，用自己的私钥解密，还支持MD5用于验证数据的完整性。SSL是网景公司发明的，由于应用广泛，成为了事实上的标准。<a href="https://en.wikipedia.org/wiki/Internet_Engineering_Task_Force" target="_blank" rel="external">IETF</a>（Internet Engineering Task Force）在1999年把SSL 3.0标准化，称为<a href="https://en.wikipedia.org/wiki/Transport_Layer_Security" target="_blank" rel="external">TLS</a>（Transport Layer Security）。除了标准化以外，相对SSL来说TLS也更加安全一些。</p>
<h3 id="HTTP-HTTPS"><a href="#HTTP-HTTPS" class="headerlink" title="HTTP/HTTPS"></a>HTTP/HTTPS</h3><p>因特网发明后，大部分的网站都是用的<a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol" target="_blank" rel="external">HTTP</a>协议。这个协议关心的是如何方便地获取到自己需要的资源，并不关心安全性。如果你的网络被监视（比如你的wifi提供者，运营商等等），对方是可以明文看到你的所有信息的，行话叫嗅探（sniffer）。在HTTP上应用SSL/TLS的协议叫做<a href="https://en.wikipedia.org/wiki/HTTPS" target="_blank" rel="external">HTTPS</a>（HTTP over SSL/TLS）。有了它，我们就还可以像以前的HTTP那样方便地在网上冲浪，而不用太担心安全问题，但不是完全不需要担心，一会儿我们会说到。</p>
<p>顺便说一句，SSL/TLS并不是只能用于HTTP，还可以用于<a href="https://en.wikipedia.org/wiki/File_Transfer_Protocol" target="_blank" rel="external">FTP</a>（File Transfer Protocol）、<a href="https://en.wikipedia.org/wiki/Simple_Mail_Transfer_Protocol" target="_blank" rel="external">SMTP</a>（Simple Mail Transfer Protocol）等一系列应用层协议。</p>
<h2 id="CA及证书"><a href="#CA及证书" class="headerlink" title="CA及证书"></a>CA及证书</h2><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>前面说到了HTTPS，为什么有了这么安全的技术我们还是不能高枕无忧呢？这是因为：虽然它能保证我们的信息不被第三方破解，但是它绕不开一个很现实的绕口问题：你怎么知道他就是他声称的那个他？举个栗子：你以为正在访问的网站是某个银行，但是却不知道其实你被钓鱼（phishing）了。对方正等着你输入你的银行卡号和密码，好用它们去真正的银行网站给自己转账。这一切发生得这么自然，你的信息只有钓鱼网站能解密看到，钓鱼网站的信息也只有你能解密看到…就算是你注意到了对方的域名，也有可能因为0和O、1和l傻傻分不清楚或者<a href="https://en.wikipedia.org/wiki/Domain_hijacking" target="_blank" rel="external">域名劫持</a>（domain hijacking）而上当。数字证书就是用来阻止这事儿发生的。虽然我不认识你，但是如果我认识一个很知名的家伙，他肯为你做担保，那我也可以相信你。这个知名的家伙就叫<a href="https://en.wikipedia.org/wiki/Certificate_authority" target="_blank" rel="external">CA</a>（Certificate Authority）。它为通信的双方起了一个中间人的作用。CA的担保就叫<a href="https://en.wikipedia.org/wiki/Public_key_certificate" target="_blank" rel="external">数字证书</a>（Digital Certificate或Public Key Certificate）。这个证书是什么格式，有什么内容呢？这是由<a href="https://en.wikipedia.org/wiki/Public_key_infrastructure" target="_blank" rel="external">PKI</a>（Public Key Infrastructure）标准决定的。常用的标准有<a href="https://en.wikipedia.org/wiki/X.509" target="_blank" rel="external">X.509</a>和<a href="https://en.wikipedia.org/wiki/PKCS_12" target="_blank" rel="external">PKCS #12</a>。它们定义了证书里应该含有签发机构名、证书用户名、有效期、算法、公钥等信息。</p>
<h3 id="信任链"><a href="#信任链" class="headerlink" title="信任链"></a>信任链</h3><p>回到刚才的问题：你怎么知道他就是他声称的那个他？我无条件地信任CA，网站又有了CA的数字证书，我就能信任他就是证书里声称的那个他。如果我因为对CA的信任而有了损失，则证书可以用来追究CA的法律责任。如果我们信任A，A信任B，B信任C，那么我们也会信任B和C，这个叫做<a href="https://en.wikipedia.org/wiki/Chain_of_trust" target="_blank" rel="external">证书信任链</a>（Chain of trust）。中间的B称为<a href="https://hk.godaddy.com/en/help/what-is-an-intermediate-certificate-868" target="_blank" rel="external">中级证书</a>（Intermediate certificate），位于信任链顶端的A称为<a href="https://en.wikipedia.org/wiki/Root_certificate" target="_blank" rel="external">根证书</a>（Root certificate）。如果根证书出了问题，那么它所信任的其它证书也就不再可信了。这个后果可是非常严重，可能会影响整个因特网的信任体系。所以，需要尽可能地少动用根证书以减少根证书的私钥被盗用的风险。如果网站想要被认证，直接用中级证书认证就好了。万一中级证书出问题，吊销掉中级证书也只会影响一部分客户，比整个根证书被吊销掉强。但事情也不绝对。对CA来说，公信力就是一切。说个案例：<a href="https://en.wikipedia.org/wiki/China_Internet_Network_Information_Center" target="_blank" rel="external">中国互联网络信息中心</a>（China Internet Network Information Center，CNNIC）是中国的顶级域名<code>.cn</code>和中文域名的注册管理机构。MCS集团用CNNIC签发的中级证书，发行了多个冒充成Google的假证书。于是在2015年4月份，chrome、firefox都宣布不再信任CNNIC的证书。如果你用chrome来打开<a href="https://www.cnnic.net.cn/" target="_blank" rel="external">https://www.cnnic.net.cn/</a>，应该会看到：<br><img src="/img/https_untrust.png" alt=""></p>
<p>而不是：<br><img src="/img/https_trust.png" alt=""></p>
<p>一般来说操作系统和浏览器都会内置一些信任的CA，比较著名的有公信力的CA有Verisign，GeoTrust等。我们打开google的时候，也能点击小锁看到它的证书：<br><img src="/img/google-ca.jpg" alt=""></p>
<p>再点击证书信息就能看到它的证书链。最上面的是GeoTrust的根证书，它包含的内容都在里面写着了，感兴趣的话就自己看看吧：<br><img src="/img/ca1.jpg" alt=""></p>
<p>中间的是谷歌自己的中级证书：<br><img src="/img/ca2.jpg" alt=""></p>
<p>最后是站点自己的证书，这个有效期一般比较短：<br><img src="/img/ca3.jpg" alt=""></p>
<p>证书是可以自签名的，也就是说，你自己作为CA来发行这个证书。当然，这个证书也只有你自己会信任，广大的网友同志们的眼睛是雪亮的，不会无缘无故地信任你的。那如果我是大企业，是不是就值得信任了？谷歌、微软等通常都是可以信任的。12306，你信任它吗？每个人都会有自己的答案吧。打开<a href="https://www.12306.cn/" target="_blank" rel="external">12306</a>看看它的根证书，SRCA（SinoRail Certification Authority）是个什么鬼？这个是中国铁路自己啊。知道为什么首页上总有一个“为保障您顺畅购票，请下载安装根证书”的提示了吧。</p>
<h3 id="申请证书"><a href="#申请证书" class="headerlink" title="申请证书"></a>申请证书</h3><p>首先，如果你觉得自己的网站没有什么信息不能公开的，那就没必要费那钱和时间去购买证书。</p>
<p>证书有很多种类型，价格也很不一样，大约一年数千到数万元人民币吧。简单列出几种：</p>
<ul>
<li>通配符证书（Wildcard SSL Certificates）：自己的域名和下一级子域名可以使用。比如<code>google.com</code>和<code>maps.google.com</code>就是域名和二级子域名的关系</li>
<li>多域名证书（Subject Alternative Name SSL Certificates）：不仅限于子域名，不同域名也能使用</li>
<li>增强型证书（Extended Validation SSL Certificate）：总之就是验证流程更麻烦，结果就是可以在地址栏显示公司的名称，增加可信度。就像这样：<br><img src="/img/github-ca.jpg" alt=""></li>
</ul>
<p>申请证书需要给CA提供一个<a href="https://en.wikipedia.org/wiki/Certificate_signing_request" target="_blank" rel="external">CSR</a>（certificate sigining request）文件。通常做法就是通过程序把域名、联系人和公钥等信息都放在这个文件里，发送给某个CA。交费之后，如果CA方面没有问题，就会对CSR文件设置有效期等操作，当然还需要用自己的私钥对证书签名，再发送给用户。最后用户把证书绑定到自己的网站上。</p>
<h2 id="动手时间"><a href="#动手时间" class="headerlink" title="动手时间"></a>动手时间</h2><h3 id="加解密"><a href="#加解密" class="headerlink" title="加解密"></a>加解密</h3><p><a href="https://en.wikipedia.org/wiki/OpenSSL" target="_blank" rel="external">OpenSSL</a>是SSL/TLS的开源实现，我们就用它来练练手吧。首先，用DES加解密文本：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> Hello World! | openssl enc -e -des -a    <span class="comment">## 需要输入两次密码，如果你输入的都是1，那么可以用下一条命令解密</span></div><div class="line"><span class="built_in">echo</span> U2FsdGVkX19NMXhTRoTNJE0YV+TKcRL0+xzT9UMUN5Y= | openssl enc -d -des -a</div></pre></td></tr></table></figure></p>
<p>其中的<code>-a</code>代表base64编码。还可以多试几次加密，就算文本、密码相同，每次加密的结果也很可能是不一样的。把上面的<code>-des</code>变成<code>-des3</code>或者是<code>-aes-256-cbc</code>就可以自行尝试DES3和AES加解密了。接下来尝试RSA。首先生成RSA的私钥：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">openssl genrsa -out private.pem 2048</div><div class="line">cat private.pem</div></pre></td></tr></table></figure></p>
<p>PEM表示这是base64编码的密钥，也可以改成DER即二进制的密钥，加上一个<code>-outform DER</code>的参数就行。然后通过私钥生成公钥：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">openssl rsa -<span class="keyword">in</span> private.pem -pubout -out public.pem</div><div class="line">cat public.pem</div></pre></td></tr></table></figure></p>
<p>接下来用刚刚生成的公钥加密，私钥解密：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> Hello World! | openssl rsautl -encrypt -pubin -inkey public.pem -out encrypt</div><div class="line">cat encrypt</div><div class="line">cat encrypt | openssl rsautl -decrypt -inkey private.pem</div></pre></td></tr></table></figure></p>
<p>然后私钥加密，公钥解密。注意这个的意义其实是私钥签名，公钥认证：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> Hello World! | openssl rsautl -sign -inkey private.pem -out encrypt</div><div class="line">cat encrypt</div><div class="line">cat encrypt | openssl rsautl -verify -pubin -inkey public.pem</div></pre></td></tr></table></figure></p>
<h3 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h3><p>现在轮到散列算法了：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> Hello World! | openssl dgst -md5</div><div class="line"><span class="built_in">echo</span> Hello World! | openssl dgst -sha1</div></pre></td></tr></table></figure></p>
<p>也可以用linux自带的小工具实现：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> Hello World! | md5sum</div><div class="line"><span class="built_in">echo</span> Hello World! | sha1sum</div><div class="line"><span class="built_in">echo</span> Hello World! | sha224sum</div><div class="line"><span class="built_in">echo</span> Hello World! | sha256sum</div><div class="line"><span class="built_in">echo</span> Hello World! | sha384sum</div><div class="line"><span class="built_in">echo</span> Hello World! | sha512sum</div></pre></td></tr></table></figure></p>
<p>是不是越来越长了？散列越长越不容易被碰撞。</p>
<h3 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h3><p>申请证书，首先需要生成CSR文件。而CSR文件需要先生成私钥：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">openssl genrsa -out private.pem 2048</div><div class="line">openssl req -new -key private.pem -out domain.csr</div><div class="line">cat domain.csr</div></pre></td></tr></table></figure></p>
<p>生成私钥文件是可以加密的，加上一个参数比如<code>-des3</code>就可以了。生成CSR文件的时候需要填写各种信息，没耐心就随便写点什么甚至一路回车也行，反正又不是真的去找CA。如果你真的有需求，<a href="https://support.rackspace.com/how-to/generate-a-csr-with-openssl/#create-a-csr" target="_blank" rel="external">这里有一张表格</a>说明了应该怎么填。填完的东西可以这么看：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">openssl req -noout -text -<span class="keyword">in</span> domain.csr</div></pre></td></tr></table></figure></p>
<p>现在我们假装自己是个CA，有自己的密钥对，然后对刚才提交的CSR文件签名：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">openssl genrsa -out private_ca.pem 2048</div><div class="line">openssl x509 -req -days 365 -<span class="keyword">in</span> domain.csr -signkey private_ca.pem -out my_domain.crt</div><div class="line">cat my_domain.crt</div></pre></td></tr></table></figure></p>
<p>大功告成！生成的my_domain.crt就是我们要的证书。由于这个是自签名证书，默认是不被我们的操作系统信任的。如果我们需要增加信任，可以参考<a href="https://briansnelson.com/How_to_add_trusted_root_certificates" target="_blank" rel="external">这里</a>。比如在Ubuntu/Debian里可以这么做：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo cp my_domain.crt /usr/<span class="built_in">local</span>/share/ca-certificates/</div><div class="line">sudo update-ca-certificates</div></pre></td></tr></table></figure></p>
<p>如果要取消信任，可以这么做：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo rm /usr/<span class="built_in">local</span>/share/ca-certificates/my_domain.crt</div><div class="line">sudo update-ca-certificates --fresh</div></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://computer.howstuffworks.com/encryption.htm" target="_blank" rel="external">How Encryption Works</a><br><a href="http://victor1980.blog.51cto.com/3664622/1659447" target="_blank" rel="external">有关SSL证书的一些事儿</a><br><a href="http://seanlook.com/2015/01/07/tls-ssl/" target="_blank" rel="external">SSL/TLS原理详解</a><br><a href="http://seanlook.com/2015/01/15/openssl-certificate-encryption/" target="_blank" rel="external">OpenSSL 与 SSL 数字证书概念贴</a><br><a href="https://program-think.blogspot.com/2010/02/introduce-digital-certificate-and-ca.html" target="_blank" rel="external">数字证书及 CA 的扫盲介绍</a><br><a href="https://program-think.blogspot.com/2014/11/https-ssl-tls-1.html" target="_blank" rel="external">扫盲 HTTPS 和 SSL/TLS 协议</a><br><a href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html" target="_blank" rel="external">数字签名是什么？</a><br><a href="http://boxingp.github.io/blog/2015/04/04/should-cnnic-certificate-to-be-trusted/" target="_blank" rel="external">CNNIC证书值得信任吗？</a></p>
]]></content>
      
        <categories>
            
            <category> devops </category>
            
        </categories>
        
        
        <tags>
            
            <tag> encryption </tag>
            
            <tag> https </tag>
            
            <tag> certficate </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用容器轻松搭建Portus运行环境]]></title>
      <url>/portus/</url>
      <content type="html"><![CDATA[<p>Docker官方并没有提供docker registry的用户界面，对权限的控制粒度也比较粗。SUSE的<a href="http://port.us.org/" target="_blank" rel="external">Portus</a>很好地解决了这个问题。除了界面以外，它还提供了更细粒度的权限控制、用户认证等功能。本文尝试从零开始用容器搭建一个portus环境。<br><a id="more"></a></p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>我们需要先安装<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="external">virtualBox</a>和<a href="https://www.vagrantup.com/downloads.html" target="_blank" rel="external">vagrant</a>。通过vagrant来驱动virtualBox搭建一个虚拟测试环境。首先在本地任意路径新建一个空文件夹比如<code>test</code>，运行以下命令：<br><figure class="highlight sh"><figcaption><span>virtual box host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mkdir <span class="built_in">test</span></div><div class="line"><span class="built_in">cd</span> <span class="built_in">test</span></div><div class="line">vagrant init minimum/ubuntu-trusty64-docker</div><div class="line">vi Vagrantfile</div></pre></td></tr></table></figure></p>
<p>里面应该有一句<code>config.vm.box = &quot;minimum/ubuntu-trusty64-docker&quot;</code>，在它的下面添加如下几行代码，相当于给它分配一台IP是<strong>192.168.33.18</strong>的虚拟机。Registry配上portus会比较耗内存，所以我们给它2G内存，默认是512M。<br><figure class="highlight ruby"><figcaption><span>Vagrantfile</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">config.vm.network <span class="string">"private_network"</span>, <span class="symbol">ip:</span> <span class="string">"192.168.33.18"</span></div><div class="line">config.vm.provider <span class="string">"virtualbox"</span> <span class="keyword">do</span> <span class="params">|v|</span></div><div class="line">  v.memory = <span class="number">2048</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p>这个vagrant镜像已经在ubuntu的基础上帮我们安装了docker，用起来很方便。然后在终端运行以下命令启动并连接虚拟机。<br><figure class="highlight sh"><figcaption><span>virtual box host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vagrant up</div><div class="line">vagrant ssh</div></pre></td></tr></table></figure></p>
<h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p>我们将会把docker registry和portus都安装在同一台虚拟机上。一方面是比较方便，另一方面也避免了<a href="https://github.com/SUSE/Portus/issues/510" target="_blank" rel="external">时钟同步问题</a>。为了启动一个带认证的docker registry，首先要生成自签名证书：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">cat &lt;&lt; EOF &gt; ssl.conf</div><div class="line">[ req ]</div><div class="line">prompt             = no</div><div class="line">distinguished_name = req_subj</div><div class="line">x509_extensions    = x509_ext</div><div class="line"></div><div class="line">[ req_subj ]</div><div class="line">CN = Localhost</div><div class="line"></div><div class="line">[ x509_ext ]</div><div class="line">subjectKeyIdentifier   = <span class="built_in">hash</span></div><div class="line">authorityKeyIdentifier = keyid,issuer</div><div class="line">basicConstraints       = CA:<span class="literal">true</span></div><div class="line">subjectAltName         = @alternate_names</div><div class="line"></div><div class="line">[ alternate_names ]</div><div class="line">DNS.1 = localhost</div><div class="line">IP.1  = 192.168.33.18</div><div class="line">EOF</div><div class="line"></div><div class="line">sudo mkdir /certs</div><div class="line">sudo sh -c <span class="string">"openssl req -config ssl.conf \</span></div><div class="line">-new -x509 -nodes -sha256 -days 365 -newkey rsa:4096 \</div><div class="line">-keyout /certs/server-key.pem -out /certs/server-crt.pem"</div></pre></td></tr></table></figure></p>
<p>证书生成好了，但是由于这是自签名证书，客户端还需要配置证书文件：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo mkdir -p /etc/docker/certs.d/192.168.33.18:5000</div><div class="line">sudo cp /certs/server-crt.pem /etc/docker/certs.d/192.168.33.18:5000/ca.crt</div><div class="line">sudo service docker restart</div></pre></td></tr></table></figure></p>
<p>接下来生成一个registry的配置文件，里面指定刚才的证书和token方式的认证。认证服务器设置到一会儿要启动的portus去：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">cat &lt;&lt; EOF &gt; config.yml</div><div class="line">version: 0.1</div><div class="line">loglevel: debug</div><div class="line">storage:</div><div class="line">    cache:</div><div class="line">        blobdescriptor: inmemory</div><div class="line">    filesystem:</div><div class="line">        rootdirectory: /var/lib/registry</div><div class="line">    delete:</div><div class="line">        enabled: <span class="literal">true</span></div><div class="line">http:</div><div class="line">    addr: :5000</div><div class="line">    headers:</div><div class="line">        X-Content-Type-Options: [nosniff]</div><div class="line">    tls:</div><div class="line">        certificate: /certs/server-crt.pem</div><div class="line">        key: /certs/server-key.pem</div><div class="line">auth:</div><div class="line">    token:</div><div class="line">        realm: https://192.168.33.18/v2/token</div><div class="line">        service: 192.168.33.18:5000</div><div class="line">        issuer: 192.168.33.18</div><div class="line">        rootcertbundle: /certs/server-crt.pem</div><div class="line">notifications:</div><div class="line">    endpoints:</div><div class="line">      - name: portus</div><div class="line">        url: https://192.168.33.18/v2/webhooks/events</div><div class="line">        timeout: 500ms</div><div class="line">        threshold: 5</div><div class="line">        backoff: 1s</div><div class="line">EOF</div></pre></td></tr></table></figure></p>
<p>然后就可以启动registry容器了：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">docker run -d \</div><div class="line">    --name registry \</div><div class="line">    -p 5000:5000 \</div><div class="line">    --restart=always \</div><div class="line">    -v /var/lib/registry:/var/lib/registry \</div><div class="line">    -v /certs:/certs \</div><div class="line">    -v `<span class="built_in">pwd</span>`/config.yml:/etc/docker/registry/config.yml \</div><div class="line">    registry:2.3.0</div></pre></td></tr></table></figure></p>
<p>Docker registry配置完成后，就该准备portus了。Portus需要一个数据库来存储信息，官方推荐<a href="https://mariadb.org/" target="_blank" rel="external">MariaDB</a>，当然mysql也是没问题的。我们把数据库启动起来：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">docker run -d \</div><div class="line">    --name mariadb \</div><div class="line">    --net=host \</div><div class="line">    --restart=always \</div><div class="line">    -e MYSQL_ROOT_PASSWORD=123456 \</div><div class="line">    -e TERM=xterm \</div><div class="line">    mariadb:10.1.10</div></pre></td></tr></table></figure></p>
<p>等数据库启动完成，我们连接上去：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> -it mariadb mysql -uroot -p123456</div></pre></td></tr></table></figure></p>
<p>为portus创建用户和数据库：<br><figure class="highlight sh"><figcaption><span>sql</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">create database portus;</div><div class="line">GRANT ALL ON portus.* TO <span class="string">'portus'</span>@<span class="string">'%'</span> IDENTIFIED BY <span class="string">'portus'</span>;</div><div class="line"><span class="built_in">exit</span></div></pre></td></tr></table></figure></p>
<p>万事俱备，让我们来启动portus：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">docker run -it -d \</div><div class="line">    --name portus \</div><div class="line">    --net host \</div><div class="line">    --restart=always \</div><div class="line">    -v /certs:/certs \</div><div class="line">    -v /usr/sbin/update-ca-certificates:/usr/sbin/update-ca-certificates \</div><div class="line">    -v /etc/ca-certificates:/etc/ca-certificates \</div><div class="line">    --env DB_ADAPTER=mysql2 \</div><div class="line">    --env DB_ENCODING=utf8 \</div><div class="line">    --env DB_HOST=192.168.33.18 \</div><div class="line">    --env DB_PORT=3306 \</div><div class="line">    --env DB_USERNAME=portus \</div><div class="line">    --env DB_PASSWORD=portus \</div><div class="line">    --env DB_DATABASE=portus \</div><div class="line">    --env RACK_ENV=production \</div><div class="line">    --env RAILS_ENV=production \</div><div class="line">    --env PUMA_SSL_KEY=/certs/server-key.pem \</div><div class="line">    --env PUMA_SSL_CRT=/certs/server-crt.pem \</div><div class="line">    --env PUMA_PORT=443 \</div><div class="line">    --env PUMA_WORKERS=4 \</div><div class="line">    --env MACHINE_FQDN=192.168.33.18 \</div><div class="line">    --env SECRETS_SECRET_KEY_BASE=secret-goes-here \</div><div class="line">    --env SECRETS_ENCRYPTION_PRIVATE_KEY_PATH=/certs/server-key.pem \</div><div class="line">    --env SECRETS_PORTUS_PASSWORD=portuspw \</div><div class="line">    h0tbird/portus:v2.0.2-1</div></pre></td></tr></table></figure></p>
<p>启动完成后，在浏览器打开<code>https://192.168.33.18/</code>，应该会看到证书不被浏览器所信任的提示。无视之，选择继续的话，应该就能看到注册页面啦：<br><img src="/img/portus-sign-up.jpg" alt=""></p>
<h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><p>Portus现在只能管理一个私有库。它有一个团队的概念，每一个团队可以有多个命名空间，每个命名空间就是多个镜像的集合。每个团队有三种角色：</p>
<ul>
<li>查看者（Viewer）：只能pull镜像</li>
<li>贡献者（Contributor）：除了pull，还可以push镜像</li>
<li>所有者（Owner）：除了推拉镜像，还可以对团队成员进行管理</li>
</ul>
<p>由于角色是定义在团队里的，所以命名空间就不需要再考虑权限问题了，它只是镜像的集合而已。命名空间也有三种类型：</p>
<ul>
<li>全局（Global）：只有管理员可以push，其他人只能pull</li>
<li>团队（Team）：团队成员可以做自己角色支持的操作</li>
<li>个人（Personal）：只有所有者和管理员可以推拉</li>
</ul>
<p>命名空间还可以设置为public，这样不需要login也能pull。</p>
<p>说完一些基本概念，让我们来尝试一下。首先，portus需要配置一个用户，来调用docker registry的API，与其进行同步。<a href="http://port.us.org/docs/How-to-setup-secure-registry.html#synchronizing-the-registry-and-portus" target="_blank" rel="external">同步</a>有<a href="http://port.us.org/features/1_Synchronizing-the-Registry-and-Portus.html" target="_blank" rel="external">两种方式</a>：一是在docker registry的配置文件里写的<code>notifications</code>，这样每当有人push一个新镜像上去，docker registry将会通知portus修改数据库。可是时间长了，有可能数据库偶尔挂掉或是网络不稳定啥的导致两边数据不一致。Portus针对这种情况也提供了一个crono的job，设置定时运行即可，一会儿我们会试验。现在先让我们来创建这个用户：<br><figure class="highlight sh"><figcaption><span>registry</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> portus bundle <span class="built_in">exec</span> rake portus:create_api_account</div></pre></td></tr></table></figure></p>
<p>接下来就可以在注册页面自行注册啦，注册完毕后会跳转到登记registry页面：<br><img src="/img/portus-new-registry.jpg" alt=""></p>
<p>照上图填入registry，点击<strong>Create</strong>按钮创建一个docker registry。接着创建一个新用户。点击左边的<strong>Admin</strong>，再点击中间的<strong>Users</strong>，然后点击右边的<strong>Create new user</strong>，填写用户信息：<br><img src="/img/portus-new-user.jpg" alt=""></p>
<p>点击<strong>Add</strong>按钮就可以创建一个新用户了。接下来创建一个团队。点击左边的<strong>Teams</strong>，再点击右边的<strong>Create new team</strong>，填写团队信息：<br><img src="/img/portus-new-team.jpg" alt=""></p>
<p>点击<strong>Add</strong>按钮就可以创建一个新团队了。点击刚刚创建好的团队，再点击右边的<strong>Add namespace</strong>，填写命名空间信息：<br><img src="/img/portus-new-namespace.jpg" alt=""></p>
<p>点击<strong>Add</strong>按钮就可以创建一个新命名空间了。接下来把用户添加到这个团队中。点击右边的<strong>Add members</strong>，填写刚才增加的用户信息：<br><img src="/img/portus-new-member.jpg" alt=""></p>
<p>点击<strong>Add</strong>按钮就可以把用户加进来了。回到控制台，搞一个镜像，push一下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker pull microbox/etcd:2.1.1</div><div class="line">docker tag microbox/etcd:2.1.1 192.168.33.18:5000/microbox/etcd:2.1.1</div><div class="line">docker push 192.168.33.18:5000/microbox/etcd:2.1.1</div></pre></td></tr></table></figure></p>
<p>出错了：<strong>unauthorized: authentication required</strong>，我们必须用docker先登录：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker login -u gggg -e gggg@123.com 192.168.33.18:5000</div></pre></td></tr></table></figure></p>
<p>填上自己刚才设置的密码，登录成功之后，再试着push一下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker push 192.168.33.18:5000/microbox/etcd:2.1.1</div></pre></td></tr></table></figure></p>
<p>Bingo！换一个命名空间试试看：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker tag h0tbird/portus:v2.0.2-1 192.168.33.18:5000/h0tbird/portus:v2.0.2-1</div><div class="line">docker push 192.168.33.18:5000/h0tbird/portus:v2.0.2-1</div></pre></td></tr></table></figure></p>
<p>出错了：<strong>unauthorized: authentication required</strong>，可见我们的权限控制确实起作用了。</p>
<h2 id="镜像同步"><a href="#镜像同步" class="headerlink" title="镜像同步"></a>镜像同步</h2><p>接下来我们试试定时同步任务。首先需要在容器里信任我们的自签名证书：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> portus mkdir /usr/<span class="built_in">local</span>/share/ca-certificates</div><div class="line">docker cp /certs/server-crt.pem portus:/usr/<span class="built_in">local</span>/share/ca-certificates/ca.crt</div><div class="line">docker <span class="built_in">exec</span> portus update-ca-certificates</div></pre></td></tr></table></figure></p>
<p>然后启动定时同步任务，设置为每10秒钟同步一次：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> -it portus bash</div><div class="line">RAILS_ENV=production CATALOG_CRON=<span class="string">"10.seconds"</span> bundle <span class="built_in">exec</span> crono</div></pre></td></tr></table></figure></p>
<p>等十秒钟，就会看到<strong>[catalog] Created the tag ‘2.1.1’</strong>的提示。如果先前没有信任自签名证书，同步的时候会报<strong>certificate verify failed</strong>的错误。现在回到portus的界面，点击左边的<strong>Dashboard</strong>，就能看到刚才push的microbox/etcd镜像已经显示在右边了：<br><img src="/img/portus-dashboard.jpg" alt=""></p>
<p>最后一步就是自动同步了，先把刚才的crono给Ctrl+C掉，Ctrl+D退出portus容器。由于docker registry需要调用portus的API，所以我们需要在registry容器里也信任这个证书：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker cp /certs/server-crt.pem registry:/usr/<span class="built_in">local</span>/share/ca-certificates/ca.crt</div><div class="line">docker <span class="built_in">exec</span> registry update-ca-certificates</div><div class="line">sudo service docker restart</div></pre></td></tr></table></figure></p>
<p>然后再push一个镜像：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker tag registry:2.3.0 192.168.33.18:5000/microbox/registry:2.3.0</div><div class="line">docker push 192.168.33.18:5000/microbox/registry:2.3.0</div></pre></td></tr></table></figure></p>
<p>到portus的dashboard刷新一下，搞定！在中间的<strong>Recent activities</strong>还能看到是谁push的这个镜像，对审计、追踪来说很有帮助。</p>
]]></content>
      
        <categories>
            
            <category> devops </category>
            
        </categories>
        
        
        <tags>
            
            <tag> docker registry </tag>
            
            <tag> portus </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HTC VIVE初体验]]></title>
      <url>/vr-htc-vive/</url>
      <content type="html"><![CDATA[<p>没想到到深圳来出差，竟然碰上了<a href="https://bbs.htc.com/cn/news.php?mod=viewthread&amp;tid=68841" target="_blank" rel="external">HTC Vive中国开发者峰会</a>。虽然我不是VR开发者，但怎么说也是一名消费者，借着周末赶紧去体验了一把。趁着现在热乎劲还没过去，写一下我的一些见闻及感受吧。<br><a id="more"></a></p>
<h2 id="日程"><a href="#日程" class="headerlink" title="日程"></a>日程</h2><p>3月9~11日是开发者峰会，11~18日的每天10:00~18:00是公众开放体验时间，可以在深圳大学附近的威盛科技大厦29层参与免费体验。一共有8个项目，分为A、B两组，每组4个项目。一次排队只能排一个组，每人有十分钟的时间，可以自己选择两个项目来体验。A组有蓝色世界、空间画刷、神秘商店和太空海盗，较B组来说会稍微刺激一些。B组有机器人修理、亚利桑那阳光、未来办公室和预算消减（真个怪名字）。具体项目内容下文会详细叙述。</p>
<h2 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h2><p>Vive包含一个头戴设备（含耳机），两个手柄和两个基站。玩之前先坐在椅子上，首先工作人员会帮忙戴上头戴设备及耳机。Vive是可以把眼镜一起套在设备里的。第一次体验的时候，戴得比较正，几乎感觉不出来里面还有个我自己的眼镜。第二次的工作人员就有点儿不那么专业，戴着不那么舒服，也影响了效果。可见姿势很重要。这时候眼前看到的是一片白色的背景，还有很多经纬线。往下看的话，有很多同心圆，中心就是自己所在的位置。如果转向了，可以根据脚下的显示回到中心。这感觉像是Vive的操作系统。上下左右前后都是有内容的，都可以扭头、转身去看。但是光转动眼珠子是不行的哦，因为Vive是根据陀螺仪来判断方位的。底下稍稍有点儿漏光，不过不注意的话也不太能感觉出来。这时旁边的工作人员会帮助选择要体验的项目，教玩家一些基本用法。之后工作人员把手柄递给我。这时我眼前看到的是两个悬空的手柄在等着我伸手去够。在没有准备的时候可能会吓一小跳。手柄下面有扳机，两侧有按钮，大拇指可以够着正面，有一个圆形的触摸板，也可以当作按钮按下。然后工作人员让我站起来，我可以自由移动了。如果快要碰到实体墙的话，眼镜里会有虚拟的透明墙出现，这时就知道不要再过去了，不然要碰鼻子滴。</p>
<p>很快工作人员用电脑帮我调到第一个项目：亚利桑那阳光。这是个打僵尸的游戏，那两个带扳机的手柄就是我的手枪，按下触摸板可以装子弹。工作人员提醒我向左边看，我一扭头，原来是几个玻璃瓶。用手枪瞄准玻璃瓶，把它们都打碎，游戏也就正式开始了。手枪带有激光瞄准，准心处是有红点的，所以知道子弹会射向哪里，但是因为手总是不可能完全静止，会有轻微的抖动，所以射击出来也不是那么的准，需要适应一下。画面随即切换到了户外，估计是亚利桑那洲吧，有几个僵尸向我冲过来。用刚才的手枪把僵尸们都干掉吧。随着剧情的深入，可以拿到更高级的武器，打起来也就更爽了。可惜手柄没有震动反馈，不然加上后坐力一定更能带来更深的沉浸感。如果仔细观看，还是有一些颗粒感的。</p>
<p>五分钟很快就结束了，接下来是未来办公室项目。这是一个虚拟的办公室，工作人员会引导我用手柄拿杯子，接咖啡，开抽屉，拿文件，开电脑什么的。中间咖啡杯没拿稳还摔地上了，可惜了一整杯咖啡 ：） 吐个槽，怎么未来办公室的电脑屏幕还是CRT的呢，也太不和谐了。</p>
<p>B组的两个项目体验完了，我就到A组去，这回排了一个半小时。听说这还是快的了，去年12月在北京的活动，都需要排3个小时队。接下来我选的项目是神秘商店。我在一个商店里，寻找白色的图腾。每找到一个，商店就会把我传送到另一个地方去。可能出现各种奇怪的东西，比如一个盒子里蹦出来一个弹簧人，吓了我一跳。可以拿手上的手柄（这次是魔法杖）狠狠地抽它。</p>
<p>然后是太空海盗。这也是一个射击游戏。两个手柄一个是枪，一个是盾。海盗们源源不断地乘小飞机逼近并射击我，需要用盾挡住他们的进攻并用枪把他们击落。由于这个比较立体，不像上面打僵尸那个游戏，僵尸只会在地面跑，所以难度还是会大一点的。</p>
<p>A组也体验了两个项目，接下来继续回到B组。中午了，排队的人少了一些，这回只用了一个小时就排到了。首先是预算消减。这是一个密室逃脱类游戏，由于空间限制，不可能无限制地走动，所以是通过手柄来移动的。剧情上，大约就是费劲心思搞到一把刀，然后用它去捅某个怪物…我比较愚钝一点，反倒是被怪物给捅了…</p>
<p>下一个是机器人修理。一开始先是开抽屉等基本动作，然后大门打开，有个有问题的机器人过来，让我帮忙修理它。也不知道是我水平不行还是程序设计如此，总之没有修好，然后地板自动翻开，机器人变成一堆零件掉了下去。虽然知道实际上只是普通的地板而已，但是看着脚下的深渊，还是不由的让人感叹如此深的沉浸感。</p>
<p>本想就此结束体验，但是听说剩下的A组两个项目都是最好玩的…于是咬咬牙又等了一个半小时。这回是蓝色世界。我在一艘沉船上，看着周围的鱼儿游来游去。后来来了一条大鲸鱼，细节之处看得非常清楚。最后鲸鱼游走，大尾巴打过来，那种感觉还是很震撼的。</p>
<p>最后一个项目是google开发的空间画刷。一支手柄是菜单，另一支是画笔。只要旋转菜单手柄就可以切换菜单，再用画笔手柄来选择。中间工作人员会帮助切换不同的背景，比如雪世界等等。而画笔也能画出不同的效果，比如火焰般的燃烧效果。而这一切都是在三维空间上存在着的，于是乎就有了神笔马良般的感觉。Google出品，果然不一般。可惜啊，体验时间很快又结束了。就这么的一天过去了。不过一个项目也没落下，还是很值得的。</p>
<h2 id="行业现状"><a href="#行业现状" class="headerlink" title="行业现状"></a>行业现状</h2><p>现在的现实模拟技术主要分为两类：VR（Virtual Reality）虚拟现实和AR（Augmented Reality）增强现实。前者就像玩游戏那样，一切都是假的。后者是在现实中增加虚拟的物体，代表产品有谷歌眼镜和微软的HoloLens。VR贵则数千，便宜则一两百甚至几十。高级的代表产品有Oculus Rift（这就是被facebook以20亿刀收购的公司开发的产品），PS VR（还未发售，据说快了）和HTC Vive（最贵，但效果也最好，支持几平米级别的移动）。为了减少头晕现象，需要提高刷新率至90Hz，降低延迟至15ms。除了PS VR有PS4以外，另外两款都需要配合高性能PC（至少970以上显卡才能玩转，整机估计得上万元了）才能跑得动，这也有点儿限制了高端VR的普及。便宜的VR以三星Gear VR、暴风魔镜等为代表，不像高端VR那样自带屏幕，一般就是透镜加手机。甚至谷歌搞出一个Cardboard，就是纸盒加透镜。由于大众手机分辨率目前一般是1920×1080，分成左右眼的两个屏幕后就变成960×1080，如果看片的话，由于影片的宽高比，1080还得往下降到540左右，所以导致颗粒感比较明显。如果配上更高的分辨率和源文件，那效果就会更好一些。当然这个价格的话，体验体验还是可以的哈。其实还有一个混合现实（Mixed Reality），它包括增强现实和增强虚拟，在新的可视化环境里物理和数字对象共存，并实时互动。不过目前还是以研究居多，暂时还没有代表产品问世。</p>
<p>体验完最顶级的VR后，正好这几天又碰上阿尔法狗大胜李世石。看来黑客帝国的时代离我们人类不远了。</p>
]]></content>
      
        <categories>
            
            <category> vr </category>
            
        </categories>
        
        
        <tags>
            
            <tag> HTC Vive </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[轻松搭建Docker Registry运行环境]]></title>
      <url>/docker-registry/</url>
      <content type="html"><![CDATA[<p>我们知道Docker官方提供了一个公有的registry叫做Docker Hub。但是企业内部可能有些镜像还是不方便放到公网上去，所以docker也提供了registry镜像来让需要的人自己搭建私有仓库。本文从零开始搭建Docker Registry的运行环境，并添加用户界面和认证功能。<br><a id="more"></a></p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>我们需要先安装<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="external">virtualBox</a>和<a href="https://www.vagrantup.com/downloads.html" target="_blank" rel="external">vagrant</a>。通过vagrant来驱动virtualBox搭建一个虚拟测试环境。首先在本地任意路径新建一个空文件夹比如<code>test</code>，运行以下命令：<br><figure class="highlight sh"><figcaption><span>virtual box host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mkdir <span class="built_in">test</span></div><div class="line"><span class="built_in">cd</span> <span class="built_in">test</span></div><div class="line">vagrant init minimum/ubuntu-trusty64-docker</div><div class="line">vi Vagrantfile</div></pre></td></tr></table></figure></p>
<p>里面应该有一句<code>config.vm.box = &quot;minimum/ubuntu-trusty64-docker&quot;</code>，在它的下面添加如下几行代码，相当于给它分配两台虚拟机，一台叫做<strong>registry</strong>，它的IP是<strong>192.168.33.18</strong>；另一台叫做<strong>client</strong>，它的IP是<strong>192.168.33.19</strong>。Registry配上界面会比较耗内存，所以我们给它1G内存，默认是512M。<br><figure class="highlight ruby"><figcaption><span>Vagrantfile</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">config.vm.define <span class="string">"registry"</span> <span class="keyword">do</span> <span class="params">| host |</span></div><div class="line">  host.vm.hostname = <span class="string">"registry"</span></div><div class="line">  host.vm.network <span class="string">"private_network"</span>, <span class="symbol">ip:</span> <span class="string">"192.168.33.18"</span></div><div class="line">  host.vm.provider <span class="string">"virtualbox"</span> <span class="keyword">do</span> <span class="params">|v|</span></div><div class="line">    v.memory = <span class="number">1024</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">config.vm.define <span class="string">"client"</span> <span class="keyword">do</span> <span class="params">| host |</span></div><div class="line">  host.vm.hostname = <span class="string">"client"</span></div><div class="line">  host.vm.network <span class="string">"private_network"</span>, <span class="symbol">ip:</span> <span class="string">"192.168.33.19"</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p>这个vagrant镜像已经在ubuntu的基础上帮我们安装了docker，用起来很方便。然后分别在两个终端运行以下命令启动并连接两台虚拟机。<br><figure class="highlight sh"><figcaption><span>virtual box host terminal 1</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vagrant up</div><div class="line">vagrant ssh registry</div></pre></td></tr></table></figure></p>
<figure class="highlight sh"><figcaption><span>virtual box host terminal 2</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vagrant ssh client</div></pre></td></tr></table></figure>
<h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p>启动一个registry是很容易的：<br><figure class="highlight sh"><figcaption><span>registry</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">docker run -d \</div><div class="line">    -p 5000:5000 \</div><div class="line">    --name registry \</div><div class="line">    --restart=always \</div><div class="line">    -v /var/lib/registry:/var/lib/registry \</div><div class="line">    registry:2.3.0</div></pre></td></tr></table></figure></p>
<p>这里指定了一个<code>/var/lib/registry</code>的卷，是为了把真实的镜像数据储存在主机上，而别在容器挂掉之后丢失数据。就算这样，也还是不保险。要是主机挂了呢？Docker官方建议可以放到<a href="https://github.com/docker/distribution/blob/master/docs/storage-drivers/rados.md" target="_blank" rel="external">ceph</a>、<a href="https://github.com/docker/distribution/blob/master/docs/storage-drivers/swift.md" target="_blank" rel="external">swift</a>这样的存储里，或是<a href="https://github.com/docker/distribution/blob/master/docs/storage-drivers/s3.md" target="_blank" rel="external">亚马逊S3</a>、<a href="https://github.com/docker/distribution/blob/master/docs/storage-drivers/azure.md" target="_blank" rel="external">微软Azure</a>、<a href="https://github.com/docker/distribution/blob/master/docs/storage-drivers/gcs.md" target="_blank" rel="external">谷歌GCS</a>、<a href="https://github.com/docker/distribution/blob/master/docs/storage-drivers/oss.md" target="_blank" rel="external">阿里云OSS</a>之类的云商那里。Docker registry提供了配置文件，可以从容器里复制出来查看：<br><figure class="highlight sh"><figcaption><span>registry</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker cp registry:/etc/docker/registry/config.yml config.yml</div><div class="line">cat config.yml</div></pre></td></tr></table></figure></p>
<p>配置文件里有一个<code>storage</code>，按照<a href="https://github.com/docker/distribution/blob/master/docs/configuration.md#storage" target="_blank" rel="external">这里</a>写的配置，然后执行以下命令重新挂载这个文件来启动registry就可以了，有条件的话可以去试一试：<br><figure class="highlight sh"><figcaption><span>registry</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">docker rm -fv registry</div><div class="line">docker run -d \</div><div class="line">    -p 5000:5000 \</div><div class="line">    --name registry \</div><div class="line">    --restart=always \</div><div class="line">    -v /var/lib/registry:/var/lib/registry \</div><div class="line">    -v `<span class="built_in">pwd</span>`/config.yml:/etc/docker/registry/config.yml \</div><div class="line">    registry:2.3.0</div></pre></td></tr></table></figure></p>
<p>Docker Registry配置完了，我们在client上传一个镜像试试：<br><figure class="highlight sh"><figcaption><span>client</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker pull busybox:1.24.1</div><div class="line">docker tag busybox:1.24.1 192.168.33.18:5000/busybox:1.24.1</div><div class="line">docker push 192.168.33.18:5000/busybox:1.24.1</div></pre></td></tr></table></figure></p>
<p>结果push的时候就挂了。原来是我们没有配置认证信息，所以这是一个“不安全”的registry。Docker要求在docker daemon的启动参数里增加<code>--insecure-registry</code>，才能允许我们上传镜像：<br><figure class="highlight sh"><figcaption><span>client</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo sh -c <span class="string">'echo DOCKER_OPTS=\"--insecure-registry 192.168.33.18:5000\" &gt;&gt; /etc/default/docker'</span></div><div class="line">sudo service docker restart</div><div class="line">docker push 192.168.33.18:5000/busybox:1.24.1</div></pre></td></tr></table></figure></p>
<p>这回就没问题啦。同样地在registry端也配置一下，然后把registry:2.3.0这个镜像上传：<br><figure class="highlight sh"><figcaption><span>registry</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo sh -c <span class="string">'echo DOCKER_OPTS=\"--insecure-registry 192.168.33.18:5000\" &gt;&gt; /etc/default/docker'</span></div><div class="line">sudo service docker restart</div><div class="line">docker tag registry:2.3.0 192.168.33.18:5000/library/registry:2.3.0</div><div class="line">docker push 192.168.33.18:5000/library/registry:2.3.0</div></pre></td></tr></table></figure></p>
<p>如果是没有用户的镜像（通常是官方镜像），打标签和上传都需要加一个<code>library/</code>。客户端必须再配置一个参数<code>--registry-mirror</code>才能在我们自己的私有registry里下载镜像：<br><figure class="highlight sh"><figcaption><span>client</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo sed -i <span class="string">'$d'</span> /etc/default/docker</div><div class="line">sudo sh -c <span class="string">'echo DOCKER_OPTS=\"--insecure-registry 192.168.33.18:5000 --registry-mirror http://192.168.33.18:5000\" &gt;&gt; /etc/default/docker'</span></div><div class="line">sudo service docker restart</div><div class="line">docker pull registry:2.3.0</div></pre></td></tr></table></figure></p>
<p>应该有飞一般的感觉了吧。如果镜像不在registry里，客户端会自动去docker hub下载。但是每次打标签再上传岂不是很麻烦？所幸docker提供了一个proxy的功能。只要在<code>config.yml</code>里增加如下配置，重启registry容器即可。这样，客户端pull的镜像，也会自动同步到registry里去。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">proxy:</div><div class="line">  remoteurl: https://registry-1.docker.io</div></pre></td></tr></table></figure></p>
<h2 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h2><p>Docker官方只提供了REST API，并没有给我们一个界面。好在有热心人士出马，所以我们只需执行以下命令就可以给我们的私有库提供一个UI了：<br><figure class="highlight sh"><figcaption><span>registry</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">docker run -d \</div><div class="line">    -p 8080:8080 \</div><div class="line">    --name web \</div><div class="line">    -e REGISTRY_HOST=172.17.0.1 \</div><div class="line">    -e REGISTRY_PORT=5000\</div><div class="line">    hyper/docker-registry-web</div></pre></td></tr></table></figure></p>
<p>然后打开<code>http://192.168.33.18:8080</code>，应该就能看到如下界面：<br><img src="/img/docker-registry-web.png" alt=""></p>
<p>上面是个简易版，如果有更深入的需求，可以尝试SUSE的<a href="http://port.us.org/" target="_blank" rel="external">Portus</a>。除了界面以外，它还提供了更细粒度的权限控制、用户认证等功能。</p>
<h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p>我们刚刚配好的insecure registry是不支持认证的，如果要上产品环境，找CA申请一个证书吧。我们自己测试的话，可以用自签名证书。我们准备使用IP代替域名，所以需要在证书里面包含我们的IP：<br><figure class="highlight sh"><figcaption><span>registry</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sudo mkdir /certs</div><div class="line">sudo sed -i <span class="string">'/^\[ v3_ca \]$/a subjectAltName = IP:192.168.33.18'</span> /etc/ssl/openssl.cnf</div><div class="line">sudo sh -c <span class="string">"openssl req \</span></div><div class="line">    -newkey rsa:4096 -nodes -sha256 -keyout /certs/domain.key \</div><div class="line">    -x509 -days 365 -out /certs/domain.crt"</div></pre></td></tr></table></figure></p>
<p>随便填点值完成这繁琐的流程，就能看见certs里面多了两个文件。现在可以用以下命令来启动registry：<br><figure class="highlight sh"><figcaption><span>registry</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">docker rm -f registry</div><div class="line">docker run -d \</div><div class="line">    -p 5000:5000 \</div><div class="line">    --name registry \</div><div class="line">    --restart=always \</div><div class="line">    -v /var/lib/registry:/var/lib/registry \</div><div class="line">    -v /certs:/certs \</div><div class="line">    -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/domain.crt \</div><div class="line">    -e REGISTRY_HTTP_TLS_KEY=/certs/domain.key \</div><div class="line">    registry:2.3.0</div></pre></td></tr></table></figure></p>
<p>客户端现在就不需要<code>--insecure-registry</code>了，但是由于这是自签名证书，客户端还需要把证书文件复制过去：<br><figure class="highlight sh"><figcaption><span>client</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo sed -i <span class="string">'$d'</span> /etc/default/docker</div><div class="line">sudo mkdir -p /etc/docker/certs.d/192.168.33.18:5000/</div><div class="line">sudo scp vagrant@192.168.33.18:/certs/domain.crt /etc/docker/certs.d/192.168.33.18:5000/ca.crt</div><div class="line">sudo service docker restart</div></pre></td></tr></table></figure></p>
<p>注意vagrant的默认密码也是vagrant。现在push就没有问题了：<br><figure class="highlight sh"><figcaption><span>client</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker push 192.168.33.18:5000/busybox:1.24.1</div></pre></td></tr></table></figure></p>
<p>提示镜像已经存在，并没有阻止我们提交。接下来我们加上认证。首先在registry生成用户名hello和密码world：<br><figure class="highlight sh"><figcaption><span>registry</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo mkdir /auth</div><div class="line">sudo sh -c <span class="string">"docker run --entrypoint htpasswd registry:2.3.0 -Bbn hello world &gt; /auth/htpasswd"</span></div></pre></td></tr></table></figure></p>
<p>还得指定认证方式和认证文件等参数，重新启动registry容器：<br><figure class="highlight sh"><figcaption><span>registry</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">docker rm -f registry</div><div class="line">docker run -d \</div><div class="line">    -p 5000:5000 \</div><div class="line">    --name registry \</div><div class="line">    --restart=always \</div><div class="line">    -v /var/lib/registry:/var/lib/registry \</div><div class="line">    -v /auth:/auth \</div><div class="line">    -v /certs:/certs \</div><div class="line">    -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/domain.crt \</div><div class="line">    -e REGISTRY_HTTP_TLS_KEY=/certs/domain.key \</div><div class="line">    -e REGISTRY_AUTH=htpasswd \</div><div class="line">    -e REGISTRY_AUTH_HTPASSWD_REALM=<span class="string">"Registry Realm"</span> \</div><div class="line">    -e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd \</div><div class="line">    registry:2.3.0</div></pre></td></tr></table></figure></p>
<p>这回客户端用<code>docker push 192.168.33.18:5000/busybox:1.24.1</code>来尝试push就会失败啦。但是我们可以用用户名hello和密码world登录啦：<br><figure class="highlight sh"><figcaption><span>client</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker login -u hello -p world -e email_whatever 192.168.33.18:5000</div></pre></td></tr></table></figure></p>
<p>再次push，就没有问题了：<br><figure class="highlight sh"><figcaption><span>client</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker push 192.168.33.18:5000/busybox:1.24.1</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> devops </category>
            
        </categories>
        
        
        <tags>
            
            <tag> docker </tag>
            
            <tag> docker registry </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[轻松搭建nfs存储环境]]></title>
      <url>/nfs-demo/</url>
      <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Network_File_System" target="_blank" rel="external">NFS</a>是1984年SUN公司开发的一套网络文件系统。它能够让用户像在本机一样操作远程文件。本文用一个比较简单的方式来搭建NFS试验环境。<br><a id="more"></a></p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>我们需要先安装<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="external">virtualBox</a>和<a href="https://www.vagrantup.com/downloads.html" target="_blank" rel="external">vagrant</a>。通过vagrant来驱动virtualBox搭建一个虚拟测试环境。首先在本地任意路径新建一个空文件夹比如<code>test</code>，运行以下命令：<br><figure class="highlight sh"><figcaption><span>virtual box host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mkdir <span class="built_in">test</span></div><div class="line"><span class="built_in">cd</span> <span class="built_in">test</span></div><div class="line">vagrant init ubuntu/trusty64</div><div class="line">vi Vagrantfile</div></pre></td></tr></table></figure></p>
<p>里面应该有一句<code>config.vm.box = &quot;ubuntu/trusty64&quot;</code>，在它的下面添加如下几行代码，相当于给它分配两台虚拟机，一台叫做<strong>server</strong>，它的IP是<strong>192.168.33.17</strong>；另外一台叫做<strong>client</strong>，它的IP是<strong>192.168.33.18</strong>。我们将会在<strong>server</strong>上启动nfs服务并共享一个目录，然后在client挂载并操作这个目录。<br><figure class="highlight ruby"><figcaption><span>Vagrantfile</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">config.vm.define <span class="string">"server"</span> <span class="keyword">do</span> <span class="params">| host |</span></div><div class="line">  host.vm.hostname = <span class="string">"server"</span></div><div class="line">  host.vm.network <span class="string">"private_network"</span>, <span class="symbol">ip:</span> <span class="string">"192.168.33.17"</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">config.vm.define <span class="string">"client"</span> <span class="keyword">do</span> <span class="params">| host |</span></div><div class="line">  host.vm.hostname = <span class="string">"client"</span></div><div class="line">  host.vm.network <span class="string">"private_network"</span>, <span class="symbol">ip:</span> <span class="string">"192.168.33.18"</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p>分别在两个终端运行以下命令启动并连接两台虚拟机。<br><figure class="highlight sh"><figcaption><span>virtual box host terminal 1</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vagrant up</div><div class="line">vagrant ssh server</div></pre></td></tr></table></figure></p>
<figure class="highlight sh"><figcaption><span>virtual box host terminal 2</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vagrant ssh client</div></pre></td></tr></table></figure>
<h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p>启动nfs服务需要nfs-kernel-server这个包，让我们安装并启动：<br><figure class="highlight sh"><figcaption><span>server</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install -y nfs-kernel-server</div><div class="line">sudo service nfs-kernel-server start</div></pre></td></tr></table></figure></p>
<p>服务启动完成后，会生成一个<code>/etc/exports</code>文件，里面就是nfs的配置。我们创建一个文件夹<code>/tmp/nfs</code>，把它配置成nfs的目录，然后重新启动nfs服务：<br><figure class="highlight sh"><figcaption><span>server</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mkdir /tmp/nfs</div><div class="line">sudo sh -c <span class="string">"echo '/tmp/nfs *(rw,no_subtree_check,no_root_squash)' &gt;&gt; /etc/exports"</span></div><div class="line">sudo service nfs-kernel-server start</div></pre></td></tr></table></figure></p>
<p>往<code>/etc/exports</code>里写的那一行里，<code>*</code>代表允许所有的客户端访问。如果只想让192.168.33.18访问，把星号改为这个IP就好了。需要支持多个IP的话，用逗号分隔就行。括号里的<code>rw</code>表示允许读写。<code>no_subtree_check</code>表示在服务器端不检查此nfs文件夹的父目录权限。<code>no_root_squash</code>表示客户端root用户也被视为对此nfs文件夹有全部权限的服务端root用户，生产环境不建议使用，因为那样nfs上的文件就可能被随意篡改。想要了解更多的设置，请自行<code>man exports</code>。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>这时候我们就可以去client挂载server的这个nfs目录了：<br><figure class="highlight sh"><figcaption><span>client</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo mount -t nfs 192.168.33.17:/tmp/nfs /mnt</div><div class="line">ls /mnt</div></pre></td></tr></table></figure></p>
<p>往里面写一个文件：<br><figure class="highlight sh"><figcaption><span>client</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> <span class="string">"Hello World!"</span> &gt; /mnt/hw.txt</div><div class="line">ll /mnt</div></pre></td></tr></table></figure></p>
<p>然后去server端看一下，是不是已经被同步过来了：<br><figure class="highlight sh"><figcaption><span>server</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ll /tmp/nfs</div></pre></td></tr></table></figure></p>
<p>Server端也可以往nfs的文件夹里写文件：<br><figure class="highlight sh"><figcaption><span>server</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> <span class="string">"Hello NFS"</span> &gt; /tmp/nfs/hn.txt</div></pre></td></tr></table></figure></p>
<p>照样可以同步到client端：<br><figure class="highlight sh"><figcaption><span>client</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ll /mnt</div></pre></td></tr></table></figure></p>
<p>无论server端还是client端，都可以通过下面这个命令来查看<code>192.168.33.17</code>上公开了哪些nfs文件夹：<br><figure class="highlight sh"><figcaption><span>server or client</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">showmount -e 192.168.33.17</div></pre></td></tr></table></figure></p>
<p>再来一个nfs2文件夹：<br><figure class="highlight sh"><figcaption><span>server</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mkdir /tmp/nfs2</div><div class="line">sudo sh -c <span class="string">"echo '/tmp/nfs2 *(rw,no_subtree_check,no_root_squash)' &gt;&gt; /etc/exports"</span></div></pre></td></tr></table></figure></p>
<p>这时候再<code>showmount -e 192.168.33.17</code>看一下，<code>/tmp/nfs2</code>并没有出现在列表中。因为nfs并不会去监视<code>/etc/exports</code>这个文件，所以这时候它还不知道我们改变了配置。虽然重新启动nfs服务可以解决这个问题，但是它会中断现存的nfs服务。建议使用以下命令：<br><figure class="highlight sh"><figcaption><span>server</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo exportfs -ar    <span class="comment"># a代表所有的文件夹，r代表重新导出</span></div></pre></td></tr></table></figure></p>
<p>这时候在再<code>showmount -e 192.168.33.17</code>看一下，<code>/tmp/nfs2</code>已经出来啦。加载一下：<br><figure class="highlight sh"><figcaption><span>client</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo umount /mnt</div><div class="line">sudo mount -t nfs 192.168.33.17:/tmp/nfs2 /mnt</div><div class="line">ls /mnt</div></pre></td></tr></table></figure></p>
<p>完全没问题。</p>
]]></content>
      
        <categories>
            
            <category> linux/unix </category>
            
        </categories>
        
        
        <tags>
            
            <tag> storage </tag>
            
            <tag> nfs </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如果有10000台机器，你想怎么玩？（八）网络]]></title>
      <url>/kubernetes-in-mesos-8/</url>
      <content type="html"><![CDATA[<p>这次聊聊docker、k8s、mesos+k8s的网络，了解一下容器、pod和服务间是怎样通信的。</p>
<ul>
<li><a href="/kubernetes-in-mesos-1">如果有10000台机器，你想怎么玩？（一）概述</a></li>
<li><a href="/kubernetes-in-mesos-2">如果有10000台机器，你想怎么玩？（二）高可用</a></li>
<li><a href="/kubernetes-in-mesos-3">如果有10000台机器，你想怎么玩？（三）持久化</a></li>
<li><a href="/kubernetes-in-mesos-4">如果有10000台机器，你想怎么玩？（四）监控</a></li>
<li><a href="/kubernetes-in-mesos-5">如果有10000台机器，你想怎么玩？（五）日志</a></li>
<li><a href="/kubernetes-in-mesos-6">如果有10000台机器，你想怎么玩？（六）性能</a></li>
<li><a href="/kubernetes-in-mesos-7">如果有10000台机器，你想怎么玩？（七）生命周期</a></li>
<li><a href="/kubernetes-in-mesos-8">如果有10000台机器，你想怎么玩？（八）网络</a></li>
<li><a href="/kubernetes-in-mesos-9">如果有10000台机器，你想怎么玩？（九）安全性</a><a id="more"></a>
</li>
</ul>
<h2 id="Docker的网络模型"><a href="#Docker的网络模型" class="headerlink" title="Docker的网络模型"></a>Docker的网络模型</h2><p>Docker默认使用<a href="/docker-bridge-network">桥接网络</a>。Docker daemon启动时，会在主机上启动一个名为docker0的网桥接口。当容器启动的时候，自动分配一对VETH设备，一个连接到docker0上，另一个连接到容器内部的eth0里，于是同一台主机上的容器便能够跨越网络的命名空间，经由主机相互通信。可是不同的主机上的容器就不是那么简单的了。有一种办法是把容器的端口映射到主机的某个端口上去，这样其他主机上的容器可以通过访问这个主机端口的方式实现跨主机通信。Docker 1.6版本之后发布了一个<a href="/docker-overlay-network">覆盖网络</a>overlay network。当使用这个覆盖网络的时候，它便能实现容器的跨主机通信和隔离。</p>
<h2 id="Kubernetes的网络模型"><a href="#Kubernetes的网络模型" class="headerlink" title="Kubernetes的网络模型"></a><a href="http://kubernetes.io/docs/admin/networking/" target="_blank" rel="external">Kubernetes的网络模型</a></h2><p>Kubernetes把每个pod当成是一个节点，在这个pod内的所有容器的网络命名空间是共享的，也就意味着它们共享着一个IP地址。Pod内的容器可以用localhost相互通信，与其他容器通信时，直接使用其他pod的IP地址就可以了。如果把每个pod当成一个虚拟机，这样的设计方式是再正常不过的了。用户无需再去考虑pod间的通信问题，也不用考虑pod和主机端口映射的问题了。从这样的易用性出发，kubernetes对网络有三个要求：</p>
<ul>
<li>所有的容器可以在不使用NAT的情况下相互通信</li>
<li>所有的主机和容器可以在不使用NAT的情况下相互通信</li>
<li>容器自己的IP和外部看它的IP是一样的</li>
</ul>
<p>Kubernetes项目启动的时候，docker还只提供了桥接网络。所以单纯地安装docker和kubernetes并不能够满足kubernetes对网络的要求。常见的公有云如GCE、AWS的基础设施都是默认满足网络要求的。私有云的话，一个方法是直接路由，也就是在所有主机的路由表增加其他主机的docker0网桥。但是，增删主机时所有节点都需要重新配置，非常麻烦。另一种方法使用覆盖网络来实现容器跨主机互通，操作相对容易一些。有不少人使用<a href="https://github.com/coreos/flannel#flannel" target="_blank" rel="external">Flannel</a>，也有人使用<a href="http://kubernetes.io/docs/admin/ovs-networking/" target="_blank" rel="external">Open vSwitch</a>、<a href="https://github.com/zettio/weave" target="_blank" rel="external">Weave</a>、<a href="https://github.com/Metaswitch/calico" target="_blank" rel="external">Calico</a>。就flannel来说，它的网络传输如下图：<br><img src="https://raw.githubusercontent.com/coreos/flannel/master/packet-01.png" alt=""></p>
<p>Flannel会在每个主机上运行一个叫做flanneld的代理，它通过etcd保证所有主机上的容器都不会出现重复IP，并能通过物理网络将数据包投递到目标节点的flanneld去。有兴趣的话可以参考<a href="http://dockone.io/article/618" target="_blank" rel="external">《一篇文章带你了解Flannel》</a>。大部分通过覆盖网络实现跨主机容器互通的方案是工作在L2层，在性能上是有些损耗的，但是Calico略微有点不一样。它直接工作在L3层，没有封包解包的损耗，所以性能上影响很小。所付出的代价就是它仅能支持TCP、UDP、ICMP等协议，不过通常来说也足够了。Open vSwitch功能强大，但是配置也比较麻烦。</p>
<p>虽然docker 1.9版正式宣布内置的覆盖网络可以使用在产品环境了，但是kubernetes并不打算支持docker的覆盖网络，据说技术上最主要的原因是kubernetes并不仅仅是为docker这一种容器技术服务的，kubernetes既不想再引入一个键值存储，也不愿意把自己的键值存储暴露给docker用。当然如果用户自己把docker需要的键值存储管理起来，docker自己的覆盖网络还是能够工作的。非技术上的原因是kubernetes认为docker不够开放，都是因为利益啊。详情可以参考<a href="http://blog.kubernetes.io/2016/01/why-Kubernetes-doesnt-use-libnetwork.html" target="_blank" rel="external">这篇文章</a>。</p>
<h2 id="Kubernetes的服务"><a href="#Kubernetes的服务" class="headerlink" title="Kubernetes的服务"></a><a href="http://kubernetes.io/docs/user-guide/services/" target="_blank" rel="external">Kubernetes的服务</a></h2><p>Kubernetes是怎么做到一个pod内的容器只有一个IP地址的呢？假如我们启动一个包含俩容器的pod，然后到启动pod的那台虚拟机查看，就会发现除了这两个容器之外，kubernetes另外还启动了一个叫做<code>gcr.io/google_containers/pause</code>的容器。Pod自身的两个容器都是通过在<code>docker run</code>时，net指定使用pause容器网络的办法，把自己需要的端口由pause容器暴露出来的。如下图所示：<br><img src="/img/pause.png" alt=""></p>
<p>当我们通过replication controller，把pod暴露为服务的时候，kubernetes会通过etcd，为这个服务分配一个唯一的虚拟IP。这样做的好处是：避免了用户自己定义的端口有可能重复的问题。每个kube-proxy都会往iptables里写一条关于service虚拟IP的规则。当内部用户使用这个服务的时候，这个虚拟IP便会把流量导入到kube-proxy监听的某个端口上，由kube-proxy使用轮询或基于客户端IP的会话保持的方式，决定最终来提供服务的pod。外部用户由于没有kube-proxy，是不能访问这个服务的，除非我们把服务通过负载均衡或者NodePort的方式暴露出去，本文就不再赘述了。</p>
<h2 id="Kubernetes-Mesos的网络模型"><a href="#Kubernetes-Mesos的网络模型" class="headerlink" title="Kubernetes-Mesos的网络模型"></a><a href="https://github.com/kubernetes/kubernetes/blob/master/contrib/mesos/docs/issues.md#user-content-endpoints" target="_blank" rel="external">Kubernetes-Mesos的网络模型</a></h2><p>Mesos使用最基本的Docker网络模型，也就是主机内共享的桥接网络。这点跟kubernetes的要求是矛盾的。所以当一个pod的端点（endpoint），也就是以<strong>pod的IP:端口</strong>的格式暴露出来的时候，由于pod的IP并不能被其他主机所访问，就会导致通信出问题。于是Kubernetes-Mesos开发组想了一个权宜之计：把端点以<strong>主机IP:端口</strong>的格式暴露出来。由于主机的IP是在集群内是都能访问的，所以只要开放端口，通信就能正常工作。如果用户没有指定主机的端口，那就随机分配一个。这个策略是可以通过指定scheduler和controller-manager的启动参数<code>-host-port-endpoints=false</code>（默认为true）来绕过去的，也就是能恢复到kubernetes默认的网络方案去，不过我们就得自己来想办法实现容器的跨主机通信了。</p>
]]></content>
      
        <categories>
            
            <category> devops </category>
            
        </categories>
        
        
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> mesos </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Docker的覆盖网络是怎么工作的]]></title>
      <url>/docker-overlay-network/</url>
      <content type="html"><![CDATA[<p>我们都知道docker支持多种网络，覆盖网络overlay顾名思义，就是指建立在另一个网络上的网络。比如p2p技术，就是建立在因特网上的覆盖网络。而因特网，原来也是建立在电话网络上的覆盖网络，但现在，电话网络更像是建立在因特网上的覆盖网络（引自<a href="https://en.wikipedia.org/wiki/Overlay_network" target="_blank" rel="external">维基百科</a>）。Docker使用覆盖网络可以解决容器跨主机互通和隔离的问题。在覆盖网络这个领域里，除了docker的overlay network以外，Flannel、Calico、Weave等也都是干这个的。<br><a id="more"></a></p>
<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>如果把容器的网络驱动设置成overlay，就意味着所有的容器都可以直接ping通，所以所有容器的ip地址都不会重复。为了做到这一点，就需要一个轻量级的存储来存放已经分配出去的ip信息，和其它的一些配置信息。技术上Docker使用了<a href="https://github.com/docker/libkv" target="_blank" rel="external">libkv</a>和<a href="https://github.com/docker/libnetwork" target="_blank" rel="external">libnetwork</a>来实现自己的覆盖网络。它们都是用go语言所写，前者是对操作分布式键值存储系统如consul，etcd，zookeeper的抽象层，后者实现了容器的网络连接，它的设计如下图：<br><img src="https://raw.githubusercontent.com/docker/libnetwork/master/docs/cnm-model.jpg" alt=""></p>
<p>容器网络模型由三部分组成：</p>
<ul>
<li>Sandbox：保存着容器的网络配置，一个Sandbox里可以有多个Endpoint</li>
<li>Endpoint：可以通过Network和其他的Endpoint通信，每个Endpoint都只在一个网络里</li>
<li>Network：由数个可以相互通信的Endpoint组成，不同的网络相互隔离</li>
</ul>
<p>基于这个网络模型，在同一个网络里的所有容器，都是可以相互通信的。如果容器需要隔离，创建另一个网络即可。通过<a href="/docker-swarm">创建Swarm集群</a>来应用覆盖网络是个很自然的做法，也是docker官方的推荐。而kubernetes并不打算支持docker的覆盖网络，据说技术上最主要的原因是kubernetes并不仅仅是为docker这一种容器技术服务的，kubernetes既不想再引入一个键值存储，也不愿意把自己的键值存储暴露给docker用。当然如果用户自己把docker需要的键值存储管理起来，docker自己的覆盖网络还是能够工作的。非技术上的原因是kubernetes认为docker不够开放，都是因为利益啊。详情可以参考<a href="http://blog.kubernetes.io/2016/01/why-Kubernetes-doesnt-use-libnetwork.html" target="_blank" rel="external">这篇文章</a>。这里为了不引入更多复杂度，我们不用Swarm，直接使用原生的docker daemon来做实验。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>我们需要先安装<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="external">virtualBox</a>和<a href="https://www.vagrantup.com/downloads.html" target="_blank" rel="external">vagrant</a>。通过vagrant来驱动virtualBox搭建一个虚拟测试环境。首先在本地任意路径新建一个空文件夹比如<code>test</code>，运行以下命令：<br><figure class="highlight sh"><figcaption><span>virtual box host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mkdir <span class="built_in">test</span></div><div class="line"><span class="built_in">cd</span> <span class="built_in">test</span></div><div class="line">vagrant init minimum/ubuntu-trusty64-docker</div><div class="line">vi Vagrantfile</div></pre></td></tr></table></figure></p>
<p>里面应该有一句<code>config.vm.box = &quot;minimum/ubuntu-trusty64-docker&quot;</code>，在它的下面添加如下几行代码，相当于给它分配三台虚拟机，一台叫做<strong>conf</strong>，它的IP是<strong>192.168.33.19</strong>；另两台叫做<strong>node1</strong>和<strong>node2</strong>，它们的IP是<strong>192.168.33.17</strong>和<strong>192.168.33.18</strong>。<br><figure class="highlight ruby"><figcaption><span>Vagrantfile</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">config.vm.define <span class="string">"node1"</span> <span class="keyword">do</span> <span class="params">| host |</span></div><div class="line">  host.vm.hostname = <span class="string">"node1"</span></div><div class="line">  host.vm.network <span class="string">"private_network"</span>, <span class="symbol">ip:</span> <span class="string">"192.168.33.17"</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">config.vm.define <span class="string">"node2"</span> <span class="keyword">do</span> <span class="params">| host |</span></div><div class="line">  host.vm.hostname = <span class="string">"node2"</span></div><div class="line">  host.vm.network <span class="string">"private_network"</span>, <span class="symbol">ip:</span> <span class="string">"192.168.33.18"</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">config.vm.define <span class="string">"conf"</span> <span class="keyword">do</span> <span class="params">| host |</span></div><div class="line">  host.vm.hostname = <span class="string">"conf"</span></div><div class="line">  host.vm.network <span class="string">"private_network"</span>, <span class="symbol">ip:</span> <span class="string">"192.168.33.19"</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p>这个vagrant镜像已经在ubuntu的基础上帮我们安装了docker，用起来很方便。然后分别在三个终端运行以下命令启动并连接三台虚拟机。<br><figure class="highlight sh"><figcaption><span>virtual box host terminal 1</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vagrant up</div><div class="line">vagrant ssh node1</div></pre></td></tr></table></figure></p>
<figure class="highlight sh"><figcaption><span>virtual box host terminal 2</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vagrant ssh node2</div></pre></td></tr></table></figure>
<figure class="highlight sh"><figcaption><span>virtual box host terminal 3</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vagrant ssh conf</div></pre></td></tr></table></figure>
<p>Ubuntu 14.04的内核版本是3.13，而<a href="https://github.com/docker/docker/issues/14145" target="_blank" rel="external">使用docker overlay网络需要Linux内核版本3.16+</a>，所以需要升级内核，建议升级到3.19或以上。因为我们用node1和node2来跑覆盖网络，所以只用升级这两台虚拟机就好了，conf不用管。命令如下：<br><figure class="highlight sh"><figcaption><span>node1 and node2</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install linux-generic-lts-vivid</div><div class="line"></div><div class="line">sudo reboot</div></pre></td></tr></table></figure></p>
<p>等待重启之后，重新连接进vagrant虚拟机：<br><figure class="highlight sh"><figcaption><span>virtual box host terminal 1</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vagrant ssh node1</div></pre></td></tr></table></figure></p>
<figure class="highlight sh"><figcaption><span>virtual box host terminal 2</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vagrant ssh node2</div></pre></td></tr></table></figure>
<p>完成之后再用<code>uname -r</code>看一下，现在应该已经是3.19了。</p>
<h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p>如上所述，docker的overlay网络支持consul，etcd，zookeeper等键值存储系统。这里我们使用比较轻量点的etcd，整个镜像不到15Mb。运行以下命令启动etcd：<br><figure class="highlight sh"><figcaption><span>conf</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">docker run -d \</div><div class="line">  --net=host \</div><div class="line">  --name=etcd \</div><div class="line">  kubernetes/etcd:2.0.5 \</div><div class="line">  /usr/<span class="built_in">local</span>/bin/etcd \</div><div class="line">  --addr=192.168.33.19:4001 \</div><div class="line">  --<span class="built_in">bind</span>-addr=0.0.0.0:4001 \</div><div class="line">  --data-dir=/var/etcd/data</div></pre></td></tr></table></figure></p>
<p>在node上，docker daemon启动参数里需要支持TCP，指定键值存储等。在node1和node2上分别运行以下命令：<br><figure class="highlight sh"><figcaption><span>node1</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo sh -c <span class="string">'echo DOCKER_OPTS=\"-H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock --cluster-store=etcd://192.168.33.19:4001 --cluster-advertise=192.168.33.17:2375\" &gt;&gt; /etc/default/docker'</span></div><div class="line">sudo service docker restart</div></pre></td></tr></table></figure></p>
<figure class="highlight sh"><figcaption><span>node2</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo sh -c <span class="string">'echo DOCKER_OPTS=\"-H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock --cluster-store=etcd://192.168.33.19:4001 --cluster-advertise=192.168.33.18:2375\" &gt;&gt; /etc/default/docker'</span></div><div class="line">sudo service docker restart</div></pre></td></tr></table></figure>
<p>有了这些，就可以开始创建overlay网络了。</p>
<h2 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h2><p>现在在node1或者node2上创建两个overlay网络backend和frontend：<br><figure class="highlight sh"><figcaption><span>node1 or node2</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker network create --driver overlay --subnet=10.0.7.0/24 backend</div><div class="line">docker network create --driver overlay --subnet=10.0.8.0/24 frontend</div><div class="line">docker network ls</div></pre></td></tr></table></figure></p>
<p>所有的网络在节点上是分享的，不管在哪个node上运行<code>docker network ls</code>，都能看到全部网络。另外，墙裂建议创建覆盖网络的时候使用<code>--subnet</code>，否则，docker将随机分配一个子网段，虽然docker内部是不会出现重复IP的，但是跟docker外部的其他虚拟机、容器等就不能保证不重复了。</p>
<p>现在在node1上分别用两个网络各自创建一个容器：<br><figure class="highlight sh"><figcaption><span>node1</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">docker run -d --net=backend --name=be1 busybox sleep 3600</div><div class="line">docker run -d --net=frontend --name=fe1 busybox sleep 3600</div><div class="line">docker <span class="built_in">exec</span> be1 ifconfig</div><div class="line">docker <span class="built_in">exec</span> fe1 ifconfig</div></pre></td></tr></table></figure></p>
<p>执行上面的<code>ifconfig</code>可以看到，eth0的IP地址确实是在指定的<code>subnet</code>里的。然后在node2上用backend网络创建一个容器：<br><figure class="highlight sh"><figcaption><span>node2</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker run -d --net=backend --name=be2 busybox sleep 3600</div><div class="line">docker <span class="built_in">exec</span> be2 ifconfig</div></pre></td></tr></table></figure></p>
<p>容器建好以后，我们可以<code>ping</code>一下看看：<br><figure class="highlight sh"><figcaption><span>node2</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> be2 ping -c 4 be1</div><div class="line">docker <span class="built_in">exec</span> be2 ping -c 4 fe1</div></pre></td></tr></table></figure></p>
<p>上面命令<code>ping</code>里的主机名可以换成IP。运行完可以看到，node2上是可以访问node1上的相同overlay网络的，但是不同的overlay网络不能访问。在node1运行<code>docker exec be1 ping -c 4 fe1</code>也能知道，即使主机相同，不同的overlay网络也是不能访问的，这就很好地实现了网络隔离。原来默认使用bridge的时候，相同主机的所有容器都是可以相互访问的，而不同主机的所有容器都是不能相互访问的。</p>
<p>最后我们再按照上面的原理图中间那个容器那样，创建一个既使用backend网络也使用frontend网络的容器：<br><figure class="highlight sh"><figcaption><span>node2</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker run -d --net=backend --name=bf2 busybox sleep 3600</div><div class="line">docker network connect frontend bf2</div><div class="line">docker <span class="built_in">exec</span> bf2 ifconfig</div></pre></td></tr></table></figure></p>
<p>从上面的<code>ifconfig</code>中可以看到，这个新容器既有<code>10.0.7</code>网段的IP地址，又有<code>10.0.8</code>网段的IP地址。网络搭好以后，我们可以<code>ping</code>一下看看，果然它能够和两个覆盖网络里的容器通信：<br><figure class="highlight sh"><figcaption><span>node2</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> bf2 ping -c 4 be1</div><div class="line">docker <span class="built_in">exec</span> bf2 ping -c 4 fe1</div></pre></td></tr></table></figure></p>
<p>有兴趣的话，我们还可以去conf虚拟机上看看etcd里面的东东：<br><figure class="highlight sh"><figcaption><span>conf</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> -it etcd etcdctl ls /docker/nodes                           <span class="comment"># 所有的节点信息</span></div><div class="line">docker <span class="built_in">exec</span> -it etcd etcdctl ls /docker/network/v1.0/endpoint           <span class="comment"># 所有的endpoint信息</span></div><div class="line">docker <span class="built_in">exec</span> -it etcd etcdctl ls /docker/network/v1.0/overlay/network    <span class="comment"># 所有的overlay网络信息</span></div></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://xelatex.github.io/2015/11/15/Battlefield-Calico-Flannel-Weave-and-Docker-Overlay-Network/" target="_blank" rel="external">这篇文章</a>比较了Docker Overlay Network、Flannel、Calico、Weave等4种覆盖网络，作者还有其它文章分别使用了这些覆盖网络。<br>此外，当然还有<a href="https://docs.docker.com/engine/userguide/networking/dockernetworks/#an-overlay-network" target="_blank" rel="external">Docker官方文档</a>和<a href="https://docs.docker.com/engine/userguide/networking/get-started-overlay/" target="_blank" rel="external">新手教程</a>。</p>
]]></content>
      
        <categories>
            
            <category> devops </category>
            
        </categories>
        
        
        <tags>
            
            <tag> docker </tag>
            
            <tag> network </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[看例子学awk]]></title>
      <url>/awk/</url>
      <content type="html"><![CDATA[<p>写<a href="/sed">sed</a>不写awk真是对强迫症的我的一种折磨啊。这次重温一下Linux/Unix下另一个也很老（还是比我老）的文本处理神器：awk（名字来源于三个创始人的姓的首字母）。Linux下的<a href="http://www.delorie.com/gnu/docs/gawk/gawk_3.html" target="_blank" rel="external">gawk</a>是awk的GNU实现。要是不经常使用，很容易忘记。可以把本文当成一个例子库，有用的时候来查一下。<br><a id="more"></a></p>
<p>假设我们有一个不合法格式的csv文件如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">cat &lt;&lt; EOF &gt;staff.csv</div><div class="line">Country Name Age</div><div class="line">US Gavo 35</div><div class="line">US Jane 21</div><div class="line">US Bill 25</div><div class="line">China Jimmy 42</div><div class="line">EOF</div></pre></td></tr></table></figure></p>
<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h3 id="查询列"><a href="#查询列" class="headerlink" title="查询列"></a>查询列</h3><p>最基本的用法就是过滤出某列来：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'&#123;print $1&#125;'</span> staff.csv</div></pre></td></tr></table></figure></p>
<p>其中的大括号表示一个动作，<code>print</code>就是一个打印的动作。<code>$1</code>代表第1列，<code>$0</code>代表所有列。所以以下的命令也很好理解：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'&#123;print $3&#125;'</span> staff.csv</div><div class="line">awk <span class="string">'&#123;print $0&#125;'</span> staff.csv</div><div class="line">awk <span class="string">'&#123;print $1 $2&#125;'</span> staff.csv       <span class="comment"># 中间的字符不管用</span></div><div class="line">awk <span class="string">'&#123;print $1" "$1&#125;'</span> staff.csv     <span class="comment"># 加引号才生效</span></div><div class="line">awk <span class="string">'&#123;print NR FS NF&#125;'</span> staff.csv    <span class="comment"># NR代表行号，FS代表分隔符，NF代表列数</span></div><div class="line">awk <span class="string">'&#123;print $(NF-1)&#125;'</span> staff.csv     <span class="comment"># 支持计算，加上$代表列内容</span></div></pre></td></tr></table></figure></p>
<p>我们可以把这个不合法的csv文件变得合法：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'&#123;print $1","$2","$3 &gt; "staff.csv"&#125;'</span> staff.csv</div><div class="line">cat staff.csv</div></pre></td></tr></table></figure></p>
<p>注意这里awk的语法：写文件是在大括号里面，而不是外面。当然外面也是可以的，只要别和<code>staff.csv</code>重名就好。</p>
<h3 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h3><p>现在再来一次<code>awk &#39;{print $1}&#39; staff.csv</code>，就会发现awk无视逗号，把一整行都当成第一列了。可以用以下命令指定分隔符：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">awk -F<span class="string">","</span> <span class="string">'&#123;print $1,$2&#125;'</span> staff.csv             <span class="comment"># -F必须写在前面，双引号可以省略，变成-F,</span></div><div class="line">awk <span class="string">'&#123;print $1,$2&#125;'</span> FS=<span class="string">","</span> staff.csv            <span class="comment"># FS必须写在后面，双引号可以省略，变成FS=,</span></div><div class="line">awk <span class="string">'&#123;print $1,$2&#125;'</span> FS=<span class="string">","</span> OFS=<span class="string">":"</span> staff.csv    <span class="comment"># OFS指定输出分隔符</span></div></pre></td></tr></table></figure></p>
<p>上面最后一个命令中，虽然OFS指定了输出分隔符，但是需要在<code>$1</code>和<code>$2</code>中间加上这个分隔符才能生效。另外，有时候省略双引号会出错的，比如对于<code>|</code>这个符号来说，有“或者”的意思，可能有歧义，所以还是加上双引号比较稳妥。</p>
<h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><p>awk支持丰富的条件语法以及正则表达式匹配：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'NR==1&#123;print $3&#125;'</span> FS=, staff.csv                     <span class="comment"># 打印第1行第3列</span></div><div class="line">awk <span class="string">'NR!=1&#123;print $3&#125;'</span> FS=, staff.csv                     <span class="comment"># 打印所有行的第3列，除了第1行</span></div><div class="line">awk <span class="string">'/Gavo/&#123;print $3&#125;'</span> FS=, staff.csv                    <span class="comment"># 打印Gavo的Age</span></div><div class="line">awk <span class="string">'/Gavo|Jane/&#123;print $0&#125;'</span> FS=, staff.csv               <span class="comment"># 打印Gavo或Jane的记录</span></div><div class="line">awk <span class="string">'$3&gt;40&#123;print $0&#125;'</span> FS=, staff.csv                     <span class="comment"># 打印40岁以上的记录，注意这里表头也按字符串来比较了</span></div><div class="line">awk <span class="string">'/Gavo/ || $3&gt;40&#123;print $0&#125;'</span> FS=, staff.csv           <span class="comment"># 打印Gavo或40岁以上的记录</span></div><div class="line">awk <span class="string">'$1 ~ /US/&#123;print $0&#125;'</span> FS=, staff.csv                 <span class="comment"># 打印第1列为US的所有记录</span></div><div class="line">awk <span class="string">'$3 ~ /^2/&#123;print $0&#125;'</span> FS=, staff.csv                 <span class="comment"># 打印第三列以2开头的所有记录，即所有二十多岁的记录</span></div><div class="line">awk <span class="string">'/Gavo/&#123;print $0&#125;/Jane/&#123;print $2&#125;'</span> FS=, staff.csv    <span class="comment"># 打印Gavo的整行记录并打印Jane的第二列</span></div></pre></td></tr></table></figure></p>
<p>还支持在动作里写更复杂的条件：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'&#123;if (NR==1) print $0;&#125;&#123;print $2&#125;'</span> FS=, staff.csv    <span class="comment"># 打印第1行和所有行的第2列</span></div><div class="line">awk <span class="string">'c=(NR==1)&#123;print $0&#125; !c&#123;print $2&#125;'</span> FS=, staff.csv    <span class="comment"># 简易版的if else，把条件赋值给变量c</span></div><div class="line">awk <span class="string">'(NR==1)&#123;print $0;next&#125;&#123;print $2&#125;'</span> FS=, staff.csv    <span class="comment"># next的意思是跳过后面的命令（print $2）</span></div><div class="line">awk <span class="string">'&#123;r=(NR==1)?$0:$2; print r&#125;'</span> FS=, staff.csv          <span class="comment"># 三目赋值运算符</span></div></pre></td></tr></table></figure></p>
<p>以上命令的后三条的效果是一样的。下面是大招：条件表达式的这一套全齐了：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'&#123;if (NR==1) &#123;print $1;&#125; else if (NR==2) &#123;print $2&#125; else &#123;print $3&#125;&#125;'</span> FS=, staff.csv</div></pre></td></tr></table></figure></p>
<h2 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h2><p>为了命令简单起见，我们再把csv文件换成最早那个但是去掉表头：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">cat &lt;&lt; EOF &gt;staff.csv</div><div class="line">US Gavo 35</div><div class="line">US Jane 21</div><div class="line">US Bill 25</div><div class="line">China Jimmy 42</div><div class="line">EOF</div></pre></td></tr></table></figure></p>
<h3 id="入参"><a href="#入参" class="headerlink" title="入参"></a>入参</h3><p>过了一年，要把所有人的Age都加上一岁：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'&#123;print $3&#125;'</span> staff.csv</div><div class="line">awk <span class="string">'&#123;print $3+1&#125;'</span> staff.csv</div></pre></td></tr></table></figure></p>
<p>如果这个一岁是个变量，那就这么做：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">age=1</div><div class="line">awk -v value=<span class="variable">$age</span> <span class="string">'&#123;print $3+value&#125;'</span> staff.csv</div><div class="line">awk <span class="string">'&#123;print $3+value&#125;'</span> value=<span class="variable">$age</span> staff.csv</div></pre></td></tr></table></figure></p>
<p>如果这个一岁是个环境变量，那就这么做：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> AGE=1</div><div class="line">awk <span class="string">'&#123;print $3+ENVIRON["AGE"]&#125;'</span> staff.csv</div></pre></td></tr></table></figure></p>
<h3 id="出参"><a href="#出参" class="headerlink" title="出参"></a>出参</h3><p>如果我们想拿到Jane和Bill的Age，怎么做呢？<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">value=`awk <span class="string">'&#123;if($2=="Jane")print "jane_age="$3;if($2=="Bill")print "bill_age="$3&#125;'</span> staff.csv`</div><div class="line"><span class="built_in">echo</span> <span class="variable">$value</span></div><div class="line"><span class="built_in">eval</span> <span class="variable">$value</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$jane_age</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$bill_age</span></div></pre></td></tr></table></figure></p>
<p>这个方案的思路是在<code>awk</code>里拼命令，然后出来执行。</p>
<h2 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h2><h3 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h3><p>求所有人的年龄总和：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'&#123;s+=$3&#125;END&#123;print s&#125;'</span> staff.csv</div><div class="line">awk <span class="string">'&#123;s+=$3;print $2":"$3&#125;END&#123;print "SUM:"s&#125;'</span> staff.csv</div></pre></td></tr></table></figure></p>
<h3 id="求平均"><a href="#求平均" class="headerlink" title="求平均"></a>求平均</h3><p>下一个命令可以求平均值，也就是求和之后除以行数NR：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'&#123;a+=$3&#125;END&#123;print a/NR&#125;'</span> staff.csv</div></pre></td></tr></table></figure></p>
<p>如果没有<code>END</code>，awk会在每处理一行之后打印一次。</p>
<h3 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h3><p>查看所有的国家，去除重复项目：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'&#123;a[$1];&#125;END&#123;for (i in a)print i&#125;'</span> staff.csv</div><div class="line">awk <span class="string">'&#123;print $1&#125;'</span> staff.csv | uniq                   <span class="comment"># 用这个多简单</span></div></pre></td></tr></table></figure></p>
<p>上面第一个命令比较复杂：<code>a[$1]</code>是awk的数组（其实是字典），<code>a[&quot;US&quot;]=1</code>意味着在a的数组里，<code>&quot;US&quot;</code>的值为1。在这里并没有用到它的值，而是利用了字典的键不能重复的原理。后面有一个<code>for</code>循环，把字典的键都打印出来。如果要打印值，用<code>a[i]</code>就好了。比如下面这个打印每个国家的总年龄：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'&#123;a[$1]+=$3;&#125;END&#123;for (i in a)print a[i]&#125;'</span> staff.csv</div></pre></td></tr></table></figure></p>
<h2 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h2><h3 id="分割文件"><a href="#分割文件" class="headerlink" title="分割文件"></a>分割文件</h3><p>还是以上面那个文件为例：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">cat &lt;&lt; EOF &gt;staff.csv</div><div class="line">US Gavo 35</div><div class="line">US Jane 21</div><div class="line">US Bill 25</div><div class="line">China Jimmy 42</div><div class="line">EOF</div></pre></td></tr></table></figure></p>
<p>将不同国家的记录写到不同文件中：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'&#123;print &gt; $1".csv"&#125;'</span> staff.csv</div><div class="line">ls</div><div class="line">cat China.csv</div><div class="line">cat US.csv</div></pre></td></tr></table></figure></p>
<p>这回看起来好简单啊。<code>print</code>默认打印出整行，所以可以省略<code>$0</code>。<br>每两行写一个文件：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'NR%2==1&#123;f=++i".csv";&#125;&#123;print &gt; f&#125;'</span> staff.csv</div><div class="line">ls</div><div class="line">cat 1.csv</div><div class="line">cat 2.csv</div></pre></td></tr></table></figure></p>
<p>把多余文件删掉：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rm !(staff.csv)</div><div class="line">ls</div></pre></td></tr></table></figure></p>
<h3 id="増删改列"><a href="#増删改列" class="headerlink" title="増删改列"></a>増删改列</h3><p>先看下面这个命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'&#123;$1=++i FS $1&#125;1'</span> staff.csv</div></pre></td></tr></table></figure></p>
<p>它在每行的前面增加了行号。关于<code>$1=++i FS $1</code>，以第一行为例：<code>++i</code>为1，<code>FS</code>为分隔符，<code>$1</code>为第一列，这三项结合起来赋值给前面的<code>$1</code>，所以第一列就变成了<code>1 US</code>。后面的<code>1</code>代表<code>True</code>，是整行打印的意思，也可以用<code>{print $0}</code>来代替。所以：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'&#123;$(NF+1)=++i&#125;1'</span> staff.csv                        <span class="comment"># 最后一列加一列</span></div><div class="line">awk <span class="string">'&#123;$(NF+1)=++i FS NF&#125;1'</span> staff.csv                  <span class="comment"># 最后一列加两列</span></div><div class="line">awk <span class="string">'&#123;$NF=++i FS $NF&#125;1'</span> staff.csv                     <span class="comment"># 倒数第二列加一列</span></div><div class="line">awk <span class="string">'&#123;$2=toupper($2)&#125;1'</span> staff.csv                     <span class="comment"># Name列变大写，tolower就是变小写</span></div><div class="line">awk <span class="string">'&#123;$2=substr($2,0,3)&#125;1'</span> staff.csv                  <span class="comment"># Name列截前3个字符</span></div><div class="line">awk <span class="string">'&#123;$2=""&#125;1'</span> staff.csv                              <span class="comment"># 清空Name列</span></div><div class="line">awk <span class="string">'&#123;NF=2&#125;1'</span> staff.csv                               <span class="comment"># 删除最后一列</span></div><div class="line">awk <span class="string">'&#123;for(i=1;i&lt;NF;i++)$i=$(i+1);NF=2&#125;1'</span> staff.csv    <span class="comment"># 删除第一列</span></div><div class="line">awk <span class="string">'&#123;$2=$2$3;NF=2&#125;1'</span> staff.csv                       <span class="comment"># 合并最后两列</span></div></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>The UNIX School 里的<a href="http://www.theunixschool.com/p/awk-sed.html" target="_blank" rel="external">awk and sed tutorials</a>含有大量的例子和解释，非常容易上手，本文就是以其为基础整理而成。<br>酷壳的<a href="http://coolshell.cn/articles/9070.html" target="_blank" rel="external">AWK 简明教程</a>很适合入门。<br>当然还有最全面的<a href="http://www.gnu.org/software/gawk/manual/gawk.html" target="_blank" rel="external">官方文档</a>。</p>
]]></content>
      
        <categories>
            
            <category> linux/unix </category>
            
        </categories>
        
        
        <tags>
            
            <tag> awk </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[看例子学sed]]></title>
      <url>/sed/</url>
      <content type="html"><![CDATA[<p>这次重温一下Linux/Unix下一个很老（反正比我老）很有用的流编辑器：sed（stream editor）。要是不经常使用，很容易忘记。可以把本文当成一个例子库，有用的时候来查一下。后来还写了篇<a href="/awk">看例子学awk</a>。<br><a id="more"></a></p>
<p>假设我们有一个csv文件如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">cat &lt;&lt; EOF &gt;staff.csv</div><div class="line">Gavo,35</div><div class="line">Jane,21</div><div class="line">Bill,25</div><div class="line">Jimmy,42</div><div class="line">EOF</div></pre></td></tr></table></figure></p>
<h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><h3 id="在文件头-尾增加一行"><a href="#在文件头-尾增加一行" class="headerlink" title="在文件头/尾增加一行"></a>在文件头/尾增加一行</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sed -i <span class="string">'1i Name,Age'</span> staff.csv</div><div class="line">cat staff.csv</div></pre></td></tr></table></figure>
<p>如果没有<code>-i</code>，第一行命令会输出新的文件内容但不会改变<code>staff.csv</code>。<code>1i</code>中的<code>1</code>是指第1行，<code>i</code>是指在读取文件此行前增加（include）记录。如果把<code>i</code>换成<code>a</code>，指的是读取文件此行后增加（append）记录。是不是有点vi的感觉？下面这条命令的结果就会把新行插入到第三行：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="string">'2a Hetty,29'</span> staff.csv</div></pre></td></tr></table></figure></p>
<p>要是想在文件尾增加一行的话，用：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sed <span class="string">'$a Hetty,29'</span> staff.csv    <span class="comment"># 指定行内容</span></div><div class="line">sed $<span class="string">'$a \\\n'</span> staff.csv       <span class="comment"># 增加空行</span></div></pre></td></tr></table></figure></p>
<p>其中的<code>$</code>指最后一行。如果要在倒数第二行增加一行呢？把<code>a</code>换成<code>i</code>吧。倒数第三行呢？你确认你真的有这么奇葩的需求么…</p>
<h3 id="在匹配的地方增加一行"><a href="#在匹配的地方增加一行" class="headerlink" title="在匹配的地方增加一行"></a>在匹配的地方增加一行</h3><p>如果我们要在Jane上面增加一行，这么做：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="string">'/Jane/i Hetty,29'</span> staff.csv</div></pre></td></tr></table></figure></p>
<p>意思是当匹配到<code>Jane</code>的时候，便做后面的操作。接下来的<code>i</code>不用说了吧，也能替换成<code>a</code>。这里的匹配指的是部分匹配，也能匹配多行。如果需要插入的行以空格开头，就用反斜杠<code>\</code>来转义这个空格。试试下列命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sed <span class="string">'/Jane/i \ \ Hetty,29'</span> staff.csv    <span class="comment"># 行头插入两个空格</span></div><div class="line">sed <span class="string">'/21/i Hetty,29'</span> staff.csv          <span class="comment"># 部分匹配</span></div><div class="line">sed <span class="string">'/J/i Hetty,29'</span> staff.csv           <span class="comment"># 匹配了两行</span></div></pre></td></tr></table></figure></p>
<p>下面这个命令可以在Gavo后面增加两行：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="string">'/Gavo/a Hetty,29\nEmma,45'</span> staff.csv</div></pre></td></tr></table></figure></p>
<h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><h3 id="删除特定行"><a href="#删除特定行" class="headerlink" title="删除特定行"></a>删除特定行</h3><p>删（delete）和<a href="/sed/#u589E">増</a>很相似，区别是把<code>i</code>或<code>a</code>换成<code>d</code>即可：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sed <span class="string">'1d'</span> staff.csv         <span class="comment"># 删除第一行</span></div><div class="line">sed <span class="string">'$d'</span> staff.csv         <span class="comment"># 删除最后一行</span></div><div class="line">sed <span class="string">'/Jane/d'</span> staff.csv    <span class="comment"># 删除包含Jane的一行</span></div><div class="line">sed <span class="string">'/21/d'</span> staff.csv      <span class="comment"># 删除包含21的一行</span></div><div class="line">sed <span class="string">'/J/d'</span> staff.csv       <span class="comment"># 删除包含J的两行</span></div></pre></td></tr></table></figure></p>
<h3 id="删除关联行"><a href="#删除关联行" class="headerlink" title="删除关联行"></a>删除关联行</h3><p>下面这个命令把Gavo这一行和下一行都删掉：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="string">'/Gavo/&#123;N;d;&#125;'</span> staff.csv</div></pre></td></tr></table></figure></p>
<p>其中的<code>N</code>就是下一行（next line）的意思。如果不想删除Gavo这行，用这个命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="string">'/Gavo/&#123;N;s/\n.*//;&#125;'</span> staff.csv</div></pre></td></tr></table></figure></p>
<p>相当于匹配了两行也就是<code>Gavo,35\nJane,21</code>之后，再把<code>\n</code>之后的所有文本替换成空白，即删除。替换的命令在下面的<a href="/sed/#u6539">改</a>中会详细介绍。</p>
<h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><h3 id="所有行头-尾增加项目"><a href="#所有行头-尾增加项目" class="headerlink" title="所有行头/尾增加项目"></a>所有行头/尾增加项目</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sed -i <span class="string">'s/^/China,/'</span> staff.csv</div><div class="line">cat staff.csv</div></pre></td></tr></table></figure>
<p>其中的<code>s</code>表示替换（substitute），<code>^</code>表示开头，相对应的<code>$</code>表示结尾。</p>
<h3 id="所有行修改项目"><a href="#所有行修改项目" class="headerlink" title="所有行修改项目"></a>所有行修改项目</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sed -i <span class="string">'s/China/US/'</span> staff.csv</div><div class="line">cat staff.csv</div></pre></td></tr></table></figure>
<p>这样就能把所有的China换成US。如果想把所有的名字后面都加上一个<code>-dev</code>呢？运行：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sed <span class="string">'s/,[A-Z][a-z]*/&amp;-dev/'</span> staff.csv</div><div class="line">sed -r <span class="string">'s/(,.*),/\1-dev,/'</span> staff.csv</div></pre></td></tr></table></figure></p>
<p>其中第一条命令的正则表达式<code>,[A-Z][a-z]*</code>匹配逗号和名字，<code>&amp;</code>表示匹配上的内容，比如对于第二行来说，是<code>,Gavo</code>。第二条命令略微麻烦点，<code>-r</code>表示扩展的正则表达式（extended regular expressions），圆括号表示分组，第一个圆括号中间是第一组，替换的时候用<code>\1</code>表示匹配上的内容。所以<code>\1</code>就是<code>,</code>之前的文本。文件的每一行都有两个逗号，sed会匹配最远的那一个。比如对于第二行来说，匹配到了第二个逗号，所以<code>\1</code>的值就是<code>US,Gavo</code>。加完<code>-dev</code>之后要再补上逗号。所以sed是非常灵活的，可以用多种办法来实现一个功能。</p>
<h3 id="正则替换"><a href="#正则替换" class="headerlink" title="正则替换"></a>正则替换</h3><p>给所有的项目都加上引号：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sed -r <span class="string">'s/[^,]+/"&amp;"/g'</span> staff.csv</div><div class="line">sed -e <span class="string">'s/^\|$/"/g'</span> -e <span class="string">'s/,/","/g'</span> staff.csv</div></pre></td></tr></table></figure></p>
<p>上面的命令是实现的两种方式。第一条命令的意思是除了逗号以外的所有匹配文本都加双引号。对于第二行来说，匹配到了三个文本：<code>US</code>，<code>Gavo</code>和<code>35</code>。第二条命令的思路则完全不同，是先在首尾都加上双引号，然后再把所有的<code>,</code>都替换成<code>&quot;,&quot;</code>。中间的竖线<code>|</code>用反斜杠转义后就是正则表达式中的“或”的意思。如果不想用正则的方式，只想做完全匹配的字符串替换，可以用<code>perl</code>，例如：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">sed -r <span class="string">'s/[name]/ggg/g'</span> &lt;&lt; EOF</div><div class="line">hello [name]</div><div class="line">EOF</div><div class="line"><span class="comment"># hgggllo [gggggggggggg]</span></div><div class="line"></div><div class="line">perl -pe <span class="string">'s/\Q[name]/ggg/g'</span> &lt;&lt; EOF</div><div class="line">hello [name]</div><div class="line">EOF</div><div class="line"><span class="comment"># hello ggg</span></div></pre></td></tr></table></figure></p>
<h3 id="全局替换"><a href="#全局替换" class="headerlink" title="全局替换"></a>全局替换</h3><p>把所有的<code>l</code>改成<code>L</code>：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="string">'s/l/L/g'</span> staff.csv</div></pre></td></tr></table></figure></p>
<p>后面的<code>/g</code>代表整行范围内的所有匹配全部替换，不加<code>g</code>的话就会被替换成<code>BiLl</code>。可以换成<code>2</code>只替换第二个匹配项。还可以选择<code>i</code>来忽略大小写，也可以一起用。它们都是正则表达式的范畴。</p>
<p>同时替换<code>l</code>和<code>m</code>，以下两种方式都可以：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sed <span class="string">'s/l/L/g; s/m/M/g'</span> staff.csv</div><div class="line">sed -e <span class="string">'s/l/L/g'</span> -e <span class="string">'s/m/M/g'</span> staff.csv</div></pre></td></tr></table></figure></p>
<h3 id="大小写替换"><a href="#大小写替换" class="headerlink" title="大小写替换"></a>大小写替换</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sed <span class="string">'s/.*/\L&amp;/'</span> staff.csv</div><div class="line">sed <span class="string">'s/.*/\U&amp;/'</span> staff.csv</div></pre></td></tr></table></figure>
<p><code>\L</code>就是全部小写（lowercase），<code>\U</code>就是全部大写（uppercase）。<code>&amp;</code>在上文有提到，表示匹配上的内容。</p>
<h3 id="修改指定行"><a href="#修改指定行" class="headerlink" title="修改指定行"></a>修改指定行</h3><p>现在表头的第一列也成了US，把它改成Country：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sed -i <span class="string">'1s/US/Country/'</span> staff.csv</div><div class="line">cat staff.csv</div></pre></td></tr></table></figure></p>
<p>把第2行到4行的US替换成China：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="string">'2,4s/US/China/'</span> staff.csv</div></pre></td></tr></table></figure></p>
<p>把第3行整行替换掉：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="string">'3s/.*/China,Hetty,29/'</span> staff.csv</div></pre></td></tr></table></figure></p>
<h3 id="删除所有符号"><a href="#删除所有符号" class="headerlink" title="删除所有符号"></a>删除所有符号</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="string">'s/[[:punct:]]//g'</span> staff.csv</div></pre></td></tr></table></figure>
<p><code>[[:punct:]]</code>是正则表达式中预先定义的子字符类（character classes），代表所有的标点符号。sed支持的<a href="http://www.gnu.org/software/grep/manual/html_node/Character-Classes-and-Bracket-Expressions.html" target="_blank" rel="external">子字符类</a>如下：</p>
<ul>
<li>[:alnum:]：[0-9A-Za-z]</li>
<li>[:alpha:]：[A-Za-z]</li>
<li>[:blank:]：空格和TAB</li>
<li>[:cntrl:]：控制字符（Control characters），ASCII码为000~037和177 (DEL)</li>
<li>[:digit:]：[0-9]</li>
<li>[:graph:]：[:alnum:]和[:punct:]</li>
<li>[:lower:]：[a-z]</li>
<li>[:print:]：[:alnum:]、[:punct:]和空格</li>
<li>[:punct:]：符号 ! “ # $ % &amp; ‘ ( ) * + , - . / : ; &lt; = &gt; ? @ [ \ ] ^ _ ` { | } ~</li>
<li>[:space:]：[:blank:]和回车、换行等</li>
<li>[:upper:]：[A-Z]</li>
<li>[:xdigit:]：16进制 [0-9A-Fa-f]</li>
</ul>
<h3 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h3><p>如果想用变量里的值来代替，可以这么写（注意是双引号而不是单引号了）：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">name=ggg</div><div class="line"><span class="built_in">echo</span> <span class="variable">$name</span></div><div class="line"></div><div class="line">sed -r <span class="string">"s/name/<span class="variable">$&#123;name&#125;</span>/g"</span> &lt;&lt; EOF</div><div class="line">hello name</div><div class="line">EOF</div><div class="line"></div><div class="line"><span class="built_in">unset</span> name</div></pre></td></tr></table></figure></p>
<h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><h3 id="查看特定行"><a href="#查看特定行" class="headerlink" title="查看特定行"></a>查看特定行</h3><p>查（print）也和<a href="/sed/#u589E">増</a>很类似，区别是把<code>i</code>或<code>a</code>换成<code>p</code>即可：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="string">'1p'</span> staff.csv</div></pre></td></tr></table></figure></p>
<p>但是…只是把匹配的行多打一遍而已。如果想要达到<code>grep</code>般的效果，加上<code>-n</code>就可以了：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">sed -n <span class="string">'1p'</span> staff.csv         <span class="comment"># 查看第一行</span></div><div class="line">sed -n <span class="string">'$p'</span> staff.csv         <span class="comment"># 查看最后一行</span></div><div class="line">sed -n <span class="string">'/Jane/p'</span> staff.csv    <span class="comment"># 查看包含Jane的一行</span></div><div class="line">sed -n <span class="string">'/21/p'</span> staff.csv      <span class="comment"># 查看包含21的一行</span></div><div class="line">sed -n <span class="string">'/J/p'</span> staff.csv       <span class="comment"># 查看包含J的两行</span></div><div class="line">sed -n <span class="string">'/21$/p'</span> staff.csv     <span class="comment"># 查看以21结尾的一行</span></div><div class="line">sed -n <span class="string">'/21/!p'</span> staff.csv     <span class="comment"># 查看包含21以外的其它行</span></div></pre></td></tr></table></figure></p>
<p>倒数第二个命令中的<code>21$</code>表示以21结尾。如果要以21开头，用<code>^21</code>。最后一个命令中的<code>!</code>是取反的意思，所以21的记录就反而被隐藏了，而其他的记录倒都显示出来了。</p>
<h3 id="查看行范围"><a href="#查看行范围" class="headerlink" title="查看行范围"></a>查看行范围</h3><p>如果想要查看直到匹配某条记录，用下面这条命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="string">'/Jane/q'</span> staff.csv</div></pre></td></tr></table></figure></p>
<p>其中的<code>q</code>代表查到后退出（quit）。还有几种方式：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sed -n <span class="string">'1,/Jane/p'</span> staff.csv         <span class="comment"># 从第一行开始到匹配Jane的记录为止</span></div><div class="line">sed -n <span class="string">'/Gavo/,/Jane/p'</span> staff.csv    <span class="comment"># 从匹配Gavo的记录开始到匹配Jane的记录为止</span></div><div class="line">sed -n <span class="string">'/Jane/,$p'</span> staff.csv         <span class="comment"># 从匹配Jane的记录开始到最后一行为止</span></div></pre></td></tr></table></figure></p>
<h3 id="查看奇-偶数行"><a href="#查看奇-偶数行" class="headerlink" title="查看奇/偶数行"></a>查看奇/偶数行</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sed <span class="string">'n;d'</span> staff.csv       <span class="comment"># 奇数行</span></div><div class="line">sed <span class="string">'1d;n;d'</span> staff.csv    <span class="comment"># 偶数行</span></div></pre></td></tr></table></figure>
<p>第一条命令中的<code>n;</code>表示输出当前行并立即读取下一行。第二条命令先把第一行记录删除，于是再输出的奇数行就自然变成原来的偶数行了。</p>
<h3 id="从单行中查找"><a href="#从单行中查找" class="headerlink" title="从单行中查找"></a>从单行中查找</h3><p>比如想从<strong>I am 18 years old</strong>里查找18这个年龄，可以这么做：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> <span class="string">"I am 18 years old"</span> | sed -n <span class="string">"s/I am \(.*\) years old/\1/p"</span></div></pre></td></tr></table></figure></p>
<p>这里<code>\1</code>代表第一个被匹配上的内容也就是<code>\(.*\)</code>。发挥想象力：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> <span class="string">"I am 18 years old"</span> | sed -n <span class="string">"s/I am \(.*\) \(.*\) old/\2: \1/p"</span></div></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>The UNIX School 里的<a href="http://www.theunixschool.com/p/awk-sed.html" target="_blank" rel="external">awk and sed tutorials</a>含有大量的例子和解释，非常容易上手，本文就是以其为基础整理而成。<br>酷壳的<a href="http://coolshell.cn/articles/9104.html" target="_blank" rel="external">sed 简明教程</a>很适合入门。<br>当然还有最全面的<a href="http://www.gnu.org/software/sed/manual/sed.html" target="_blank" rel="external">官方文档</a>。</p>
]]></content>
      
        <categories>
            
            <category> linux/unix </category>
            
        </categories>
        
        
        <tags>
            
            <tag> sed </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SaltStack环境安装及入门]]></title>
      <url>/saltstack/</url>
      <content type="html"><![CDATA[<p><a href="http://saltstack.com/" target="_blank" rel="external">SaltStack</a>简称salt，是一个配置管理工具，类似<a href="http://www.ansible.com/get-started" target="_blank" rel="external">Ansible</a>、<a href="https://www.chef.io/chef/" target="_blank" rel="external">Chef</a>和<a href="https://puppetlabs.com/" target="_blank" rel="external">Puppet</a>，可以用脚本批量操作多台机器。SaltStack运行得很快，可以很容易管理上万台服务器，还有<a href="http://docs.saltstack.cn/zh_CN/latest/" target="_blank" rel="external">部分中文文档</a>。它分为服务器（master）和客户端（minion），服务器也是一个客户端。<a href="http://ohmystack.com/articles/salt-1-basic/" target="_blank" rel="external">Salt (1) 入门</a>是个不错的参考教程。<br><a id="more"></a></p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>我们需要先安装<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="external">virtualBox</a>和<a href="https://www.vagrantup.com/downloads.html" target="_blank" rel="external">vagrant</a>。通过vagrant来驱动virtualBox搭建一个虚拟测试环境。首先在本地任意路径新建一个空文件夹比如<code>test</code>，运行以下命令：<br><figure class="highlight sh"><figcaption><span>virtual box host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mkdir <span class="built_in">test</span></div><div class="line"><span class="built_in">cd</span> <span class="built_in">test</span></div><div class="line">vagrant init ubuntu/trusty64</div><div class="line">vi Vagrantfile</div></pre></td></tr></table></figure></p>
<p>里面应该有一句<code>config.vm.box = &quot;ubuntu/trusty64&quot;</code>，在它的下面添加如下几行代码，相当于给它分配三台虚拟机，一台叫做<strong>master</strong>，它的IP是<strong>192.168.33.17</strong>；另两台叫做<strong>minion1</strong>和<strong>minion2</strong>，它们的IP是<strong>192.168.33.18</strong>和<strong>192.168.33.19</strong>，其中minion2安装CentOS，其它安装Ubuntu。<br><figure class="highlight ruby"><figcaption><span>Vagrantfile</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">config.vm.define <span class="string">"master"</span> <span class="keyword">do</span> <span class="params">| host |</span></div><div class="line">  host.vm.hostname = <span class="string">"master"</span></div><div class="line">  host.vm.network <span class="string">"private_network"</span>, <span class="symbol">ip:</span> <span class="string">"192.168.33.17"</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">config.vm.define <span class="string">"minion1"</span> <span class="keyword">do</span> <span class="params">| host |</span></div><div class="line">  host.vm.hostname = <span class="string">"minion1"</span></div><div class="line">  host.vm.network <span class="string">"private_network"</span>, <span class="symbol">ip:</span> <span class="string">"192.168.33.18"</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">config.vm.define <span class="string">"minion2"</span> <span class="keyword">do</span> <span class="params">| host |</span></div><div class="line">  host.vm.box = <span class="string">"bento/centos-7.1"</span></div><div class="line">  host.vm.hostname = <span class="string">"minion2"</span></div><div class="line">  host.vm.network <span class="string">"private_network"</span>, <span class="symbol">ip:</span> <span class="string">"192.168.33.19"</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p>改好之后，分别在三个终端运行以下命令启动并连接三台虚拟机。<br><figure class="highlight sh"><figcaption><span>virtual box host terminal 1</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vagrant up</div><div class="line">vagrant ssh master</div></pre></td></tr></table></figure></p>
<figure class="highlight sh"><figcaption><span>virtual box host terminal 2</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vagrant ssh minion1</div></pre></td></tr></table></figure>
<figure class="highlight sh"><figcaption><span>virtual box host terminal 3</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vagrant ssh minion2</div></pre></td></tr></table></figure>
<h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p>首先在master的虚拟机上安装salt-master和salt-minion，注意master自己也是一个minion：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">wget -O - https://repo.saltstack.com/apt/ubuntu/14.04/amd64/latest/SALTSTACK-GPG-KEY.pub | sudo apt-key add -</div><div class="line">sudo sh -c <span class="string">"echo 'deb http://repo.saltstack.com/apt/ubuntu/14.04/amd64/latest trusty main' &gt;&gt; /etc/apt/sources.list"</span></div><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install -y salt-minion</div><div class="line">sudo apt-get install -y salt-master</div></pre></td></tr></table></figure></p>
<p>然后在minion上安装salt-minion，这次salt-master就没有必要了，Ubuntu和CentOS的安装方法不太一样：<br><figure class="highlight sh"><figcaption><span>minion1</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">wget -O - https://repo.saltstack.com/apt/ubuntu/14.04/amd64/latest/SALTSTACK-GPG-KEY.pub | sudo apt-key add -</div><div class="line">sudo sh -c <span class="string">"echo 'deb http://repo.saltstack.com/apt/ubuntu/14.04/amd64/latest trusty main' &gt;&gt; /etc/apt/sources.list"</span></div><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install -y salt-minion</div></pre></td></tr></table></figure></p>
<figure class="highlight sh"><figcaption><span>minion2</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">sudo rpm --import https://repo.saltstack.com/yum/redhat/7/x86_64/latest/SALTSTACK-GPG-KEY.pub</div><div class="line">sudo sh -c <span class="string">"cat &lt;&lt; EOF &gt;/etc/yum.repos.d/saltstack.repo</span></div><div class="line">[saltstack-repo]</div><div class="line">name=SaltStack repo for RHEL/CentOS 7</div><div class="line">baseurl=https://repo.saltstack.com/yum/redhat/7/x86_64/latest</div><div class="line">enabled=1</div><div class="line">gpgcheck=1</div><div class="line">gpgkey=https://repo.saltstack.com/yum/redhat/7/x86_64/latest/SALTSTACK-GPG-KEY.pub</div><div class="line">EOF"</div><div class="line">sudo yum clean expire-cache</div><div class="line">sudo yum update</div><div class="line">sudo yum install -y salt-minion</div></pre></td></tr></table></figure>
<p>默认安装好的minion会自动试图连接到名为salt的master去，所以我们得配置一下，然后重新启动salt-minion服务：<br><figure class="highlight sh"><figcaption><span>master and minion1</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo sed -i <span class="string">"s/#master: salt/master: 192.168.33.17/"</span> /etc/salt/minion</div><div class="line">sudo service salt-minion restart</div></pre></td></tr></table></figure></p>
<figure class="highlight sh"><figcaption><span>minion2</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo sed -i <span class="string">"s/#master: salt/master: 192.168.33.17/"</span> /etc/salt/minion</div><div class="line">sudo systemctl start salt-minion</div></pre></td></tr></table></figure>
<p>随便在哪台虚拟机上运行<code>sudo tail -1 /var/log/salt/minion</code>，如果看到错误消息<strong>The Salt Master has cached the public key for this node</strong>，那就说明前面的安装都是顺利的—这是因为第一次运行的时候，需要建立互信。Salt维护着一个互信列表，在master上运行<code>sudo salt-key</code>可以看到这个表，现在应该是这样子的：<br><strong>Accepted Keys:</strong><br><strong>Denied Keys:</strong><br><strong>Unaccepted Keys:</strong><br>master<br>minion1<br>minion2<br><strong>Rejected Keys:</strong></p>
<p>从上表可以看出，互信列表里的记录有<a href="https://docs.saltstack.com/en/latest/ref/cli/salt-key.html#description" target="_blank" rel="external">四种状态</a>：</p>
<ul>
<li>Unaccepted：待处理</li>
<li>Accepted：互信</li>
<li>Rejected：运维人员运行命令拒绝</li>
<li>Denied：master自动拒绝（比如ID重复等）</li>
</ul>
<p>现在所有的minion包括master自己都是处于Unaccepted的状态。运行以下命令就可以把它们都加入到Accepted：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo salt-key --accept=master --yes</div><div class="line">sudo salt-key --accept=minion1 --yes</div><div class="line">sudo salt-key --accept=minion2 --yes</div></pre></td></tr></table></figure></p>
<p>如果minion太多了，也可以用<code>sudo salt-key --accept-all --yes</code>来全部accept。忽略<code>--yes</code>可以让我们手动确认所有的Unaccepted记录。再次运行<code>sudo salt-key</code>，确认所有的minion都已经加入到Accepted Keys里了，安装步骤就此完成。</p>
<p>小贴士：可以用<code>sudo salt-key --reject=minion2</code>来把minion2加入到Rejected列表中。用<code>sudo salt-key --include-all --accept-all</code>来把Rejected列表中的minion再加到Accepted中来。</p>
<h2 id="运行命令"><a href="#运行命令" class="headerlink" title="运行命令"></a>运行命令</h2><h3 id="salt"><a href="#salt" class="headerlink" title="salt"></a>salt</h3><p>安装完成之后，在master上运行<code>sudo salt &#39;*&#39; test.ping</code>可以看到各minion是否能联通。其中的<strong>*</strong>代表<a href="https://docs.saltstack.com/en/latest/topics/targeting/index.html" target="_blank" rel="external">目标（target）</a>，这里即是所有的minion（master现在也是一个minion），<strong>test.ping</strong>称为<a href="https://docs.saltstack.com/en/latest/ref/modules/" target="_blank" rel="external">执行模块（execution module）</a>，也就是需要在目标上调用的方法。<a href="https://docs.saltstack.com/en/latest/ref/modules/all/index.html" target="_blank" rel="external">这个列表</a>里记载了所有的原生执行模块。我们来尝试一下其中的<a href="https://docs.saltstack.com/en/latest/ref/modules/all/salt.modules.cmdmod.html#module-salt.modules.cmdmod" target="_blank" rel="external">cmdmod</a>模块：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo salt minion1 cmd.run <span class="string">'ifconfig'</span></div></pre></td></tr></table></figure></p>
<p>这就相当于在minion1上直接运行ifconfig了。</p>
<h3 id="salt-call"><a href="#salt-call" class="headerlink" title="salt-call"></a>salt-call</h3><p>Salt还提供了一个<code>salt-call</code>命令，它只能在本机执行，所以无需输入目标。在master上运行<code>sudo salt-call cmd.run &#39;hostname&#39;</code>，效果相当于直接本地运行命令。有所不同的是，它相当于运行在salt的机制上。Salt需要两个端口来运行：通过<a href="http://zeromq.org/" target="_blank" rel="external">ZeroMQ</a>在4505发消息，4506用来接收结果，所有的minion都会订阅4505端口。也就是说，运行这条命令使用了这两个端口。配合上<code>--log-level=debug</code>的参数，使得<code>salt-call</code>非常适用于调试。运行以下命令：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo salt-call --<span class="built_in">log</span>-level=debug disk.usage</div></pre></td></tr></table></figure></p>
<p>从打印出来的调试信息，我们能看到原来<strong>disk.usage</strong>模块用的是<code>df -P</code>命令。</p>
<h3 id="salt-run"><a href="#salt-run" class="headerlink" title="salt-run"></a>salt-run</h3><p>最后再介绍一个<code>salt-run</code>命令。我们简单地试一试在master上运行<code>sudo salt-run manage.up</code>，这个manage.up是个runner，在这里它的作用类似于test.ping模块，也是查看所有minion的状态，但是不需要指定目标即可使用。它一般分为几个步骤，一个步骤内并行执行，步骤之间串行执行。比如先部署好数据库（步骤A）再部署应用服务器（步骤B）。<code>salt-run</code>运行的命令称为runner，<a href="https://docs.saltstack.com/en/latest/ref/runners/all/index.html" target="_blank" rel="external">这个列表</a>里记载了所有的原生runner。</p>
<h2 id="指定目标"><a href="#指定目标" class="headerlink" title="指定目标"></a>指定目标</h2><p>Salt支持多种方式来指定目标，简单尝试一下就知道啦。<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">sudo salt <span class="string">'minion*'</span> test.ping                      <span class="comment"># 通配符，以"minion"开头的minion</span></div><div class="line">sudo salt -L <span class="string">'minion1,minion2'</span> test.ping           <span class="comment"># 列表，minion1和minion2</span></div><div class="line">sudo salt -E <span class="string">'minion(1|2)'</span> test.ping               <span class="comment"># 正则表达式，minion1或minion2</span></div><div class="line">sudo salt -S <span class="string">'192.168.33.19'</span> test.ping             <span class="comment"># IP，minion2</span></div><div class="line">sudo salt -G <span class="string">'os:Ubuntu'</span> test.ping                 <span class="comment"># Grains，操作系统为Ubuntu</span></div><div class="line">sudo salt -C <span class="string">'minion* and G@os:Ubuntu'</span> test.ping   <span class="comment"># 组合，以"minion"开头的minion并且操作系统为Ubuntu</span></div><div class="line">sudo salt -C <span class="string">'master or G@os:CentOS'</span> test.ping     <span class="comment"># 组合，master或操作系统为CentOS（不区分大小写）</span></div><div class="line">sudo salt -I <span class="string">'region:cn'</span> test.ping                 <span class="comment"># Pillar，region为cn的minion</span></div></pre></td></tr></table></figure></p>
<p>其中的<a href="https://docs.saltstack.com/en/latest/topics/targeting/grains.html" target="_blank" rel="external">Grains</a>是minion的属性，包含机器名、IP、操作系统、CPU等多种信息。可以运行<code>sudo salt &#39;*&#39; grains.items</code>来查看所有的grains数据。那<a href="https://docs.saltstack.com/en/latest/topics/pillar/index.html" target="_blank" rel="external">Pillar</a>又是什么鬼？简言之，Pillar是存放在master的变量，Grains是minion自己的常量。上面的命令中，Pillar这行应该会报错：<strong>No minions matched the target</strong>，这是因为我们没有在master上加Pillar的缘故。Pillar文件为yaml格式，默认存放在<code>/srv/pillar</code>里。由于pillar只会加密传送给指定的minion，所以可以存放密码等敏感信息。我们来加两个文件：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sudo sh -c <span class="string">"cat &lt;&lt; EOF &gt; /srv/pillar/top.sls</span></div><div class="line">base:</div><div class="line">  '*':</div><div class="line">    - default</div><div class="line">EOF"</div><div class="line">sudo sh -c <span class="string">"echo 'region: cn' &gt; /srv/pillar/default.sls"</span></div></pre></td></tr></table></figure></p>
<p>首先创建的<code>top.sls</code>是一个默认的入口文件，它表示所有minion都适用<code>default.sls</code>文件。而<code>default.sls</code>里指定了变量。运行以下的命令：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo salt <span class="string">'*'</span> pillar.items            <span class="comment"># 生成、分发、查看现在的pillar。用pillar.raw可以仅查看当前值</span></div><div class="line">sudo salt -I <span class="string">'region:cn'</span> test.ping    <span class="comment"># 再次运行test.ping，以pillar为目标</span></div></pre></td></tr></table></figure></p>
<p>就能看到现在已经不报错了，所有的minion都是目标。</p>
<h2 id="维持状态（State）"><a href="#维持状态（State）" class="headerlink" title="维持状态（State）"></a>维持状态（State）</h2><p>Salt提供了<a href="https://docs.saltstack.com/en/latest/topics/tutorials/starting_states.html" target="_blank" rel="external">state</a>（点开一看，设计哲学是“简单，简单，简单”。大家都知道重要的事情说三遍）的方式让我们维持所有minion的状态一致。我们来加两个文件：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">sudo sh -c <span class="string">"cat &lt;&lt; EOF &gt; /srv/salt/top.sls</span></div><div class="line">base:</div><div class="line">  '*':</div><div class="line">    - default</div><div class="line">EOF"</div><div class="line">sudo sh -c <span class="string">"cat &lt;&lt; EOF &gt; /srv/salt/default.sls</span></div><div class="line">/tmp/ggg:</div><div class="line">  file.directory:</div><div class="line">    - makedirs: True</div><div class="line">EOF"</div></pre></td></tr></table></figure></p>
<p>如同pillar，首先创建的<code>top.sls</code>是一个默认的入口文件，<code>default.sls</code>里指定了这个状态需要有<code>/tmp/ggg</code>这个文件夹。接下来让我们来运行它：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sudo salt <span class="string">'master'</span> state.show_sls default    <span class="comment"># 检查并显示default的state</span></div><div class="line">sudo salt <span class="string">'master'</span> state.sls default         <span class="comment"># 运行default的state</span></div><div class="line">ls /tmp                                      <span class="comment"># 能够看到ggg文件夹已经创建好了</span></div><div class="line">sudo salt <span class="string">'master'</span> state.sls default         <span class="comment"># 再次运行default的state</span></div><div class="line">ls /tmp                                      <span class="comment"># 运行几次都一样，维持状态</span></div></pre></td></tr></table></figure></p>
<p>State可以说是salt的核心功能。它通过yaml格式的数据文件sls（<strong>S</strong>a<strong>L</strong>t <strong>S</strong>tate file）确保了一个系统应该是什么状态的。<a href="https://docs.saltstack.com/en/latest/ref/states/all/" target="_blank" rel="external">这个列表</a>里记载了所有可用的状态。</p>
]]></content>
      
        <categories>
            
            <category> devops </category>
            
        </categories>
        
        
        <tags>
            
            <tag> salt </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用容器轻松搭建Bamboo来提供Marathon的对外服务]]></title>
      <url>/marathon-bamboo/</url>
      <content type="html"><![CDATA[<p>如果我们在marathon上部署了一个tomcat服务并希望它能暴露给外网，应该怎么做呢？<a href="https://github.com/QubitProducts/bamboo" target="_blank" rel="external">Bamboo</a>提供了一个非常方便运行的办法帮我们做到这一点。它集成了HAproxy，当marathon检测到应用挂掉并重启应用时，bamboo能够检测到并更新HAproxy的配置文件，然后自动重启HAproxy，从而无须人工干预便能持续不断地对外提供服务。<br><a id="more"></a></p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>参考《用容器轻松搭建Marathon运行环境》的<a href="/mesos-marathon/#u51C6_u5907_u5DE5_u4F5C">准备工作</a>一节，用vagrant搭建两台虚拟机<strong>master</strong>和<strong>slave</strong>。</p>
<h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p>参考《用容器轻松搭建Marathon运行环境》的<a href="/mesos-marathon/#u642D_u5EFA_u73AF_u5883">搭建环境</a>一节，但是用下面这个命令来启动marathon。它相比原来的命令多了一个<code>--event_subscriber http_callback</code>的参数，如果不配置，便不能实现HAproxy动态加载服务的功能。<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">docker run -d \</div><div class="line">    --net=host \</div><div class="line">    --name=ma \</div><div class="line">    mesosphere/marathon:v0.15.0 \</div><div class="line">    --master zk://192.168.33.18:2181/mesos \</div><div class="line">    --zk zk://192.168.33.18:2181/marathon \</div><div class="line">    --event_subscriber http_callback</div></pre></td></tr></table></figure></p>
<p>现在启动Bamboo镜像，在里面指定marathon的地址：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">docker run -d \</div><div class="line">    -p 8000:8000 \</div><div class="line">    -p 80:80 \</div><div class="line">    --name=bam \</div><div class="line">    -e MARATHON_ENDPOINT=http://192.168.33.18:8080 \</div><div class="line">    -e BAMBOO_ENDPOINT=http://192.168.33.18:8000 \</div><div class="line">    -e BAMBOO_ZK_HOST=192.168.33.18:2181 \</div><div class="line">    -e BAMBOO_ZK_PATH=/bamboo \</div><div class="line">    -e BIND=<span class="string">":8000"</span> \</div><div class="line">    -e CONFIG_PATH=<span class="string">"config/production.example.json"</span> \</div><div class="line">    -e BAMBOO_DOCKER_AUTO_HOST=<span class="literal">true</span> \</div><div class="line">    gregory90/bamboo:0.2.11</div></pre></td></tr></table></figure></p>
<p>在浏览器打开<code>http://192.168.33.18:8000/</code>应该能看到下图：<br><img src="/img/bamboo.png" alt=""></p>
<h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><p>现在让我们用marathon来启动一个tomcat服务。在任意一台机器上运行以下命令，把创建tomcat服务的请求发送给marathon的REST api：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">curl -X POST http://192.168.33.18:8080/v2/apps \</div><div class="line">    -H <span class="string">"Content-type: application/json"</span> \</div><div class="line">    -d <span class="string">'&#123;"cpus":0.5,"mem":200,"disk":0,"instances":1,"id":"tomcat", </span></div><div class="line">    "container":&#123;"docker":&#123;"image":"tomcat","network":"BRIDGE","portMappings": </div><div class="line">    [&#123;"containerPort":8080,"hostPort":0,"servicePort":0,"protocol":"tcp"&#125;]&#125;&#125;&#125;'</div></pre></td></tr></table></figure></p>
<p>分别刷新marathon和bamboo，就能看到它们各自多了个tomcat的服务。点击bamboo页面上的<strong>/tomcat</strong>记录最右边的加号按钮，在<strong>acl</strong>里输入<code>path_beg -i /</code>（表示运行在根目录上，有兴趣的话可以参考HAproxy的<a href="http://cbonte.github.io/haproxy-dconv/configuration-1.5.html#7" target="_blank" rel="external">ACL语法</a>），然后点击<strong>Create</strong>按钮：<br><img src="/img/bamboo-tomcat.png" alt=""></p>
<p>顺利的话，打开<code>http://192.168.33.18/</code>应该能看到tomcat出现啦：<br><img src="/img/tomcat.jpg" alt=""></p>
<p>这个时候，在marathon的页面上点击tomcat这行记录，便会到tomcat application页面里。如下图选中当前的tomcat实例，点击<strong>Kill</strong>按钮：<br><img src="/img/marathon-application-tomcat.png" alt=""></p>
<p>稍等几秒，就会看到tomcat的服务运行地址从<code>192.168.33.19:31071</code>变成了<code>192.168.33.19:31571</code>，端口因机而异。再回去刷新tomcat的<code>http://192.168.33.18/</code>页面，是不是仍然提供服务呢？如果你手快，应该能看到<strong>503 Service Unavailable</strong>，那就多刷新两下 ：） 到slave虚拟机上用命令删除tomcat容器，再观察一下，是不是一样的效果呢？</p>
<h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><p>Marathon官方还支持其它<a href="https://mesosphere.github.io/marathon/docs/service-discovery-load-balancing" target="_blank" rel="external">三种服务发现的方法</a>：</p>
<ol>
<li>Mesos-DNS：Mesosphere公司提供的DNS产品，不仅适用于marathon，而且适用于其它Mesos Framework。</li>
<li>Marathon-lb：感觉上跟k8s的<a href="http://kubernetes.io/v1.1/docs/user-guide/services.html#type-nodeport" target="_blank" rel="external">NodePort</a>有点像，不过它像Bamboo那样包含了HAproxy。</li>
<li>haproxy-marathon-bridge：现在已经不推荐了。需要在每个slave上安装HAproxy，定时更新HAproxy的配置文件。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> devops </category>
            
        </categories>
        
        
        <tags>
            
            <tag> bamboo </tag>
            
            <tag> marathon </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[轻松搭建Docker Swarm运行环境]]></title>
      <url>/docker-swarm/</url>
      <content type="html"><![CDATA[<p><a href="https://docs.docker.com/swarm/" target="_blank" rel="external">Docker Swarm</a>是官方发布的集群容器管理工具。它的特点是：比较轻量级，无缝支持标准的docker API。<a href="http://blog.daocloud.io/swarm_analysis_part1/" target="_blank" rel="external">深入浅出Swarm</a>一文很清晰地讲解了它的架构和命令。本文从零开始搭建并管理一个swarm集群。<br><a id="more"></a></p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>我们需要先安装<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="external">virtualBox</a>和<a href="https://www.vagrantup.com/downloads.html" target="_blank" rel="external">vagrant</a>。通过vagrant来驱动virtualBox搭建一个虚拟测试环境。首先在本地任意路径新建一个空文件夹比如<code>test</code>，运行以下命令：<br><figure class="highlight sh"><figcaption><span>virtual box host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mkdir <span class="built_in">test</span></div><div class="line"><span class="built_in">cd</span> <span class="built_in">test</span></div><div class="line">vagrant init minimum/ubuntu-trusty64-docker</div><div class="line">vi Vagrantfile</div></pre></td></tr></table></figure></p>
<p>里面应该有一句<code>config.vm.box = &quot;minimum/ubuntu-trusty64-docker&quot;</code>，在它的下面添加如下几行代码，相当于给它分配三台虚拟机，一台叫做<strong>manager</strong>，它的IP是<strong>192.168.33.17</strong>；另两台叫做<strong>node1</strong>和<strong>node2</strong>，它们的IP是<strong>192.168.33.18</strong>和<strong>192.168.33.19</strong>。<br><figure class="highlight ruby"><figcaption><span>Vagrantfile</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">config.vm.define <span class="string">"manager"</span> <span class="keyword">do</span> <span class="params">| host |</span></div><div class="line">  host.vm.hostname = <span class="string">"manager"</span></div><div class="line">  host.vm.network <span class="string">"private_network"</span>, <span class="symbol">ip:</span> <span class="string">"192.168.33.17"</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">config.vm.define <span class="string">"node1"</span> <span class="keyword">do</span> <span class="params">| host |</span></div><div class="line">  host.vm.hostname = <span class="string">"node1"</span></div><div class="line">  host.vm.network <span class="string">"private_network"</span>, <span class="symbol">ip:</span> <span class="string">"192.168.33.18"</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">config.vm.define <span class="string">"node2"</span> <span class="keyword">do</span> <span class="params">| host |</span></div><div class="line">  host.vm.hostname = <span class="string">"node2"</span></div><div class="line">  host.vm.network <span class="string">"private_network"</span>, <span class="symbol">ip:</span> <span class="string">"192.168.33.19"</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p>这个vagrant镜像已经在ubuntu的基础上帮我们安装了docker，用起来很方便。然后分别在三个终端运行以下命令启动并连接三台虚拟机。<br><figure class="highlight sh"><figcaption><span>virtual box host terminal 1</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vagrant up</div><div class="line">vagrant ssh manager</div></pre></td></tr></table></figure></p>
<figure class="highlight sh"><figcaption><span>virtual box host terminal 2</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vagrant ssh node1</div></pre></td></tr></table></figure>
<figure class="highlight sh"><figcaption><span>virtual box host terminal 3</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vagrant ssh node2</div></pre></td></tr></table></figure>
<h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p>想要让swarm管理node，首先得让docker daemon支持TCP。在三台虚拟机上运行以下命令：<br><figure class="highlight sh"><figcaption><span>manager and node1 and node2</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo sh -c <span class="string">'echo DOCKER_OPTS=\"-H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock\" &gt;&gt; /etc/default/docker'</span></div><div class="line">sudo rm /etc/docker/key.json    <span class="comment"># 免得我们用vagrant生成的docker id都一样，删掉了重启docker服务会自动生成一个新的</span></div><div class="line">sudo service docker restart</div></pre></td></tr></table></figure></p>
<p>接下来，我们用最简单的静态节点列表方式来启动swarm环境。把node1和node2的节点信息都写到参数里即可：<br><figure class="highlight sh"><figcaption><span>manager</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -t -p 2376:2375 swarm:1.1.0 manage nodes://192.168.33.18:2375,192.168.33.19:2375</div></pre></td></tr></table></figure></p>
<p>2376是我随便设的一个端口，可以改成2375外的其他可用端口，因为2375已经被docker daemon占用了。可以Ctrl+C后，用下面这个命令查看：<br><figure class="highlight sh"><figcaption><span>manager</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo netstat -tulnp | grep 2375</div></pre></td></tr></table></figure></p>
<p>随便在哪台机器运行以下命令就能看到这个集群的信息和节点信息。这里的2376就是上面随便设出来的2376：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker -H tcp://192.168.33.17:2376 info</div></pre></td></tr></table></figure></p>
<h2 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h2><p>Swarm的环境已经搭建完成，现在我们可以用swarm来运行容器了。随便在哪台机器运行以下命令来创建一个busybox容器：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker -H tcp://192.168.33.17:2376 run -d busybox sleep 3000</div></pre></td></tr></table></figure></p>
<p>可能一开始的时候有点儿慢，这是因为需要下载镜像的缘故。如果等不及，就到两个node里分别先把镜像下载下来：<code>docker pull busybox</code>。之所以说无缝支持docker API，那是因为swarm里能运行所有的docker命令。跑一下<code>docker -H tcp://192.168.33.17:2376 ps</code>就能看到一个busybox的容器已经启动起来了。容器的<strong>NAMES</strong>属性里有node的信息，所以不需要分别在两个node运行<code>docker ps</code>就能看到这个busybox的容器在哪个node运行。之后，再运行3次上面的命令，共创建4个busybox的容器，就能看到它们被均匀分配到两个node上了。这是因为swarm默认的调度策略所致。目前swarm支持<a href="https://docs.docker.com/swarm/scheduler/strategy/" target="_blank" rel="external">三种调度策略</a>：</p>
<ul>
<li>spread：默认，swarm会把任务分配到目前运行的容器数量最少的node上去。这里说的容器数量包括已经停止的容器。</li>
<li>binpack：把任务分配到目前最大负荷的node上去。目的是把其他机器的资源留给将来可能要运行的大容器。</li>
<li>random：随机分配。</li>
</ul>
<p>如果看到的容器分配不均匀，那很可能是存在着非运行中的容器，可以用<code>docker ps -a</code>看一下。如果想要修改调度策略，可以在manager启动的时候指定<code>--strategy</code>参数，比如修改成binpack：<br><figure class="highlight sh"><figcaption><span>manager</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker rm -f `docker ps -aq`</div><div class="line">docker run -t -p 2376:2375 swarm:1.1.0 manage nodes://192.168.33.18:2375,192.168.33.19:2375 --strategy binpack</div></pre></td></tr></table></figure></p>
<p>这回再试试启动4个新的busybox，是不是都跑到同一个node上去了？Swarm的过滤器功能还允许我们指定让容器运行在哪个node上。目前，<a href="https://docs.docker.com/swarm/scheduler/filter/" target="_blank" rel="external">swarm支持如下的过滤器</a>：</p>
<ul>
<li>node过滤器<ul>
<li>constraint：限制新任务只能在label符合的node上执行</li>
<li>health：限制新任务只能在“健康”的node上执行</li>
</ul>
</li>
<li>容器过滤器<ul>
<li>affinity：使新任务在已运行某个名字或label的容器，或者有某个镜像的node上执行</li>
<li>dependency：使新任务在有依赖（–volumes-from=dependency、–link=dependency:alias或–net=container:dependency）的node上执行</li>
<li>port：使新任务在某个端口可用的node上执行</li>
</ul>
</li>
</ul>
<p>可以在manager启动的时候指定<code>--filter</code>参数来启用过滤器功能。我们先来试验一下constraint。由于Label是docker daemon的属性，所以我们又要修改<code>/etc/default/docker</code>并重启docker daemon。假设node1为ssd，node2为普通disk：<br><figure class="highlight sh"><figcaption><span>node1</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">docker rm -f `docker ps -aq`</div><div class="line">sudo sed -i <span class="string">'$d'</span> /etc/default/docker    <span class="comment"># 删掉最后一行，因为要加新的label</span></div><div class="line">sudo sh -c <span class="string">'echo DOCKER_OPTS=\"-H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock --label storage=ssd\" &gt;&gt; /etc/default/docker'</span></div><div class="line">sudo service docker restart</div></pre></td></tr></table></figure></p>
<figure class="highlight sh"><figcaption><span>node2</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">docker rm -f `docker ps -aq`</div><div class="line">sudo sed -i <span class="string">'$d'</span> /etc/default/docker    <span class="comment"># 删掉最后一行，因为要加新的label</span></div><div class="line">sudo sh -c <span class="string">'echo DOCKER_OPTS=\"-H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock --label storage=disk\" &gt;&gt; /etc/default/docker'</span></div><div class="line">sudo service docker restart</div></pre></td></tr></table></figure>
<p>随便在哪台机器运行以下命令，看看两个node是不是分别多出来<code>storage==ssd</code>和<code>storage==disk</code>：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker -H tcp://192.168.33.17:2376 info</div></pre></td></tr></table></figure></p>
<p>如果不是，就重启一下manager的swarm容器。然后就可以指定<code>storage=ssd</code>的node运行：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker -H tcp://192.168.33.17:2376 run -d -e constraint:storage==ssd busybox sleep 3000</div></pre></td></tr></table></figure></p>
<p>随便再创建几个容器玩玩，再换<code>constraint:storage==disk</code>试试看。熟悉之后，我们再试验一下affinity：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker -H tcp://192.168.33.17:2376 run -d -e constraint:storage==disk --name=bb busybox sleep 3000</div></pre></td></tr></table></figure></p>
<p>要的就是<strong>bb</strong>这个名字。然后运行以下命令让新容器运行在有bb容器的node上，也就是node2：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker -H tcp://192.168.33.17:2376 run -d -e affinity:container==bb busybox sleep 3000</div></pre></td></tr></table></figure></p>
<p>在node2上运行<code>docker ps</code>应该能看到新容器已经启动起来了。如果constraint和affinity冲突会怎样呢？试试看：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker -H tcp://192.168.33.17:2376 run -d  -e affinity:container==bb -e constraint:storage==ssd busybox sleep 3000</div></pre></td></tr></table></figure></p>
<p>不出意外的话，应该能看见<strong>unable to find a node that satisfies storage==ssd</strong>的错误消息了吧。</p>
<h2 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h2><p>Swarm共支持下面<a href="https://docs.docker.com/swarm/discovery/" target="_blank" rel="external">几种主机发现方式</a>：</p>
<ul>
<li>分布式键值存储<ul>
<li>Consul 0.5.1或更高版本</li>
<li>Etcd 2.0或更高版本</li>
<li>ZooKeeper 3.4.5或更高版本</li>
</ul>
</li>
<li>静态方式<ul>
<li>文件</li>
<li>节点列表</li>
</ul>
</li>
<li>Docker Hub</li>
</ul>
<p>我们刚才<a href="/docker-swarm/#u642D_u5EFA_u73AF_u5883">搭建环境</a>用到的是静态的节点列表方式，现在我们再试试其它几种方式。</p>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>先从简单的开始。文件的主机发现方式和节点列表很类似，它们都是静态的。首先把node的信息都写到一个临时文件<code>/tmp/cluster</code>里，然后让swamp容器管理这个文件即可：<br><figure class="highlight sh"><figcaption><span>manager</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> 192.168.33.[18:19]:2375 &gt; /tmp/cluster</div><div class="line">docker run -t -p 2376:2375 -v /tmp/cluster:/tmp/cluster swarm:1.1.0 manage file:///tmp/cluster</div></pre></td></tr></table></figure></p>
<p>随便选台虚拟机检查一下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker -H tcp://192.168.33.17:2376 info</div></pre></td></tr></table></figure></p>
<p>是不是有换汤不换药的感觉？</p>
<h3 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h3><p>接下来试验一下ZooKeeper。先在manager上启动一个ZooKeeper的服务：<br><figure class="highlight sh"><figcaption><span>manager</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">docker run -d \</div><div class="line">    --net=host \</div><div class="line">    --name=zk \</div><div class="line">    -e MYID=1 \</div><div class="line">    -e SERVERS=192.168.33.18 \</div><div class="line">    mesoscloud/zookeeper:3.4.6-ubuntu-14.04</div></pre></td></tr></table></figure></p>
<p>然后运行swarm manager：<br><figure class="highlight sh"><figcaption><span>manager</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -t -p 2376:2375 swarm:1.1.0 manage zk://192.168.33.17:2181/swarm</div></pre></td></tr></table></figure></p>
<p>由于这回不像文件和节点列表方式那样静态，我们需要把两个node加入到集群里：<br><figure class="highlight sh"><figcaption><span>node1</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d swarm:1.1.0 join --addr=192.168.33.18:2375 zk://192.168.33.17:2181/swarm</div></pre></td></tr></table></figure></p>
<figure class="highlight sh"><figcaption><span>node2</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d swarm:1.1.0 join --addr=192.168.33.19:2375 zk://192.168.33.17:2181/swarm</div></pre></td></tr></table></figure>
<p>随便选台虚拟机检查一下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker -H tcp://192.168.33.17:2376 info    <span class="comment"># 由于是动态加载，可能需要等待半分钟左右才能看见node</span></div></pre></td></tr></table></figure></p>
<p>Consul和Etcd也都很类似，这里就不一一列举了。</p>
<h3 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h3><p>Docker Hub的主机发现方式，就是在docker hub上使用发现服务来生成一个唯一的集群ID（别在生产环境上这么干！）。Docker hub会为我们保留大概一个星期。在任意一台机器上运行以下命令：<br><figure class="highlight sh"><figcaption><span>manager or node1 or node2</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run --rm swarm:1.1.0 create</div></pre></td></tr></table></figure></p>
<p>然后我们就能看见上面的命令生成了一个字符串，这就是我们的集群ID。在我的机器上是这样的：<code>3137ebf83d771f1db06bf4eab7ccc73b</code>。我大天朝的网络，有时候会出现<strong>TLS handshake timeout</strong>，那就再运行一次吧。</p>
<p>这时候可以把manager启动起来了，别忘了替换成你自己的token：<br><figure class="highlight sh"><figcaption><span>manager</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -t -p 2376:2375 swarm:1.1.0 manage token://3137ebf83d771f1db06bf4eab7ccc73b</div></pre></td></tr></table></figure></p>
<p>然后可以在两个node上分别运行以下命令，启动swarm的代理并加入到集群中，别忘了替换成你自己的token：<br><figure class="highlight sh"><figcaption><span>node1</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d swarm:1.1.0 join --addr=192.168.33.18:2375 token://3137ebf83d771f1db06bf4eab7ccc73b</div></pre></td></tr></table></figure></p>
<figure class="highlight sh"><figcaption><span>node2</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d swarm:1.1.0 join --addr=192.168.33.19:2375 token://3137ebf83d771f1db06bf4eab7ccc73b</div></pre></td></tr></table></figure>
<p>随便选台虚拟机检查一下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker -H tcp://192.168.33.17:2376 info    <span class="comment"># 可能比较慢，下面那条命令更快</span></div><div class="line">docker run --rm swarm:1.1.0 list token://3137ebf83d771f1db06bf4eab7ccc73b</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> devops </category>
            
        </categories>
        
        
        <tags>
            
            <tag> docker </tag>
            
            <tag> swarm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用容器轻松搭建Chronos运行环境]]></title>
      <url>/mesos-chronos/</url>
      <content type="html"><![CDATA[<p>Apache Mesos把自己定位成一个数据中心操作系统，它能管理上万台的从机（slave）。Framework相当于这个操作系统的应用程序，每当应用程序需要执行，Framework就会在Mesos中选择一台有合适资源（cpu、内存等）的从机来运行。Chronos是Framework的一种，被Airbnb公司设计用来代替cron执行作业。本文尝试从零开始用docker搭建Mesos和Chronos的运行环境，并用此环境运行作业。<br><a id="more"></a></p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>参考《用容器轻松搭建Marathon运行环境》的<a href="/mesos-marathon/#u51C6_u5907_u5DE5_u4F5C">准备工作</a>一节，用vagrant搭建两台虚拟机<strong>master</strong>和<strong>slave</strong>。</p>
<h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p>参考《用容器轻松搭建Marathon运行环境》的<a href="/mesos-marathon/#u642D_u5EFA_u73AF_u5883">搭建环境</a>一节，跳过marathon部分。</p>
<p>搭建mesos master和slave环境完成后，最后在master的虚拟机上启动chronos：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">docker run -d \</div><div class="line">    --net=host \</div><div class="line">    --name=ch \</div><div class="line">    mesosphere/chronos:chronos-2.4.0-0.1.20150828104228.ubuntu1404-mesos-0.27.0-0.2.190.ubuntu1404 \</div><div class="line">    usr/bin/chronos \</div><div class="line">    --master zk://192.168.33.18:2181/mesos \</div><div class="line">    --zk_hosts zk://192.168.33.18:2181/marathon \</div><div class="line">    --cluster_name ggg</div></pre></td></tr></table></figure></p>
<p>我们还可以打开<code>http://192.168.33.18:8080/</code>感知一下chronos：<br><img src="/img/chronos.jpg" alt=""></p>
<h2 id="运行作业"><a href="#运行作业" class="headerlink" title="运行作业"></a>运行作业</h2><p>在chronos的页面上，点击<strong>New Job</strong>按钮，然后填入如下参数：</p>
<ul>
<li>NAME：test</li>
<li>COMMAND：docker run -d busybox sleep 30</li>
<li>SCHEDULE P：T1M</li>
</ul>
<p>如下图所示：<br><img src="/img/chronos-run-job.jpg" alt=""></p>
<p>点击<strong>Create</strong>按钮，立刻就能看见有一个名为<strong>test</strong>的作业正在运行。同时，在mesos的主页上也能看到有一个任务运行起来了。如果手慢一点或者喝了杯茶，还能看见有几个任务已经是完成的状态了，这是因为根据我们设置的T1M，1分钟之后，chronos就会帮助再重新启动一次作业。另外还可以在slave的虚拟机上用<code>docker ps -a</code>看到busybox容器已经启动起来了。</p>
<p><em>T1M的意思是：1分钟之后。1M的意思是：1个月之后。1Y2M3DT4H5M6S的意思是：1年2月3天4小时5分钟6秒之后。</em></p>
<h2 id="管理作业"><a href="#管理作业" class="headerlink" title="管理作业"></a>管理作业</h2><p>新建作业的窗口里还有一个<strong>Other settings</strong>的链接，是可以在里面设置一些高级功能的，比如说CPU、内存和磁盘，默认是0.1、128MB和256MB，还能设置作业优先级、运行方式等。已经生成的作业也可以再次修改、强制运行、复制和删除。作业也可以是一次性的，只要把SCHEDULE R设成0就可以了，记得同时调整一下时间T哦。</p>
<p>作业直接还可以指定依赖。我们再创建一个如下作业：</p>
<ul>
<li>NAME：test2</li>
<li>COMMAND：date &gt;&gt; /tmp/test.txt</li>
<li>PARENTS: test</li>
</ul>
<p>这回我们并没有设置SCHEDULE，而是设置了一个PARENTS为<strong>test</strong>，它的意思就是当test运行成功时，运行这个test2的作业。等1分钟，test作业再次运行后，在slave虚拟机上运行<code>docker exec ms1 cat /tmp/test.txt</code>就能看到当前时间已经被写进<code>/tmp/test.txt</code>文件中，test2作业也被成功运行了。</p>
<p>我们再创建第三个作业：</p>
<ul>
<li>NAME：test3</li>
<li>COMMAND：echo “hello world” &gt;&gt; /tmp/test.txt</li>
<li>PARENTS: test, test2</li>
</ul>
<p>这次test3依赖于test和test2，那么它们之间是“或”还是“和”的关系呢？我们强制运行一次test，在slave虚拟机上运行<code>docker exec ms1 cat /tmp/test.txt</code>就能看到增加了一行日期和一行hello world。强制运行一次test2，却只增加了一行日期而没有增加hello world。由此推断，只有当test2和test全部被执行后，才会执行一次test3。那如果我们要“或”的关系怎么办呢？首先把test3的PARENTS修改为test，记得作业是有一个复制功能的吧？再复制一份test3把它的PARENTS设成test2就好啦。</p>
<p>最后介绍一下那个<strong>Graph</strong>按钮，它可以显示一幅图来表示作业之间的依赖关系。对于我们的示例来说，这图应该是长这样的：<br><img src="/img/chronos-graph.png" alt=""></p>
<p>对于一个非常复杂的作业系统来说，这样的图能让我们很容易找到并分析作业间的依赖关系，从而采取优化措施。许多持续集成系统也都能提供类似的依赖图供管理员决策。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>这个版本的chronos页面上有一些bug，会导致有时候侧面的作业详细信息栏显示有问题，刷新一下整个页面或者尝试多点击几次左边的作业表就好了。</li>
<li>还是页面的bug，有时候新建作业时会提示需要输入OWNER(S)，这是个Email地址，这样当作业出错时会通知这个Email。可是我们的测试应该是不需要错误通知的。当你看到这个提示的时候，随便输个自己的邮箱就好啦。</li>
<li>像marathon一样，chronos也支持REST API，我们可以来试一下。先随便在哪台机器找个路径生成一个<code>test4.json</code>文件，内容如下：<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"parents"</span>: [</div><div class="line">    <span class="string">"test"</span></div><div class="line">  ],</div><div class="line">  <span class="attr">"name"</span>: <span class="string">"test4"</span>,</div><div class="line">  <span class="attr">"command"</span>: <span class="string">"echo test4 &gt;&gt; /tmp/test.txt"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>然后运行以下命令来发送请求给chronos：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -X POST http://192.168.33.18:8080/scheduler/dependency -d @test4.json -H <span class="string">"Content-type: application/json"</span></div></pre></td></tr></table></figure></p>
<p>刷新chronos的页面就能看见这个作业在跑啦。想要删掉它？当然没问题：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -X DELETE http://192.168.33.18:8080/scheduler/job/test4 -H <span class="string">"Content-type: application/json"</span></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> devops </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mesos </tag>
            
            <tag> chronos </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用容器轻松搭建Marathon运行环境]]></title>
      <url>/mesos-marathon/</url>
      <content type="html"><![CDATA[<p>Apache Mesos把自己定位成一个数据中心操作系统，它能管理上万台的从机（slave）。Framework相当于这个操作系统的应用程序，每当应用程序需要执行，Framework就会在Mesos中选择一台有合适资源（cpu、内存等）的从机来运行。<a href="https://mesosphere.github.io/marathon/" target="_blank" rel="external">Marathon</a>是Framework的一种，被设计来支持长时间运行的服务。本文尝试从零开始用docker搭建Mesos和Marathon的运行环境，并用此环境长时间运行docker容器。<br><a id="more"></a></p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>我们需要先安装<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="external">virtualBox</a>和<a href="https://www.vagrantup.com/downloads.html" target="_blank" rel="external">vagrant</a>。通过vagrant来驱动virtualBox搭建一个虚拟测试环境。首先在本地任意路径新建一个空文件夹比如<code>test</code>，运行以下命令：<br><figure class="highlight sh"><figcaption><span>virtual box host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mkdir <span class="built_in">test</span></div><div class="line"><span class="built_in">cd</span> <span class="built_in">test</span></div><div class="line">vagrant init minimum/ubuntu-trusty64-docker</div><div class="line">vi Vagrantfile</div></pre></td></tr></table></figure></p>
<p>里面应该有一句<code>config.vm.box = &quot;minimum/ubuntu-trusty64-docker&quot;</code>，在它的下面添加如下几行代码，相当于给它分配两台虚拟机，一台叫做<strong>master</strong>，它的IP是<strong>192.168.33.18</strong>；另一台叫做<strong>slave</strong>，它的IP是<strong>192.168.33.19</strong>。<br><figure class="highlight ruby"><figcaption><span>Vagrantfile</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">config.vm.define <span class="string">"master"</span> <span class="keyword">do</span> <span class="params">| host |</span></div><div class="line">  host.vm.hostname = <span class="string">"master"</span></div><div class="line">  host.vm.network <span class="string">"private_network"</span>, <span class="symbol">ip:</span> <span class="string">"192.168.33.18"</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">config.vm.define <span class="string">"slave"</span> <span class="keyword">do</span> <span class="params">| host |</span></div><div class="line">  host.vm.hostname = <span class="string">"slave"</span></div><div class="line">  host.vm.network <span class="string">"private_network"</span>, <span class="symbol">ip:</span> <span class="string">"192.168.33.19"</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p>这个vagrant镜像已经在ubuntu的基础上帮我们安装了docker，用起来很方便。然后分别在两个终端运行以下命令启动并连接两台虚拟机。<br><figure class="highlight sh"><figcaption><span>virtual box host terminal 1</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vagrant up</div><div class="line">vagrant ssh master</div></pre></td></tr></table></figure></p>
<figure class="highlight sh"><figcaption><span>virtual box host terminal 2</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vagrant ssh slave</div></pre></td></tr></table></figure>
<h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p>在master的虚拟机上启动zookeeper：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">docker run -d \</div><div class="line">    --net=host \</div><div class="line">    --name=zk \</div><div class="line">    -e MYID=1 \</div><div class="line">    -e SERVERS=192.168.33.18 \</div><div class="line">    mesoscloud/zookeeper:3.4.6-ubuntu-14.04</div></pre></td></tr></table></figure></p>
<p>可以用<code>docker ps</code>看到名为zk的容器已经启动起来了。有兴趣的话，可以用下面的命令验证：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> -it zk zkCli.sh -server 127.0.0.1:2181</div></pre></td></tr></table></figure></p>
<p>这里就不详细介绍zookeeper的命令了，<code>ls /</code>可以查看根节点，<code>help</code>可以查看所有命令，<code>quit</code>退出客户端。</p>
<p>接下来在master的虚拟机上启动mesos master：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">docker run -d \</div><div class="line">    --net=host \</div><div class="line">    --name=mm \</div><div class="line">    -e MESOS_HOSTNAME=192.168.33.18 \</div><div class="line">    -e MESOS_IP=192.168.33.18 \</div><div class="line">    -e MESOS_ZK=zk://192.168.33.18:2181/mesos \</div><div class="line">    -e MESOS_QUORUM=1 \</div><div class="line">    -e MESOS_LOG_DIR=/var/<span class="built_in">log</span>/mesos \</div><div class="line">    mesoscloud/mesos-master:0.24.1-ubuntu-14.04</div></pre></td></tr></table></figure></p>
<p>顺利的话，打开<code>http://192.168.33.18:5050/</code>应该能看到下图：<br><img src="/img/mesos-master-init.png" alt=""></p>
<p>然后在slave的虚拟机上启动mesos slave：<br><figure class="highlight sh"><figcaption><span>slave</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">docker run -d \</div><div class="line">    --net=host \</div><div class="line">    --pid=host \</div><div class="line">    --privileged=<span class="literal">true</span> \</div><div class="line">    --name=ms1 \</div><div class="line">    -v /usr/bin/docker:/usr/bin/docker \</div><div class="line">    -v /dev:/dev \</div><div class="line">    -v /usr/lib/x86_64-linux-gnu/libapparmor.so.1:/usr/lib/x86_64-linux-gnu/libapparmor.so.1:ro \</div><div class="line">    -v /var/run/docker.sock:/var/run/docker.sock \</div><div class="line">    -v /var/<span class="built_in">log</span>/mesos:/var/<span class="built_in">log</span>/mesos \</div><div class="line">    -v /tmp/mesos:/tmp/mesos \</div><div class="line">    -e MESOS_HOSTNAME=192.168.33.19 \</div><div class="line">    -e MESOS_IP=192.168.33.19 \</div><div class="line">    -e MESOS_MASTER=zk://192.168.33.18:2181/mesos \</div><div class="line">    -e MESOS_CONTAINERIZERS=docker,mesos \</div><div class="line">    mesoscloud/mesos-slave:0.24.1-ubuntu-14.04</div></pre></td></tr></table></figure></p>
<p>点击mesos页面上的<strong>Slaves</strong>应该能看到下图，这说明slave节点已经关联到mesos master了：<br><img src="/img/mesos-slaves.png" alt=""></p>
<p>最后在master的虚拟机上启动marathon：<br><figure class="highlight sh"><figcaption><span>master</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">docker run -d \</div><div class="line">    --net=host \</div><div class="line">    --name=ma \</div><div class="line">    mesosphere/marathon:v0.15.0 \</div><div class="line">    --master zk://192.168.33.18:2181/mesos \</div><div class="line">    --zk zk://192.168.33.18:2181/marathon</div></pre></td></tr></table></figure></p>
<p>点击mesos页面上的<strong>Frameworks</strong>应该能看到下图，这说明marathon已经作为一个framework关联到mesos master了：<br><img src="/img/mesos-frameworks.png" alt=""></p>
<p>我们还可以打开<code>http://192.168.33.18:8080/</code>感知一下marathon：<br><img src="/img/marathon.png" alt=""></p>
<h2 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h2><p>在marathon的页面上，点击<strong>Create Application</strong>按钮，然后填入如下参数：</p>
<ul>
<li>ID：test</li>
<li>Command：sleep 30</li>
<li>Image：busybox</li>
</ul>
<p>如下图所示：<br><img src="/img/marathon-run-docker.png" alt=""></p>
<p>点击<strong>+ Create</strong>按钮，不一会儿，就能看见有一个名为<strong>test</strong>的应用程序正在运行。同时，在mesos的主页上也能看到有一个任务运行起来了。如果手慢一点或者喝了杯茶，还能看见有几个任务已经是完成的状态了，这是因为我们只让这个容器<code>sleep 30</code>存活30秒钟，如果容器自己停止了，marathon就会帮助再重新启动一个。另外还可以在slave的虚拟机上用<code>docker ps</code>看到busybox容器已经启动起来了。</p>
<h2 id="管理应用"><a href="#管理应用" class="headerlink" title="管理应用"></a>管理应用</h2><p>Marathon也能很方便地对容器进行扩缩容。当容器启动起来后，在<strong>Health</strong>栏里会有一个<strong>…</strong>的按钮，按下按钮如下图所示：<br><img src="/img/marathon-actions.png" alt=""></p>
<p>里面的<strong>Scale</strong>按钮提供了一个比较易用的方法，让我们能轻易地改变容器的数量。可以试试在弹出的界面上填2，然后点击<strong>Scale Application</strong>按钮，就会看到<strong>Running Instances</strong>很快就变成了<strong>2 of 2</strong>，点击这一行，就能看到这两个实例的状态，还可以分别下载它们的日志。同时，在mesos的主页上也能看到又多了一个运行中的任务。另外，在slave的虚拟机上用<code>docker ps</code>也能看到2个busybox的容器实例。</p>
<p>除了扩缩容，还能重新启动应用、暂停应用（实际上就是把它缩容为0个实例）和删除应用等。另外，在test这个Application的Configuration页上，还支持修改这个Application的启动参数。比如还可以在这里设置基于TCP、HTTP或者命令的健康检查，设置环境变量等多种操作。如下图所示：<br><img src="/img/marathon-edit-configuration.png" alt=""></p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>如果第一次运行一个比较大的镜像，可能需要比较长的下载时间。在这种情况下，需要往mesos master的启动参数里增加<code>-e MESOS_EXECUTOR_REGISTRATION_TIMEOUT=10mins</code>，否则可能会报timeout的错误，默认是1分钟。还得在marathon的启动参数里增加<code>--task_launch_timeout=600000</code>，默认为300000毫秒，即5分钟。</li>
<li>如果一个容器老是启动不起来，可能是分配给它的资源太少。可以在marathon新建应用的窗口里指定分配给此应用的CPU和内存，默认是0.1和16MB。但是不要超过mesos slave能提供的资源哦。</li>
<li>如果你是坚定不移的命令行狂人，可以用<code>curl</code>来发送一个http请求来运行容器。还是用上面的<strong>test</strong>来举例子，先随便在哪台机器找个路径生成一个<code>test.json</code>文件，内容如下：<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"id"</span>: <span class="string">"test"</span>,</div><div class="line">  <span class="attr">"cmd"</span>: <span class="string">"sleep 30"</span>,</div><div class="line">  <span class="attr">"cpus"</span>: <span class="number">0.1</span>,</div><div class="line">  <span class="attr">"mem"</span>: <span class="number">16.0</span>,</div><div class="line">  <span class="attr">"container"</span>: &#123;</div><div class="line">    <span class="attr">"type"</span>: <span class="string">"DOCKER"</span>,</div><div class="line">    <span class="attr">"volumes"</span>: [],</div><div class="line">    <span class="attr">"docker"</span>: &#123;</div><div class="line">      <span class="attr">"image"</span>: <span class="string">"busybox"</span>,</div><div class="line">      <span class="attr">"privileged"</span>: <span class="literal">false</span>,</div><div class="line">      <span class="attr">"parameters"</span>: [],</div><div class="line">      <span class="attr">"forcePullImage"</span>: <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>然后运行以下命令来发送请求给marathon：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -X POST http://192.168.33.18:8080/v2/apps -d @test.json -H <span class="string">"Content-type: application/json"</span></div></pre></td></tr></table></figure></p>
<p>打开marathon的页面就能看见这个应用在跑啦。想要删掉它？当然没问题：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -X DELETE http://192.168.33.18:8080/v2/apps/<span class="built_in">test</span> -H <span class="string">"Content-type: application/json"</span></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> devops </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mesos </tag>
            
            <tag> marathon </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[删除Docker Registry里的镜像怎么那么难]]></title>
      <url>/docker-registry-delete/</url>
      <content type="html"><![CDATA[<p>除了官方的Docker Hub，Docker也提供了Docker Registry来让大家搭建自己的私有镜像库。虽然它提供了<a href="https://github.com/docker/distribution/blob/master/docs/spec/api.md#user-content-detail" target="_blank" rel="external">删除的API</a>，但是不好用。为什么小小的删除功能没弄好呢？我们该怎么办？<br><a id="more"></a></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>有很多人抱怨说<a href="https://github.com/docker/distribution/issues/1183" target="_blank" rel="external">Docker Registry的删除功能并不会真正地释放空间</a>。虽然官方提供了API，但那些都是软删除（soft delete），只是把二进制和镜像的关系解除罢了，并不是真正的删除。真正的删除有那么困难吗？</p>
<p>目前docker官方提供了如下3个软删除的方法：</p>
<ol>
<li><code>DELETE:/v2/&lt;name&gt;/manifests/&lt;reference&gt;</code>：这个API是软删除一个<a href="https://github.com/docker/distribution/blob/master/docs/spec/manifest-v2-2.md" target="_blank" rel="external">清单（manifest）</a>，但是真正占用存储空间的层还在。</li>
<li><code>DELETE:/v2/&lt;name&gt;/blobs/&lt;digest&gt;</code>：这个API类似上面那个，只不过它要软删除的对象是层（layer）罢了。</li>
<li><code>DELETE:/v2/&lt;name&gt;/blobs/uploads/&lt;uuid&gt;</code>：这个只是取消掉另一个上传的进程罢了。</li>
</ol>
<h2 id="难点"><a href="#难点" class="headerlink" title="难点"></a><a href="https://github.com/docker/distribution/blob/master/ROADMAP.md#deletes" target="_blank" rel="external">难点</a></h2><p>为了删除不需要的数据，腾出磁盘空间，我们希望有删除功能。但是如果一个不健全的删除功能不小心把有用的数据给删了，那还不如没有这个功能呢。在这个逻辑前提下，docker团队选择了不删除数据。除此之外，还有一个考虑：删除功能是需要很大工作量的。大家知道程序员们的价格是比较高的，以相对便宜的磁盘空间为代价，在眼下先节省这笔人工费开销，并把它投入到更有价值的地方去，不是更有意义么。</p>
<p>那为什么删除功能需要很大的工作量呢？这是因为删除有一个大坑。首先我们来看一下存储模型：所有的数据都被存放到VFS之上，它提供了最终一致性，但是可能需要较长时间才能达到一致。再看镜像的数据结构：一个docker镜像包含了3个概念：标签（tag）、清单（manifest）和层（layer）。标签被关联到清单上，而清单则被关联到层上，就像下图一样：<br><img src="/img/docker-image.jpg" alt=""></p>
<p>其实单说删除本身其实是比较容易的事情，就像现在的垃圾收集算法一样。一个是根搜索法，从根节点开始计算，若某对象不可达，则表明不被用到，可删之。在docker镜像中并没有“根层”的概念，所以需要循环所有的清单来看是否有哪些层不被用到。还有一个是引用计数法，它为每一个对象添加一个引用计数器，为0则表明不被用到。实现起来比较简单，但是很难删除掉循环引用。在docker镜像中，因为它是一个<a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph" target="_blank" rel="external">有向无环图（DAG）</a>，所以并不会有“循环引用”，正是解决这个问题的极佳方案之一。那么这个大坑在哪里呢？问题在于并发。想象一下，如果在删除某层的过程中，有另外一个push的线程误认为此层已经存在，就会在删除之后导致第二个线程push的镜像不能正常工作。</p>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>目前docker官方有几个数据删除的方案（但是还没有实现）：</p>
<ol>
<li>引用计数法：如上文所述是垃圾收集算法的一种。需要维护引用计数器，对于已经存在着的docker registry来说需要数据迁移。</li>
<li>全局锁：引入GC线程来做删除。删除的时候不能写入。实现简单，但是影响性能。</li>
<li>新老代：也是引入GC线程来做删除。将存储分为年轻年老两代，GC线程删除某一代的时候允许同时写入另一代。避免了全局锁的性能问题但是实现起来比较麻烦。</li>
<li>数据库：引入一个数据库，用事务来解决并发的问题。</li>
</ol>
<p>如果你等不及docker官方的实现，并且对自己的私有库的控制力比较强，不需要考虑并发，可以使用<a href="https://github.com/burnettk/delete-docker-registry-image" target="_blank" rel="external">这个脚本</a>来彻底删除，记得先把registry停掉，或者是设置为<a href="https://github.com/docker/distribution/blob/master/docs/configuration.md#user-content-read-only-mode" target="_blank" rel="external">只读模式</a>以避免并发哦。设置一个cron任务，每天凌晨停止服务一小段时间，然后运行脚本，再启动服务就好了。</p>
<p>如果你也认为磁盘空间是比较廉价的，那么使用软删除，也就是上文介绍的官方删除API应该能够符合需求。虽然磁盘空间并没有真正地释放出来，但是删除之后镜像真的就不能再被pull下来了。记得要把<a href="https://github.com/docker/distribution/blob/master/docs/configuration.md#user-content-delete" target="_blank" rel="external">delete的设置</a>打开，否则会得到<code>The operation is unsupported</code>的异常信息。</p>
<p>如果不想使用那些感觉上奇奇怪怪的脚本，还有一个选择是设置两套docker registry，比较稳定的镜像版本放在其中一个库里，不稳定的开发版放另一个库里。每天凌晨把不稳定的版本库清空。这样的话就不会让稳定的版本库的磁盘消耗增长太快，但是也增加了一些管理的难度。没有两全其美的事啊。</p>
<p>写完这篇博客后不久，一个<a href="https://github.com/docker/distribution/blob/master/docs/gc.md" target="_blank" rel="external">gc</a>的commit被合并到了主干，有望在docker registry的2.4版本提供官方的删除功能。不过，它跟上面脚本的思路类似，也需要停止服务或者设置只读模式，并不能完美解决这个问题。抛开解决方案，就删除功能而言，我在测试过程中也发现了一个<a href="https://github.com/docker/distribution/issues/1548" target="_blank" rel="external">缺陷</a>，需要使用docker 1.10版和registry 2.3版才能解决。</p>
<h2 id="v1-vs-v2"><a href="#v1-vs-v2" class="headerlink" title="v1 vs v2"></a>v1 vs v2</h2><p>Docker Registry的老版本v1是用python写的，源码在<a href="https://github.com/docker/docker-registry" target="_blank" rel="external">这里</a>。新版本v2是用go写的，源码在<a href="https://github.com/docker/distribution" target="_blank" rel="external">这里</a>。它们的模型略有变化。老版本v1是个链表，A层链接到B层，B层链接到C层，层层组织起来一个镜像，每一层的ID都是随机生成的。这样一来浪费空间，不能实现层存储的共享，二来有安全隐患，如果不停地提交，会造成ID冲突概率提升。但也正因如此，删除的时候完全没有顾忌，真是成也萧何败也萧何啊。新版本v2的ID是对内容进行sha256哈希之后的结果，所以相同内容的层ID一定是相同的，很好地解决了v1的问题，就是删除功能需要仔细地设计才能实现。除此之外还有鉴权等其他改动，有兴趣的话可以参考<a href="http://www.csdn.net/article/2015-09-09/2825651" target="_blank" rel="external">这篇文章</a>。</p>
<p>题外话：有些人看英文容易把registry和repository搞混。在docker的领域内，repository就是相同名字镜像的集合，比如tomcat的docker repository。而registry就是提供repository服务的系统，比如Docker Hub或者是自己使用Docker Registry安装的私有库等。</p>
]]></content>
      
        <categories>
            
            <category> devops </category>
            
        </categories>
        
        
        <tags>
            
            <tag> docker </tag>
            
            <tag> docker registry </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如果有10000台机器，你想怎么玩？（七）生命周期]]></title>
      <url>/kubernetes-in-mesos-7/</url>
      <content type="html"><![CDATA[<p>这次聊聊mesos+k8s的生命周期管理，包括pod、job、node等对象。</p>
<ul>
<li><a href="/kubernetes-in-mesos-1">如果有10000台机器，你想怎么玩？（一）概述</a></li>
<li><a href="/kubernetes-in-mesos-2">如果有10000台机器，你想怎么玩？（二）高可用</a></li>
<li><a href="/kubernetes-in-mesos-3">如果有10000台机器，你想怎么玩？（三）持久化</a></li>
<li><a href="/kubernetes-in-mesos-4">如果有10000台机器，你想怎么玩？（四）监控</a></li>
<li><a href="/kubernetes-in-mesos-5">如果有10000台机器，你想怎么玩？（五）日志</a></li>
<li><a href="/kubernetes-in-mesos-6">如果有10000台机器，你想怎么玩？（六）性能</a></li>
<li><a href="/kubernetes-in-mesos-7">如果有10000台机器，你想怎么玩？（七）生命周期</a></li>
<li><a href="/kubernetes-in-mesos-8">如果有10000台机器，你想怎么玩？（八）网络</a></li>
<li><a href="/kubernetes-in-mesos-9">如果有10000台机器，你想怎么玩？（九）安全性</a><a id="more"></a>
</li>
</ul>
<h2 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h2><p>一个pod在运行中，难免出现容器还好好地跑着，但是却不正常工作的情况。Kubernetes的做法是引入定时<a href="http://kubernetes.io/docs/user-guide/pod-states/#container-probes" target="_blank" rel="external">健康检查</a>，如果健康检查失败，就把这个容器杀掉，然后kubelet就会重新启动一个容器来代替它。目前支持两种健康检查的机制：</p>
<ul>
<li><code>LivenessProbe</code>：如果健康检查失败，就把这个容器杀掉，然后kubelet根据预先设置的<a href="http://kubernetes.io/docs/user-guide/pod-states/#restartpolicy" target="_blank" rel="external">重启规则</a>来决定怎么处理：啥也不干、挂了才重启或者总是重启。</li>
<li><code>ReadinessProbe</code>：如果健康检查失败，这个pod的IP地址将会从endpoints里移除，所以相当于屏蔽这个pod提供的服务而不是将它杀掉。</li>
</ul>
<p>那健康检查怎么做呢？可以是一段脚本，返回非0就代表错误；可以说一个http请求，返回200~400之间代表成功；还可以是一个tcp端口，打开即算成功。可以通过设置kubelet的参数<code>--sync-frequency</code>来设置健康检查的间隔时间。还可以在设置probe的时候指定健康检查的超时时间和第一次健康检查的延时（从容器启动完毕开始）。</p>
<h2 id="钩子（hook）"><a href="#钩子（hook）" class="headerlink" title="钩子（hook）"></a>钩子（hook）</h2><p>有时候我们需要在pod启动完成或者快要关闭的时候做点儿事情。做的事情可以是执行脚本或者发出http请求，越轻量级越好。Kubernetes提供了两个<a href="http://kubernetes.io/docs/user-guide/container-environment/#container-hooks" target="_blank" rel="external">钩子</a>来做这样的事：</p>
<ul>
<li>postStart：当一个容器被创建成功的时候</li>
<li>preStop：当一个容器即将被关闭的时候</li>
</ul>
<p>钩子的设计理念是“宁滥毋缺”，所以某些情况下它是有可能被执行多次的，设计自己的钩子时需要考虑这样的情况，尽量使操作“无状态”。</p>
<h2 id="一次性任务"><a href="#一次性任务" class="headerlink" title="一次性任务"></a>一次性任务</h2><p>Kubernetes除了支持服务，也支持一次性任务<a href="http://kubernetes.io/docs/user-guide/jobs/" target="_blank" rel="external">Job</a>。这个概念在Kubernetes 1.1版中已经有了，<a href="https://github.com/kubernetes/kubernetes/wiki/Release-1.2" target="_blank" rel="external">1.2版</a>才算开发完成。因为一次性任务结束以后还重启没有意义，所以它不支持“总是重启”的重启规则。Job有三种类型：</p>
<ul>
<li>非并行：就是启动一个pod，当pod成功结束了就算是job完成了</li>
<li>固定数量并行：并行启动固定数量个pod，每个pod都成功结束了就算是job完成了</li>
<li>工作队列并行：行启动多个pod，其中一个pod成功结束了，其他pod就开始停止运行。当全部pod都停止了就算是job完成了</li>
</ul>
<p>其实我们当然也能不使用job这个概念而直接启动一个pod来完成我们的一次性任务。可是如果pod运行过程中那个node要是挂掉了那就糟糕了。对了，rc不就是来保证pod总是有实例在运行的机制吗？那么为啥我们还需要job这个概念呢？原来rc是为永不停止的pod设计的，而job是为需要停止的pod设计的，就这么简单。</p>
<h2 id="扩容缩容"><a href="#扩容缩容" class="headerlink" title="扩容缩容"></a>扩容缩容</h2><p>虚拟机级别上，Mesos也能轻松做到动态增删slave，从而为kubernetes提供更多的offer；与此同时，kubernetes也支持动态增删节点。容器级别上，Kubernetes的replication controller可以很容易地对pod进行扩缩容。此外，Kubernetes 1.2版正式支持<a href="http://kubernetes.io/docs/user-guide/horizontal-pod-autoscaler/" target="_blank" rel="external">HPA</a>。大致来说，就是根据CPU的使用率来自动扩缩容。由于获取CPU使用率需要用到heapster，所以必须部署它。</p>
<p>值得一提的是，Kubernetes在删除pod的时候并不会把容器删除，是出于可能需要在以后查看日志的<a href="https://github.com/kubernetes/kubernetes/issues/1148" target="_blank" rel="external">考虑</a>。</p>
<h2 id="滚动升级"><a href="#滚动升级" class="headerlink" title="滚动升级"></a>滚动升级</h2><p>Kubernetes的replication controller还支持滚动升级（<a href="http://kubernetes.io/docs/user-guide/replication-controller/#rolling-updates" target="_blank" rel="external">rolling update</a>）。当我们想用新版本的镜像来代替已经部署的旧容器的时候，这个特性能用类似蓝绿部署的方式帮我们轻易升级。这个方式是：创建一个副本数为1的rc并关联到新pod，逐渐增加它的副本数并减少旧rc的副本数，最终完全替代。讲起来挺生涩，其实很简单：举个栗子，有一个既存服务来自于3个pod，我们希望用新的pod来代替旧的。这是现在的情况：<br><img src="/img/rolling-update-1.png" alt=""></p>
<p>Kubernetes启动了一个新的rc，它有一个新的pod，并关联到服务上去。<br><img src="/img/rolling-update-2.png" alt=""></p>
<p>然后停掉一个旧的pod，保持这个服务的pod总数还是3个：<br><img src="/img/rolling-update-3.png" alt=""></p>
<p>继续增加新pod：<br><img src="/img/rolling-update-4.png" alt=""></p>
<p>继续停掉旧pod：<br><img src="/img/rolling-update-5.png" alt=""></p>
<p>增加新pod：<br><img src="/img/rolling-update-6.png" alt=""></p>
<p>停掉旧pod，再把没用了的旧rc也删掉：<br><img src="/img/rolling-update-7.png" alt=""></p>
<p>这样新服务就起来了！中间的替换速度是可以由我们设定的，还支持回滚。在<a href="http://kubernetes.io/docs/user-guide/update-demo/" target="_blank" rel="external">这里</a>有一个例子可供参考。</p>
]]></content>
      
        <categories>
            
            <category> devops </category>
            
        </categories>
        
        
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> mesos </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如果有10000台机器，你想怎么玩？（六）性能]]></title>
      <url>/kubernetes-in-mesos-6/</url>
      <content type="html"><![CDATA[<p>这次聊聊mesos+k8s的性能。纯粹的kubernetes v1.1可以支持250个节点，但是一跟mesos结合起来，由于需要等待、接受资源邀约等行为，确实会更慢一些。</p>
<ul>
<li><a href="/kubernetes-in-mesos-1">如果有10000台机器，你想怎么玩？（一）概述</a></li>
<li><a href="/kubernetes-in-mesos-2">如果有10000台机器，你想怎么玩？（二）高可用</a></li>
<li><a href="/kubernetes-in-mesos-3">如果有10000台机器，你想怎么玩？（三）持久化</a></li>
<li><a href="/kubernetes-in-mesos-4">如果有10000台机器，你想怎么玩？（四）监控</a></li>
<li><a href="/kubernetes-in-mesos-5">如果有10000台机器，你想怎么玩？（五）日志</a></li>
<li><a href="/kubernetes-in-mesos-6">如果有10000台机器，你想怎么玩？（六）性能</a></li>
<li><a href="/kubernetes-in-mesos-7">如果有10000台机器，你想怎么玩？（七）生命周期</a></li>
<li><a href="/kubernetes-in-mesos-8">如果有10000台机器，你想怎么玩？（八）网络</a></li>
<li><a href="/kubernetes-in-mesos-9">如果有10000台机器，你想怎么玩？（九）安全性</a><a id="more"></a>
</li>
</ul>
<h2 id="关于性能"><a href="#关于性能" class="headerlink" title="关于性能"></a>关于性能</h2><p>有一篇很知名的<a href="http://blog.kubernetes.io/2015/09/kubernetes-performance-measurements-and.html" target="_blank" rel="external">kubernetes性能测试文章</a>，提到了不少性能测试的考量、结果和计划，也有<a href="http://dockone.io/article/677" target="_blank" rel="external">中文译文</a>。相信看完后对kubernetes自身的性能会有一些感性认识。</p>
<p>Kubernetes v1.0仅仅支持100个节点，kubernetes v1.1已经可以支持250个节点了。官方也希望能<a href="https://github.com/kubernetes/kubernetes/blob/master/docs/admin/multi-cluster.md#user-content-selecting-the-right-number-of-clusters" target="_blank" rel="external">在2016年初支持1000个节点</a>。Kubernetes还提供了一个性能测试工具<a href="https://github.com/kubernetes/kubernetes/blob/master/docs/devel/kubemark-guide.md" target="_blank" rel="external">Kubemark</a>。它由真实的master和虚拟的空节点组成，默认跑在<a href="https://cloud.google.com/container-engine/" target="_blank" rel="external">GCE</a>上，这样不需要大量机器便可以进行性能测试了。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>根据<a href="https://github.com/kubernetes/kubernetes/blob/master/docs/admin/cluster-large.md" target="_blank" rel="external">kubernetes大集群</a>这篇文章的描述，1.1版本支持最大250个节点，每个节点30个pod，每个pod 1~2个容器。当使用50台以上的节点时，最好用单独的etcd来存储事件。可以在kubernetes的api server启动参数里配置类似<code>--etcd-servers-overrides=/events#http://192.168.33.11:4001</code>这样的值来分离事件etcd。</p>
<p>如果想尽可能的模拟生产环境，所以在测试环境中使用kubernetes自身的系统插件（如DNS、Heapster、ElasticSearch等）时，也需要注意由于集群规模的增大，默认的插件资源有可能不够，从而导致OOM最终使插件不停地挂掉重启。可以通过配置resources的limit来增大插件的内存供给。</p>
<p>Docker的性能方面，由于Ubuntu的docker存储驱动默认使用AUFS，速度比Device Mapper快上不少。所以如果用CentOS来做node，会明显感觉容器的启动删除都比较慢。网上也有<a href="https://www.linux-toys.com/?p=374" target="_blank" rel="external">文章</a>指出这点，笔者测试的感觉与之相符。</p>
<h2 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h2><h3 id="Mesos-Kubernetes"><a href="#Mesos-Kubernetes" class="headerlink" title="Mesos+Kubernetes"></a>Mesos+Kubernetes</h3><p>Mesos的资源分配现在是酱紫的：</p>
<ol>
<li>slave告诉master自己有什么资源</li>
<li>master把这个资源包装成offer发送给framework（这里是kubernetes）</li>
<li>framework接受或拒绝</li>
<li>若是framework接受了，让slave运行任务<br><img src="/img/mesos-architecture.jpg" alt=""></li>
</ol>
<p>有一点需要注意的是mesos master并不是一收到slave的资源便把它发送给framework的。想象一下如果有1000台机器的话，那offer的发送频率得是什么样子。Mesos master是每隔一段时间发送一次。它的启动参数里有一个<code>--allocation_interval</code>，它决定了这个间隔时间，默认为1秒。当有多个slave的时候，有可能master在前一秒告诉framework有10份offer，后一秒又告诉说现在有15份（有些被拒绝的offer回来了，有些新slave能提供新offer，有些被接受了，但是还有余裕…）。</p>
<p>Mesos+Kubernetes的<a href="https://github.com/kubernetes/kubernetes/blob/master/contrib/mesos/docs/issues.md#scheduling" target="_blank" rel="external">分配算法</a>现在还很原始：一个offer只会运行一个pod。所以如果请求启动的大量的pod的时候，就需要很多个offer来运行这些pod。为了提高性能，一个办法是在一个offer里安排多个pods，这个是kubernetes的未来计划，现在还不是我们的菜。另一个办法是提高mesos master的offer频率。虽然把<code>--allocation_interval</code>调低可以增加offer发送频率，但是如果offer回流得很慢，那又有什么意义呢。所以kubernetes的scheduler处理得越久，offer的流动性就越差，pod的启动速度就越慢。接着往下走，如何提高scheduler的处理速度呢？最简单的处理办法：换高配！4C8G的虚拟机撑死能扛住250台mesos slave。软件上就还得靠优化scheduler的流程了。另外，mesos master由于要不断发offer出去，还要处理被接受或拒绝的offer，也需要比较强的配置，但是kubernetes master的配置影响力更大，需要相对更好的配置。</p>
<p>Mesos+Kubernetes的scheduler还支持一些细粒度的性能调优，有兴趣的朋友可以去<a href="https://github.com/kubernetes/kubernetes/blob/master/contrib/mesos/docs/scheduler.md#user-content-tuning" target="_blank" rel="external">看一看</a>。</p>
<h3 id="纯kubernetes"><a href="#纯kubernetes" class="headerlink" title="纯kubernetes"></a>纯kubernetes</h3><p>不带mesos玩儿的kubernetes会简单一些，它的scheduler支持一个参数<code>--bind-pods-qps</code>，这个值决定每秒启动的pod数，默认为50。可以根据机器和网络性能相对应地调节。</p>
<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><h3 id="Mesos-Kubernetes-1"><a href="#Mesos-Kubernetes-1" class="headerlink" title="Mesos+Kubernetes"></a>Mesos+Kubernetes</h3><p>Mesos+Kubernetes的情况下，100台mesos slave的情况下，启动100个pod需要将近50秒。由上可知，由于offer是比较均匀的，pod的创建时间基本上也是均匀的。这就意味着启动500个pod需要将近250秒。而且，pod还是比较平均地分布在所有slave上的。删除pod的话，因为无关offer，所以就不是线性关系了。100个pod需要10~15秒，如果一口气删得多一些，需要的时间会比线性增加的时间少一些。250台mesos slave的情况下，基本上kubernetes就带不动了，api server的cpu占用率很高。</p>
<h3 id="纯kubernetes-1"><a href="#纯kubernetes-1" class="headerlink" title="纯kubernetes"></a>纯kubernetes</h3><p>不带mesos玩儿的kubernetes在100台节点的情况下，速度要快得多：启动100个pod仅需10秒左右，1000个约80秒。如果分配超过3000的pod，就会出现部分pod起不来的情况。笔者试验了4000个pod，有280个起不来。250台节点的时候也没有什么压力，性能上比Mesos+Kubernetes好了不止一星半点。现在kubernetes 1.2版已经发布，支持1000个node不成问题。就是…如果按本文的标题来说，10000台机器，还是得建10个kubernetes集群才行呀。</p>
]]></content>
      
        <categories>
            
            <category> devops </category>
            
        </categories>
        
        
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> mesos </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Docker的存储是怎么工作的]]></title>
      <url>/docker-storage/</url>
      <content type="html"><![CDATA[<p>我们都知道docker支持多种存储驱动，默认在ubuntu上使用AUFS，其他Linux系统上使用devicemapper。这篇文章从零开始，用一些Linux的命令来使用这些不同的存储，包括AUFS、Device Mapper、Btrfs和Overlay。<br><a id="more"></a></p>
<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>Docker最早只是运行在Ubuntu和Debian上，使用的存储驱动是AUFS。随着Docker越来越流行，很多人都希望能把它运行在RHEL系列上。可是Linux内核和RHEL并不支持AUFS，最后红帽公司和Docker公司一起合作开发了基于Device Mapper技术的devicemapper存储驱动，这也成为Docker支持的第二款存储。由于Linux内核2.6.9就已经包含Device Mapper技术了，所以它也非常的稳定，代价是比较慢。<a href="https://en.wikipedia.org/wiki/ZFS" target="_blank" rel="external">ZFS</a>是被Oracle收购的Sun公司为Solaris 10开发的新一代文件系统，支持快照，克隆，<a href="https://docs.docker.com/engine/userguide/storagedriver/imagesandcontainers/#the-copy-on-write-strategy" target="_blank" rel="external">写时复制</a>（CoW）等。ZFS的“Z”是最后一个字母，表示终极文件系统，不需要开发其它的文件系统了。虽然ZFS各种好，但是毕竟它的Linux版本是移植过来的，Docker官方并不推荐在生产环境上使用，除非你对ZFS相当熟悉。而且由于软件许可证不同的关系，它也无法被合并进Linux内核里。这么NB的文件系统出来后，Linux社区也有所回应。<a href="https://btrfs.wiki.kernel.org/index.php/Main_Page" target="_blank" rel="external">Btrfs</a>就是和ZFS比较类似的Linux原生存储系统，在Linux内核2.6.29里就包含它了。虽然Btrfs未来是要替换devicemapper的，但是目前devicemapper更安全，更稳定，更适合生产环境。所以如果不是有很经验的话，也不那么推荐在生产环境使用。<a href="https://en.wikipedia.org/wiki/OverlayFS" target="_blank" rel="external">OverlayFS</a>是类似AUFS的<a href="https://en.wikipedia.org/wiki/UnionFS" target="_blank" rel="external">联合文件系统</a>，但是轻量级一些，而且还能快一点儿。更重要的是，它已经被合并到Linux内核3.18版了。虽然OverlayFS发展得很快，但是它还非常年轻，如果要上生产系统，还是要记得小心为上。Docker还支持一个<a href="https://en.wikipedia.org/wiki/Virtual_file_system" target="_blank" rel="external">VFS</a>驱动，它是一个中间层的抽象，底层支持ext系列，ntfs，nfs等等，对上层提供一个标准的文件操作接口，很早就被包含到Linux内核里了。但是由于它不支持写时复制，所以比较占磁盘空间，速度也慢，同样并不推荐上生产环境。</p>
<p>说到这里，好几个存储驱动都上Linux内核了，怎么AUFS一直被拒于门外呢？AUFS是一个日本人岡島順治郎开发的，他也曾希望能把这个存储驱动提交到内核中。但是据说<a href="http://www.programering.com/a/MTM0YDNwATQ.html" target="_blank" rel="external">Linus Torvalds有点儿嫌弃AUFS的代码写得烂</a>……</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>我们需要先安装<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="external">virtualBox</a>和<a href="https://www.vagrantup.com/downloads.html" target="_blank" rel="external">vagrant</a>。通过vagrant来驱动virtualBox搭建一个虚拟测试环境。首先在本地任意路径新建一个空文件夹比如<code>test</code>，运行以下命令启动并连接虚拟机：<br><figure class="highlight sh"><figcaption><span>virtual box host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mkdir <span class="built_in">test</span></div><div class="line"><span class="built_in">cd</span> <span class="built_in">test</span></div><div class="line">vagrant init minimum/ubuntu-trusty64-docker</div><div class="line">vagrant up</div><div class="line">vagrant ssh</div></pre></td></tr></table></figure></p>
<h2 id="AUFS"><a href="#AUFS" class="headerlink" title="AUFS"></a>AUFS</h2><p>AUFS是一个联合文件系统，也就是说，它是一层层垒上去的文件系统。最上层能看到的就是下层的所有系统合并后的结果。我们创建几个文件夹，layer1是最底层，result用来挂载，再搞几个文件：<br><figure class="highlight sh"><figcaption><span>vagrant host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mkdir ~/aufs</div><div class="line"><span class="built_in">cd</span> ~/aufs</div><div class="line"></div><div class="line">mkdir layer1 layer2 result</div><div class="line"><span class="built_in">echo</span> <span class="string">"file1 in layer1"</span> &gt; layer1/file1</div><div class="line"><span class="built_in">echo</span> <span class="string">"file2 in layer1"</span> &gt; layer1/file2</div><div class="line"><span class="built_in">echo</span> <span class="string">"file1 in layer2"</span> &gt; layer2/file1</div></pre></td></tr></table></figure></p>
<p>现在文件夹的层级结构看起来是酱紫的：</p>
<p><pre><br>└── aufs<br>    ├── layer1<br>    │   ├── file1    # file1 in layer1<br>    │   └── file2    # file2 in layer1<br>    ├── layer2<br>    │   └── file1    # file1 in layer2<br>    └── result<br></pre><br>然后一层层地挂载到result文件夹去（none的意思是挂载的不是设备文件），就能看到result现在有两个文件，以及它们的内容：<br><figure class="highlight sh"><figcaption><span>vagrant host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sudo mount -t aufs -o br=layer2=rw:layer1=ro none result</div><div class="line"></div><div class="line">ls result</div><div class="line">cat result/file1    <span class="comment"># file1 in layer2</span></div><div class="line">cat result/file2    <span class="comment"># file2 in layer1</span></div></pre></td></tr></table></figure></p>
<p>file1是由layer2提供的，file2是由layer1提供的，因为layer2里没有file2。如果我们在挂载后的目录写入file1~3：<br><figure class="highlight sh"><figcaption><span>vagrant host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> <span class="string">"file1 in result"</span> &gt; result/file1</div><div class="line"><span class="built_in">echo</span> <span class="string">"file2 in result"</span> &gt; result/file2</div><div class="line"><span class="built_in">echo</span> <span class="string">"file3 in result"</span> &gt; result/file3</div><div class="line"></div><div class="line">cat layer1/file1    <span class="comment"># file1 in layer1</span></div><div class="line">cat layer1/file2    <span class="comment"># file2 in layer1</span></div><div class="line">cat layer2/file1    <span class="comment"># file1 in result</span></div><div class="line">cat layer2/file2    <span class="comment"># file2 in result</span></div><div class="line">cat layer2/file3    <span class="comment"># file3 in result</span></div></pre></td></tr></table></figure></p>
<p>就会看到这些文件都是写入到layer2的。测试完成，清场~<br><figure class="highlight sh"><figcaption><span>vagrant host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo umount result</div><div class="line"></div><div class="line"><span class="built_in">cd</span> ..</div><div class="line">rm -rf aufs</div></pre></td></tr></table></figure></p>
<p>想要了解更细致点的话可以参考<a href="http://coolshell.cn/articles/17061.html" target="_blank" rel="external">Docker基础技术：AUFS</a>这篇文章。</p>
<p>回头来看Docker官方的这幅图：<br><img src="https://docs.docker.com/engine/userguide/storagedriver/images/aufs_delete.jpg" alt=""></p>
<p>虽然是删除文件的示例，但是也能清楚看到AUFS是怎么工作的。然后再结合docker一起看：<br><img src="https://docs.docker.com/engine/userguide/storagedriver/images/aufs_layers.jpg" alt=""></p>
<p>一切就都很清楚明了：一层层地累加所有的文件，最终加载到镜像里。</p>
<h2 id="Device-Mapper"><a href="#Device-Mapper" class="headerlink" title="Device Mapper"></a>Device Mapper</h2><p>Device Mapper是块设备的驱动，它的写时复制是基于块而非文件的。它包含3个概念：原设备，快照和映射表，它们的关系是：原设备通过映射表映射到快照去。一个快照只能有一个原设备，而一个原设备可以映射成多个快照。快照还能作为原设备映射到其他快照中，理论上可以无限迭代。</p>
<p>Device Mapper还提供了一种<a href="https://www.kernel.org/doc/Documentation/device-mapper/thin-provisioning.txt" target="_blank" rel="external">Thin-Provisioning</a>技术。它实际上就是允许存储的超卖，用以提升空间利用率。当它和快照结合起来的时候，就可以做到许多快照挂载在一个原设备上，除非某个快照发生写操作，不然不会真正给快照们分配空间。这样的原设备叫做<a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Logical_Volume_Manager_Administration/thinprovisioned_volumes.html" target="_blank" rel="external">Thin Volume</a>，它和快照都会由thin-pool来分配，超卖就发生在thin-pool之上。它需要两个设备用来存放实际数据和元数据。下面我们来创建两个文件，用来充当实际数据文件和元数据文件：<br><figure class="highlight sh"><figcaption><span>vagrant host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">mkdir ~/devicemapper</div><div class="line"><span class="built_in">cd</span> ~/devicemapper</div><div class="line"></div><div class="line">mkdir thin</div><div class="line">mkdir snap1</div><div class="line">mkdir snap11</div><div class="line">mkdir snap12</div><div class="line"></div><div class="line">dd <span class="keyword">if</span>=/dev/zero of=metadata.img bs=1024K count=1</div><div class="line">dd <span class="keyword">if</span>=/dev/zero of=data.img bs=1024K count=10</div></pre></td></tr></table></figure></p>
<p>文件建好了之后，用<a href="https://en.wikipedia.org/wiki/Loop_device" target="_blank" rel="external">Loop device</a>把它们模拟成块设备：<br><figure class="highlight sh"><figcaption><span>vagrant host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo losetup /dev/loop0 metadata.img</div><div class="line">sudo losetup /dev/loop1 data.img</div><div class="line">sudo losetup -a</div></pre></td></tr></table></figure></p>
<p>然后创建thin-pool（参数的含义可以参考<a href="http://coolshell.cn/articles/17200.html" target="_blank" rel="external">这篇文章</a>）：<br><figure class="highlight sh"><figcaption><span>vagrant host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo dmsetup create pool --table <span class="string">"0 20480 thin-pool /dev/loop0 /dev/loop1 128 32768 1 skip_block_zeroing"</span></div><div class="line">ls /dev/mapper/    <span class="comment"># 这里就会多一个pool</span></div></pre></td></tr></table></figure></p>
<p>之后创建Thin Volume并格式化：<br><figure class="highlight sh"><figcaption><span>vagrant host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo dmsetup message /dev/mapper/pool 0 <span class="string">"create_thin 0"</span></div><div class="line">sudo dmsetup create thin --table <span class="string">"0 2048 thin /dev/mapper/pool 0"</span></div><div class="line">sudo mkfs.ext4 /dev/mapper/thin</div><div class="line">ls /dev/mapper/    <span class="comment"># 这里又会多一个thin</span></div></pre></td></tr></table></figure></p>
<p>加载这个Thin Volume并往里写个文件。我的测试机器上需80秒左右才能把这个文件同步回thin-pool去。如果不等待，可能接下来的快照里就不会有这个文件；如果等待时间不足（小于30秒），可能快照里会有这个文件，但是内容为空。这个时间跟thin-pool的参数，尤其是先前创建的实际数据和元数据文件有关。<br><figure class="highlight sh"><figcaption><span>vagrant host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo mount /dev/mapper/thin thin</div><div class="line">sudo sh -c <span class="string">"echo file1 in thin &gt; thin/file1"</span></div><div class="line">sleep 80s</div></pre></td></tr></table></figure></p>
<p>睡饱后，给thin这个原设备添加一份快照snap1：<br><figure class="highlight sh"><figcaption><span>vagrant host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo dmsetup message /dev/mapper/pool 0 <span class="string">"create_snap 1 0"</span></div><div class="line">sudo dmsetup create snap1 --table <span class="string">"0 2048 thin /dev/mapper/pool 1"</span></div><div class="line">ls /dev/mapper/    <span class="comment"># 这里又会多一个snap1</span></div></pre></td></tr></table></figure></p>
<p>加载这个快照，能看见先前写的file1文件被同步过来了。再往里写个新文件。还是要保证睡眠充足：<br><figure class="highlight sh"><figcaption><span>vagrant host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sudo mount /dev/mapper/snap1 snap1</div><div class="line">sudo ls -l snap1</div><div class="line">sudo cat snap1/file1    <span class="comment"># file1 in thin</span></div><div class="line">sudo sh -c <span class="string">"echo file2 in snap1 &gt; snap1/file2"</span></div><div class="line">sleep 80s</div></pre></td></tr></table></figure></p>
<p>快照是能作为原设备映射成其他快照的，下面从snap1映射一份snap11：<br><figure class="highlight sh"><figcaption><span>vagrant host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo dmsetup message /dev/mapper/pool 0 <span class="string">"create_snap 2 1"</span></div><div class="line">sudo dmsetup create snap11 --table <span class="string">"0 2048 thin /dev/mapper/pool 2"</span></div></pre></td></tr></table></figure></p>
<p>加载完后就能看到file1和file2都被同步过来了：<br><figure class="highlight sh"><figcaption><span>vagrant host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo mount /dev/mapper/snap11 snap11</div><div class="line">sudo ls -l snap11</div><div class="line">sudo cat snap11/file1    <span class="comment"># file1 in thin</span></div><div class="line">sudo cat snap11/file2    <span class="comment"># file2 in snap1</span></div></pre></td></tr></table></figure></p>
<p>一份原设备是可以映射成多个快照的，下面从snap1再映射一份snap12：<br><figure class="highlight sh"><figcaption><span>vagrant host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">sudo dmsetup message /dev/mapper/pool 0 <span class="string">"create_snap 3 1"</span></div><div class="line">sudo dmsetup create snap12 --table <span class="string">"0 2048 thin /dev/mapper/pool 3"</span></div><div class="line"></div><div class="line">sudo mount /dev/mapper/snap12 snap12</div><div class="line">sudo ls -l snap12</div><div class="line">sudo cat snap11/file1    <span class="comment"># file1 in thin</span></div><div class="line">sudo cat snap11/file2    <span class="comment"># file2 in snap1</span></div></pre></td></tr></table></figure></p>
<p>测试完成，清场~<br><figure class="highlight sh"><figcaption><span>vagrant host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">sudo umount snap1</div><div class="line">sudo umount snap11</div><div class="line">sudo umount snap12</div><div class="line">sudo umount thin</div><div class="line"></div><div class="line">sudo dmsetup remove snap11</div><div class="line">sudo dmsetup remove snap12</div><div class="line">sudo dmsetup remove snap1</div><div class="line">sudo dmsetup remove thin</div><div class="line">sudo dmsetup remove pool</div><div class="line"></div><div class="line">sudo losetup -d /dev/loop0</div><div class="line">sudo losetup -d /dev/loop1</div><div class="line"></div><div class="line"><span class="built_in">cd</span> ..</div><div class="line">rm -rf devicemapper</div></pre></td></tr></table></figure></p>
<p>在RHEL，CentOS系列上，Docker默认使用loop-lvm，类似上文的机制（配的是<a href="https://en.wikipedia.org/wiki/Sparse_file" target="_blank" rel="external">稀疏文件</a>），虽然性能比本文要好，但也是堪忧。官方推荐使用<a href="https://docs.docker.com/engine/userguide/storagedriver/device-mapper-driver/#other-device-mapper-performance-considerations" target="_blank" rel="external">direct-lvm</a>，也就是直接使用raw分区。<a href="http://blog.opskumu.com/docker-storage-setup.html" target="_blank" rel="external">这篇文章</a>介绍了如何在CentOS 7上使用direct-lvm。另外，<a href="http://www.infoq.com/cn/articles/analysis-of-docker-file-system-aufs-and-devicemapper/" target="_blank" rel="external">剖析Docker文件系统</a>对AUFS和Device Mapper有很详细的讲解。</p>
<p>回头来看Docker官方的这幅图：<br><img src="http://farm1.staticflickr.com/703/22116692899_0471e5e160_b.jpg" alt=""></p>
<p>一切就都很清楚明了：最底层是两个文件：数据和元数据文件。这两个文件上面是一个pool，再上面是一个原设备，然后就是一层层的快照叠加上去，直至镜像，充分共享了存储空间。</p>
<h2 id="Btrfs"><a href="#Btrfs" class="headerlink" title="Btrfs"></a>Btrfs</h2><p>Btrfs的Btr是B-tree的意思，元数据用B树管理，比较高效。它也支持块级别的写时复制，性能也不错，对SSD有优化，但是不支持SELinux。它支持把文件系统的一部分配置为<a href="https://btrfs.wiki.kernel.org/index.php/SysadminGuide#Subvolumes" target="_blank" rel="external">Subvolume</a>子文件系统，父文件系统就像一个pool一样给这些子文件系统们提供底层的存储空间。这就意味着子文件系统无需关心设置各自的大小，反正背后有父文件系统撑腰。Btrfs还支持对子文件系统的快照，速度非常快，起码比Device Mapper快多了。快照在Btrfs里也是一等公民，同样也可以像Subvolume那样再快照、被加载，享受写时复制技术。</p>
<p>要使用Btrfs，得先安装工具包：<br><figure class="highlight sh"><figcaption><span>vagrant host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install btrfs-tools</div></pre></td></tr></table></figure></p>
<p>下面我们来创建一个文件，用Loop device把它模拟成块设备：<br><figure class="highlight sh"><figcaption><span>vagrant host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">mkdir ~/btrfs</div><div class="line"><span class="built_in">cd</span> ~/btrfs</div><div class="line"></div><div class="line">mkdir result</div><div class="line"></div><div class="line">dd <span class="keyword">if</span>=/dev/zero of=data.img bs=1024K count=10</div><div class="line"></div><div class="line">sudo losetup /dev/loop0 data.img</div><div class="line">sudo losetup -a</div></pre></td></tr></table></figure></p>
<p>把这个块设备格式化成btrfs：<br><figure class="highlight sh"><figcaption><span>vagrant host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo mkfs.btrfs -f /dev/loop0</div><div class="line">sudo mount /dev/loop0 result/</div></pre></td></tr></table></figure></p>
<p>新建一个subvolumn并往里写个文件：<br><figure class="highlight sh"><figcaption><span>vagrant host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo btrfs subvolume create result/origin/</div><div class="line">sudo sh -c <span class="string">"echo file1 in origin &gt; result/origin/file1"</span></div></pre></td></tr></table></figure></p>
<p>给result/origin这个subvolumn添加一份快照snap1，能看见先前写的file1文件被同步过来了。再往里写个新文件：<br><figure class="highlight sh"><figcaption><span>vagrant host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo btrfs subvolume snapshot result/origin/ result/snap1</div><div class="line">sudo ls -l result/snap1</div><div class="line">sudo cat result/snap1/file1    <span class="comment"># file1 in origin</span></div><div class="line">sudo sh -c <span class="string">"echo file2 in snap1 &gt; result/snap1/file2"</span></div></pre></td></tr></table></figure></p>
<p>快照也像Device Mapper那样能生成其他的快照，下面从snap1生成一份snap11：<br><figure class="highlight sh"><figcaption><span>vagrant host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo btrfs subvolume snapshot result/snap1/ result/snap11</div><div class="line">sudo ls -l result/snap11</div><div class="line">sudo cat result/snap11/file1    <span class="comment"># file1 in origin</span></div><div class="line">sudo cat result/snap11/file2    <span class="comment"># file2 in snap1</span></div></pre></td></tr></table></figure></p>
<p>也是可以生成多个快照的，下面从snap1再生成一份snap12：<br><figure class="highlight sh"><figcaption><span>vagrant host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo btrfs subvolume snapshot result/snap1/ result/snap12</div><div class="line">sudo ls -l result/snap12</div><div class="line">sudo cat result/snap12/file1    <span class="comment"># file1 in origin</span></div><div class="line">sudo cat result/snap12/file2    <span class="comment"># file2 in snap1</span></div></pre></td></tr></table></figure></p>
<p>可以使用这个命令来查看所有快照：<br><figure class="highlight sh"><figcaption><span>vagrant host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo btrfs subvolume list result</div></pre></td></tr></table></figure></p>
<p>可以使用这个命令来查看这个文件系统：<br><figure class="highlight sh"><figcaption><span>vagrant host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo btrfs filesystem show /dev/loop0</div></pre></td></tr></table></figure></p>
<p>测试完成，清场~<br><figure class="highlight sh"><figcaption><span>vagrant host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sudo umount result</div><div class="line"></div><div class="line">sudo losetup -d /dev/loop0</div><div class="line"></div><div class="line"><span class="built_in">cd</span> ..</div><div class="line">rm -rf btrfs</div></pre></td></tr></table></figure></p>
<p>我们看到它比Device Mapper更简单一些，并且速度很快，不需要sleep以待同步完成。<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-btrfs/index.html" target="_blank" rel="external">这篇文章</a>虽然有点儿旧了，但是对Btrfs的原理讲得挺清楚的。</p>
<p>回头来看Docker官方的这幅图：<br><img src="https://docs.docker.com/engine/userguide/storagedriver/images/btfs_container_layer.jpg" alt=""></p>
<p>一切就都很清楚明了：最底层是个subvolume，再它之上层层累加快照，镜像也不例外。</p>
<h2 id="Overlay"><a href="#Overlay" class="headerlink" title="Overlay"></a>Overlay</h2><p>最初它叫做OverlayFS，后来被合并进Linux内核的时候被改名为Overlay。它和AUFS一样都是联合文件系统。Overlay由两层文件系统组成：upper（上层）和lower（下层）。下层可以是只读的任意的Linux支持的文件系统，甚至可以是另一个Overlay，而上层一般是可读写的。所以模型上比AUFS要简单一些，这就是为什么我们会认为它更轻量级一些。</p>
<p>用<code>uname -r</code>可以看到我们现在这个vagrant虚拟机的Linux内核版本是3.13，而内核3.18之后才支持Overlay，所以我们得先升级一下内核，否则在mount的时候会出错：<code>mount: wrong fs type, bad option, bad superblock on overlay</code>。运行以下命令来升级ubuntu 14.04的内核：<br><figure class="highlight sh"><figcaption><span>vagrant host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /tmp/</div><div class="line"></div><div class="line">wget http://kernel.ubuntu.com/~kernel-ppa/mainline/v3.18-vivid/linux-headers-3.18.0-031800-generic_3.18.0-031800.201412071935_amd64.deb</div><div class="line">wget http://kernel.ubuntu.com/~kernel-ppa/mainline/v3.18-vivid/linux-headers-3.18.0-031800_3.18.0-031800.201412071935_all.deb</div><div class="line">wget http://kernel.ubuntu.com/~kernel-ppa/mainline/v3.18-vivid/linux-image-3.18.0-031800-generic_3.18.0-031800.201412071935_amd64.deb</div><div class="line">sudo dpkg -i linux-headers-3.18.0-*.deb linux-image-3.18.0-*.deb</div><div class="line">sudo update-grub</div><div class="line"></div><div class="line">sudo reboot</div></pre></td></tr></table></figure></p>
<p>等待重启之后，重新连接进vagrant虚拟机：<br><figure class="highlight sh"><figcaption><span>virtual box host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vagrant ssh</div></pre></td></tr></table></figure></p>
<p>完成之后再用<code>uname -r</code>看一下，现在应该已经是3.18了。下面我们开搞吧：<br><figure class="highlight sh"><figcaption><span>vagrant host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mkdir ~/overlay</div><div class="line"><span class="built_in">cd</span> ~/overlay</div><div class="line"></div><div class="line">mkdir lower upper work merged</div><div class="line"><span class="built_in">echo</span> file1 <span class="keyword">in</span> lower &gt; lower/file1</div><div class="line"><span class="built_in">echo</span> file2 <span class="keyword">in</span> lower &gt; lower/file2</div><div class="line"><span class="built_in">echo</span> file1 <span class="keyword">in</span> upper &gt; upper/file1</div></pre></td></tr></table></figure></p>
<p>现在的文件层级结构看起来是酱紫的：</p>
<p><pre><br>├── lower<br>│   ├── file1   # file1 in lower<br>│   └── file2   # file2 in lower<br>├── merged<br>├── upper<br>│   └── file1   # file1 in upper<br>└── work<br></pre><br>然后我们加载merged，让它的下层是lower，上层是upper。除此之外还需要一个workdir，据说是用来<a href="https://github.com/codelibre-net/schroot/issues/1" target="_blank" rel="external">做一些内部文件原子性操作</a>的，必须是空文件夹：<br><figure class="highlight sh"><figcaption><span>vagrant host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo mount -t overlay overlay -olowerdir=lower,upperdir=upper,workdir=work merged</div><div class="line"></div><div class="line">cat merged/file1   <span class="comment"># file1 in upper</span></div><div class="line">cat merged/file2   <span class="comment"># file2 in lower</span></div></pre></td></tr></table></figure></p>
<p>所以我们最终得到了类似AUFS一样的结果。测试完成，清场~<br><figure class="highlight sh"><figcaption><span>vagrant host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo umount merged</div><div class="line"></div><div class="line"><span class="built_in">cd</span> ..</div><div class="line">rm -rf overlay</div></pre></td></tr></table></figure></p>
<p>在Linux内核3.19之后，overlay还能够支持多层lower（Multiple lower layers），这样就能更好地支持docker镜像的模型了。多层的mount命令是酱紫的：<code>mount -t overlay overlay -olowerdir=/lower1:/lower2:/lower3 /merged</code>，有兴趣的朋友可以再次升级Linux内核试试。</p>
<p>回头来看Docker官方的这幅图：<br><img src="https://docs.docker.com/engine/userguide/storagedriver/images/overlay_constructs.jpg" alt=""></p>
<p>很好地说明了OverlayFS驱动下容器和镜像的存储是怎么工作的，lower、upper和merged各自的关系。然后看看docker镜像：<br><img src="https://docs.docker.com/engine/userguide/storagedriver/images/overlay_constructs2.jpg" alt=""></p>
<p>因为目前docker支持的还不是多层存储，所以在镜像里只是用硬链接来在较低层之间共享数据。今后docker应该会利用overlay的多层技术来改善镜像各层的存储。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ZFS和VFS由于官方都不推荐上生产我们就不试了，虽然OverlayFS也不推荐，但是它毕竟代表着未来的趋势，还是值得我们看一看的。下表列出了docker所支持的存储驱动特性对比：</p>
<table>
<thead>
<tr>
<th style="text-align:center">驱动</th>
<th style="text-align:center">联合文件系统</th>
<th style="text-align:center">写时复制</th>
<th style="text-align:center">内核</th>
<th style="text-align:center">SELinux</th>
<th style="text-align:center">上生产环境</th>
<th style="text-align:center">速度</th>
<th style="text-align:center">存储空间占用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">AUFS</td>
<td style="text-align:center">是</td>
<td style="text-align:center">文件级别</td>
<td style="text-align:center">不支持</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">推荐</td>
<td style="text-align:center">快</td>
<td style="text-align:center">小</td>
</tr>
<tr>
<td style="text-align:center">Device Mapper</td>
<td style="text-align:center">不是</td>
<td style="text-align:center">块级别</td>
<td style="text-align:center">2.6.9</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">有限推荐</td>
<td style="text-align:center">慢</td>
<td style="text-align:center">较大</td>
</tr>
<tr>
<td style="text-align:center">Btrfs</td>
<td style="text-align:center">不是</td>
<td style="text-align:center">块级别</td>
<td style="text-align:center">2.6.29</td>
<td style="text-align:center">不支持</td>
<td style="text-align:center">有限推荐</td>
<td style="text-align:center">较快</td>
<td style="text-align:center">较小</td>
</tr>
<tr>
<td style="text-align:center">OverlayFS</td>
<td style="text-align:center">是</td>
<td style="text-align:center">文件级别</td>
<td style="text-align:center">3.18</td>
<td style="text-align:center">不支持</td>
<td style="text-align:center">不推荐</td>
<td style="text-align:center">快</td>
<td style="text-align:center">小</td>
</tr>
<tr>
<td style="text-align:center">ZFS</td>
<td style="text-align:center">不是</td>
<td style="text-align:center">块级别</td>
<td style="text-align:center">不支持</td>
<td style="text-align:center">不支持</td>
<td style="text-align:center">不推荐</td>
<td style="text-align:center">较快</td>
<td style="text-align:center">较小</td>
</tr>
<tr>
<td style="text-align:center">VFS</td>
<td style="text-align:center">不是</td>
<td style="text-align:center">不支持</td>
<td style="text-align:center">2.4</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">不推荐</td>
<td style="text-align:center">很慢</td>
<td style="text-align:center">大</td>
</tr>
</tbody>
</table>
]]></content>
      
        <categories>
            
            <category> devops </category>
            
        </categories>
        
        
        <tags>
            
            <tag> docker </tag>
            
            <tag> storage </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Docker的桥接网络是怎么工作的]]></title>
      <url>/docker-bridge-network/</url>
      <content type="html"><![CDATA[<p>我们都知道docker支持多种网络，默认网络bridge是通过一个网桥进行容器间通信的。这篇文章从零开始，用一些Linux的命令来查看主机和容器间的网络通信，也顺带介绍一些网络的基本知识。<br><a id="more"></a></p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>我们需要先安装<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="external">virtualBox</a>和<a href="https://www.vagrantup.com/downloads.html" target="_blank" rel="external">vagrant</a>。通过vagrant来驱动virtualBox搭建一个虚拟测试环境。首先在本地任意路径新建一个空文件夹比如<code>test</code>，运行以下命令：<br><figure class="highlight sh"><figcaption><span>virtual box host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mkdir <span class="built_in">test</span></div><div class="line"><span class="built_in">cd</span> <span class="built_in">test</span></div><div class="line">vagrant init minimum/ubuntu-trusty64-docker</div><div class="line">vi Vagrantfile</div></pre></td></tr></table></figure></p>
<p>里面应该有一句<code># config.vm.network &quot;private_network&quot;, ip: &quot;192.168.33.10&quot;</code>，删掉前面的<code>#</code>注释，相当于给它分配一个<code>192.168.33.10</code>的IP。这个vagrant镜像已经在ubuntu的基础上帮我们安装了docker，用起来很方便。然后运行以下命令启动并连接虚拟机。<br><figure class="highlight sh"><figcaption><span>virtual box host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vagrant up</div><div class="line">vagrant ssh</div></pre></td></tr></table></figure></p>
<h2 id="主机和容器间的网络连接"><a href="#主机和容器间的网络连接" class="headerlink" title="主机和容器间的网络连接"></a>主机和容器间的网络连接</h2><p>进入虚拟机后，在vagrant主机上运行<code>ifconfig</code>，就能看到有4个网络设备及它们的IPv4地址：</p>
<ul>
<li>docker0：172.17.0.1</li>
<li>eth0：10.0.2.15</li>
<li>eth1：192.168.33.10</li>
<li>lo：127.0.0.1</li>
</ul>
<p>其中的<code>eth0</code>和<code>eth1</code>是普通的以太网卡，<code>eth1</code>就是我们解除注释的IP：<code>192.168.33.10</code>。<code>lo</code>是所谓的<a href="https://en.wikipedia.org/wiki/Loopback" target="_blank" rel="external">环回网卡</a>，每台机器都有。它将这台机器/容器绑定到<code>127.0.0.1</code>的IP上，这样子就算没有真实的网卡，也能通过这个IP访问自己，对于测试来说尤其方便。最上面的<code>docker0</code>就是我们常说的网桥。怎么知道它是个网桥呢？安装<code>bridge-utils</code>的包就能看到了：<br><figure class="highlight sh"><figcaption><span>vagrant host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install bridge-utils</div><div class="line">brctl show</div></pre></td></tr></table></figure></p>
<p>网桥设备就好比交换机，可以和其他的网络设备相连接，就像在其他网络设备上拉根网线到这个交换机一样。那么docker怎么使用这个网桥呢，让我们来启动一个容器看看：<br><figure class="highlight sh"><figcaption><span>vagrant host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -it --name=ubuntu ubuntu:14.04 bash</div></pre></td></tr></table></figure></p>
<p>进入容器后，运行<code>ifconfig</code>，就能够看到有2个网络设备及它们的IPv4地址：</p>
<ul>
<li>eth0：172.17.0.2</li>
<li>lo：127.0.0.1</li>
</ul>
<p>它也有自己的<code>lo</code>，还有一块以太网卡<code>eth0</code>，目前的IP是<code>172.17.0.2</code>。使用快捷键<code>Ctrl+P</code>然后再<code>Ctrl+Q</code>，就能退出容器并保持它继续运行。在vagrant主机上运行<code>route</code>命令，可以看到类似下面这个表格：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Destination</th>
<th style="text-align:center">Gateway</th>
<th style="text-align:center">Genmask</th>
<th style="text-align:center">Flags</th>
<th style="text-align:center">Metric</th>
<th style="text-align:center">Ref</th>
<th style="text-align:center">Use</th>
<th style="text-align:center">Iface</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">default</td>
<td style="text-align:center">10.0.2.2</td>
<td style="text-align:center">0.0.0.0</td>
<td style="text-align:center">UG</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">eth0</td>
</tr>
<tr>
<td style="text-align:center">10.0.2.0</td>
<td style="text-align:center">*</td>
<td style="text-align:center">255.255.255.0</td>
<td style="text-align:center">U</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">eth0</td>
</tr>
<tr>
<td style="text-align:center">172.17.0.0</td>
<td style="text-align:center">*</td>
<td style="text-align:center">255.255.0.0</td>
<td style="text-align:center">U</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">docker0</td>
</tr>
<tr>
<td style="text-align:center">192.168.33.0</td>
<td style="text-align:center">*</td>
<td style="text-align:center">255.255.255.0</td>
<td style="text-align:center">U</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">eth1</td>
</tr>
</tbody>
</table>
<p>这个就是vagrant主机的路由表。我们重点看一下<code>172.17.0.0</code>这一行。它的Genmask为<code>255.255.0.0</code>，就意味着<code>255.255</code>对应着的IP<code>172.17</code>是网络地址，而Genmask中<code>0.0</code>对应着的IP<code>0.0</code>是主机地址。整行的意思就是当目标地址是<code>172.17.*.*</code>的时候，匹配这条路由规则。还有一种写法是<code>172.17.0.0/16</code>。当Gateway不为<code>*</code>号时，那就会路由到Gateway去，否则就路由到Iface去。刚才我们知道新容器的IP是<code>172.17.0.2</code>，所以当vagrant主机上的某个数据包的地址是这个新容器的IP时，就会匹配这条路由规则，由docker0来接受这个数据包。如果数据包的地址都不匹配这些规则，就送到<code>default</code>那一行的<code>Gateway</code>里。</p>
<p>那么docker0在接收数据包之后，又会送到哪里去呢？我们在vagrant主机再次运行<code>brctl show</code>，便能看到docker0这个网桥有所变化。它的<code>interfaces</code>里增加了一个<code>vethXXX</code>，在我的机器上叫<code>vethd6d3942</code>。在vagrant主机再次运行<code>ifconfig</code>，我们也能看到这一块新增的VETH虚拟网卡。实际上每启动一个容器，docker便会增加一个叫<code>vethXXX</code>的设备，并把它连接到docker0上，于是docker0就可以把收到的数据包发给这个VETH设备。VETH设备总是成对出现，一端进去的请求总会从peer也就是另一端出来，这样就能将一个namespace的数据发往另一个namespace，就像虫洞一样。那么现在这一端是<code>vethd6d3942</code>，它的另一端是哪儿呢？运行这个命令（记得把VETH设备名改成你自己主机上的设备名）：<br><figure class="highlight sh"><figcaption><span>vagrant host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ethtool -S vethd6d3942</div></pre></td></tr></table></figure></p>
<p>可以看到这个VETH设备的<code>peer_ifindex</code>是某个数字，在我的机器上是<code>5</code>。这个<a href="http://www.cisco.com/c/en/us/support/docs/ip/simple-network-management-protocol-snmp/28420-ifIndex-Persistence.html" target="_blank" rel="external">ifindex</a>是一个网络接口的唯一识别编号。通过<code>docker exec -it ubuntu bash</code>进入容器里，然后运行：<br><figure class="highlight sh"><figcaption><span>ubuntu container</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ip link</div></pre></td></tr></table></figure></p>
<p>可以看到<code>5: eth0</code>，原来跨越namespace跑到容器里头来啦。这就是主机上的VETH设备能跟容器内部通信的原因。每当新启动一个容器，主机就会增加一对VETH设备，把一个连接到docker0上，另一个挂载到容器内部的eth0里。</p>
<h2 id="IP和mac地址映射"><a href="#IP和mac地址映射" class="headerlink" title="IP和mac地址映射"></a>IP和mac地址映射</h2><p>还有一个问题：每个网络设备都有自己的mac地址，通过ip怎么能找到它呢？在容器外运行这个命令：<br><figure class="highlight sh"><figcaption><span>vagrant host</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arp -n</div></pre></td></tr></table></figure></p>
<p>我们就能看到<code>Address</code>和<code>HWaddress</code>，它们分别对应着IP地址和mac地址，这样就匹配起来了。到容器里<code>ifconfig</code>一下，看看<code>172.17.0.2</code>的mac地址，是不是和主机<code>arp -n</code>运行结果中<code>172.17.0.2</code>那行的mac地址一样呢？</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.ibm.com/developerworks/cn/linux/1310_xiawc_networkdevice/" target="_blank" rel="external">Linux上的基础网络设备详解</a>，介绍了不同的网络设备工作原理。<br><a href="http://www.oschina.net/translate/docker-network-configuration" target="_blank" rel="external">Docker网络配置</a>，从零开始配置docker的网络。<br><a href="http://vbird.dic.ksu.edu.tw/linux_server/0110network_basic.php" target="_blank" rel="external">基础网络概念</a>，来自鸟哥，深入浅出地介绍了网络的基础知识。<br><a href="http://linux.vbird.org/linux_server/0140networkcommand.php" target="_blank" rel="external">Linux常用网络命令</a>，来自鸟哥，看完了就对茫茫的网络命令有了清晰的了解。</p>
]]></content>
      
        <categories>
            
            <category> devops </category>
            
        </categories>
        
        
        <tags>
            
            <tag> docker </tag>
            
            <tag> network </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用ansible管理大规模集群]]></title>
      <url>/ansible-large-scale-cluster/</url>
      <content type="html"><![CDATA[<p><a href="http://www.ansible.com/get-started" target="_blank" rel="external">Ansible</a>是一个配置管理工具，可以用脚本批量操作多台机器。它的特点是非常简洁，基于<a href="https://wiki.archlinux.org/index.php/Secure_Shell_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="external">SSH</a>，不需要安装代理。但它的缺点也很明显：效率较低，容易挂起，不那么适合大规模环境（如500台以上）。本文介绍了使用ansible管理大规模集群的几种方法。<br><a id="more"></a></p>
<h2 id="增加并行进程数"><a href="#增加并行进程数" class="headerlink" title="增加并行进程数"></a>增加并行进程数</h2><p>Ansible提供一个<a href="http://docs.ansible.com/ansible/intro_configuration.html#forks" target="_blank" rel="external">forks</a>的属性，可以设置运行并行进程数。这个值默认比较保守，只有5个并行进程。我们可以根据自己的机器性能以及网络情况来设定，很多人使用50，也有用500以上的。如果有很多机器要管理的话，可以尝试先增加这个值，看看效果。有三个地方可以设置forks的数量：</p>
<ul>
<li>环境变量：<code>export ANSIBLE_FORKS=100</code></li>
<li>ansible.cfg这个配置文件里设置：<code>forks=100</code></li>
<li>运行ansible命令时增加参数：<code>-f 100</code></li>
</ul>
<p>当机器数量比较大的时候，难免会有几台机器不能正常执行。这时候ansible会有提示<code>to retry, use: --limit @/xxx/xxx.retry</code>，把它增加到上个命令的后面就好了。</p>
<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>有时候执行某个任务可能需要很长的时间，在集群规模较大的情况下慢得让人无法忍受。这时可以考虑使用<a href="http://docs.ansible.com/ansible/playbooks_async.html" target="_blank" rel="external">异步模式</a>。在<code>tasks</code>里增加<code>async</code>的属性，设成某个数字，比如60，意思就是这个任务最大运行时间不能超过60秒。也可以设成0，意思是不管任务运行多久，一直等待即可。如果没有指定<code>async</code>，则默认为同步模式。还可以设定<code>poll</code>，默认值为10，意思就是每隔10秒轮询查看结果。如果不需要查看结果，设为0就好了。还可以通过<code>register</code>和<code>async_status</code>设定暂时不查看结果，等需要的时候再查看。具体做法可以参考上面的<a href="http://docs.ansible.com/ansible/playbooks_async.html" target="_blank" rel="external">异步模式官网文档</a>，也可以看<a href="http://www.ansible.com.cn/docs/playbooks_async.html" target="_blank" rel="external">翻译的中文文档</a>。</p>
<h2 id="Pull模式"><a href="#Pull模式" class="headerlink" title="Pull模式"></a>Pull模式</h2><p>有些配置管理工具比如<a href="https://www.chef.io/chef/" target="_blank" rel="external">Chef</a>和<a href="https://puppetlabs.com/" target="_blank" rel="external">Puppet</a>，是基于拉模式的。所谓拉模式，是酱紫的：</p>
<ul>
<li>管理员写脚本</li>
<li>管理员上传脚本</li>
<li>agent定时取脚本（例如每隔1分钟）</li>
<li>agent运行新脚本</li>
</ul>
<p>Ansible是没有agent的，它默认基于推模式，也就是说：</p>
<ul>
<li>管理员写脚本</li>
<li>管理员运行脚本</li>
<li>ansible连接各主机运行脚本</li>
</ul>
<p>一般来说，拉模式能轻松应付大规模集群，因为每台机器都是自己去拉取脚本来完成任务。不过也有人用ansible的推模式管理着上千台机器。Ansible提供了<a href="http://docs.ansible.com/ansible/playbooks_intro.html#ansible-pull" target="_blank" rel="external">ansible-pull</a>的工具，能把它变成拉模式。官方资料不多，<a href="https://www.stavros.io/posts/automated-large-scale-deployments-ansibles-pull-mo/" target="_blank" rel="external">这篇文章</a>写得比较详细。大致思路是新建一个<a href="http://git-scm.com/" target="_blank" rel="external">git</a>的仓库，每台机器运行一个cron定时任务（扮演者agent的角色）每隔一段时间去仓库取最新脚本，然后运行之。在<a href="https://raw.githubusercontent.com/ansible/ansible/stable-2.0/CHANGELOG.md" target="_blank" rel="external">ansible 2.0</a>里<code>ansible-pull</code>也有若干改进。</p>
<h2 id="多级调度"><a href="#多级调度" class="headerlink" title="多级调度"></a>多级调度</h2><p>还有一种想法是：如果一台主机的性能只能撑100<code>forks</code>，那么10台主机应该就能撑1000台机器。将这1000台机器分区，比如A区到J区。所以由一台主机分发命令给10台主机，让它们各自运行<code>ansible-playbook</code>，而每台主机根据不同的<a href="http://docs.ansible.com/ansible/intro_inventory.html" target="_blank" rel="external">inventory</a>或者是不同的<a href="http://allandenot.com/devops/2015/01/16/ansible-with-multiple-inventory-files.html" target="_blank" rel="external">limit方式</a>来控制不同区的机器并返回结果。理论上这样的多级调度是能够撑起大规模集群的，就是脚本写起来比较麻烦，需要考虑一级主机和二级主机。</p>
<h2 id="其他参考资料"><a href="#其他参考资料" class="headerlink" title="其他参考资料"></a>其他参考资料</h2><p>说到底，如果运行得快，那么集群规模大一点也可以。<a href="http://www.ansible.com/blog/ansible-performance-tuning" target="_blank" rel="external">这篇文章</a>介绍了一些ansible性能调优的方法。<br><a href="https://mackerel.io/" target="_blank" rel="external">Mackerel</a>是一个监控平台。<a href="http://yuuki.hatenablog.com/entry/ansible-mackerel-1000" target="_blank" rel="external">这篇日文文章</a>介绍了使用Ansible和Mackerel API管理1000台规模集群的方法。<a href="http://www.ansible.com/tower" target="_blank" rel="external">Ansible tower</a>也提供了类似的可视化管理页面，官方出品，是不是更靠谱呢。</p>
]]></content>
      
        <categories>
            
            <category> devops </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ansible </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[传统企业敏捷转型纪实（二）]]></title>
      <url>/waterfall-to-agile-2/</url>
      <content type="html"><![CDATA[<p>这是启动会议结束之后一周内发生的事。我们现在有了迭代计划，一堆的story和一堆迷茫的人。接下来怎么做开发？本系列目前有两篇：</p>
<ul>
<li><a href="/waterfall-to-agile-1">传统企业敏捷转型纪实（一）</a></li>
<li><a href="/waterfall-to-agile-2">传统企业敏捷转型纪实（二）</a><a id="more"></a>
</li>
</ul>
<h2 id="迭代开始"><a href="#迭代开始" class="headerlink" title="迭代开始"></a>迭代开始</h2><p>上次刚刚理清楚了各组自己的需求，但是组员们并不是都完全了解。Ken先把所有人都召集起来，告诉大家：现在需求不仅仅是BA的事情了，需求不清是开发和测试的责任，大家有义务互相协作，把需求理清楚。各个PO开始讲依赖：有没有依赖于其他组的story？有没有依赖其他人（比如整个大组只有一位安全专家，可能有些story会对这个人有依赖）？PO们讲完了，有的组可能就凭空多了几张被别的组所依赖的卡，优先级还都比较高。所以需要重新安排一下迭代。计划调整完后，各个PO依次大致地给SPO讲一下自己组第一迭代的主要功能和风险，在获得SPO的认可之后，第一个迭代的计划就算确定下来。</p>
<p>然后就该每个组员认领story了。Ken要求每个story都要有对应的开发和测试人员，从新人开始认领。每个成员自己想学什么，想做什么，职业规划是什么，按照它们来决定自己要开发的story。这样的目的是激发每个人的潜能，提高团队的能力，而不仅仅是着眼于这个版本的交付。同样的，每个成员，都不仅仅是开发这个版本，而是开发一个产品。现实中，可能会出现胡乱挑卡的情况，比如说A卡可能很适合甲来做，但是乙是新人，抢先把卡挑走了，这时候就需要PO来与大家沟通，做决策。</p>
<p>落实完了每个人的工作，Ken又把大家叫到一起，问：你们对按时发布有没有信心？5分就是信心指数最高，1分最低，大家一起伸手指示意。大部分人都举4或者5，也许是无所谓，也许是还没适应一个有话就应该讲出来的环境。有个别成员伸3个指头的，就需要解释一下为什么信心不足，SPO需要当场把问题解决，尽量做到所有人都信心爆棚，起码看上去得是这样。</p>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>到了具体开发阶段了，怎么做呢？第二天就是一堂需求分析的课程。大家探讨一下开发和测试怎么协作，需求应该怎么分析，测试用例应该怎么写。对于一个story，开发人员需要知道怎么测，做出来的东西由谁来用，才有能力开发。Ken引入了场景树来做需求分析。举个栗子：一个<strong>买手机</strong>的story。看起来好像需求很明确，但是具体做就会有各种问题：到底对方要的是什么样的手机？所以开发前必须搞清楚，这个story的目的是什么。买手机是内容，不是目的。用5个为什么来深挖，可能就能得到这样的目的：<strong>女朋友手机坏了，让我买个新手机</strong>。然后我们可以画出这样的图：<br><img src="/img/scene-tree-1.png" alt=""></p>
<p>第一个步骤可能就是去取款准备买手机。这个步骤可以用<strong>活动</strong>、<strong>实体</strong>、<strong>结果</strong>来建模。活动应该是动词，描述一个活动：取款。它产生了一个名词实体：人民币。校验这个实体可以得到结果，结果具有若干维度。有点晕？看图：<br><img src="/img/scene-tree-2.png" alt=""></p>
<p>取款这个活动，产生了人民币这个实体。结果的维度是金额。取完款之后，去手机店的动作，产生了手机店这个实体。结果的维度有哪家店和日期时间。到店之后，购买手机的活动产生了手机这个实体。结果的维度有品牌、型号、价格等等。这些维度越清晰，这个需求分析的质量越好。如图：<br><img src="/img/scene-tree-3.png" alt=""></p>
<p>有的朋友可能会问：除了最后得到新手机，是不是也得校验我取的款花了多少，那怎么体现在图里呢？这个还是看需求。如果必要的话，可以在购买完手机后増加一个计算余额的活动。</p>
<h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><p>画完场景图之后，就能比较容易地根据实体和维度导出测试用例来。还是以买手机为例：首先验证第一个实体：人民币。画张表格如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:right">金额</th>
<th style="text-align:center">预期结果</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">人民币</td>
<td style="text-align:right">1000</td>
<td style="text-align:center">OK</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">人民币</td>
<td style="text-align:right">0</td>
<td style="text-align:center">NG</td>
<td style="text-align:left">银行账户余额不足</td>
</tr>
</tbody>
</table>
<p>从Given、When、Then的角度上看，再加上Given，这就是一个很具体的单元测试用例。然后是手机店：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">哪家店</th>
<th style="text-align:center">日期时间</th>
<th style="text-align:center">预期结果</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">手机店</td>
<td style="text-align:center">国美</td>
<td style="text-align:center">2016/01/20 10:00:00</td>
<td style="text-align:center">OK</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">手机店</td>
<td style="text-align:center">苏宁</td>
<td style="text-align:center">2016/01/20 22:00:00</td>
<td style="text-align:center">NG</td>
<td style="text-align:left">下班了</td>
</tr>
<tr>
<td style="text-align:center">手机店</td>
<td style="text-align:center">苏美</td>
<td style="text-align:center">2016/01/20 10:00:00</td>
<td style="text-align:center">NG</td>
<td style="text-align:left">没有这家店</td>
</tr>
</tbody>
</table>
<p>最后是新手机：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">品牌</th>
<th style="text-align:center">型号</th>
<th style="text-align:right">价格</th>
<th style="text-align:center">预期结果</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">新手机</td>
<td style="text-align:center">小米</td>
<td style="text-align:center">Mi Note</td>
<td style="text-align:right">1999</td>
<td style="text-align:center">OK</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">新手机</td>
<td style="text-align:center">魅族</td>
<td style="text-align:center">MX-5</td>
<td style="text-align:right">1799</td>
<td style="text-align:center">NG</td>
<td style="text-align:left">没有这个型号</td>
</tr>
<tr>
<td style="text-align:center">新手机</td>
<td style="text-align:center">华为</td>
<td style="text-align:center">Mate8</td>
<td style="text-align:right">-3199</td>
<td style="text-align:center">NG</td>
<td style="text-align:left">价格不正确</td>
</tr>
<tr>
<td style="text-align:center">新手机</td>
<td style="text-align:center">小魅</td>
<td style="text-align:center">MiMX</td>
<td style="text-align:right">999</td>
<td style="text-align:center">NG</td>
<td style="text-align:left">没有这个品牌</td>
</tr>
</tbody>
</table>
<p>从上面这几张表我们也能看出来，维度越多，测试案例也就越多，所以说需求的质量就会越高。</p>
]]></content>
      
        <categories>
            
            <category> agile </category>
            
        </categories>
        
        
        <tags>
            
            <tag> agile </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如果有10000台机器，你想怎么玩？（五）日志]]></title>
      <url>/kubernetes-in-mesos-5/</url>
      <content type="html"><![CDATA[<p>这次聊聊mesos+k8s的集中化日志方案。日志通常是由许多文件组成，被分散地储存到不同的地方，所以需要集中化地进行日志的统计和检索。</p>
<ul>
<li><a href="/kubernetes-in-mesos-1">如果有10000台机器，你想怎么玩？（一）概述</a></li>
<li><a href="/kubernetes-in-mesos-2">如果有10000台机器，你想怎么玩？（二）高可用</a></li>
<li><a href="/kubernetes-in-mesos-3">如果有10000台机器，你想怎么玩？（三）持久化</a></li>
<li><a href="/kubernetes-in-mesos-4">如果有10000台机器，你想怎么玩？（四）监控</a></li>
<li><a href="/kubernetes-in-mesos-5">如果有10000台机器，你想怎么玩？（五）日志</a></li>
<li><a href="/kubernetes-in-mesos-6">如果有10000台机器，你想怎么玩？（六）性能</a></li>
<li><a href="/kubernetes-in-mesos-7">如果有10000台机器，你想怎么玩？（七）生命周期</a></li>
<li><a href="/kubernetes-in-mesos-8">如果有10000台机器，你想怎么玩？（八）网络</a></li>
<li><a href="/kubernetes-in-mesos-9">如果有10000台机器，你想怎么玩？（九）安全性</a><a id="more"></a>
</li>
</ul>
<h2 id="集中化日志架构"><a href="#集中化日志架构" class="headerlink" title="集中化日志架构"></a>集中化日志架构</h2><p><a href="http://jasonwilder.com/blog/2013/07/16/centralized-logging-architecture/" target="_blank" rel="external">集中化日志架构</a>包括这几个阶段：收集、传输、存储和分析，有时候也许会涉及告警。</p>
<ul>
<li>收集：通常以代理的形式运行在各个节点上，负责收集日志。我们希望能尽可能地实时，因为当我们重现一个bug的时候，不会愿意再等上好几分钟才能看到当时的操作日志。</li>
<li>传输：把收集到的日志传给存储。这个阶段关注的是可靠性。万一日志丢失的话那可就麻烦了。</li>
<li>存储：按需选择用什么形式的存储。比如要存多久时间？要不要支持扩容？找历史数据的可能性有多大？</li>
<li>分析：不同的分析工具适用于不同的存储。这个也包含可视化的分析及报表导出等等。</li>
<li>告警：出现错误日志的时候通知运维人员。最好还能聚合相同的错误，因为作为运维来说，实在是不想看到同一个类型的错误不停地骚扰过来。</li>
</ul>
<h2 id="传统日志方案"><a href="#传统日志方案" class="headerlink" title="传统日志方案"></a>传统日志方案</h2><p>商业方案<a href="http://www.splunk.com/" target="_blank" rel="external">splunk</a>几乎拥有市面上最丰富的功能，高可用，可扩展，安全，当然很复杂也很贵。还有一个试图成为splunk的SaaS版本<a href="https://www.sumologic.com/" target="_blank" rel="external">Sumo Logic</a>，包含精简的免费版和收费版。免费方案中比较著名的有Elasticsearch公司（现在叫Elastic公司）的<a href="https://www.elastic.co/webinars/introduction-elk-stack" target="_blank" rel="external">ELK</a>和Apache的<a href="http://flume.apache.org/" target="_blank" rel="external">Flume</a>+<a href="http://kafka.apache.org/" target="_blank" rel="external">Kafka</a>+<a href="http://storm.apache.org/" target="_blank" rel="external">Storm</a>。</p>
<p>ELK是<a href="https://www.elastic.co/products/elasticsearch" target="_blank" rel="external">Elastic search</a>、<a href="https://www.elastic.co/products/logstash" target="_blank" rel="external">Logstash</a>和<a href="https://www.elastic.co/products/kibana" target="_blank" rel="external">Kibana</a>三个开源软件的组合。其中logstash可以对日志进行收集、过滤和简单处理，并将其存储到elastic search上，最终供kibana展示（和上一篇的监控很类似啊）。这套方案可以参考<a href="http://dockone.io/article/505" target="_blank" rel="external">新浪的实时日志架构</a>。这一本<a href="http://kibana.logstash.es/content/" target="_blank" rel="external">ELKstack 中文指南</a>也写得非常详细。</p>
<p>Apache的flume扮演者类似logstash的角色来收集数据，storm可以对flume采集到的数据进行实时分析。由于数据的采集和处理速度可能不一致，因此用消息中间件kafka来作为缓冲。但是kafka不可能存储所有的日志数据，所以会用其他的存储系统来负责持久化，如同样由Apache提供的<a href="https://hadoop.apache.org/docs/r1.2.1/hdfs_design.html" target="_blank" rel="external">HDFS</a>。这套方案可以参考<a href="http://tech.meituan.com/mt-log-system-arch.html" target="_blank" rel="external">美团的日志收集系统架构</a>。如果需要对分析后的结果持久化，还可以引入<a href="https://www.mysql.com/" target="_blank" rel="external">mysql</a>等数据库。</p>
<h2 id="kubernetes方案"><a href="#kubernetes方案" class="headerlink" title="kubernetes方案"></a>kubernetes方案</h2><p>虽然也支持logstash，Kubernetes官方使用的是<a href="http://www.fluentd.org/" target="_blank" rel="external">fluentd</a>（有<a href="http://www.tuicool.com/articles/7FzqeeI" target="_blank" rel="external">文章</a>称logstash侧重可扩展性而fluentd侧重可靠性）。比方说我们要收集tomcat的日志，可以在tomcat的pod里增加一个<a href="https://github.com/kubernetes/contrib/tree/master/logging/fluentd-sidecar-es" target="_blank" rel="external">fluentd-sidecar-es</a>的辅助容器，指定tomcat容器的日志文件地址，再指定elastic search服务的位置（对于fluentd-sidecar-es这个特定容器来说，是写死在td-agent.conf文件里的），fluentd便会自行将日志文件发送给elastic search。至于kibana，只需指定elastic search的url就能用了。这是kibana的日志页面：<br><img src="/img/kibana.jpg" alt=""></p>
<p>还可以根据日志来配置各种图表，生成很炫的Dashboard。这个是官方的<a href="http://demo.elastic.co/packetbeat/" target="_blank" rel="external">demo</a>：<br><img src="/img/kibana-official.jpg" alt=""></p>
<p>如果日志不是写到文件系统，而是写到stdout或者stderr，那么kubernetes直接就可以用logs命令看到，就不需要这一整套了。但是一个复杂的web应用，通常还是有复杂的日志文件配置的。</p>
]]></content>
      
        <categories>
            
            <category> devops </category>
            
        </categories>
        
        
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> mesos </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如果有10000台机器，你想怎么玩？（四）监控]]></title>
      <url>/kubernetes-in-mesos-4/</url>
      <content type="html"><![CDATA[<p>这次聊聊mesos+k8s的监控告警方案。所谓监控主要就是收集和储存主机和容器的实时数据，根据运维人员的需求展示出来的过程。</p>
<ul>
<li><a href="/kubernetes-in-mesos-1">如果有10000台机器，你想怎么玩？（一）概述</a></li>
<li><a href="/kubernetes-in-mesos-2">如果有10000台机器，你想怎么玩？（二）高可用</a></li>
<li><a href="/kubernetes-in-mesos-3">如果有10000台机器，你想怎么玩？（三）持久化</a></li>
<li><a href="/kubernetes-in-mesos-4">如果有10000台机器，你想怎么玩？（四）监控</a></li>
<li><a href="/kubernetes-in-mesos-5">如果有10000台机器，你想怎么玩？（五）日志</a></li>
<li><a href="/kubernetes-in-mesos-6">如果有10000台机器，你想怎么玩？（六）性能</a></li>
<li><a href="/kubernetes-in-mesos-7">如果有10000台机器，你想怎么玩？（七）生命周期</a></li>
<li><a href="/kubernetes-in-mesos-8">如果有10000台机器，你想怎么玩？（八）网络</a></li>
<li><a href="/kubernetes-in-mesos-9">如果有10000台机器，你想怎么玩？（九）安全性</a><a id="more"></a>
</li>
</ul>
<h2 id="数据采集"><a href="#数据采集" class="headerlink" title="数据采集"></a>数据采集</h2><p><a href="https://github.com/google/cadvisor" target="_blank" rel="external">cAdvisor</a>由谷歌出品，可以收集主机及容器的CPU、内存、网络和存储的各项指标。它也提供了REST API以供其他程序来收集这些指标。可以很简单地用容器将它启动起来。它提供了一个页面，通过下面这幅图可以有个直观地认识：<br><img src="/img/cAdvisor.jpg" alt=""><br>kubelet集成了cAdvisor，由于kubernetes会在每个slave上启动kubelet，所以我们不用额外运行cAdvisor容器，就能够监控所有slave的主机和容器。</p>
<p>从cAdvisor提供的漂亮页面上，我们能看到某台主机及其中的容器监控数据。但是还不够，我们想要的是整个集群的数据，而非一个个单体。这时候就轮到<a href="https://github.com/kubernetes/heapster" target="_blank" rel="external">heapster</a>出场了。它支持cAdvisor和kubernetes v1.0.6及后续的版本。运行heapster需要指定两个参数：一个是用https的方式启动的kubernetes api server用来收集数据，另一个是将收集到的数据储存起来的地方，以供随时查看。</p>
<h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><p><a href="https://influxdata.com/time-series-platform/influxdb/" target="_blank" rel="external">InfluxDB</a>正是这样一个数据存储的地方。它是InfluxData公司开发的一个分布式键值<a href="http://www.infoq.com/cn/articles/database-timestamp-01" target="_blank" rel="external">时序数据库</a>，也就是说，任何数据都包含时间属性。这样可以很方便地查询到某段时间内的监控数据。举个栗子，查找5分钟前的数据：<code>WHERE time &gt; NOW() - 5m</code>。InfluxDB提供了前端页面供我们查找数据：<br><img src="/img/InfluxDB.jpg" alt=""></p>
<p>听说InfluxDB的性能一般，如果使用中遇到坑，可以试试<a href="http://opentsdb.net/" target="_blank" rel="external">OpenTSDB</a>。</p>
<h2 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h2><p>数据也都整合起来了，现在缺的是一个页面将这些数据显示出来。<a href="http://grafana.org/" target="_blank" rel="external">Grafana</a>是纯js开发的、拥有很炫页面的，你们喜欢的Darcula风格的前端。只要指定InfluxDB的url，它就可以轻易地将数据显示出来。看看这个页面：<br><img src="/img/Grafana.jpg" alt=""></p>
<p>heapster的数据除了传送出去保存起来，也可以被<a href="https://github.com/kubernetes/kubedash" target="_blank" rel="external">kubedash</a>所用。它也提供了监控信息的实时聚合页面，可是由于没有地方储存，看不了历史数据：<br><img src="/img/kubedash.jpg" alt=""></p>
<h2 id="告警"><a href="#告警" class="headerlink" title="告警"></a>告警</h2><p>InfluxData公司除了InfluxDB，还提供了一整套的<a href="https://influxdata.com/get-started/what-is-the-tick-stack/" target="_blank" rel="external">TICK stack</a>开源方案，其中的<a href="https://influxdata.com/time-series-platform/kapacitor/" target="_blank" rel="external">Kapacitor</a>正是一个我们需要的告警平台。它使用叫做<a href="https://docs.influxdata.com/kapacitor/v0.2/tick/" target="_blank" rel="external">TICKscript</a>的DSL，通过数据流水线来定义各种任务。通知方式除了写log、发送http请求和执行脚本，还支持<a href="https://slack.com/" target="_blank" rel="external">Slack</a>、<a href="https://www.pagerduty.com/" target="_blank" rel="external">PagerDuty</a>和<a href="https://victorops.com/" target="_blank" rel="external">VictorOps</a>。因为Kapacitor和InfluxDB都是InfluxData公司的产品，所以它们之间的无缝集成也是理所当然的。</p>
<h2 id="其他解决方案"><a href="#其他解决方案" class="headerlink" title="其他解决方案"></a>其他解决方案</h2><p><a href="https://github.com/prometheus/prometheus" target="_blank" rel="external">Prometheus</a>是一个监控系统解决方案，包含了数据采集、时序数据库、UI可视化、告警等诸多功能。它的特点是可以实现多纬度的监控，在对比不同实例的监控数据图上有优势。它还有许多的<a href="https://prometheus.io/docs/instrumenting/exporters/" target="_blank" rel="external">exporter</a>可以很方便地从许多第三方应用中导出数据，如Apache、AWS、Redis等，也支持Mesos、Kubernetes和Kubernetes-Mesos。可以参考<a href="/prometheus">《用容器轻松搭建Prometheus运行环境》</a>来自己搭建一个测试环境。</p>
]]></content>
      
        <categories>
            
            <category> devops </category>
            
        </categories>
        
        
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> mesos </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[传统企业敏捷转型纪实（一）]]></title>
      <url>/waterfall-to-agile-1/</url>
      <content type="html"><![CDATA[<p>这是发生在某大型企业中的某个部门的事儿。他们有六七十名成员，运用瀑布开发模式，三个月发布一次内部产品。部署的过程长达一周，质量堪忧，交付日难以保证。于是请来一位很有经验的敏捷教练Ken，来帮助这个部门做敏捷转型，解决问题。本文的主要内容是在培训完敏捷的基本思想后，<a href="http://scaledagileframework.com/pi-planning/" target="_blank" rel="external">PI Planning</a>（启动会议）上发生的事。本系列目前有两篇：</p>
<ul>
<li><a href="/waterfall-to-agile-1">传统企业敏捷转型纪实（一）</a></li>
<li><a href="/waterfall-to-agile-2">传统企业敏捷转型纪实（二）</a><a id="more"></a>
</li>
</ul>
<h2 id="团队构建"><a href="#团队构建" class="headerlink" title="团队构建"></a>团队构建</h2><p>这个部门由四个团队组成，各自主管产品的一部分。每个团队都有对交付负责的人，称为PO（Product Owner）。Ken的第一步是让所有团队选出一名SPO（Super Product Owner），来对整个产品负责。SPO不做兼职，负责解决各种问题，其最重要的任务是做决策。而对于一款探索性的产品来说，决策是没有对错之分的，只是它需要靠执行力和客户反馈来修正。PO们需要力挺SPO，充分信任SPO的决策，并以团队的执行力来保证决策的执行。所以有个PO与SPO隔空喊话效忠的过程。</p>
<p>这个部门比较特殊的地方在于，大部分成员属于两个外包公司，其中有不少新人。大家对敏捷都没有什么概念，对要做的事也心有疑虑。有鉴于此，Ken让两个外包公司的人各选出1名leader来当<a href="http://scaledagileframework.com/scrum-master/" target="_blank" rel="external">SM</a>（scrum master）。如果团队成员士气低落，不管任何原因，都可以找SM沟通。如果涉及到甲方公司，便由SM来沟通PO处理。这样做的目的是让每个团队成员都有渠道摆脱自己受到的干扰，增加工作效率。团队成员也需要在团队中建立起自己的人脉，好让自己遇到问题时容易找人帮忙。SM主要负责沟通，PO带领团队前进。这样的构建适用于200~300人以下的团队。</p>
<h2 id="了解产品"><a href="#了解产品" class="headerlink" title="了解产品"></a>了解产品</h2><p>要做好产品，首先需要让团队成员理解产品，建立共识。如果只见树木不见森林，那么人人都只是开发自己的那一亩三分地，根本无从得知自己的工作在整个产品中处于什么样的位置，那怎么能做好这个产品呢？现实中，这个产品有着非常复杂的架构，甚至没有一个人能完整地解释整个架构图。Ken建议SPO找几个资深人员，专门抽出一天时间给所有人都讲清楚架构。这很重要，如果你连孩子是男是女都不知道，怎么抚养ta？团队成员需要非常了解产品，而不仅仅是某个需求或者某个版本。要做产品，不是为了做事而做事。同时，Ken也建议所有成员都花时间在架构课之前自学其中的一些重要技术，以便让自己能够在架构课上更加清除对方究竟在讲什么。也就是预习，省的回头听不懂。</p>
<h2 id="日程管理"><a href="#日程管理" class="headerlink" title="日程管理"></a>日程管理</h2><p>接下来用倒推法确定迭代截止日。假设产品5月底上线，需要提前一个月也就是4月底出beta版。需要3周的SIT时间，所以差不多是4月8号所有迭代完成。如果每两周一个迭代，从下周一算第一迭代开始，扣去春节，那么正好有5个迭代。如何能保证按时交付呢？需求可能发生变化，环境可能有问题，心情可能不太好影响了效率。迭代的意义在于提早发现风险。所以每个团队成员遇到问题时，需要尽快把这个问题暴露出来，否则，按时完成是不太可能的。</p>
<h2 id="估算工作量"><a href="#估算工作量" class="headerlink" title="估算工作量"></a>估算工作量</h2><p>因为是从瀑布开发模式转过来的，所以现在每个团队手里都有一大堆需求。这里使用估点的方式来估算每个需求的工作量，转化成各个<a href="https://en.wikipedia.org/wiki/User_story" target="_blank" rel="external">User Story</a>。先找一个清晰的需求，最好半天就能开发完成，再半天测试完成。对这个story估点为1。以其为基准，其他的story与它相比较，得到其他story的估点。估的点数是在一个斐波那契数列里的：<a href="https://en.wikipedia.org/wiki/Planning_poker" target="_blank" rel="external">1，2，3，5，8，13，20，40，100</a>（当然后面几个不是）。例如基准story是3点，如果一个story感觉比它难上两个等级，那这个story应该是8个点。如果比它容易一个等级，那应该是2个点。如果难上4个等级呢？因为估点是个主观的过程，而且是比较不精确的。所以当差别很大的时候误差也会很大的。20，40，100这三个数虽然不是斐波那契数列，但也有它的含义。如果一个story只有一行字，谁也说不清它包含着什么，那就是100点。如果知道一部分，那就是40点。如果知道得更多，那就是20点。当然这也是非常主观且粗糙的，但是当你看到这3个数的时候自然就知道应该先把需求搞清楚。</p>
<p>值得一提的是如果一个story估点为8，并不意味着它需要在整8天的时候做完。这个story和其他story一样，需要在最短的时间内有质量地完成。8代表着这个story的复杂度，或者说它是一个风险识别指标。如果做这个story的时候出了问题，需要开发人员尽快把这个问题暴露出来，就像上面讲的那样。而PO、SPO应该要想办法解决这个问题。如果问题超出SPO的权力，那就需要SPO的决策–可以选择不做这个story，或者只做一部分，或者绕过去。估点往往需要很长的时间。为了效率起见，当<a href="https://en.wikipedia.org/wiki/Business_analyst" target="_blank" rel="external">Business Analyst</a>讲完story时，团队成员应该有意识地思考：这个story有什么业务价值？是必须要做的吗？只有必要的story才估点。估点时新人由于还不熟悉背景，可以仅旁观不参与。参与的成员们同时伸手指表示点数，如果一样就记下点数，跳到下一个story。否则，大家就需要解释为什么自己估的点数是这个数，最后由PO拍脑袋做决策。</p>
<p>估点是个很费时，但又很重要的事情，所以先由一个团队演示几个story，其他团队观看，等大家都了解了，再由所有团队自行估点。</p>
<h2 id="迭代计划"><a href="#迭代计划" class="headerlink" title="迭代计划"></a>迭代计划</h2><p>最后就是安排工作量了。先要确认所有人力是否可以100%地投入。资深成员可以算全职，新人算半职，资深成员但还兼其他工作安排的也算半职。假如说最后我们得到了这样的数：</p>
<ul>
<li>全职开发：3个</li>
<li>半职开发：4个</li>
<li>全职测试：1个</li>
<li>半职测试：2个</li>
</ul>
<p>如果第一迭代有10个工作日，那么我们就能计算出来最大工作量：<code>(3+1)×10+(4+2)×10÷2=70</code>。由于是春节，可能请假会比较多，扣去请假天数，也许得到60点。然后是打折，由各组PO和SPO商量，得到一个折扣。这个折扣可能是：我们组对外部环境依赖很多，第一迭代刚开始效率会很低，春节假期效率不高，团队成员都是单身需要相亲无心干活等等等等。比如说第一迭代打个7折，就能得到合理工作量：<code>60×7=42</code>。由此，我们就得到最大工作量和合理工作量。算出各个迭代的工作量，把它们写在显眼处。最后将先前估好点的story按优先级及依赖顺序往里安排，点数到合理工作量即可。至此，一个看似合理的、由团队成员做出的计划便产生了。项目启动会议完成。</p>
]]></content>
      
        <categories>
            
            <category> agile </category>
            
        </categories>
        
        
        <tags>
            
            <tag> agile </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于docker的MySQL主从复制（replication）]]></title>
      <url>/mysql-replication/</url>
      <content type="html"><![CDATA[<p><a href="http://dev.mysql.com/doc/refman/5.7/en/replication.html" target="_blank" rel="external">MySQL复制技术</a>可以异步地将主数据库的数据同步到从数据库。根据设置可以复制所有数据库、指定数据库甚至可以指定表。本文的主要内容是怎样用docker从零开始搭建mysql主从复制环境，支持binary logging方式和GTIDs方式。<br><a id="more"></a></p>
<p>MySQL 5.7支持多种复制方法。<a href="http://dev.mysql.com/doc/refman/5.7/en/replication-howto.html" target="_blank" rel="external">传统的方法</a>是master使用binary logging，slave复制并重放日志中的事件。<a href="http://dev.mysql.com/doc/refman/5.7/en/replication-gtids.html" target="_blank" rel="external">另一种方法</a>是利用GTIDs（global transaction identifiers）将所有未执行的事务在slave重放。</p>
<h2 id="binary-logging方式"><a href="#binary-logging方式" class="headerlink" title="binary logging方式"></a>binary logging方式</h2><p>接下来先用传统的方法试一下。使用<a href="https://hub.docker.com/r/library/mysql/" target="_blank" rel="external">MySQL 5.7镜像</a>，将<code>/etc/mysql/conf.d/</code>复制到主机，然后修改配置：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker run -d -e MYSQL_ROOT_PASSWORD=123456 --name=mysql mysql:5.7</div><div class="line">docker cp mysql:/etc/mysql/my.cnf my.cnf</div></pre></td></tr></table></figure></p>
<p>master的配置在<code>my.cnf</code>文件中是这样的，改完后另存为<code>/vagrant/mysql/mymaster.cnf</code>：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="section">[mysqld]</span></div><div class="line"><span class="attr">log-bin</span>=mysql-bin # 使用binary logging，mysql-bin是log文件名的前缀</div><div class="line"><span class="attr">server-id</span>=<span class="number">1</span>       # 唯一服务器ID，非<span class="number">0</span>整数，不能和其他服务器的server-id重复</div></pre></td></tr></table></figure></p>
<p>slave的配置就更简单了，改完后另存为<code>/vagrant/mysql/myslave.cnf</code>：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="section">[mysqld]</span></div><div class="line"><span class="attr">server-id</span>=<span class="number">2</span>       # 唯一服务器ID，非<span class="number">0</span>整数，不能和其他服务器的server-id重复</div></pre></td></tr></table></figure></p>
<p>slave没有必要非得用binary logging，但是如果用了，除了binary logging带来的好处以外，还能使这个slave成为其他slave的master。现在我们重新启动mysql master和slave：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">docker rm -f mysql</div><div class="line">docker run -d \</div><div class="line">  --net=host \</div><div class="line">  --name=master \</div><div class="line">  -e MYSQL_ROOT_PASSWORD=123456 \</div><div class="line">  -v /vagrant/mysql/mymaster.cnf:/etc/mysql/my.cnf \</div><div class="line">  mysql:5.7</div><div class="line">docker run -d \</div><div class="line">  --name=slave \</div><div class="line">  -e MYSQL_ROOT_PASSWORD=123456 \</div><div class="line">  -v /vagrant/mysql/myslave.cnf:/etc/mysql/my.cnf \</div><div class="line">  mysql:5.7</div></pre></td></tr></table></figure></p>
<p>在master创建一个复制用的用户：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> -it master mysql -uroot -p123456</div></pre></td></tr></table></figure></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">'repl'</span>@<span class="string">'%'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'123456'</span>;       <span class="comment">-- '%'意味着所有的终端都可以用这个用户登录</span></div><div class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>,<span class="keyword">REPLICATION</span> <span class="keyword">SLAVE</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">'repl'</span>@<span class="string">'%'</span>; <span class="comment">-- SELECT权限是为了让repl可以读取到数据，生产环境建议创建另一个用户</span></div></pre></td></tr></table></figure>
<p>在slave用新创建的用户连接master（记得把MASTER_HOST改为自己的主机IP）：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> -it slave mysql -uroot -p123456</div></pre></td></tr></table></figure></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CHANGE</span> <span class="keyword">MASTER</span> <span class="keyword">TO</span> MASTER_HOST=<span class="string">'192.168.33.32'</span>, MASTER_USER=<span class="string">'repl'</span>, MASTER_PASSWORD=<span class="string">'123456'</span>;</div><div class="line"><span class="keyword">START</span> <span class="keyword">SLAVE</span>;</div><div class="line"><span class="keyword">SHOW</span> <span class="keyword">SLAVE</span> <span class="keyword">STATUS</span>\G       <span class="comment">-- \G用来代替";"，能把查询结果按键值的方式显示</span></div></pre></td></tr></table></figure>
<p>如果一切正常，应该在<code>Last_Error</code>中能看到<code>Can&#39;t create database &#39;mysql&#39;</code>的错误。这是因为slave也是像master一样正常地启动，mysql数据库已经被创建了，所以不能再将master的mysql数据库同步过来。有4种解决办法：</p>
<ol>
<li><p>通过在slave上运行SQL来跳过这个复制操作的方式来实现。在slave上运行：</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">STOP</span> <span class="keyword">SLAVE</span>;</div><div class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> SQL_SLAVE_SKIP_COUNTER = <span class="number">1</span>;</div><div class="line"><span class="keyword">START</span> <span class="keyword">SLAVE</span>;</div><div class="line"><span class="keyword">SHOW</span> <span class="keyword">SLAVE</span> <span class="keyword">STATUS</span>\G</div></pre></td></tr></table></figure>
<p> 不出意外的话，上面的错误应该已经换成了其他错误（例如：<code>Duplicate entry &#39;row_evaluate_cost&#39; for key &#39;PRIMARY&#39;</code>），都是跟mysql这个数据库有关。反复运行上面的SQL直至错误消失。</p>
</li>
<li><p>通过在slave上面配置log文件名及位置的方式来实现。在master上运行：</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> -it master mysql -uroot -p123456</div></pre></td></tr></table></figure>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">FLUSH</span> <span class="keyword">TABLES</span> <span class="keyword">WITH</span> <span class="keyword">READ</span> <span class="keyword">LOCK</span>; <span class="comment">--防止有人对master做更新操作使Position持续变化，先锁表</span></div><div class="line"><span class="keyword">SHOW</span> <span class="keyword">MASTER</span> <span class="keyword">STATUS</span>\G</div></pre></td></tr></table></figure>
<p> 可以看到<code>File: mysql-bin.000003</code>和<code>Position: 154</code>这样的行。删掉这个旧的slave并重新启动一个新的容器，然后运行：</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">docker rm -f slave</div><div class="line">docker run -d \</div><div class="line">  --name=slave \</div><div class="line">  -e MYSQL_ROOT_PASSWORD=123456 \</div><div class="line">  -v /vagrant/mysql/myslave.cnf:/etc/mysql/my.cnf \</div><div class="line">  mysql:5.7</div><div class="line">docker <span class="built_in">exec</span> -it slave mysql -uroot -p123456</div></pre></td></tr></table></figure>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">STOP</span> <span class="keyword">SLAVE</span>;</div><div class="line"><span class="keyword">CHANGE</span> <span class="keyword">MASTER</span> <span class="keyword">TO</span> MASTER_HOST=<span class="string">'192.168.33.32'</span>, MASTER_USER=<span class="string">'repl'</span>, MASTER_PASSWORD=<span class="string">'123456'</span>, MASTER_LOG_FILE=<span class="string">'mysql-bin.000003'</span>, MASTER_LOG_POS=<span class="number">154</span>;</div><div class="line"><span class="keyword">START</span> <span class="keyword">SLAVE</span>;</div><div class="line"><span class="keyword">SHOW</span> <span class="keyword">SLAVE</span> <span class="keyword">STATUS</span>\G</div></pre></td></tr></table></figure>
<p> 我们将会看到<code>Slave_IO_Running: Yes</code>和<code>Slave_SQL_Running: Yes</code>。这两项说明我们的slave已经成功启动了。如果先前锁了master的表，记得在master上运行<code>UNLOCK TABLES;</code>来恢复。</p>
</li>
<li><p>通过不记录<code>mysql</code>数据库binary logging的方式来实现。既然<code>mysql</code>不在binary logging里，那它也无法被同步到slave上。在<code>/vagrant/mysql/mymaster.cnf</code>里增加一个参数，如果有多个数据库，可以复制多行：</p>
 <figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">binlog-ignore-db</span>=mysql</div></pre></td></tr></table></figure>
<p> 删除master和slave容器然后再重新创建之：</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">docker rm -f master</div><div class="line">docker rm -f slave</div><div class="line">docker run -d \</div><div class="line">  --net=host \</div><div class="line">  --name=master \</div><div class="line">  -e MYSQL_ROOT_PASSWORD=123456 \</div><div class="line">  -v /vagrant/mysql/mymaster.cnf:/etc/mysql/my.cnf \</div><div class="line">  mysql:5.7</div><div class="line">docker run -d \</div><div class="line">  --name=slave \</div><div class="line">  -e MYSQL_ROOT_PASSWORD=123456 \</div><div class="line">  -v /vagrant/mysql/myslave.cnf:/etc/mysql/my.cnf \</div><div class="line">  mysql:5.7</div></pre></td></tr></table></figure>
<p> 然后根据上文所述在master创建一个复制用的用户并在slave用新创建的用户连接master，最后观察<code>Slave_IO_Running</code>和<code>Slave_SQL_Running</code>。</p>
</li>
<li><p>通过不复制<code>mysql</code>数据库binary logging的方式来实现。这种方式很类似上面一种方法，只不过配置在slave端而非master端而已。在<code>/vagrant/mysql/myslave.cnf</code>里增加一个参数，删除master和slave容器然后再重新创建之：</p>
 <figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">replicate-ignore-db</span>=mysql</div></pre></td></tr></table></figure>
<p> 其余操作同方法3。</p>
</li>
</ol>
<p>既然slave已经成功启动了，我们便可以测试一下。看看在master上创建一个新数据库是否能同步到slave上：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> master mysql -uroot -p123456 -e <span class="string">"CREATE DATABASE ggg"</span></div><div class="line">docker <span class="built_in">exec</span> slave mysql -uroot -p123456 -e <span class="string">"SHOW DATABASES"</span></div></pre></td></tr></table></figure></p>
<h2 id="GTIDs方式"><a href="#GTIDs方式" class="headerlink" title="GTIDs方式"></a>GTIDs方式</h2><p>下面介绍一下GTIDs方式的主从复制方法。需要修改<code>/vagrant/mysql/mymaster.cnf</code>：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="section">[mysqld]</span></div><div class="line"><span class="attr">log-bin</span>=mysql-bin</div><div class="line"><span class="attr">server-id</span>=<span class="number">1</span></div><div class="line"><span class="attr">gtid-mode</span>=<span class="literal">on</span></div><div class="line"><span class="attr">enforce-gtid-consistency</span>=<span class="literal">true</span></div></pre></td></tr></table></figure></p>
<p>还需要修改<code>/vagrant/mysql/myslave.cnf</code>（MySQL 5.7.4及之前的版本还需要开启log-bin）：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="section">[mysqld]</span></div><div class="line"><span class="attr">server-id</span>=<span class="number">2</span></div><div class="line"><span class="attr">replicate-ignore-db</span>=mysql</div><div class="line"><span class="attr">gtid-mode</span>=<span class="literal">on</span></div><div class="line"><span class="attr">enforce-gtid-consistency</span>=<span class="literal">true</span></div></pre></td></tr></table></figure></p>
<p>启动容器，创建复制的用户都和上面一样，在slave增加<code>MASTER_AUTO_POSITION</code>参数来连接master（记得把MASTER_HOST改为自己的主机IP）：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> -it slave mysql -uroot -p123456</div></pre></td></tr></table></figure></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CHANGE</span> <span class="keyword">MASTER</span> <span class="keyword">TO</span> MASTER_HOST=<span class="string">'192.168.33.32'</span>, MASTER_USER=<span class="string">'repl'</span>, MASTER_PASSWORD=<span class="string">'123456'</span>, MASTER_AUTO_POSITION=<span class="number">1</span>;</div><div class="line"><span class="keyword">START</span> <span class="keyword">SLAVE</span>;</div><div class="line"><span class="keyword">SHOW</span> <span class="keyword">SLAVE</span> <span class="keyword">STATUS</span>\G</div></pre></td></tr></table></figure>
<p>搞定！这样就不需要用到<code>MASTER_LOG_FILE</code>和<code>MASTER_LOG_POS</code>了，省事儿啊。在<code>START SLAVE</code>之前master的其它更新也都会被同步到slave。</p>
<h2 id="其他技巧"><a href="#其他技巧" class="headerlink" title="其他技巧"></a>其他技巧</h2><p>最后再介绍一些实用技巧：</p>
<ol>
<li>如果master已经有数据了，怎么新增slave：可以先把master的数据导入到slave，再启动slave。具体可以参考<a href="http://dev.mysql.com/doc/refman/5.7/en/replication-setup-slaves.html#replication-howto-existingdata" target="_blank" rel="external">这里</a>。</li>
<li>如果已经有主从复制了，怎么增加slave：思路同上，不过不需要使用master的数据，直接用已有的slave数据就可以了。不需要停止master，新slave使用新的<code>server-id</code>。具体可以参考<a href="http://dev.mysql.com/doc/refman/5.7/en/replication-howto-additionalslaves.html" target="_blank" rel="external">这里</a>。</li>
<li><p>slave设置只读操作：在<code>/vagrant/mysql/myslave.cnf</code>里增加参数即可。    <figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attr">read-only</span>=<span class="number">1</span>       # 除非有SUPER权限，否则只读</div><div class="line"><span class="attr">super-read-only</span>=<span class="number">1</span> # SUPER权限也是只读</div></pre></td></tr></table></figure></p>
</li>
<li><p>前面介绍的都是主从，如果需要slave也能同步到master就要设置主主复制：也就是说反过来再做一遍。</p>
</li>
<li>当slave比较多得时候，master的负载可能会成为问题。可以用主从多级复制：以slave为master来再引入新的slave。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> db </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如果有10000台机器，你想怎么玩？（三）持久化]]></title>
      <url>/kubernetes-in-mesos-3/</url>
      <content type="html"><![CDATA[<p>这次聊聊mesos+k8s的持久化问题。如果我用容器跑一个数据库，比如mysql，我关心的是数据保存在哪里。这样万一这个容器发生意外，起码我的数据还在，还可以东山再起。</p>
<ul>
<li><a href="/kubernetes-in-mesos-1">如果有10000台机器，你想怎么玩？（一）概述</a></li>
<li><a href="/kubernetes-in-mesos-2">如果有10000台机器，你想怎么玩？（二）高可用</a></li>
<li><a href="/kubernetes-in-mesos-3">如果有10000台机器，你想怎么玩？（三）持久化</a></li>
<li><a href="/kubernetes-in-mesos-4">如果有10000台机器，你想怎么玩？（四）监控</a></li>
<li><a href="/kubernetes-in-mesos-5">如果有10000台机器，你想怎么玩？（五）日志</a></li>
<li><a href="/kubernetes-in-mesos-6">如果有10000台机器，你想怎么玩？（六）性能</a></li>
<li><a href="/kubernetes-in-mesos-7">如果有10000台机器，你想怎么玩？（七）生命周期</a></li>
<li><a href="/kubernetes-in-mesos-8">如果有10000台机器，你想怎么玩？（八）网络</a></li>
<li><a href="/kubernetes-in-mesos-9">如果有10000台机器，你想怎么玩？（九）安全性</a><a id="more"></a>
</li>
</ul>
<p>为了方便部署和升级，我们目前把mesos slave跑在容器里。如果我有一个网络存储比如nfs，ceph之类的，当我命令k8s给我跑一个mysql pod，存储挂载到ceph上的时候，k8s就会先找一个mesos slave，让它挂载远端的ceph。由于mesos slave是在容器里，所以挂载点也在这个容器里，姑且把这个路径叫做<code>/tmp/mesos/slaves/20160105-xxx</code>。然后mysql容器也启动了，挂载了<code>/tmp/mesos/slaves/20160105-xxx</code>–可惜的是这个路径是主机的路径，并不是mesos slave容器里的路径，所以它并不能把数据同步到远端的ceph存储去。持久化失败。</p>
<p>有三种方案可以解决持久化的问题。第一个方案：如果我们要继续使用容器化的mesos slave，有一个办法是提前在主机上挂载远端存储。这样的话，mysql容器就可以配置成hostPath的方式，直接挂载这个主机路径，这样就能把数据同步到远端去。这么做是可行的，但是也有不少缺点。首先，因为不知道mysql容器会在哪台机器上运行，所以不得不在所有的机器上都预加载，这样做就失去了动态性，可能引发更多的问题。其次，不是所有类型的存储都可以被很多机器加载。比如ceph的rbd存储就(最好)只能被一台机器加载。还有，何时卸载？如何卸载？存储太多的时候如何管理？这些都是问题。另一个办法是使用kubernetes的<a href="https://github.com/kubernetes/kubernetes/blob/master/docs/user-guide/container-environment.md#container-hooks" target="_blank" rel="external">container hook</a>。目前支持<a href="http://kubernetes.io/docs/api-reference/v1/definitions/#_v1_lifecycle" target="_blank" rel="external">postStart和preStop</a>两个时点。可惜mesos slave容器里的mount并不能为外部所用。直接在mysql容器去做mount理论能行，但是需要主机的root权限，或者是hook挂上http请求去外部挂载，不管怎样都相当于重新自己来一套，并不划算。</p>
<p>第二个方案：还是容器化的mesos slave，但是使用<a href="https://hub.docker.com/r/mesosphere/mesos-slave-dind/" target="_blank" rel="external">docker in docker</a>。这种容器方案会把mysql容器运行在mesos slave容器里面，而不像第一种那样把它运行在与mesos slave并列的主机级别。所以mysql使用的存储自然而然就落到了mesos slave容器里面，而这个路径正是加载了远端ceph的地方。这个方案相对来说在操作上也挺简单，仅仅是换个mesos slave dind的镜像而已。它的缺点也正是由于新容器会运行在mesos slave dind容器里，从而导致这个主容器里面可能同时运行许多个从容器，这样就有点儿把容器当虚拟机的意思了，不是最佳实践。另外在实际操作上还出现了新的问题：比如kubernetes使用rbd方式作为volumn的时候，mesos slave会尝试将一个rbd镜像映射成一个设备<code>/dev/rbd1</code>。这个设备就会跑到主机上而非mesos slave dind容器里，从而使我们不得不将主机的<code>/dev</code>也挂载到mesos slave dind容器里。而这样的操作又会带来更多的问题：比如容器删除时提示<code>device or resource busy</code>，从而无法轻易释放<code>/var/lib/docker/aufs</code>的磁盘资源等等。鉴于继续前行可能会碰到更多更深的坑，我们主动放弃了这个方案，但它的前途也有可能是光明的。</p>
<p>第三个方案：放弃mesos slave的容器化。回顾问题的根源，一切的一切都是因为引入mesos slave的容器造成的。如果把mesos slave还原成系统进程，那么这一堆存储问题都将不复存在。我们仍然有其他手段来实现mesos slave部署和升级的便利性，如自动化脚本、数据用容器等。虽然这样可能引入更大的部署工作量，但这可能是针对这个问题来说更加正统的解决方案。</p>
]]></content>
      
        <categories>
            
            <category> devops </category>
            
        </categories>
        
        
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> mesos </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用容器轻松搭建ceph实验环境]]></title>
      <url>/ceph-demo/</url>
      <content type="html"><![CDATA[<p><a href="http://ceph.com/" target="_blank" rel="external">Ceph</a>是一个高性能的PB级分布式文件系统。它能够在一个系统中提供对象存储、块存储和文件存储。本文的主要内容是怎样用docker从零开始搭建ceph环境，并分别以cephfs和rbd的方式加载它。<br><a id="more"></a></p>
<p>这是ceph的模块架构图：<br><img src="http://docs.ceph.com/docs/master/_images/stack.png" alt=""><br>最底层的RADOS提供了对象存储的功能，是ceph的根基所在。所有的其他功能都是在RADOS之上构建的。LIBRADOS看名字就能猜到，它提供了一系列语言的接口，可以直接访问RADOS。RADOSGW基于LIBRADOS实现了REST的接口并兼容S3和Swift。RBD也基于LIBRADOS提供了块存储。最后是CEPH FS直接基于RADOS实现了文件存储系统。想要详细了解它的朋友可以看看<a href="/ceph-radosgw">这篇文章](http://www.wzxue.com/why-ceph-and-how-to-use-ceph/)，把ceph介绍得很清楚。笔者的另一篇文章《通过RADOSGW提供ceph的S3和Swift接口》</a>介绍了RADOSGW的使用方法。</p>
<h2 id="cephfs方式"><a href="#cephfs方式" class="headerlink" title="cephfs方式"></a>cephfs方式</h2><p>Talk is cheap，让我们来看看如何用最简单的方式来搭建一个ceph环境吧。Ceph提供了一个<a href="https://hub.docker.com/r/ceph/demo/" target="_blank" rel="external">deph/demo</a>的docker镜像来给我们做实验，注意<strong>别在产品环境用它（THIS CONTAINER IS NOT RECOMMENDED FOR PRODUCTION USAGE）</strong>。只要装好了docker，跑起来是很容易的：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d --net=host -v /etc/ceph:/etc/ceph -e MON_IP=192.168.0.20 -e CEPH_NETWORK=192.168.0.0/24 --name=ceph ceph/demo</div></pre></td></tr></table></figure></p>
<p>上面的<code>MON_IP</code>可以填写运行这个镜像的机器IP，<code>CEPH_NETWORK</code>填写允许访问这个ceph的IP范围。启动之后，由于挂载了宿主机的<code>/etc/ceph</code>，这个文件夹里面会生成几个配置文件。其中有一个叫<code>ceph.client.admin.keyring</code>的文件里面有一个<code>key</code>，作为cephfs加载的时候认证会用到。</p>
<p>直接作为cephfs来加载就是一句话的事情：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo mount -t ceph -o name=admin,secret=AEAq5XtW5SLsARBAAh6kwpBmGVVjUwPQmZeuik== 192.168.0.20:/ /mnt/cephfs</div></pre></td></tr></table></figure></p>
<p>用的时候记得事先创建好<code>/mnt/cephfs/</code>这个文件夹，替换<code>secret</code>为你自己的<code>key</code>，再改成用你的ceph服务器ip就好了。</p>
<h2 id="rbd方式"><a href="#rbd方式" class="headerlink" title="rbd方式"></a>rbd方式</h2><p>还有一种方式是作为rbd来加载。这边需要啰嗦几句rbd的模型：最外层是<a href="http://docs.ceph.com/docs/master/rados/operations/pools/" target="_blank" rel="external">pool</a>，相当于一块磁盘，默认的pool名字叫做rbd。每个pool里面可以有多个image，相当于文件夹。每个image可以映射成一个块设备，有了设备就可以加载它。下面我们来尝试一下。如果打算用另一台机器，需要先把<code>/etc/ceph</code>这个文件夹复制过去，这个文件夹里面包含了ceph的连接信息。为了运行ceph的命令，我们还需要安装<code>ceph-common</code>，自己选一个命令吧：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">apt-get install -y ceph-common</div><div class="line">yum install -y ceph-common</div></pre></td></tr></table></figure></p>
<p>准备工作做完了，我们首先创建一个名为ggg的pool：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph osd pool create ggg 128</div></pre></td></tr></table></figure></p>
<p>128代表<a href="http://docs.ceph.com/docs/master/rados/operations/placement-groups/" target="_blank" rel="external">placement-group</a>的数量。每个pg都是一个虚拟节点，将自己的数据存在不同的位置。这样一旦存储挂了，pg就会选择新的存储，从而保证了自动高可用。运行这个命令就可以看到现在系统中的所有pool：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph osd lspools</div></pre></td></tr></table></figure></p>
<p>然后在ggg这个pool里创建一个名为qqq的image：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rbd create ggg/qqq --size 1024</div></pre></td></tr></table></figure></p>
<p>size的单位是MB，所以这个qqq image的大小为1GB。要是这条命令一直没有响应，试着重启一下ceph/demo容器<code>docker restart ceph</code>，说了这不适合用于生产环境…运行下列命令可以看到ggg的pool中的所有image和查看qqq image的详细信息：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rbd ls ggg</div><div class="line">rbd info ggg/qqq</div></pre></td></tr></table></figure></p>
<p>接下来要把qqq image映射到块设备中，可能需要root权限：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo rbd map ggg/qqq</div></pre></td></tr></table></figure></p>
<p>运行这个命令就可以看到映射到哪个设备去了，我的是<code>/dev/rbd1</code>：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rbd showmapped</div></pre></td></tr></table></figure></p>
<p>格式化之：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo mkfs.ext4 -m0 /dev/rbd1</div></pre></td></tr></table></figure></p>
<p>然后就可以加载了！里面应该有一个<code>lost+found</code>的文件夹：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo mkdir -p /mnt/rbd/qqq</div><div class="line">sudo mount /dev/rbd1 /mnt/rbd/qqq</div><div class="line">ls /mnt/rbd/qqq/</div></pre></td></tr></table></figure></p>
<h2 id="还原环境"><a href="#还原环境" class="headerlink" title="还原环境"></a>还原环境</h2><p>最后把我们的环境恢复回去：卸载-&gt;解除映射-&gt;删除image-&gt;删除pool：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo umount /mnt/rbd/qqq</div><div class="line">sudo rbd unmap /dev/rbd1</div><div class="line">rbd rm ggg/qqq</div><div class="line">ceph osd pool delete ggg</div></pre></td></tr></table></figure></p>
<p>如果严格按照上面的命令，你应该会在最后一步得到一个错误提示：Error EPERM: WARNING: this will <em>PERMANENTLY DESTROY</em> all data stored in pool ggg.  If you are <em>ABSOLUTELY CERTAIN</em> that is what you want, pass the pool name <em>twice</em>, followed by –yes-i-really-really-mean-it.</p>
<p>删掉pool，里面的数据就真没有啦，所以要谨慎，除了pool名写两遍（重要的事情不应该是三遍么），还得加上<code>--yes-i-really-really-mean-it</code>的免责声明：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph osd pool delete ggg ggg --yes-i-really-really-mean-it</div></pre></td></tr></table></figure></p>
<p>最后删掉ceph容器（如果你愿意，还有ceph/demo镜像），就当一切都没有发生过：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker rm -f ceph</div><div class="line">docker rmi ceph/demo</div></pre></td></tr></table></figure></p>
<p>悄悄的我走了，正如我悄悄的来；我挥一挥衣袖，不带走一个byte。</p>
]]></content>
      
        <categories>
            
            <category> devops </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ceph </tag>
            
            <tag> storage </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如果有10000台机器，你想怎么玩？（二）高可用]]></title>
      <url>/kubernetes-in-mesos-2/</url>
      <content type="html"><![CDATA[<p>这次聊聊k8s的<a href="http://kubernetes.io/v1.1/docs/admin/high-availability.html" target="_blank" rel="external">高可用性</a>是怎么做的。所谓高可用性，就是在一些服务或机器挂掉了之后集群仍然能正常工作的能力。</p>
<ul>
<li><a href="/kubernetes-in-mesos-1">如果有10000台机器，你想怎么玩？（一）概述</a></li>
<li><a href="/kubernetes-in-mesos-2">如果有10000台机器，你想怎么玩？（二）高可用</a></li>
<li><a href="/kubernetes-in-mesos-3">如果有10000台机器，你想怎么玩？（三）持久化</a></li>
<li><a href="/kubernetes-in-mesos-4">如果有10000台机器，你想怎么玩？（四）监控</a></li>
<li><a href="/kubernetes-in-mesos-5">如果有10000台机器，你想怎么玩？（五）日志</a></li>
<li><a href="/kubernetes-in-mesos-6">如果有10000台机器，你想怎么玩？（六）性能</a></li>
<li><a href="/kubernetes-in-mesos-7">如果有10000台机器，你想怎么玩？（七）生命周期</a></li>
<li><a href="/kubernetes-in-mesos-8">如果有10000台机器，你想怎么玩？（八）网络</a></li>
<li><a href="/kubernetes-in-mesos-9">如果有10000台机器，你想怎么玩？（九）安全性</a><a id="more"></a>
</li>
</ul>
<p>作为背景知识，先介绍一下<a href="https://github.com/kubernetes/kubernetes/blob/master/docs/design/architecture.md" target="_blank" rel="external">k8s的架构</a>：<br><img src="https://raw.githubusercontent.com/kubernetes/kubernetes/master/docs/design/architecture.png" alt=""></p>
<p>它分为服务器端（master）和客户端（node）。服务器端主要是3个组件：API Server、Controller Manager和Scheduler。API Server是操作人员和k8s的接口。比如我想看一下当前k8s有几个pod在跑，就需要连接到这个API Server上。Controller Manager顾名思义就是管理各种各样的controller比如先前提到的Replication Controller。Scheduler做的事就是把用户想要启动/删除的pod分发到对应的客户端上。客户端主要是2个组件：Kubelet和Proxy。Kubelet负责响应服务器端的Scheduler分出来的任务。Proxy用来接通服务和对应的机器。举个栗子：如果我们运行这个命令：<code>kubectl -s 192.168.33.10:8080 run nginx —image=nginx</code>来启动一个nginx的rc和pod，API Server（192.168.33.10:8080）就会得到消息并把这些数据存放到<a href="https://github.com/coreos/etcd" target="_blank" rel="external">etcd</a>里。Controller Manager就会去创建rc，Scheduler则会找个客户端，把启动pod的描述放到客户端上的某个文件夹里。客户端上的Kubelet会监视这个文件夹，一旦发现有了新的pod描述文件，便会将这个pod启动起来。多说一句，<a href="http://kubernetes.io/docs/admin/kubelet/" target="_blank" rel="external">Kubelet</a>除了监听文件夹或是某个Url，还有种方式是干脆直接启动一个Http Server让别人来调用。</p>
<p>高可用的情况下，由于用户的命令直接操作的是API Server，所以当API Server挂掉的时候，需要能自动重启。我们可以使用k8s客户端上现成的Kubelet来满足这个需求。Kubelet有一个Standalone模式，把启动API Server的描述文件丢到Kubelet的监视文件夹里就好了。当Kubelet发现API Server挂掉了，就会自动再启动一个API Server，反正新旧API Server连接的存储etcd还是原来那一个。API Server高可用了，要是Kubelet挂了呢？这个…还得监视一下Kubelet…可以用monit之类的东东，这边就不细说了。当然etcd也需要高可用，但是作为分布式存储来说，它的高可用相对而言较为简单并且跟k8s关联不大，这里也不提了。</p>
<p>刚刚提到的都是进程或容器挂掉的高可用。但是万一整个机器都完蛋了，咋办呢？最直接的做法就是整它好几个服务端，一个挂了还有其他的嘛。好几个服务端就有好几个API Server，其中一个为主，其他为从，简单地挂在一个负载均衡如HAProxy上就可以了。如果还嫌HAProxy上可能有单点故障，那就再做负载均衡集群好了，本文不再赘述。API Server可以跑多份，但是Controller Manager和Scheduler现在不建议跑多份。怎么做到呢？官方提供了一个叫做podmaster的镜像，用它启动的容器可以连接到etcd上。当它从etcd上发现当前机器的API Server为主机的时候，便会把Controller Manager和Scheduler的描述文件丢到Kubelet的监视文件夹里，于是Kubelet就会把这俩启动起来。若当前机器的API Server为从机时，它会把Controller Manager和Scheduler的描述文件从Kubelet的监视文件夹里删掉，这样就可以保证整个集群中Controller Manager和Scheduler各只有一份。上面说的这些画到图里就是这样滴：<br><img src="http://kubernetes.io/images/docs/ha.svg" alt=""></p>
<p>和mesos配合的话，k8s还有<a href="https://github.com/kubernetes/kubernetes/blob/master/contrib/mesos/docs/ha.md" target="_blank" rel="external">另一种高可用方式</a>。这种方式会给Scheduler増加一个叫做–ha的参数，于是Scheduler就能多个同时工作。但是官方也说了，不建议同时起2个以上的Scheduler。这种高可用方式的其它配置还是跟上文所说的一样，照样得使用podmaster，只不过它这回只用管Controller Manager一个而已。</p>
<p>做了这么多，终于把k8s master搞定了。但是还没完，node们还在等着我们呢！如果没用mesos，那就需要把node们的Kubelet重启一下，让它们连接到API Server的负载均衡上去。要是用了mesos就会简单一点儿，因为node们的Kubelet就是由Scheduler帮忙起起来的。记得吗？服务器端我们已经搞定了~</p>
]]></content>
      
        <categories>
            
            <category> devops </category>
            
        </categories>
        
        
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> mesos </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如果有10000台机器，你想怎么玩？（一）概述]]></title>
      <url>/kubernetes-in-mesos-1/</url>
      <content type="html"><![CDATA[<p>这一系列文章主要是关于kubernetes和mesos集群管理的内容，里面不会说用啥命令，怎么操作，而是了解一些基本概念，理清思路。如果你需要的是实操，请参考<a href="/kubernetes-installation">《轻松搭建Kubernetes 1.2版运行环境》</a>。</p>
<p>本系列目前有九篇：</p>
<ul>
<li><a href="/kubernetes-in-mesos-1">如果有10000台机器，你想怎么玩？（一）概述</a></li>
<li><a href="/kubernetes-in-mesos-2">如果有10000台机器，你想怎么玩？（二）高可用</a></li>
<li><a href="/kubernetes-in-mesos-3">如果有10000台机器，你想怎么玩？（三）持久化</a></li>
<li><a href="/kubernetes-in-mesos-4">如果有10000台机器，你想怎么玩？（四）监控</a></li>
<li><a href="/kubernetes-in-mesos-5">如果有10000台机器，你想怎么玩？（五）日志</a></li>
<li><a href="/kubernetes-in-mesos-6">如果有10000台机器，你想怎么玩？（六）性能</a></li>
<li><a href="/kubernetes-in-mesos-7">如果有10000台机器，你想怎么玩？（七）生命周期</a></li>
<li><a href="/kubernetes-in-mesos-8">如果有10000台机器，你想怎么玩？（八）网络</a></li>
<li><a href="/kubernetes-in-mesos-9">如果有10000台机器，你想怎么玩？（九）安全性</a><a id="more"></a>
</li>
</ul>
<p>少年，10000台机器只是哄你进来看看而已。这是个虚数，想做的事情其实是：我有那么几台虚拟机，要对外提供容器化PaaS服务，你想怎么玩？</p>
<p>不管这些机器是虚拟还是实体，是啥操作系统，实际上我拥有的是一堆的资源，如cpu、内存、硬盘等。当有人需要某个服务的时候，我从这堆资源中启动某个服务给对方即可。在单机环境中，操作系统有能力帮我们做这样的事情。当我们需要一个服务时，我们就启动一个应用，这个应用使用了操作系统的一些资源，为我们提供服务。剩下的资源可以为我们提供其他的服务。在集群环境中，<a href="http://mesos.apache.org/" target="_blank" rel="external">mesos</a>有能力帮我们做这样的事情。它就像一个操作系统，告诉我们现在集群中有多少的资源。当我们需要一个服务时，我们就启动一个任务，这个任务使用了集群环境的一些资源，为我们提供服务。剩下的资源可以为我们提供其他的服务。一般情况下我们看到的mesos主页是这样子滴：<br><img src="/img/mesos.jpg" alt=""></p>
<p>我们不希望各个任务太不一样，因为那管理起来很麻烦。神一般的<a href="http://www.docker.com/" target="_blank" rel="external">docker</a>把各种任务都抽象成一个容器，这样启动一个任务就变成启动一个容器了，大大解放了我们的双手，让我还有时间在这里码码字。尽管如此，我们还是需要管理我们的容器。<a href="http://kubernetes.io/" target="_blank" rel="external">Kubernetes</a>就是这样一个容器编排工具。大家叫它k8s，听起来就像i18n那么的亲切。它有自己的一些概念：首先是<a href="http://kubernetes.io/docs/user-guide/pods/" target="_blank" rel="external">pod</a>，它里头可以含着多个容器的实例，是k8s调度的原子单元。其次是<a href="http://kubernetes.io/docs/user-guide/replication-controller/" target="_blank" rel="external">Replication Controller</a>简称rc，它关联一个pod和一个pod数量。最后是<a href="http://kubernetes.io/docs/user-guide/services/" target="_blank" rel="external">service</a>，它通过rc暴露出来。这三个概念听起来没啥，混合起来使用威力十足。举个栗子：pod里面有一个nginx容器，有一个rc关联到这个pod，并暴露出服务以使外界可以访问这个nginx。当访问量很大的时候，运维人员可以把rc的pod数量这个值从1调整成10，k8s会自动把pod变成10份，从而让nginx容器也启动10份，而服务则会自动在这10份pod中做负载均衡（截稿为止，这个负载均衡的算法是随机）。一条命令就能轻易实现扩容，当然前提是mesos那头有足够的资源。Kubernetes有一个kube-ui的插件可以可视化当前的主机、资源、pod、rc、服务等：<br><img src="/img/kube-ui.jpg" alt=""></p>
<p>集群操作系统和容器编排工具都有了，假设我们需要一个mysql服务。用k8s启动一个docker hub下的官方镜像，于是它就会被mesos分配在某台有资源的机器上。用户并不关心到底被分配到哪台机器上，只关心服务能不能用，好不好用。现在问题来了：要是服务挂掉，数据会不会丢失？那么应该怎么做持久化？这里需要引入k8s的另外两个概念：<a href="http://kubernetes.io/docs/user-guide/persistent-volumes/#persistent-volumes" target="_blank" rel="external">PersistentVolume</a>（PV）和<a href="http://kubernetes.io/docs/user-guide/persistent-volumes/#persistentvolumeclaims" target="_blank" rel="external">PersistentVolumeClaim</a>（PVC）。简单说来，PV就是存储资源，它表示一块存储区域。比如：nfs上的、可读写的、10G空间。PVC就是对PV的请求，比如需要–可读写的1G空间。我们的mysql直接挂载在需要的PVC上就可以了，k8s自己会帮这个PVC寻找适配的PV。就算mysql挂掉或者是被停掉不用了，PVC仍然存在并可被其他pod使用，数据不会丢失。</p>
<p>现在数据库也有了，需要一个tomcat服务来使用刚才创建的mysql服务并把自己暴露到公网上。传统上说，要使用数据库那就得在自己应用的xml或config文件中配置一下数据库的链接，java平台上一般是酱紫滴：<code>jdbc:mysql://localhost:3306/dbname</code>。可是mysql服务并不在localhost上，我们也不知道它被分配到哪台机器上去了，怎么写这个链接呢？这里边就涉及到k8s服务发现的概念了。一种方法是，k8s在新启动一个pod的时候，会把当前所有的服务都写到这个pod的容器的环境变量里去。于是就可以使用环境变量来“发现”这个服务。但是这种做法并不推荐，因为它要求在启动pod的时候，它所需要的服务已经存在。是啊，如果服务不存在，怎么知道往环境变量写什么呢？由于环境变量大法严重依赖于启动顺序，所以一般使用DNS大法。k8s提供了kube2sky和skydns的插件，当mysql服务启动后，这哥俩就会监听到mysql服务，并为之提供dns服务。所以只要配置成<code>jdbc:mysql://mysql.default.svc.cluster.local:3306/dbname</code>便可以解决服务发现的问题了。</p>
<p>接着往下走，还会涉及到外部负载均衡、高可用、多租户、监控、安全等一系列挑战，你想怎么玩？</p>
]]></content>
      
        <categories>
            
            <category> devops </category>
            
        </categories>
        
        
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> mesos </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
